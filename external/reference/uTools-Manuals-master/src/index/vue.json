[{"name":"silent","type":"全局配置","path":"vue/全局配置.html#silent","desc":"取消 Vue 所有的日志与警告。"},{"name":"optionMergeStrategies","type":"全局配置","path":"vue/全局配置.html#optionMergeStrategies","desc":"自定义合并策略的选项。"},{"name":"devtools","type":"全局配置","path":"vue/全局配置.html#devtools","desc":"配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。"},{"name":"errorHandler","type":"全局配置","path":"vue/全局配置.html#errorHandler","desc":"指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。"},{"name":"warnHandler","type":"全局配置","path":"vue/全局配置.html#warnHandler","desc":"为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。"},{"name":"ignoredElements","type":"全局配置","path":"vue/全局配置.html#ignoredElements","desc":"须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。"},{"name":"keyCodes","type":"全局配置","path":"vue/全局配置.html#keyCodes","desc":"给 v-on 自定义键位别名。"},{"name":"performance","type":"全局配置","path":"vue/全局配置.html#performance","desc":"设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。"},{"name":"productionTip","type":"全局配置","path":"vue/全局配置.html#productionTip","desc":"设置为 false 以阻止 vue 在启动时生成生产提示。"},{"name":"Vue.extend( options )","type":"全局配置","path":"vue/全局配置.html#Vue-extend","desc":"使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。"},{"name":"Vue.nextTick( [callback, context] )","type":"全局配置","path":"vue/全局配置.html#Vue-nextTick","desc":"在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。"},{"name":"Vue.set( target, key, value )","type":"全局配置","path":"vue/全局配置.html#Vue-set","desc":"向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = 'hi')"},{"name":"Vue.delete( target, key )","type":"全局配置","path":"vue/全局配置.html#Vue-delete","desc":"删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。"},{"name":"Vue.directive( id, [definition] )","type":"全局配置","path":"vue/全局配置.html#Vue-directive","desc":"注册或获取全局指令。"},{"name":"Vue.filter( id, [definition] )","type":"全局配置","path":"vue/全局配置.html#Vue-filter","desc":"注册或获取全局过滤器。"},{"name":"Vue.component( id, [definition] )","type":"全局配置","path":"vue/全局配置.html#Vue-component","desc":"注册或获取全局组件。注册还会自动使用给定的id设置组件的名称"},{"name":"Vue.use( plugin )","type":"全局配置","path":"vue/全局配置.html#Vue-use","desc":"安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。"},{"name":"Vue.mixin( mixin )","type":"全局配置","path":"vue/全局配置.html#Vue-mixin","desc":"全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。"},{"name":"Vue.compile( template )","type":"全局配置","path":"vue/全局配置.html#Vue-compile","desc":"在 render 函数中编译模板字符串。只在独立构建时有效"},{"name":"Vue.observable( object )","type":"全局配置","path":"vue/全局配置.html#Vue-observable","desc":"让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。"},{"name":"Vue.version","type":"选项-数据","path":"vue/选项-数据.html#Vue-version","desc":"类型：Object | Function"},{"name":"data","type":"选项-数据","path":"vue/选项-数据.html#data","desc":"Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。"},{"name":"props","type":"选项-数据","path":"vue/选项-数据.html#props","desc":"props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。"},{"name":"propsData","type":"选项-数据","path":"vue/选项-数据.html#propsData","desc":"创建实例时传递 props。主要作用是方便测试。"},{"name":"computed","type":"选项-数据","path":"vue/选项-数据.html#computed","desc":"计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。"},{"name":"methods","type":"选项-数据","path":"vue/选项-数据.html#methods","desc":"methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。"},{"name":"watch","type":"选项-数据","path":"vue/选项-数据.html#watch","desc":"一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。"},{"name":"el","type":"选项-数据","path":"vue/选项-数据.html#el","desc":"提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。"},{"name":"template","type":"选项-数据","path":"vue/选项-数据.html#template","desc":"一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。"},{"name":"render","type":"选项-数据","path":"vue/选项-数据.html#render","desc":"字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode。"},{"name":"renderError","type":"选项-数据","path":"vue/选项-数据.html#renderError","desc":"只在开发者环境下工作。"},{"name":"beforeCreate","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#beforeCreate","desc":"在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。"},{"name":"created","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#created","desc":"在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。"},{"name":"beforeMount","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#beforeMount","desc":"在挂载开始之前被调用：相关的 render 函数首次被调用。"},{"name":"mounted","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#mounted","desc":"el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。"},{"name":"beforeUpdate","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#beforeUpdate","desc":"数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。"},{"name":"updated","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#updated","desc":"由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。"},{"name":"activated","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#activated","desc":"keep-alive 组件激活时调用。"},{"name":"deactivated","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#deactivated","desc":"keep-alive 组件停用时调用。"},{"name":"beforeDestroy","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#beforeDestroy","desc":"实例销毁之前调用。在这一步，实例仍然完全可用。"},{"name":"destroyed","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#destroyed","desc":"Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。"},{"name":"errorCaptured","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#errorCaptured","desc":"当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。"},{"name":"directives","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#directives","desc":"包含 Vue 实例可用指令的哈希表。"},{"name":"filters","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#filters","desc":"包含 Vue 实例可用过滤器的哈希表。"},{"name":"components","type":"选项-生命周期钩子","path":"vue/选项-生命周期钩子.html#components","desc":"包含 Vue 实例可用组件的哈希表。"},{"name":"parent","type":"选项-组合","path":"vue/选项-组合.html#parent","desc":"指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中。"},{"name":"mixins","type":"选项-组合","path":"vue/选项-组合.html#mixins","desc":"mixins 选项接受一个混入对象的数组。这些混入实例对象可以像正常的实例对象一样包含选项，他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。举例：如果你的混入包含一个钩子而创建组件本身也有一个，两个函数将被调用。"},{"name":"extends","type":"选项-组合","path":"vue/选项-组合.html#extends","desc":"允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。"},{"name":"provide / inject","type":"选项-组合","path":"vue/选项-组合.html#provide-inject","desc":"这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。"},{"name":"name","type":"选项-组合","path":"vue/选项-组合.html#name","desc":"允许组件模板递归地调用自身。注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。"},{"name":"delimiters","type":"选项-组合","path":"vue/选项-组合.html#delimiters","desc":"改变纯文本插入分隔符。"},{"name":"functional","type":"选项-组合","path":"vue/选项-组合.html#functional","desc":"使组件无状态 (没有 data ) 和无实例 (没有 this 上下文)。他们用一个简单的 render 函数返回虚拟节点使他们更容易渲染。"},{"name":"model","type":"选项-组合","path":"vue/选项-组合.html#model","desc":"允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。"},{"name":"inheritAttrs","type":"选项-组合","path":"vue/选项-组合.html#inheritAttrs","desc":"默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。"},{"name":"comments","type":"选项-组合","path":"vue/选项-组合.html#comments","desc":"当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。"},{"name":"vm.$data","type":"实例属性","path":"vue/实例属性.html#vm-data","desc":"Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。"},{"name":"vm.$props","type":"实例属性","path":"vue/实例属性.html#vm-props","desc":"当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象属性的访问。"},{"name":"vm.$el","type":"实例属性","path":"vue/实例属性.html#vm-el","desc":"Vue 实例使用的根 DOM 元素。"},{"name":"vm.$options","type":"实例属性","path":"vue/实例属性.html#vm-options","desc":"用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处："},{"name":"vm.$parent","type":"实例属性","path":"vue/实例属性.html#vm-parent","desc":"父实例，如果当前实例有的话。"},{"name":"vm.$root","type":"实例属性","path":"vue/实例属性.html#vm-root","desc":"当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。"},{"name":"vm.$children","type":"实例属性","path":"vue/实例属性.html#vm-children","desc":"当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。"},{"name":"vm.$slots","type":"实例属性","path":"vue/实例属性.html#vm-slots","desc":"用来访问被插槽分发的内容。每个具名插槽 有其相应的属性 (例如：v-slot:foo 中的内容将会在 vm.$slots.foo 中被找到)。default 属性包括了所有没有被包含在具名插槽中的节点，或 v-slot:default 的内容。"},{"name":"vm.$scopedSlots","type":"实例属性","path":"vue/实例属性.html#vm-scopedSlots","desc":"用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。"},{"name":"vm.$refs","type":"实例属性","path":"vue/实例属性.html#vm-refs","desc":"一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。"},{"name":"vm.$isServer","type":"实例属性","path":"vue/实例属性.html#vm-isServer","desc":"当前 Vue 实例是否运行于服务器。"},{"name":"vm.$attrs","type":"实例属性","path":"vue/实例属性.html#vm-attrs","desc":"包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。"},{"name":"vm.$listeners","type":"实例属性","path":"vue/实例属性.html#vm-listeners","desc":"包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。"},{"name":"vm.$watch( expOrFn, callback, [options] )","type":"实例属性","path":"vue/实例属性.html#vm-watch","desc":"观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。"},{"name":"vm.$set( target, key, value )","type":"实例属性","path":"vue/实例属性.html#vm-set","desc":"这是全局 Vue.set 的别名。"},{"name":"vm.$delete( target, key )","type":"实例属性","path":"vue/实例属性.html#vm-delete","desc":"这是全局 Vue.delete 的别名。"},{"name":"vm.$on( event, callback )","type":"实例方法-事件","path":"vue/实例方法-事件.html#vm-on","desc":"监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。"},{"name":"vm.$once( event, callback )","type":"实例方法-事件","path":"vue/实例方法-事件.html#vm-once","desc":"监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。"},{"name":"vm.$off( [event, callback] )","type":"实例方法-事件","path":"vue/实例方法-事件.html#vm-off","desc":"移除自定义事件监听器。"},{"name":"vm.$emit( eventName, […args] )","type":"实例方法-事件","path":"vue/实例方法-事件.html#vm-emit","desc":"如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。"},{"name":"vm.$mount( [elementOrSelector] )","type":"实例方法-事件","path":"vue/实例方法-事件.html#vm-mount","desc":"将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。"},{"name":"vm.$forceUpdate()","type":"实例方法-事件","path":"vue/实例方法-事件.html#vm-forceUpdate","desc":"完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。"},{"name":"vm.$nextTick( [callback] )","type":"指令","path":"vue/指令.html#vm-nextTick","desc":"更新元素的 textContent。如果要更新部分的 textContent ，需要使用 {{ Mustache }} 插值。"},{"name":"vm.$destroy()","type":"指令","path":"vue/指令.html#vm-destroy","desc":"更新元素的 innerHTML 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。"},{"name":"v-text","type":"指令","path":"vue/指令.html#v-text","desc":"根据表达式之真假值，切换元素的 display CSS 属性。"},{"name":"v-html","type":"指令","path":"vue/指令.html#v-html","desc":"根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <template> ，将提出它的内容作为条件块。"},{"name":"v-show","type":"指令","path":"vue/指令.html#v-show","desc":"为 v-if 或者 v-else-if 添加“else 块”。"},{"name":"v-if","type":"指令","path":"vue/指令.html#v-if","desc":"表示 v-if 的 “else if 块”。可以链式调用。"},{"name":"v-else","type":"指令","path":"vue/指令.html#v-else","desc":"基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 alias in expression ，为当前遍历的元素提供别名："},{"name":"v-else-if","type":"指令","path":"vue/指令.html#v-else-if","desc":"绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。"},{"name":"v-for","type":"指令","path":"vue/指令.html#v-for","desc":"动态地绑定一个或多个特性，或一个组件 prop 到表达式。"},{"name":"v-on","type":"指令","path":"vue/指令.html#v-on","desc":"在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。"},{"name":"v-bind","type":"指令","path":"vue/指令.html#v-bind","desc":"提供具名插槽或需要接收 prop 的插槽。"},{"name":"v-model","type":"指令","path":"vue/指令.html#v-model","desc":"跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。"},{"name":"v-slot","type":"指令","path":"vue/指令.html#v-slot","desc":"这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。"},{"name":"v-pre","type":"指令","path":"vue/指令.html#v-pre","desc":"只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。"},{"name":"v-cloak","type":"指令","path":"vue/指令.html#v-cloak","desc":"用于将元素或组件表示为作用域插槽。特性的值应该是可以出现在函数签名的参数位置的合法的 JavaScript 表达式。这意味着在支持的环境中，你还可以在表达式中使用 ES2015 解构。它在 2.5.0+ 中替代了 scope。"},{"name":"v-once","type":"内置的组件","path":"vue/内置的组件.html#v-once","desc":"渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染。"},{"name":"key","type":"内置的组件","path":"vue/内置的组件.html#key","desc":"<transition> 元素作为单个元素/组件的过渡效果。<transition> 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在检测过的组件层级中。"},{"name":"ref","type":"内置的组件","path":"vue/内置的组件.html#ref","desc":"<transition-group> 元素作为多个元素/组件的过渡效果。<transition-group> 渲染一个真实的 DOM 元素。默认渲染 <span>，可以通过 tag 属性配置哪个元素应该被渲染。"},{"name":"is","type":"内置的组件","path":"vue/内置的组件.html#is","desc":"<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。"},{"name":"slot 废弃","type":"内置的组件","path":"vue/内置的组件.html#slot-废弃","desc":"<slot> 元素作为组件模板之中的内容分发插槽。<slot> 元素自身将被替换。"}]