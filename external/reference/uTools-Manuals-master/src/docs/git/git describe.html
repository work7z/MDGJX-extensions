<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-describe  - 描述一个使用它可以访问的最近标签的提交</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git describe [--all] [--tags] [--contains] [--abbrev=&lt;n&gt;] [&lt;commit-ish&gt;…]git describe [--all] [--tags] [--contains] [--abbrev=&lt;n&gt;] --dirty[=&lt;mark&gt;]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令查找可从提交中访问的最新标记。如果标签指向提交，则只显示标签。否则，它会将标记名称与标记对象顶部的附加提交数量以及最近提交的缩写对象名称后缀相加。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下（没有--all 或--tags）<code>git describe</code>只显示带注释的标签。有关创建带注释的标签的更多信息，请参阅 git-tag [1]中-a和-s选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;commit-ish&gt;…</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提交对象名称来描述。如果省略，则默认为 HEAD。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--dirty=&lt;mark&gt;   --broken=&lt;mark&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>描述工作树的状态。当工作树与 HEAD 匹配时，输出与“git describe HEAD”相同。如果工作树具有本地修改，则将“-dirty”附加到其上。如果存储库已损坏，
 Git 无法确定是否存在本地修改，那么 Git 将会出错，除非给出了“--broken”，而是附加后缀“-broken”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要只使用带注释的标签，而应使用<code>refs/</code>名称空间中的任何参考。该选项可以匹配任何已知的分支，远程追踪分支或轻量级标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--tags</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要只使用带注释的标签，而要使用<code>refs/tags</code>名称空间中的任何标签。该选项可以匹配一个轻量级（未注释）的标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--contains</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不是找到提交之前的标签，而是找到提交之后的标签，因此包含它。自动地表明 - 标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--abbrev=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用默认的7位十六进制数字作为缩写对象名称，而不是使用&lt;n&gt;数字或根据需要的数字来组成一个唯一的对象名称。0 的&lt;n&gt;将抑制长格式，只显示最接近的标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--candidates=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>而不是只考虑最近的10个标签作为描述输入提交的候选者，而是考虑到候选者。将&lt;n&gt;增加到10以上会稍微长一些，但可能会产生更准确的结果。0的&lt;n&gt;将只会导致精确的匹配输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--exact-match</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只输出完全匹配（一个标签直接引用提供的提交）。这是--candidates = 0的同义词。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--debug</p></div></div><div class="doc-postil"><div class="c-markdown"><p>精确地显示正在使用的搜索策略的信息以标准错误。标签名称仍将打印到标准输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--long</p></div></div><div class="doc-postil"><div class="c-markdown"><p>即使与标签匹配，始终输出长格式（标签，提交数量和缩写提交名称）。当您想要在“describe”输出中查看部分提交对象名称时，即使提交的问题恰好是标记的版本时，这也很有用。它不会仅仅发出标签名称，而是会描述这样的提交，如v1.2-0-gdeadbee（自从标签 v1.2指向 object deadbee 之后的第0次提交）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--match &lt;pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只考虑与给定<code>glob(7)</code>模式匹配的标签，不包括“refs / tags /”前缀。这可以用来避免从存储库泄漏私有标签。如果给定多次，模式列表将被累积，并且将考虑匹配任何模式的标签。使用<code>--no-match</code>清除和复位的模式列表。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--exclude &lt;pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要考虑与给定<code>glob(7)</code>模式匹配的标签，不包括“refs / tags /”前缀。这可以用来缩小标签空间并仅查找符合某些有意义标准的标签。如果给定多次，模式列表将被累积，并且匹配任何模式的标签将被排除。当与--match 结合使用时，当匹配至少一个匹配模式并且不匹配任何 - 排除模式时，将会考虑它。使用<code>--no-exclude</code>清除和复位的模式列表。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--always</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示唯一缩写的提交对象作为后备。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--first-parent</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在查看合并提交后，只跟踪第一个父提交。当您希望不匹配目标提交历史记录中合并的分支上的标签时，这非常有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>示例</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>有了些像 git.git 流树之类的东西，我得到：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[torvalds@g5 git]$ git describe parent
v1.0.4-14-g2414721</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>即我的“父”分支的当前头是基于v1.0.4，但由于它有几个提交，describe 已经增加了提交的次数（“14”）和提交的缩写对象名本身（“2414721”）最后。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>额外提交的数量是“git log v1.0.4..parent”显示的提交数量。哈希后缀是“-g”+父代提示提交（这是<code>2414721b194453f058079d897d13c4e377f92dc6</code>）的7个字符的缩写。“g”前缀代表“git”，用于描述软件的版本，具体取决于管理软件的 SCM。这在人们可能使用不同 SCM 的环境中很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在标签名上做一个<code>git describe</code>标签只会显示标签名称：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[torvalds@g5 git]$ git describe v1.0.4v1.0.4</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>使用--all命令可以使用分支头作为参考，因此输出也显示参考路径：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[torvalds@g5 git]$ git describe --all --abbrev=4 v1.0.5^2tags/v1.0.0-21-g975b</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[torvalds@g5 git]$ git describe --all --abbrev=4 HEAD^heads/lt/describe-7-g975b</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>将--abbrev 设置为0，可以使用该命令查找没有任何后缀的最接近的标记名：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[torvalds@g5 git]$ git describe --abbrev=0 v1.0.5^2tags/v1.0.0</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，如果今天输入这些命令，那么获得的后缀可能比 Linus 在运行这些命令时看到的要长，因为您的 Git 存储库可能具有新的提交，其对象名称以975b开头，并且当时不存在，“ - g975b“后缀可能不足以消除这些提交的歧义。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>搜索策略</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>对于每个提交的提交，<code>git describe</code>都将首先查找一个标签，该标签完全标记该提交。注释标签总是比轻量级标签更受欢迎，并且具有较新日期的标签始终优先于较早日期的标签。如果找到完全匹配，则会输出其名称并停止搜索。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果没有找到完全匹配，<code>git describe</code>则会遍历提交历史记录以找到已标记的祖先提交。祖先的标签将与输入提交的 SHA-1的缩写一起输出。如果<code>--first-parent</code>被指定，则散步将只考虑每个提交的第一个父代。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果在步行期间找到多个标签，那么将选择并输出具有与输入提交不同的最少提交的标签。这里最少的提交不同的定义为提交的数量<code>git log tag..input</code>将会是最小的提交数量。</p></div></div></div>