<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-repack  - 在存储库中打包解包的对象</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git repack [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [--window=&lt;n&gt;] [--depth=&lt;n&gt;] [--threads=&lt;n&gt;]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令用于将当前未驻留在“pack”中的所有对象组合到一个包中。它也可以用来重新组织现有的包装成单一，更高效的包装。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个包是对象的集合，单独压缩，应用增量压缩，存储在单个文件中，并具有关联的索引文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>软件包用于减少镜像系统，备份引擎，磁盘存储等的负载。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-a</p></div></div><div class="doc-postil"><div class="c-markdown"><p>而不是逐步打包解包的对象，将所有引用的东西打包到一个包中。打包用于私人开发的存储库时特别有用。使用<code>-d</code>。这将清理<code>git prune</code>留下的物体，但<code>git fsck --full --dangling</code>显示为悬挂。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，通过哑协议获取的用户必须获取整个新包才能获取任何包含的对象，而不管该包中已有多少个其他对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-A</p></div></div><div class="doc-postil"><div class="c-markdown"><p>和<code>-a</code>一样，除非<code>-d</code>被使用。然后，前一包中的任何无法访问的对象变成松散的，未包装的对象，而不是留在旧包中。无法到达的物体从未故意添加到包中，即使在重新包装时也是如此。此选项可防止无法访问的对象被保留在旧包中而被删除。相反，松散的不可访问的对象将在下一次<code>git gc</code>调用时根据正常的过期规则进行修剪。参见git-gc [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-d</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打包之后，如果新创建的包使某些现有包冗余，请移除冗余包。还可以运行<code>git prune-packed</code>以删除多余的松散对象文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-l</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将<code>--local</code>选项传递给<code>git pack-objects</code>。参见git-pack-objects。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-f</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将<code>--no-reuse-delta</code>选项传递给<code>git-pack-objects</code>git-pack-objects。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-F</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将<code>--no-reuse-object</code>选项传递给<code>git-pack-objects</code>git-pack-objects。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-q</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将<code>-q</code>选项传递给<code>git pack-objects</code>。参见git-pack-objects。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-n</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要使用更新服务器信息<code>git update-server-info</code>。此选项将跳过通过HTTP或FTP更新发布此存储库（或其直接副本）所需的本地目录文件。参见git-update-server-info。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--window=&lt;n&gt;   --depth=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这两个选项会影响包中包含的对象如何使用增量压缩进行存储。对象首先在内部按类型，大小和可选名称进行排序，并与其他对象进行比较，<code>--window</code>以查看使用增量压缩是否节省空间。<code>--depth</code>限制最大增量深度; 使得它太深，会影响解包方的性能，因为需要多次应用增量数据才能获得必要的对象。--window的默认值是10，--depth是50。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--threads=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项通过传递给<code>git pack-objects</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--window-memory=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此选项提供额外的限制<code>--window</code>; 窗口大小将动态缩小，以便不占用<code>&lt;n&gt;</code>内存中的多个字节。在大型和小型对象混合使用的存储库中，这对于不会用大型窗口内存不足的情况很有用，但仍可以利用大型窗口来查看较小的对象。大小可以加上“k”，“m”或“g”后缀。<code>--window-memory=0</code>使内存使用无限。默认值取自<code>pack.windowMemory</code>配置变量。请注意，实际内存使用量将是限制乘以git-pack-objects使用的线程数量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--max-pack-size=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>每个输出包文件的最大大小。大小可以加上“k”，“m”或“g”后缀。允许的最小尺寸限制为1 MiB。如果指定，则可能会创建多个包文件，这也会阻止创建位图索引。默认值是无限的，除非配置变量<code>pack.packSizeLimit</code>被设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-b   --write-bitmap-index</p></div></div><div class="doc-postil"><div class="c-markdown"><p>编写一个可达性位图索引作为重新包装的一部分。这只适用于<code>-a</code>or 时才有意义<code>-A</code>，因为位图必须能够引用所有可到达的对象。此选项覆盖设置<code>repack.writeBitmaps</code>。如果创建多个包文件，此选项不起作用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--pack-kept-objects</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>.keep</code>重新包装时在文件中包含对象。请注意，我们仍然不会<code>.keep</code>在<code>pack-objects</code>完成后删除包。这意味着我们可能会复制对象，但是这可以在并发推送或提取时使用此选项。此选项通常仅在使用<code>-b</code>or 编写位图时才有用<code>repack.writeBitmaps</code>，因为它可确保位图packfile具有必需的对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--unpack-unreachable=&lt;when&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>松开不可触及的对象时，不要打扰任何比以前更老的物体<code>&lt;when&gt;</code>。这可以用来优化任何可以立即被后续修剪的对象的写入<code>git prune</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-k   --keep-unreachable</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当与它一起使用时<code>-ad</code>，现有包中的任何不可达对象都将被添加到包文件的末尾，而不是被删除。另外，任何不可及的松散物体都将被包装（并且它们的松散对象被移除）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>组态</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，该命令将<code>--delta-base-offset</code>选项传递给<code>git pack-objects</code>; 这通常会导致更小的包，但生成的包与Git版本比1.4.4版本不兼容。如果您需要直接或通过哑HTTP协议来共享您的存储库中的古老Git版本，那么您需要将配置变量设置<code>repack.UseDeltaBaseOffset</code>为“false”并重新打包。通过本地协议从旧Git版本访问不受此选项的影响，因为在此情况下根据需要即时执行转换。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>另请参阅</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-pack-objects[1] git-prune-packed[1]</p></div></div></div>