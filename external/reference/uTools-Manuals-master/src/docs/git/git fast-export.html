<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-fast-export  -  Git 数据导出器</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git fast-export [options] | git fast-import</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>该程序将适当的修订以适合于<code>git fast-import</code>管理的形式转储。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以将其用作人可读的包替换（请参阅 git-bundle [1]），或作为一种交互式<code>git filter-branch</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Options</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>--progress=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>每个&lt;n&gt;对象插入<code>progress</code>语句，在导入期间以<code>git fast-import</code>显示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--signed-tags=(verbatim|warn|warn-strip|strip|abort)</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定如何处理签名标签。由于导出后的任何转换都可以更改标签名称（排除修订时也可能发生），因此签名将不匹配。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当询问<code>abort</code>（这是默认值）时，遇到签名标签时该程序将会死亡。使用时<code>strip</code>，标签将被无声签名，使用<code>warn-strip</code>，它们将被做成未签名的，但会显示一条警告，使用<code>verbatim</code>，它们将被静静地导出，使用<code>warn</code>，并且将被导出，但您会看到警告。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--tag-of-filtered-object=(abort|drop|rewrite)</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定如何处理其标签对象被滤除的标签。由于修改和导出的文件可能会受到路径的限制，因此标记的对象可能会被完全过滤。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当询问<code>abort</code>（这是默认值）时，遇到这样的标签时该程序将会死亡。因为<code>drop</code>它会从输出中省略这些标签。使用<code>rewrite</code>，如果带标签的对象是提交，它将重写标签以标记祖先提交（通过父级重写；请参阅 git-rev-list [1]）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-M   -C</p></div></div><div class="doc-postil"><div class="c-markdown"><p>按照 git-diff [1]手册页中所述执行移动和/或复制检测，并使用它在输出转储中生成重命名和复制命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，如果您提供了这些选项，则此命令的早期版本不会发出抱怨并产生不正确的结果。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--export-marks=&lt;file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>完成后将内部标记表转储到&lt;file&gt;。标记每行写成一个<code>:markid SHA-1</code>。只有修改标记才会被抛弃; 斑点的标记被忽略。后端可以使用此文件在导入完成后验证导入，或跨增量运行保存标记表。由于&lt;file&gt;仅在完成时打开并截断，因此可以将同一路径安全地分配给--import-marks。如果没有新的对象被标记/导出，该文件将不会被写入。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--import-marks=&lt;file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在处理任何输入之前，请加载&lt;文件&gt;中指定的标记。输入文件必须存在，必须可读，并且必须使用与--export-marks 相同的格式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>任何已经被标记的提交都不会再被导出。如果后端使用类似的--import-marks文件，则允许通过使标记在运行中保持相同来增量式双向导出存储库。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--fake-missing-tagger</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一些旧版本库的标签没有标签。快速导入协议对此非常严格，并且不允许这样做。所以假冒一个标签器可以快速导入输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--use-done-feature</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用<code>feature done</code>节开始流，并用<code>done</code>命令终止它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-data</p></div></div><div class="doc-postil"><div class="c-markdown"><p>跳过 blob 对象的输出，而是通过其原始 SHA-1散列引用 blob。当重写存储库的目录结构或历史记录而不触及单个文件的内容时，这非常有用。请注意，生成的流只能由已包含必要对象的存储库使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--full-tree</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此选项将导致快速导出为每个提交发出“deleteall”指令，后跟提交中所有文件的完整列表（而不仅仅列出与提交的第一个父代不同的文件）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--anonymize</p></div></div><div class="doc-postil"><div class="c-markdown"><p>匿名化存储库的内容，同时仍保留历史记录和存储树的形状。请参阅<code>ANONYMIZING</code>下面的部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--refspec</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将指定的 refspec 应用于每个导出的 ref。它们中的多个可以被指定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;git-rev-list-args&gt;…</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个参数的列表，可以接受<code>git rev-parse</code>和<code>git rev-list</code>，指定特定对象，并引用到出口。例如，<code>master~10..master</code>导致当前主引用与自第10个祖先提交后添加的所有对象一起导出。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>示例</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git fast-export --all | (cd /empty/repository &amp;&amp; git fast-import)</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这将导出整个存储库并将其导入现有的空存储库。除了重新编码未使用UTF-8的提交之外，它将是一对一的镜像。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git fast-export master~5..master |
        sed "s|refs/heads/master|refs/heads/other|" |
        git fast-import</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这使得从<code>master~5..master</code>一个新的分支调用<code>other</code>（即如果<code>master</code>有线性历史记录，它将采取最后5个提交）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，这假定该修订范围引用的 blob 和提交消息都不包含该字符串<code>refs/heads/master</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>匿名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--anonymize</code>给出该选项，git 将尝试从存储库中删除所有标识信息，同时仍保留足够的原始树和历史记录模式以重现一些错误。目标是在私有存储库中发现的
 git 错误将存储在匿名存储库中，后者可以与 git 开发人员共享以帮助解决该错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用这个选项，git 会用匿名数据替换输出中的所有 refnames、路径、blob内容，提交和标记消息，名称和电子邮件地址。相同字符串的两个实例将被等同替换（例如，两个同一作者的提交将在输出中具有相同的匿名作者，但与原作者字符串没有相似之处）。保留提交，分支和标签之间的关系以及提交时间戳（但提交消息和引用名与原始文件不相似）。保留树的相对构成（例如，如果您有一棵具有10个文件和3棵树的根树，输出也是如此），但是它们的名称和文件内容将被替换。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果你认为你已经发现了一个 git bug，你可以从导出整个存储库的匿名流开始：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git fast-export --anonymize --all &gt;anon-stream</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后确认该错误依然存在于从该流创建的存储库中（很多错误不会，因为它们确实取决于确切的存储库内容）：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git init anon-repo
$ cd anon-repo
$ git fast-import &lt;../anon-stream
$ ... test your bug ...</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果匿名存储库显示该错误，则可能值得<code>anon-stream</code>与常规错误报告一起共享。请注意，匿名流压缩得很好，所以鼓励它。如果您想检查流以查看它不包含任何私人数据，则可以在发送之前直接仔细阅读它。您可能还想尝试：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ perl -pe 's/\d+/X/g' &lt;anon-stream | sort -u | less</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>它显示了所有的独特行（将数字转换为“X”，将“用户0”，“用户1”等折叠为“用户X”）。这会产生更小的输出，并且通常很容易快速确认流中没有私人数据。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>限制</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>由于<code>git fast-import</code>不能标记树，因此它将不能完全导出 linux.git 存储库，因为它包含引用树而不是提交的标记。</p></div></div></div>