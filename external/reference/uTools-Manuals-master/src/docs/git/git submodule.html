<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>Name</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-submodule  - 初始化，更新或检查子模块</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git submodule [--quiet] add [&lt;options&gt;] [--] &lt;repository&gt; [&lt;path&gt;]git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;…]git submodule [--quiet] init [--] [&lt;path&gt;…]git submodule [--quiet] deinit [-f|--force] (--all|[--] &lt;path&gt;…)git submodule [--quiet] update [&lt;options&gt;] [--] [&lt;path&gt;…]git submodule [--quiet] summary [&lt;options&gt;] [--] [&lt;path&gt;…]git submodule [--quiet] foreach [--recursive] &lt;command&gt;git submodule [--quiet] sync [--recursive] [--] [&lt;path&gt;…]git submodule [--quiet] absorbgitdirs [--] [&lt;path&gt;…]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>检查，更新和管理子模块。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关子模块的更多信息，请参阅 gitsubmodules [7]。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>命令</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>add -b &lt;branch&gt; --name &lt;name&gt; --depth &lt;depth&gt; &lt;repository&gt; &lt;path&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将给定的存储库作为子模块添加到要在当前项目旁提交的变更集的给定路径：当前项目称为“超级项目”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;repository&gt; 是新子模块的源存储库的 URL 。这可能是一个绝对 URL ，或者（如果它以./或者../开始），相对于上层项目的默认远程仓库的位置（请注意，指定仓库<code>foo.git</code>位于旁边的一个上层项目<code>bar.git</code>，你”必须使用 - <code>../foo.git</code>而不是<code>./foo.git</code>- 遵循相对 URL 的规则时所期望的 - 因为 Git 中的相对 URL 的评估与相对目录的相同 URL 相同）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认远程是当前分支的远程追踪分支的远程。如果不存在这样的远程跟踪分支或 HEAD 被分离，则“原点”被假定为默认远程。如果超级项目没有配置默认远程，则超级项目是其自己的权威上游，而是使用当前工作目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可选参数 &lt;path&gt; 是克隆子模块存在于超级项目中的相对位置。如果没有给出 &lt;path&gt; ，则使用源存储库的规范部分（“repo”表示“/path/to/repo.git”，“foo”表示“host.xz：foo / .git”）。如果 &lt;path&gt; 存在并且已经是有效的 Git 存储库，那么它将进行无克隆提交。除非<code>--name</code>用于指定逻辑名称，否则 &lt;path&gt; 在其配置条目中也用作子模块的逻辑名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录给定的 URL <code>.gitmodules</code>以供后续用户克隆超级项目使用。如果该 URL 是相对于超级项目的存储库给出的，则假定是超级项目，并且子模块存储库将一起保存在相同的相对位置，并且只需要提供超级项目的 URL 。git-submodule 将使用中的 .gitmodules 的相对 URL 正确地定位子模块。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>status --cached --</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示子模块的状态。这将为每个子模块打印当前签出的提交的
 SHA-1 ，以及<code>git describe</code>用于 SHA-1 的子模块路径和输出。<code>-</code>如果子模块未初始化，<code>+</code>如果当前签出的子模块提交与包含存储库的索引中找到的 SHA-1 不匹配，并且<code>U</code>子模块存在合并冲突，则每个 SHA-1 都将加上前缀。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--recursive</code>指定，则此命令将递归嵌套子模块，并显示其状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您只对目前初始化的子模块相对于索引或 HEAD 中记录的提交感兴趣，git-status [1] 和 git-diff [1] 也会提供这些信息（也可以将更改报告给子模块的工作树）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>init --</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过<code>submodule.$name.url</code>在 .git / config 中设置来初始化索引中记录的子模块（已添加并在其他位置添加并提交）。它使用与<code>.gitmodules</code>模板相同的设置。如果 URL 是相对的，它将使用默认的远程进行解析。如果没有默认远程，则当前的存储库将被假定为上游。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可选的 &lt;path&gt; 参数限制了哪些子模块将被初始化。如果未指定路径并且已配置 submodule.active ，则将初始化配置为活动的子模块，否则会初始化所有子模块。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当存在时，它也将复制值<code>submodule.$name.update</code>。该命令不会改变 .git / config 中的现有信息。然后，您可以在 .git / config 中为您的本地设置定制子模块克隆 URL 并继续<code>git submodule update</code>; 如果您不打算自定义任何子模块位置，则也可以在<code>git submodule update --init</code>没有明确<code>init</code>步骤的情况下使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关默认远程的定义，请参阅 add 子命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>deinit -f|--force</p></div></div><div class="doc-postil"><div class="c-markdown"><p>取消注册给定的子模块，<code>submodule.$name</code>即将 .git / config 中的整个部分与其工作树一起移除。进一步呼吁<code>git submodule update</code>，<code>git submodule foreach</code>并<code>git submodule sync</code>会跳过所有未注册的子模块，直到再次初始化，所以使用这个命令，如果你不想在你的工作树子模块的本地结账了。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当命令在没有 pathspec 的情况下运行时，它会出错，而不是取消所有内容，以防止出错。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--force</code>指定，则子模块的工作树即使包含本地修改也将被删除。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您确实想从存储库中移除子模块并提交使用 git-rm [1]来代替。有关移除选项，请参阅 gitsubmodules [7]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>update --init -N | --no-fetch  -  no-recommend-shallow] -f | --force --reference &lt;repository&gt; --recursive  -</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过克隆缺失子模块和更新子模块的工作树，更新已注册的子模块以匹配超级项目所期望的内容。根据命令行选项和<code>submodule.&lt;name&gt;.update</code>配置变量的值，“更新”可以通过多种方式完成。命令行选项优先于配置变量。如果两者均未给出，则执行结账。更新过程支持从命令行以及设置<code>submodule.&lt;name&gt;.update</code>：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>checkout</p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录在超级项目中的提交将在分离的 HEAD 上的子模块中检出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--force</code>指定，则<code>git checkout --force</code>即使包含存储库的索引中指定的提交与子模块中签出的提交匹配，也会检出子模块（如果适用）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>rebase</p></div></div><div class="doc-postil"><div class="c-markdown"><p>子模块的当前分支将重新绑定到超级项目中记录的提交上。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge</p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录在超级项目中的提交将被合并到子模块中的当前分支中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以下过程仅通过<code>submodule.&lt;name&gt;.update</code>配置变量可用：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>自定义命令</p></div></div><div class="doc-postil"><div class="c-markdown"><p>执行采用单个参数（超级项目中记录的提交的sha1）的任意 shell
 命令。当<code>submodule.&lt;name&gt;.update</code>设置<code>!command</code>为时，感叹号后的剩余部分是自定义命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>none</p></div></div><div class="doc-postil"><div class="c-markdown"><p>子模块没有更新。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果子模块尚未初始化，并且只想使用存储的设置<code>.gitmodules</code>，则可以使用该<code>--init</code>选项自动初始化子模块。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--recursive</code>指定，则此命令将递归到已注册的子模块中，并更新其中的任何嵌套子模块。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>summary --cached | --files commit &lt;path&gt; ...</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在给定提交（默认为 HEAD ）和工作树/索引之间显示提交摘要。对于有问题的子模块，显示给定超级项目提交与索引或工作树（切换<code>--cached</code>）之间的子模块中的一系列提交。如果<code>--files</code>给出该选项，则在超级项目的索引和子模块的工作树之间显示子模块中的一系列提交（该选项不允许使用该<code>--cached</code>选项或提供显式提交）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>--submodule=log</code> git-diff [1] 的选项也会提供这些信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>foreach --recursive &lt;command&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在每个签出的子模块中评估一个任意的 shell 命令。该命令可以访问变量 $ name，$ path，$ sha1 和 $ toplevel：$ name 是相关子模块部分<code>.gitmodules</code>的名称，$ path 是相对于超级项目的子模块目录的名称，$ sha1 是提交记录在超级项目中，而 $ toplevel 是超级项目顶级的绝对路径。在超级项目中定义但未检出的任何子模块都将被此命令忽略。除非给出<code>--quiet</code>，否则
 foreach 在评估命令之前打印每个子模块的名称。如果<code>--recursive</code>给出子模块递归地遍历（即，给定的 shell 命令也在嵌套子模块中进行评估）。来自任何子模块中的命令的非零返回会导致处理终止。这可以通过添加<code>|| :</code>到命令的末尾来覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>作为示例，下面的命令将显示每个子模块的路径和当前签出的提交：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git submodule foreach 'echo $path `git rev-parse HEAD`'</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>sync --recursive &lt;path&gt;…</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将子模块的远程 URL 配置设置同步到中指定的值<code>.gitmodules</code>。它只会影响那些已经在 .git / config 中有
 URL 条目的子模块（这是在初始化或新添加的情况下）。当子模块 URL 更改为上游时，这很有用，因此您需要相应地更新本地存储库。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>“git submodule sync”同步所有子模块，而“git submodule sync-A”只同步子模块“A”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--recursive</code>指定，则此命令将递归到已注册的子模块中，并同步其中任何嵌套的子模块。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>absorbgitdirs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果子模块的 git 目录位于子模块内部，请将子模块的 git 目录移动到其超级项目<code>$GIT_DIR/modules</code>路径中，然后通过设置<code>core.worktree</code>和添加指向 git 目录中的 .git 文件来连接 git 目录及其工作目录超级项目 git 目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>独立克隆并随后添加为子模块或旧设置的存储库在子模块内部具有子模块 git 目录，而不是嵌入到 superprojects git 目录中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令默认是递归的。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-q   --quiet</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只打印错误消息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对 deinit 命令有效。取消注册工作树中的所有子模块。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-b   --branch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将存储库的分支添加为子模块。分支的名称记录<code>submodule.&lt;name&gt;.branch</code>在<code>.gitmodules</code>了<code>update --remote</code>。特殊值<code>.</code>用于指示子模块中分支的名称应与当前存储库中当前分支的名称相同。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-f   --force</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅适用于添加，删除和更新命令。在运行 add 时，允许添加一个否则忽略的子模块路径。在运行 deinit 时，即使子模块包含本地更改，也将删除子模块工作树。在运行 update 时（只对
 checkout 程序有效），在切换到其他提交时丢弃子模块中的本地更改; 并且始终在子模块中运行检出操作，即使包含存储库的索引中列出的提交与在子模块中检出的提交匹配也是如此。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--cached</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对状态和汇总命令有效。这些命令通常使用在子模块
 HEAD 中找到的提交，但使用此选项时，将使用存储在索引中的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--files</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对汇总命令有效。当使用此选项时，此命令会将索引中的提交与子模块 HEAD 中的提交进行比较。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-n   --summary-limit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对汇总命令有效。限制摘要大小（总共显示的提交数量）。给出0会禁用摘要; 负数表示无限制（默认）。此限制仅适用于修改的子模块。添加/删除/类型转换子模块的大小始终限制为1。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--remote</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对更新命令有效。使用子模块的远程跟踪分支的状态，而不是使用超级项目的已记录的 SHA-1 来更新子模块。使用的远程是分支的远程（<code>branch.&lt;name&gt;.remote</code>），默认为<code>origin</code>。远程分支使用默认为<code>master</code>，但分支名称可以通过设置覆盖<code>submodule.&lt;name&gt;.branch</code>选项在任一<code>.gitmodules</code>或<code>.git/config</code>（与<code>.git/config</code>采取优先次序）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这适用于任何支持的更新程序（<code>--checkout</code>，<code>--rebase</code>，等）。唯一的变化是目标 SHA-1 的来源。例如，<code>submodule update --remote --merge</code>将上<code>submodule update --merge</code>游子模块更改合并到子模块中，同时将超级项目 gitlink 更改合并到子模块中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为了确保当前的跟踪分支状态，<code>update --remote</code>在计算 SHA-1 之前获取子模块的远程存储库。如果你不想获取，你应该使用<code>submodule update --remote --no-fetch</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用此选项可将来自上游子项目的更改与子模块的当前 HEAD 集成。或者，您可以<code>git pull</code>从子模块运行，除远程分支名称外，其他子模块相同：<code>update --remote</code>使用默认的上游存储库<code>submodule.&lt;name&gt;.branch</code>，并<code>git pull</code>使用子模块<code>branch.&lt;name&gt;.merge</code>。身高：<code>submodule.&lt;name&gt;.branch</code>如果你想与上层项目分配默认的上游分支和<code>branch.&lt;name&gt;.merge</code>如果你想要一个更原始的感觉辅助模块本身工作时。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-N   --no-fetch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对更新命令有效。不要从远程站点获取新的对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--checkout</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对更新命令有效。检查子模块中分离的 HEAD 上超级项目中记录的提交。这是默认行为，此选项的主要用途是将其<code>submodule.$name.update</code>设置为除以外的值时覆盖<code>checkout</code>。如果密钥<code>submodule.$name.update</code>未明确设置或设置为<code>checkout</code>，则此选项是隐含的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--merge</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对更新命令有效。将超级项目中记录的提交合并到子模块的当前分支中。如果给出该选项，子模块的 HEAD 将不会被分离。如果合并失败阻止了此过程，则必须使用通常的冲突解决工具来解决子模块内产生的冲突。如果该键<code>submodule.$name.update</code>设置为<code>merge</code>，则此选项是隐含的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--rebase</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对更新命令有效。将当前分支重新映射到超级项目中记录的提交。如果给出该选项，子模块的 HEAD 将不会被分离。如果合并失败阻止了这个过程，你将不得不用 git-rebase 来解决这些失败[1]。如果该键<code>submodule.$name.update</code>设置为<code>rebase</code>，则此选项是隐含的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--init</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对更新命令有效。在更新之前，初始化尚未调用“git子模块init”的所有子模块。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--name</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对 add 命令有效。它将子模块的名称设置为给定字符串，而不是默认其路径。该名称必须是有效的目录名称，可能不会以<code>/</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--reference &lt;repository&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅适用于添加和更新命令。这些命令有时需要克隆远程存储库。在这种情况下，这个选项将被传递给 git-clone [1] 命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><strong>注意</strong>：不要<strong>不</strong>，除非你已经阅读说明了混帐克隆[1]的使用此选项<code>--reference</code>与<code>--shared</code>选项仔细。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--recursive</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此选项仅适用于foreach，更新，状态和同步命令。递归地遍历子模块。该操作不仅在当前回购的子模块中执行，而且在子模块内的任何嵌套子模块中执行（依此类推）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--depth</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项对添加和更新命令有效。创建一个<code>shallow</code>历史截断为指定修订版本的克隆。参见 git-clone [1]</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-recommend-shallow</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对更新命令有效。默认情况下，子模块的初始克隆将使用<code>submodule.&lt;name&gt;.shallow</code>由<code>.gitmodules</code>文件提供的建议。忽略建议使用<code>--no-recommend-shallow</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-j &lt;n&gt;   --jobs &lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅对更新命令有效。与多个作业并行克隆新的子模块。默认为<code>submodule.fetchJobs</code>选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;path&gt;…</p></div></div><div class="doc-postil"><div class="c-markdown"><p>子模块的路径。指定时，将限制该命令仅对在指定路径中找到的子模块进行操作。（这个参数是需要添加的）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>文档</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>初始化子模块时，将<code>.gitmodules</code>使用包含存储库的顶级目录中的文件来查找每个子模块的 url 。这个文件的格式应该和<code>$GIT_DIR/config</code>。每个子模块网址的关键是“submodule。$ name.url”。有关详细信息，请参阅 gitmodules [5]。</p></div></div></div>