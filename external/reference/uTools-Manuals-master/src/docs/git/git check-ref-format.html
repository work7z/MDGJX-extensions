<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-check-ref-format  - 确保引用名称格式正确</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git check-ref-format [--normalize]       [--[no-]allow-onelevel] [--refspec-pattern]       &lt;refname&gt;git check-ref-format --branch &lt;branchname-shorthand&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>检查给定<code>refname</code>是否可接受，如果不是，则退出非零状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 使用引用来指定分支和标签。分支头存储在<code>refs/heads</code>层次结构中，而标记存储在<code>refs/tags</code>ref命名空间的层次结构中（通常位于<code>$GIT_DIR/refs/heads</code>和<code>$GIT_DIR/refs/tags</code>目录中，或者作为<code>$GIT_DIR/packed-refs</code>文件中的条目，如果引用被<code>git gc</code>打包）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 对引用的命名方式施加了以下规则：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>1. 它们可以包括<code>/</code>用于分层（目录）分组的斜杠，但没有斜线不以<code>.</code>开始或以<code>.lock</code>序列结束。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>2. 它们必须包含至少一个<code>/</code>。这强制类似的<code>heads/</code>，<code>tags/</code>等存在，但是实际名称不受限制。如果使用<code>--allow-onelevel</code>选项，则放弃该规则。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>3. 他们不能在<code>..</code>任何地方有两个连续的点。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>4. 它们不能具有任何位置的 ASCII 控制字符（即，其值低于\ 040或\ 177<code>DEL</code>的字节），空格，波浪形符号<code>~</code>，插入符号<code>^</code>或冒号<code>:</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>5. 他们不能在任何地方出现问号<code>?</code>，星号<code>*</code>或开口支架<code>[</code>。有关<code>--refspec-pattern</code>此规则的例外情况，请参阅下面的选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>6. 它们不能以斜杠开始或结束，<code>/</code>或者包含多个连续的斜杠（请参阅<code>--normalize</code>下面的选项以了解此规则的例外情况）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>7. 它们不能以点<code>.</code>结束。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>8. 他们不能包含一个<code>@{</code>序列。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>9. 他们不能是单个<code>@</code>角色。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>10. 他们不能包含一个<code>\</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些规则使得基于 shell 脚本的工具可以很容易地解析引用名称，当引用名称被不加引号（错误地）使用引用名称时，通过 shell 进行路径名扩展，并且还避免了某些引用名称表达式中的歧义（请参阅gitrevisions [7]）：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>1. 像在<code>ref1..ref2</code>中经常使用双点<code>..</code>，在某些情况下，这个表示意味着<code>^ref1 ref2</code>（即不在<code>ref1</code>和在<code>ref2</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>2. 腭化符号<code>~</code>字符和补注号<code>^</code>字符被用于引入后缀<code>nth parent</code>和<code>peel onion</code>操作。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>3. 冒号<code>:</code>被用来在<code>srcref:dstref</code>中表示“ 在 srccref 的值中使用 srcref的值并将其存储在 dstref 中”在读取和推送操作中。它也可以用来选择一个特定的对象，比如 'git cat-file'：“git cat-file blob v1.3.3：refs.c”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>4. at-open-brace <code>@{</code>被用作访问 reflog 条目的符号。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过<code>--branch</code>选项，它可以扩展“以前的分支语法” <code>@{-n}</code>。例如，<code>@{-1}</code>是一种引用最后一个分支的方法。这个选项应该被porcelains用来在任何需要分支名称的地方接受这个语法，所以他们可以像你输入分支名称一样行事。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-allow-onelevel</p></div></div><div class="doc-postil"><div class="c-markdown"><p>控制是否接受单层refnames（即不包含多个<code>/</code>分离组件的refnames ）。默认是<code>--no-allow-onelevel</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--refspec-pattern</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将&lt;refname&gt;解释为refspec的参考名称模式（与远程存储库一起使用）。如果这个选项被激活，&lt;refname&gt;允许含有单个<code>*</code>中操作的Refspec（例如，<code>foo/bar*/baz</code>或<code>foo/bar*baz/</code>而不是<code>foo/bar*/baz*</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--normalize</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>refname</code>通过删除任何前导斜杠（<code>/</code>）字符并将名称组件之间相邻斜线的运行折叠为单斜杠来标准化。如果标准化的 refname 有效，那么将其输出到标准输出并以状态0退出，否则以非零状态退出。（<code>--print</code>是拼写<code>--normalize</code>的不赞成的方式。）</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>示例</h2></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>打印上一个分支的名称：$ git check-ref-format --branch @ { -  1}</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>确定用于新分支的参考名称：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ ref=$(git check-ref-format --normalize "refs/heads/$newbranch")|| { echo "we do not like '$newbranch' as a branch name." &gt;&amp;2 ; exit 1 ; }</p></div></div></div>