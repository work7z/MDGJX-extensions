<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-clone  - 将存储库克隆到新目录中</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git clone [--template=&lt;template_directory&gt;]          [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]          [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;]          [--dissociate] [--separate-git-dir &lt;git dir&gt;]          [--depth &lt;depth&gt;] [--[no-]single-branch] [--no-tags]          [--recurse-submodules] [--[no-]shallow-submodules]          [--jobs &lt;n&gt;] [--] &lt;repository&gt; [&lt;directory&gt;]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>将存储库克隆到新创建的目录中，为克隆存储库中的每个分支创建远程跟踪分支（可见使用<code>git branch -r</code>），并创建并签出分支存储库当前活动分支中分支的初始分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>克隆之后，<code>git fetch</code>没有参数的平原将更新所有远程跟踪分支，并且<code>git pull</code>如果有的话，一个不带参数的远程主分支将会合并到当前主分支中（当“--single-branch”为给出；见下文）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这种默认配置是通过创建对远程分支头的引用<code>refs/remotes/origin</code>以及通过初始化<code>remote.origin.url</code>和<code>remote.origin.fetch</code>配置变量来实现的。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>--local   -l</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当要克隆的存储库位于本地计算机上时，此标志绕过正常的“Git aware”传输机制，并通过复制 HEAD 和对象下的所有内容并引用目录来克隆存储库。<code>.git/objects/</code>如果可能，目录下的文件被硬链接以节省空间。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果存储库被指定为本地路径（例如，<code>/path/to/repo</code>），这是默认的，并且 -  
 local 本质上是没有操作的。如果存储库被指定为 URL，那么该标志将被忽略（并且我们从不使用本地优化）。指定<code>--no-local</code>将在<code>/path/to/repo</code>给定时重写默认值，而不是使用常规 Git 传输。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-hardlinks</p></div></div><div class="doc-postil"><div class="c-markdown"><p>强制从本地文件系统的存储库复制进程，以复制目录下的<code>.git/objects</code>文件而不是使用硬链接。如果您试图对存储库进行备份，这可能是可取的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--shared   -s</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当要克隆的存储库位于本地计算机上时，将自动设置<code>.git/objects/info/alternates</code>为与源存储库共享对象，而不是使用硬链接。生成的存储库首先没有任何对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><strong>注意</strong>：这是一个可能危险的操作；除非你了解它你<strong>不要</strong>使用它。如果您使用此选项克隆存储库，然后删除源存储库中的分支（或使用任何其他Git命令使任何现有的未提交的提交未引用），则某些对象可能会变为未引用（或悬挂）。这些对象可能被<code>git commit</code>自动调用的普通 Git 操作（如）删除<code>git gc --auto</code>。（请参阅 git-gc [1]。）如果这些对象被删除并被克隆存储库引用，则克隆的存储库将会损坏。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，<code>git repack</code>如果在<code>-l</code>克隆的存储库中运行时没有选项，<code>-s</code>则会将源存储库中的对象复制到克隆存储库中的包中，从而节省磁盘空间<code>clone -s</code>。但是，运行是安全的，默认情况下<code>git gc</code>使用该<code>-l</code>选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果要打破克隆<code>-s</code>在其源存储库中的存储库的依赖关系，可以简单地运行<code>git repack -a</code>以将源存储库中的所有对象复制到克隆存储库中的包中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--reference-if-able &lt;repository&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果参考存储库位于本地计算机上，则自动设置<code>.git/objects/info/alternates</code>为从参考存储库获取对象。将已经存在的存储库用作备用存储库将需要从正在克隆的存储库中复制更少的对象，从而降低网络和本地存储成本。使用时<code>--reference-if-able</code>，会跳过一个不存在的目录，并显示警告而不是中止克隆。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><strong>注意</strong>：请参阅<code>--shared</code>选项的注释，以及<code>--dissociate</code>选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--dissociate</p></div></div><div class="doc-postil"><div class="c-markdown"><p>借助<code>--reference</code>仅使用选项指定的引用存储库借用对象，以减少网络传输，并通过制作所需的借用对象的本地副本，在克隆完成后停止借用它们。当从已经借用另一个存储库中的对象的存储库本地克隆时，也可以使用此选项 - 新存储库将借用同一存储库中的对象，并且此选项可用于停止借用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--quiet   -q</p></div></div><div class="doc-postil"><div class="c-markdown"><p>安静地操作。进度未报告给标准错误流。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--verbose   -v</p></div></div><div class="doc-postil"><div class="c-markdown"><p>运行详细。不影响向标准错误流报告进度状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--progress</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定了-q。即使标准错误流未定向到终端，此标志也会强制进度状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-checkout   -n</p></div></div><div class="doc-postil"><div class="c-markdown"><p>克隆完成后，不执行HEAD签出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--bare</p></div></div><div class="doc-postil"><div class="c-markdown"><p>制作一个<code>bare</code>Git 存储库。也就是说，不是创建，<code>&lt;directory&gt;</code>并把行政文件<code>&lt;directory&gt;/.git</code>，使<code>&lt;directory&gt;</code>本身<code>$GIT_DIR</code>。这显然意味着，<code>-n</code>因为没有地方可以检查工作树。此外，遥控器上的分支头直接复制到相应的本地分支机构头上，而无需将其映射到<code>refs/remotes/origin/</code>。使用此选项时，不会创建远程跟踪分支和相关配置变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--mirror</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置源存储库的镜像。这意味着<code>--bare</code>。相比<code>--bare</code>，<code>--mirror</code>不仅映射源到目标的本地分支的地方分支，它映射所有参考文献（包括远程跟踪分支，笔记等），并设置了一个的
 Refspec 构造，使得所有这些参考文献通过覆盖<code>git remote update</code>在目标存储库。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--origin &lt;name&gt;   -o &lt;name&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要使用远程名称<code>origin</code>来跟踪上游存储库，请使用<code>&lt;name&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--branch &lt;name&gt;   -b &lt;name&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>而不是将新创建的 HEAD 指向克隆存储库 HEAD 指向的<code>&lt;name&gt;</code>分支，而是指向分支。在非裸仓库中，这是将被检出的分支。<code>--branch</code>也可以在生成的存储库中提交标签并分离 HEAD。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--upload-pack &lt;upload-pack&gt;   -u &lt;upload-pack&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当给定时，通过 ssh 访问要克隆的存储库，这为另一端运行的命令指定了非默认路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--template=&lt;template_directory&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定将使用模板的目录； （请参阅 git-init [1]的“TEMPLATE DIRECTORY”部分。）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--config &lt;key&gt;=&lt;value&gt;   -c &lt;key&gt;=&lt;value&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在新创建的存储库中设置配置变量; 这会在储存库初始化之后立即生效，但是在获取远程历史记录或检出任何文件之前。关键是与 git-config [1]预期的格式相同（例如，<code>core.eol=true</code>）。如果为同一个键指定了多个值，则每个值都将写入配置文件。例如，这可以安全地将其他提取参数添加到原始远程。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--depth &lt;depth&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>创建一个<code>shallow</code>历史截断为指定数目的提交的克隆。暗示<code>--single-branch</code>除非<code>--no-single-branch</code>给出所有分支的提示附近的历史。如果你想要简单地克隆子模块，也可以通过<code>--shallow-submodules</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--shallow-since=&lt;date&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在指定时间后创建一个具有历史记录的浅表克隆。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--shallow-exclude=&lt;revision&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>创建具有历史记录的浅层克隆，但不包括从指定远程分支或标记可访问的提交。该选项可以多次指定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-single-branch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只克隆导致单个分支尖端的历史记录，无论是由<code>--branch</code>选项指定还是主分支远程的<code>HEAD</code>指向。进一步提取到生成的存储库中将只会更新分支的远程跟踪分支，此选项用于初始克隆。如果在<code>--single-branch</code>创建克隆时远程的 HEAD 没有指向任何分支，则不会创建远程跟踪分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-tags</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要克隆任何标签，并<code>remote.&lt;remote&gt;.tagOpt=--no-tags</code>在配置中设置，确保将来<code>git pull</code>和<code>git fetch</code>操作不会跟随任何标签。后续显式标记提取仍然有效，（请参阅 git-fetch [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可以结合使用<code>--single-branch</code>来克隆和维护分支，而不是除单个克隆分支之外的引用。这对于维护某些存储库默认分支的最小克隆以实现搜索索引很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--recurse-submodules=&lt;pathspec</p></div></div><div class="doc-postil"><div class="c-markdown"><p>创建克隆后，根据提供的
 pathspec 初始化和克隆子模块。如果未提供 pathspec，则将初始化并克隆所有子模块。子模块使用其默认设置进行初始化和克隆。生成的克隆已<code>submodule.active</code>设置为提供的 pathspec 或“。” （意思是所有子模块），如果没有提供 pathspec。这相当于<code>git submodule update --init --recursive</code>克隆完成后立即运行。如果克隆库不具有 worktree /结帐忽略此选项（即如果任何的<code>--no-checkout</code>/ <code>-n</code>，<code>--bare</code>或<code>--mirror</code>给出）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-shallow-submodules</p></div></div><div class="doc-postil"><div class="c-markdown"><p>所克隆的所有子模块将会变浅，深度为1。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--separate-git-dir=&lt;git dir&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要将克隆的存储库放置在它应该存在的位置，而应将克隆的存储库放置在指定的目录中，然后创建一个与文件系统无关的 Git 符号链接。结果是 Git 仓库可以从工作树中分离出来。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-j &lt;n&gt;   --jobs &lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>同时获取的子模块的数量。默认为<code>submodule.fetchJobs</code>选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;repository&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>（可能是远程）从中克隆的存储库。有关指定存储库的更多信息，请参阅下面的
 URLS 部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;directory&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要克隆到的新目录的名称。如果没有明确指定目录（<code>repo</code>for <code>/path/to/repo.git</code>和<code>foo</code>for <code>host.xz:foo/.git</code>），则使用源代码库的“人道”部分。只有当目录为空时才允许克隆到现有目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Git urls</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>通常，URL 包含有关传输协议，远程服务器地址和存储库路径的信息。根据传输协议，这些信息可能不存在。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 支持 ssh，git，http和https 协议（另外，ftp 和 ftps 可以用于抓取，但效率不高，不推荐使用;不要使用它）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>本地传输（即 git：// URL）不会进行身份验证，因此应该谨慎使用不安全的网络。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以下语法可以与它们一起使用：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>ssh://user@host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>git://host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>https://host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>ftps://host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>ssh 协议也可以使用另一种类似 scp 的语法：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>user@host.xz:path/to/repo.git/只有在第一个冒号前没有斜线时才能识别此语法。这有助于区分包含冒号的本地路径。例如，本地路径<code>foo:bar</code>可以被指定为绝对路径或<code>./foo:bar</code>避免被误解为 ssh url。ssh 和 git 协议还支持〜用户名扩展：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>ssh://user@host.xz:port/~user/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>git://host.xz:port/~user/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>user@host.xz:/~user/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>对于本地支持的本地存储库，可以使用以下语法：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>file:///path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>这两种语法大部分是等价的，除了前者意味着--local 选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当 Git 不知道如何处理某个传输协议时，它会尝试使用<code>remote-&lt;transport&gt;</code>远程助手（如果存在）。要显式请求远程助手，可以使用以下语法：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>&lt;transport&gt; :: &lt;address&gt;其中&lt;address&gt;可能是一个路径，一个服务器和路径，或者是由被调用的特定远程助手识别的任意类似URL的字符串。有关详细信息，请参阅 gitremote-helpers [1]。如果存在大量名称相似的远程存储库，并且您希望为它们使用不同的格式（例如，您使用的URL将被重写为可工作的URL），则可以创建一个形式的配置部分：                                
                   [url "&lt;actual url base&gt;"]</p></li></ul><p>insteadOf = &lt;other url base&gt;For example, with this:        [url "git://git.host.xz/"]                                                                              
                insteadOf = host.xz:/path/to/                                             
                insteadOf = work:a URL like "work:repo.git" or like "host.xz:/path/to/repo.git" will be rewritten in any context that takes a URL to be "git://git.host.xz/repo.git".If you want to rewrite URLs for push only, you can create a configuration section of the form:        [url "&lt;actual url base&gt;"]                                                                                       
                pushInsteadOf = &lt;other url base&gt;For example, with this:        [url "ssh://example.org/"]                                                                 
                pushInsteadOf = git://example.org/a URL like "git://example.org/path/to/repo.git" will be rewritten to "ssh://example.org/path/to/repo.git" for pushes, but pulls will still use the original URL.Examples</p><p><br/></p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>从上游克隆：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux $ cd my-linux $ make</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>制作一个从当前目录借用的本地克隆，而不检查事情：$ git clone -l -s -n。../copy $ cd ../copy $ git show-branch</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>从现有本地目录借用时从上游克隆：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git clone --reference /git/linux.git \         git://git.kernel.org/pub/scm/.../linux.git \         my-linux $ cd my-linux</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>创建一个裸存储库，将公布的更改发布给公众：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git clone --bare -l /home/proj/.git /pub/scm/proj.git</p></div></div></div>