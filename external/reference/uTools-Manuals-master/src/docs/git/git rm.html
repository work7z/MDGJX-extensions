<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-rm  - 从工作树和索引中删除文件</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch] [--quiet] [--] &lt;file&gt;…</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>从索引中删除文件，或从工作树和索引中删除文件。<code>git rm</code>不会从您的工作目录中删除文件。（没有选择只从工作树中删除文件，而是将其保留在索引中; <code>/bin/rm</code>如果您想这样做，则使用该选项。）被删除的文件必须与分支的提示相同，并且不会更新他们的内容可以放在索引中，尽管这个默认行为可以被<code>-f</code>选项覆盖。当<code>--cached</code>给出时，分阶段内容必须匹配分支的尖端或磁盘上的文件，从而允许从索引中删除文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;file&gt;…</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要删除的文件。<code>*.c</code>可以给 Fileglobs（例如）删除所有匹配的文件。如果你想让 Git 扩展文件全局字符，你可能需要 shell 来逃避它们。一个主要的目录名（例如<code>dir</code>删除<code>dir/file1</code>和<code>dir/file2</code>）可以删除目录中的所有文件，递归地删除所有子目录，但是这需要<code>-r</code>明确给出选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-f   --force</p></div></div><div class="doc-postil"><div class="c-markdown"><p>覆盖最新的检查。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-n   --dry-run</p></div></div><div class="doc-postil"><div class="c-markdown"><p>切勿删除任何文件。相反，只需显示它们是否存在于索引中，否则将被命令删除。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-r</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当给出主目录名时允许递归删除。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此选项可用于将命令行选项与文件列表分开，（当文件名可能被误认为是命令行选项时很有用）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--cached</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用此选项可以取消仅从索引中删除路径的情况。工作树文件，无论是否修改，都将被单独保留。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ignore-unmatch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>即使没有匹配的文件，也可以用零状态退出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-q   --quiet</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git rm</code>通常<code>rm</code>为每个被删除的文件输出一行（以命令的形式）。该选项禁止输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>讨论</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>给该命令的 &lt;file&gt; 列表可以是精确的路径名，文件全局模式或主目录名。该命令仅删除 Git 已知的路径。给出你没有告诉 Git 的文件的名称不会删除该文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>跨越目录边界的文件匹配匹配。因此，给定两个目录<code>d</code>和<code>d2</code>使用<code>git rm 'd*'</code>和之间有区别<code>git rm 'd/*'</code>，因为前者也会删除所有目录<code>d2</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>删除已从文件系统中消失的文件</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>没有选择<code>git rm</code>只从索引中删除从文件系统中消失的路径。但是，根据使用情况，有几种方法可以完成。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>使用“git commit -a”</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您打算您的下一次提交应记录工作树中所有跟踪文件的所有修改，并记录已从工作树中删除的所有文件的清除<code>rm</code>（而不是<code>git rm</code>），请使用<code>git commit -a</code>，因为它会自动通知并记录所有清除。您也可以在不使用提交的情况下获得类似的效果<code>git add -u</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>使用 “git add -A”</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>在接受供应商分支的新代码丢失时，您可能需要记录删除路径和添加新路径以及修改现有路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通常，您将首先使用以下命令从工作树中删除所有跟踪的文件：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git ls-files -z | xargs -0 rm -f</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后解压缩工作树中的新代码。或者，您可以<code>rsync</code>将更改导入工作树。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>之后，在工作树中记录所有删除，添加和修改的最简单方法是：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git add -A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>参见git-add [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>其他方法</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您真的想要从索引中移除工作树中不再存在的文件（可能是因为您的工作树不完美，以至于无法使用<code>git commit -a</code>），请使用以下命令：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>子模块</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>只有使用 gitfile 的子模块（意味着它们被克隆为 Git 1.7.8 或更高版本）将从工作树中移除，因为它们的存储库位于超级项目的 .git 目录中。如果子模块（或其中嵌套的模块之一）仍然使用 .git 目录，<code>git rm</code>则会将子模块 git 目录移动到超级项目 git 目录中以保护子模块的历史记录。如果存在子模块，gitmodules [5]文件中的 &lt;name&gt; 部分也将被删除，并且该文件将被暂存（除非使用 --cached 或 -n ）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当 HEAD 与索引中记录的相同时，子模块被认为是最新的，没有跟踪的文件被修改，并且子模块工作树中不存在未被忽略的未跟踪文件。忽略的文件被认为是可消耗的，并且不会阻止子模块的工作树被移除。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您只想从工作树中删除子模块的本地签出而不提交删除，请将<code>deinit</code>改为使用 git-submodule [1] 。有关子模块删除的详细信息，另请参阅 gitsubmodules [7] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git rm Documentation/\*.txt</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>*.txt</code>从索引中删除<code>Documentation</code>目录及其任何子目录下的所有文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，<code>*</code>在本例中星号是从 shell 引用的; 这让 Git（而不是shell）能够扩展目录下的文件和子目录的路径名<code>Documentation/</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git rm -f git-*.sh</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>因为这个例子让 shell 扩展了星号（即你明确列出了这些文件），所以它不会被删除<code>subdir/git-foo.sh</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Bugs</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>每次父项目更新移除已填充的子模块时（例如，在移除之前和之后在提交之间切换时），旧的子模块签出将保留在旧位置。删除旧目录仅在使用 gitfile 时才是安全的，否则子模块的历史记录也会被删除。执行递归子模块更新时，此步骤将会过时。</p></div></div></div>