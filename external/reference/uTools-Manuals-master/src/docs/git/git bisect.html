<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-bisect  - 使用二进制搜索来查找引入错误的提交</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git bisect &lt;subcommand&gt; &lt;options&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令根据子命令采用各种子命令和不同的选项：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git bisect start [--term-{old,good}=&lt;term&gt; --term-{new,bad}=&lt;term&gt;]          [--no-checkout] [&lt;bad&gt; [&lt;good&gt;...]] [--] [&lt;paths&gt;...]git bisect (bad|new|&lt;term-new&gt;) [&lt;rev&gt;]git bisect (good|old|&lt;term-old&gt;) [&lt;rev&gt;...]git bisect terms [--term-good | --term-bad]git bisect skip [(&lt;rev&gt;|&lt;range&gt;)...]git bisect reset [&lt;commit&gt;]git bisect visualize
git bisect replay &lt;logfile&gt;git bisect log
git bisect run &lt;cmd&gt;...git bisect help</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令使用二进制搜索算法来查找项目历史记录中的哪个提交引入了错误。通过首先告诉它一个已知包含该错误的“错误”提交以及一个在引入该错误之前已知的“良好”提交来使用它。然后<code>git bisect</code>在这两个端点之间选择一个提交，并询问所选提交是“好”还是“坏”。它继续缩小范围，直到找到引入更改的确切提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>事实上，<code>git bisect</code>可以用来发现改变提交<strong>的任何</strong>项目的财产; 例如，修正错误的提交或导致基准性能提高的提交。为了支持这种更一般的用法，可以使用术语“旧”和“新”来代替“好”和“坏”，或者可以选择自己的术语。有关更多信息，请参见下面的“替代条款”部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>基本平分命令：开始，坏，好</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>作为一个例子，假设您正在尝试查找违反已知可在<code>v2.6.13-rc2</code>您的项目版本中工作的功能的提交。你开始平分会议如下：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect start
$ git bisect bad                 # Current version is bad
$ git bisect good v2.6.13-rc2    # v2.6.13-rc2 is known to be good</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>一旦你指定了至少一个坏的和一个好的提交，<code>git bisect</code>在该历史范围的中间选择一个提交，检查出来，并输出类似于以下内容的提交：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">Bisecting: 675 revisions left to test after this (roughly 10 steps)</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>您现在应该编译检出版本并对其进行测试。如果该版本正常工作，请键入</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect good</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果该版本已损坏，请键入</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect bad</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后<code>git bisect</code>会用类似的回应</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">Bisecting: 337 revisions left to test after this (roughly 9 steps)</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>继续重复这个过程：编译树，测试它，并根据它是好还是坏运行<code>git bisect good</code>或<code>git bisect bad</code>询问下一个需要测试的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>最终将不会有更多的修订留下来检查，并且该命令将打印出第一个错误提交的描述。该引用<code>refs/bisect/bad</code>将指向该提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>平分复位</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>在平分会话之后，要清理平分状态并返回到原始 HEAD，请发出以下命令：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect reset</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，这会将您的树返回到之前签出的提交<code>git bisect start</code>。（一个新的<code>git bisect start</code>也会这样做，因为它清理了旧的二分法状态。）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用可选参数，您可以返回到其他提交：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect reset &lt;commit&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，<code>git bisect reset bisect/bad</code>将检查第一个错误的修订，同时<code>git bisect reset HEAD</code>会让您处于当前的平分提交并避免切换提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>替代条款</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>有时候你并不是在寻找导致破坏的提交，而是寻找导致其他“旧”状态和“新”状态之间发生变化的提交。例如，您可能正在寻找引入特定修补程序的提交。或者您可能正在寻找第一次提交，其中源代码文件名最终全部转换为贵公司的命名标准。管他呢。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在这种情况下，使用“好”和“坏”这两个术语来指代“改变前的状态”和“改变后的状态”可能会非常混乱。相反，您可以分别使用术语“旧”和“新”来代替“好”和“坏”。（但请注意，您不能在单个会话中将“好”和“坏”与“旧”和“新”混合在一起。）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在这个更通用的用法中，你提供<code>git bisect</code>了一个“新”提交，它有一些属性和一个没有该属性的“旧”提交。每次<code>git bisect</code>检出提交时，都会测试该提交是否具有该属性。如果是，则将提交标记为“新”; 否则，将其标记为“旧”。当平分完成后，<code>git bisect</code>将报告哪个提交引入了属性。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要使用“old”和“new”而不是“good”和 bad，你必须运行<code>git bisect start</code>没有提交作为参数，然后运行以下命令来添加提交：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git bisect old [&lt;rev&gt;]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>表明某个提交是在寻求更改之前进行的，或者</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git bisect new [&lt;rev&gt;...]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>以表明它是在之后。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要获得当前使用条款的提醒，请使用</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git bisect terms</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>你可以用<code>git bisect term --term-old</code>or <code>git bisect term --term-good</code>来获得旧的（分别是新的）术语。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果你想用你自己的条件，而不是“坏” /“好”或“新” /“老”，你可以选择你喜欢的任何名称（除现有对开子一样<code>reset</code>，<code>start</code>通过使用开始平分，...）</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git bisect start --term-old &lt;term-old&gt; --term-new &lt;term-new&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，如果您正在寻找引入性能回归的提交，则可以使用</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git bisect start --term-old fast --term-new slow</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>或者，如果您正在寻找修复错误的提交，则可以使用</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git bisect start --term-new fixed --term-old broken</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后，使用<code>git bisect &lt;term-old&gt;</code>和<code>git bisect &lt;term-new&gt;</code>代替<code>git bisect good</code>和<code>git bisect bad</code>标记提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>平分可视化</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>要查看当前剩余的可疑对象<code>gitk</code>，请在对分过程中发出以下命令：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect visualize</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>view</code>也可以用作同义词<code>visualize</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>DISPLAY</code>没有设置环境变量，<code>git log</code>则用来代替。您还可以提供诸如<code>-p</code>和<code>--stat</code>的命令行选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect view --stat</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>平分日志和平分重播</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>在将修订标记为好或不好之后，发出以下命令以显示迄今为止所做的工作：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect log</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您发现在指定修订状态时出错，可以将此命令的输出保存到文件中，对其进行编辑以删除不正确的条目，然后发出以下命令以返回到更正的状态：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect reset
$ git bisect replay that-file</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>避免测试提交</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>如果在平分会话中，您知道建议的修订版不适合测试（例如，它无法构建并且您知道失败与您正在追踪的错误没有任何关系），那么您可以手动选择一个附近的提交并测试那个。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect good/bad                        # previous round was good or bad.Bisecting: 337 revisions left to test after this (roughly 9 steps)$ git bisect visualize                        # oops, that is uninteresting.$ git reset --hard HEAD~3                # try 3 revisions before what
                                        # was suggested</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后编译并测试所选修订版，然后以通常方式将修订版标记为好或不好。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>平分跳过</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以通过发出以下命令来请求 Git 为您执行：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect skip                 # Current version cannot be tested</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>但是，如果您跳过与您正在寻找的相邻的提交，那么 Git 将无法准确地确定哪些提交是第一个不合格提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您也可以使用范围表示法跳过一系列提交，而不是仅提交一次提交。例如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect skip v2.5..v2.6</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这告诉平分过程，在测试之后<code>v2.5</code>，直到并包括<code>v2.6</code>，都不应该进行提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，如果您还想跳过该范围的第一次提交，则可以发出以下命令：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect skip v2.5 v2.5..v2.6</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这表明平分过程，应该跳过<code>v2.5</code>和<code>v2.6</code>（包括）之间的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>通过提供更多的参数来平分开始，减少平分</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>如果通过发出<code>bisect start</code>命令时指定路径参数，您可以进一步减少试验次数，如果您知道您要追踪的问题涉及哪部分树，请执行以下操作：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect start -- arch/i386 include/asm-i386</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果事先知道多个好提交，则可以在发出<code>bisect start</code>命令时通过在错误提交之后立即指定所有好提交来缩小对分空间：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect start v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 --
                   # v2.6.20-rc6 is bad
                   # v2.6.20-rc4 and v2.6.20-rc1 are good</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>平分运行</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您有一个脚本可以确定当前源代码是好还是坏，可以通过发出以下命令来平分：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect run my_script arguments</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>注意，<code>my_script</code>如果当前源代码是好的/旧的，脚本（在上面的例子中）应该以代码0退出，并且以1和127之间的代码（包括125）退出，除非125，如果当前源代码是坏的/新的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>任何其他退出代码将中止对分过程。应该指出的是，一个程序，通过<code>exit(-1)</code> leaves $? = 255，（参见出口（3）手册页），因为值被<code>&amp; 0377</code>切断。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当不能测试当前源代码时，应使用特殊退出码125。如果脚本以此代码退出，则当前修订将被跳过（参见<code>git bisect skip</code>上文）。125被选为用于此目的的最高敏感值，因为 POSIX shell 使用126和127来表示特定的错误状态（127表示找不到命令，126表示找到的命令但不可执行 - 这些细节不会问题，因为它们在脚本中是正常的错误，就其<code>bisect run</code>而言）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>你可能经常会发现，在平分会话期间，你希望进行临时修改（例如，在头文件中s/#define DEBUG 0/#define DEBUG 1/，或者“没有这个提交的修订版本需要这个补丁应用于解决方法另一个问题是这种平分不感兴趣“）适用于正在测试的版本。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为了应对这种情况，在内部<code>git bisect</code>发现下一个修订版测试之后，脚本可以在编译之前应用修补程序，运行真实测试，然后确定修订版（可能包含所需修补程序）是否通过测试，然后倒带树到原始状态。最后，脚本应该以真实测试的状态退出，让<code>git bisect run</code>命令循环确定对分会话的最终结果。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-checkout</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在平分过程的每次迭代中，不要签出新的工作树。相反，只需更新一个特定的引用<code>BISECT_HEAD</code>，使其指向应该测试的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当您在每个步骤中执行的测试不需要检出树时，此选项可能很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设<code>--no-checkout</code>，如果存储库是裸露的。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>示例</h2></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>在v1.2和HEAD之间自动平分一个破损的构建：$ git bisect start HEAD v1.2  - ＃HEAD不好，v1.2很好$ git bisect run make＃“make”构建应用程序$ git bisect reset＃quit平分会议</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>自动平分原点和 HEAD 之间的测试失败：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git bisect start HEAD origin --    # HEAD is bad, origin is good $ git bisect run make test           # "make test" builds and tests $ git bisect reset                   # quit the bisect session</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>Automatically bisect a broken test case:
  $ cat ~/test.sh #!/bin/sh make || exit 125                     # this skips broken builds ~/check_test_case.sh                 # does the test case pass? $ git bisect start HEAD HEAD~10 --   # culprit is among the last 10 $ git bisect run ~/test.sh $ git bisect reset                   # quit the bisect sessionHere we use a <code>test.sh</code> custom script. In this script, if <code>make</code> fails, we skip the current commit. <code>check_test_case.sh</code> should <code>exit 0</code> if the test case passes, and <code>exit 1</code> otherwise.
It is safer if both <code>test.sh</code> and <code>check_test_case.sh</code> are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>通过临时修改自动平分（热修复）：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ cat ~/test.sh #!/bin/sh  # tweak the working tree by merging the hot-fix branch # and then attempt a build if        git merge --no-commit hot-fix &amp;&amp;         make then         # run project specific test and report its status         ~/check_test_case.sh         status=$? else         # tell the caller this is untestable         status=125 fi  # undo the tweak to allow clean flipping to the next commit git reset --hard  # return control exit $status</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这适用于在每次测试运行之前从热修复分支进行的修改，例如，如果您的构建或测试环境发生变化，以便旧版本可能需要修复哪些新版本已经修复。（确保烫分支是基于关闭提交其包含在你平分所有修订，使合并没有太多拉，或使用<code>git cherry-pick</code>替代<code>git merge</code>。）</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>自动对分破损的测试用例：$ git bisect start HEAD HEAD〜10  - ＃ctrprit是最后10个$ git bisect运行sh -c“make || exit 125;〜/ check_test_case.sh”$ git bisect reset＃quit平分会话这表明，如果您在单行上编写测试，则可以不使用运行脚本。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>在损坏的存储库中找到对象图的一个好区域</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git bisect start HEAD &lt;known-good-commit&gt;  &lt;boundary-commit&gt; ...  --no-checkout $ git bisect run sh -c '         GOOD=$(git for-each-ref "--format=%(objectname)" refs/bisect/good-*) &amp;&amp;         git rev-list --objects BISECT_HEAD --not $GOOD &gt;tmp.$$ &amp;&amp;         git pack-objects --stdout &gt;/dev/null &lt;tmp.$$         rc=$?         rm -f tmp.$$         test $rc = 0'  $ git bisect reset                   # quit the bisect session</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在这种情况下，当<code>git bisect run</code>完成时，bisect / bad 将引用一个提交，该提交至少有一个可达图<code>git pack objects</code>可完全遍历的父对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>在代码中寻找修复而不是回归</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git bisect start $ git bisect new HEAD    # current commit is marked as new $ git bisect old HEAD~10 # the tenth commit from now is marked as old</p></div></div><div class="doc-postil"><div class="c-markdown"><p>or:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git bisect start --term-old broken --term-new fixed$ git bisect fixed
$ git bisect broken HEAD~10</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>获得帮助</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>git bisect</code>得到一个简短的使用说明，以及<code>git bisect help</code>或<code>git bisect -h</code>获得长期的使用说明。</p></div></div></div>