<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-for-each-ref  - 每个参考的输出信息</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git for-each-ref [--count=&lt;count&gt;] [--shell|--perl|--python|--tcl]                   [(--sort=&lt;key&gt;)…] [--format=&lt;format&gt;] [&lt;pattern&gt;…]                   [--points-at=&lt;object&gt;]                   (--merged[=&lt;object&gt;] | --no-merged[=&lt;object&gt;])                   [--contains[=&lt;object&gt;]] [--no-contains[=&lt;object&gt;]]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>迭代所有匹配的ref <code>&lt;pattern&gt;</code>并根据给定的值显示它们<code>&lt;format&gt;</code>，然后根据给定的集合对它们进行排序<code>&lt;key&gt;</code>。如果<code>&lt;count&gt;</code>给出，请在显示多个参考后停止。插入的值<code>&lt;format&gt;</code>可以选择性地作为指定宿主语言中的字符串文本引用，以便用该语言直接进行评估。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;pattern&gt;…</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果给出了一个或多个模式，则只显示与至少一个模式相匹配的引用，或者使用fnmatch（3）或从字面上匹配，在后一种情况下完全匹配或从开始直到斜杠。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--count=&lt;count&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，该命令显示所有匹配的参考<code>&lt;pattern&gt;</code>。该选项会在显示多个参考文件后停止。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--sort=&lt;key&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要排序的字段名称。前缀<code>-</code>按值的降序进行排序。未指定时<code>refname</code>使用。您可以多次使用--sort = &lt;key&gt;选项，在这种情况下，最后一个键变为主键。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--format=&lt;format&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个字符串，<code>%(fieldname)</code>从显示的ref和它指向的对象中插入。如果<code>fieldname</code>前缀为asterisk（<code>*</code>）并且ref指向标记对象，则使用标记对象引用的对象中的字段的值（而不是标记对象中的字段）。未指定时，<code>&lt;format&gt;</code>默认为<code>%(objectname) SPC %(objecttype) TAB %(refname)</code>。它还插值<code>%%</code>到<code>%</code>，和<code>%xx</code>其中<code>xx</code>是十六进制数字插值以十六进制码字符<code>xx</code>; 例如<code>%00</code>内插到<code>\0</code>（NUL），<code>%09</code>到<code>\t</code>（TAB）和<code>%0a</code>到<code>\n</code>（LF）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--color = &lt;when&gt;：尊重<code>--format</code>选项中指定的任何颜色。该<code>&lt;when&gt;</code>字段必须是中的一个<code>always</code>，<code>never</code>或者<code>auto</code>（如果<code>&lt;when&gt;</code>不存在，表现得好像<code>always</code>给予）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--shell   --perl   --python   --tcl</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果给定，则替换<code>%(fieldname)</code>占位符的字符串将被引用为适用于指定主机语言的字符串文字。这是为了产生一个可以直接<code>eval</code>编辑的scriptlet 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--points-at=&lt;object&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只列出指向给定对象的ref。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--merged=&lt;object&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只列出其提示可从指定提交（HEAD，如果未指定）可访问的ref，与不兼容<code>--no-merged</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-merged=&lt;object&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只列出其提示无法从指定提交（HEAD，如果未指定）到达的ref，与之不兼容<code>--merged</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--contains=&lt;object&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只列出包含指定提交的引用（如果未指定，则为HEAD）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-contains=&lt;object&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只列出不包含指定提交的引用（如果未指定，则为HEAD）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ignore-case</p></div></div><div class="doc-postil"><div class="c-markdown"><p>排序和过滤ref是不区分大小写的。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>字段名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>引用对象中结构化字段的各种值可用于内插到结果输出中，或作为排序键。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于所有对象，可以使用以下名称：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>refname</p></div></div><div class="doc-postil"><div class="c-markdown"><p>参考名称（$ GIT_DIR /之后的部分）。对于ref的append不含糊不清的短名称<code>:short</code>。选项core.warnAmbiguousRefs用于选择严格的缩写模式。如果<code>lstrip=&lt;N&gt;</code>（<code>rstrip=&lt;N&gt;</code>）将被附加，条<code>&lt;N&gt;</code>斜线分隔径分量从refname的前部（背面）（例如<code>%(refname:lstrip=2)</code>变成<code>refs/tags/foo</code>为<code>foo</code>与<code>%(refname:rstrip=2)</code>转动<code>refs/tags/foo</code>成<code>refs</code>）。如果<code>&lt;N&gt;</code>是一个负数，从指定的端部带一样多路径成分作为必要离开<code>-&lt;N&gt;</code>路径组件（例如<code>%(refname:lstrip=-2)</code>变成<code>refs/tags/foo</code>为<code>tags/foo</code>和<code>%(refname:rstrip=-1)</code>导通<code>refs/tags/foo</code>到<code>refs</code>）。当ref没有足够的组件时，如果使用正数&lt;N&gt;剥离，结果将变为空字符串，或者如果使用负数&lt;N&gt;剥离，则结果变为完整的refname。两者都不是错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>strip</code>可以作为synomym来使用<code>lstrip</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>objecttype</p></div></div><div class="doc-postil"><div class="c-markdown"><p>类型的对象的（<code>blob</code>，<code>tree</code>，<code>commit</code>，<code>tag</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>objectsize</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对象的大小（与<code>git cat-file -s</code>报告相同）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>objectname</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对象名称（又名SHA-1）。对于对象名称的非模糊缩写追加<code>:short</code>。对于具有所需长度的对象名称的缩写append <code>:short=&lt;length&gt;</code>，其中最小长度为MINIMUM_ABBREV。长度可能会超过以确保唯一的对象名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>upstream</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示的参考文献中可以考虑为“上游”的本地参考文献的名称。尊重<code>:short</code>，<code>:lstrip</code>并<code>:rstrip</code>以与<code>refname</code>上述相同的方式。此外，<code>:track</code>还要显示“前N，后M”并<code>:trackshort</code>显示简短版本：“&gt;”（前面），“&lt;”（后面），“&lt;&gt;”（前后）或“=”（同步） 。<code>:track</code>当遇到未知的上游参考时也打印“消失”。追加<code>:track,nobracket</code>显示无括号的追踪信息（即“前N，后M”）。如果裁判没有跟踪信息，则不起作用。所有选项除外<code>nobracket</code>是互斥的，但如果一起使用，则选择最后一个选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>push</p></div></div><div class="doc-postil"><div class="c-markdown"><p>代表<code>@{push}</code>所显示文献位置的本地参考文献的名称。尊重<code>:short</code>，<code>:lstrip</code>，<code>:rstrip</code>，<code>:track</code>，和<code>:trackshort</code>选项<code>upstream</code>呢。如果未<code>@{push}</code>配置ref，则生成一个空字符串。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>HEAD</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>*</code> 如果HEAD与当前参考（已签出的分支）匹配，则返回“否则”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color</p></div></div><div class="doc-postil"><div class="c-markdown"><p>更改输出颜色。接下来<code>:&lt;colorname&gt;</code>，在git-config [1]的“CONFIGURATION FILE”部分的Values下描述颜色名称。例如，<code>%(color:bold red)</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>align</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将％（align：...）和％（end）之间的内容左对齐，中对齐或右对齐。该“对齐”之后<code>width=&lt;width&gt;</code>和<code>position=&lt;position&gt;</code>在用逗号，其中所分离的任何次序<code>&lt;position&gt;</code>要么左，右或中间，被留默认和<code>&lt;width&gt;</code>与对准的内容的总长度。为简洁起见，可以省略“width =”和/或“position =”前缀，而使用&lt;width&gt;和&lt;位置&gt;。例如，<code>%(align:&lt;width&gt;,&lt;position&gt;)</code>。如果内容长度大于宽度，则不执行对齐。如果使用<code>--quote</code>％（align：...）和％（end）之间的所有内容进行引用，但是如果嵌套，则只有最顶层执行引用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>if</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用作％（if）...％（then）...％（end）或％（if）...％（then）...％（else）...％（end）。如果在％（if）之后有值或字符串的原子，则％（then）后面的所有内容都将被打印，否则如果使用％（else）原子，则打印％（else）后的所有内容。当在％（then）之前评估字符串时，我们会忽略空格，当我们使用打印“*”或“”的％（HEAD）原子时，这很有用，我们只想将该<code>if</code>条件应用于<code>HEAD</code>ref。追加“：等于= &lt;字符串&gt;”或“：notequals = &lt;字符串&gt;”以比较％（如果......）和％（然后）原子与给定字符串之间的值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>symref</p></div></div><div class="doc-postil"><div class="c-markdown"><p>给定的符号ref引用的ref。如果不是符号参考，则不会打印任何内容。尊重<code>:short</code>，<code>:lstrip</code>并<code>:rstrip</code>在为同样的方式选择<code>refname</code>以上。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除了上述之外，用于提交和标签对象，报头字段名（<code>tree</code>，<code>parent</code>，<code>object</code>，<code>type</code>，和<code>tag</code>）可以被用来指定在报头字段中的值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于提交和标记对象，特殊字段<code>creatordate</code>和<code>creator</code>字段将根据对象类型与<code>committer</code>或<code>tagger</code>字段中的相应日期或名称 - 电子邮件日期元组相对应。这些旨在用于混合使用注释和轻量级标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有名字的电子邮件最新的元组作为其值的字段（<code>author</code>，<code>committer</code>，和<code>tagger</code>）可以与后缀<code>name</code>，<code>email</code>以及<code>date</code>提取命名组件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提交和标签对象中的完整消息是<code>contents</code>。它的第一行是<code>contents:subject</code>，主题是提交消息的所有行连接到第一个空白行。接下来的一行是<code>contents:body</code>，body是第一个空白行之后的所有行。可选的GPG签名是<code>contents:signature</code>。<code>N</code>消息的第一行是使用获得的<code>contents:lines=N</code>。此外，由git-interpret-trailers [1]解释的预告片也可以获得<code>contents:trailers</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用于排序目的，与字段排序按数值顺序排列的数字值（<code>objectsize</code>，<code>authordate</code>，<code>committerdate</code>，<code>creatordate</code>，<code>taggerdate</code>）。所有其他字段都用于按字节值顺序排序。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>还有一个选项可以按版本排序，这可以通过使用字段名<code>version:refname</code>或其别名来完成<code>v:refname</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在任何情况下，引用不适用于由ref引用的对象的字段的字段名称都不会导致错误。它返回一个空字符串。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>作为日期类型字段的特殊情况，您可以通过添加<code>:</code>日期格式名称来指定日期格式（请参阅<code>--date</code>git-rev-list [1]选项的值）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>像％（align）和％（if）这样的一些原子总是需要匹配的％（end）。我们称之为“开放原子”，有时将它们表示为％（$ open）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当脚本语言特定的引用有效时，根据开放原子的语义评估顶级开放原子与其匹配的％（end）之间的所有内容，并仅引用顶级结果。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>直接生成格式化文本的示例。显示最近3个标记的提交：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">#!/bin/sh

git for-each-ref --count=3 --sort='-*authordate' \--format='From: %(*authorname) %(*authoremail)Subject: %(*subject)Date: %(*authordate)Ref: %(*refname)%(*body)' 'refs/tags'</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>一个简单的例子，显示了在输出中使用shell eval，展示了--shell的使用。列出所有头的前缀：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">#!/bin/sh

git for-each-ref --shell --format="ref=%(refname)" refs/heads | \while read entrydo
        eval "$entry"
        echo `dirname $ref`done</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>更详细的标签报告，证明格式可能是整个脚本：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">#!/bin/sh

fmt='
        r=%(refname)
        t=%(*objecttype)
        T=${r#refs/tags/}

        o=%(*objectname)
        n=%(*authorname)
        e=%(*authoremail)
        s=%(*subject)
        d=%(*authordate)
        b=%(*body)

        kind=Tag        if test "z$t" = z
        then
                # could be a lightweight tag
                t=%(objecttype)
                kind="Lightweight tag"
                o=%(objectname)
                n=%(authorname)
                e=%(authoremail)
                s=%(subject)
                d=%(authordate)
                b=%(body)
        fi
        echo "$kind $T points at a $t object $o"        if test "z$t" = zcommit
        then
                echo "The commit was authored by $n $e
at $d, and titled

    $s

Its message reads as:"
                echo "$b" | sed -e "s/^/    /"
                echo
        fi
'

eval=`git for-each-ref --shell --format="$fmt" \
        --sort='*objecttype' \
        --sort=-taggerdate \
        refs/tags`eval "$eval"</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>示例显示％（if）...％（then）...％（else）...％（end）的用法。这以当前分支为前缀。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git for-each-ref --format="%(if)%(HEAD)%(then)* %(else)  %(end)%(refname:short)" refs/heads/</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>显示％（if）...％（then）...％（end）的用法的示例。这将打印作者名称（如果存在）。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git for-each-ref --format="%(refname)%(if)%(authorname)%(then) Authored by: %(authorname)%(end)"</code></pre></div></div></div>