<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-rev-parse - Pick out and massage parameters</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git rev-parse [ --option ] &lt;args&gt;…</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>许多Git瓷器命令会混合使用标志（即以短划线开头的参数<code>-</code>）以及参数，这些参数用于<code>git rev-list</code>它们在内部使用的基础命令，以及标志和参数用于其下游使用的其他命令<code>git rev-list</code>。该命令用于区分它们。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><h3>操作模式</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项中的每一个都必须首先出现在命令行中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--parseopt</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>git rev-parse</code>在选项解析模式（见下文PARSEOPT部分）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--sq-quote</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>git rev-parse</code>的shell引用模式（见下面的SQ-报价部分）。与<code>--sq</code>下面的选项相反，此模式只能引用。没有其他任何事情可以指挥输入。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>--parseopt的选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>--keep-dashdash</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只在<code>--parseopt</code>模式中有意义。告诉选项解析器回显第一次<code>--</code>会面而不是跳过它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--stop-at-non-option</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只在<code>--parseopt</code>模式中有意义。让选项解析器在第一个非选项参数处停止。这可以用来解析自己接受选项的子命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--stuck-long</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只在<code>--parseopt</code>模式中有意义。如果可用的话，以长格式输出选项，并且其参数被卡住。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>筛选选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>--revs-only</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要输出不适用于<code>git rev-list</code>命令的标志和参数。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-revs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要输出用于<code>git rev-list</code>命令的标志和参数。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--flags</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要输出非标志参数。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-flags</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不输出标志参数。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>输出选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>--default &lt;arg&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果没有用户给出的参数，则<code>&lt;arg&gt;</code>改为使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--prefix &lt;arg&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>行为就像<code>git rev-parse</code>从<code>&lt;arg&gt;</code>工作树的子目录中调用一样。任何相关的文件名被解析，就好像它们以前缀一样，<code>&lt;arg&gt;</code>并将以该形式打印。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这可用于将参数转换为在子目录中运行的命令，以便在移动到存储库的顶层后仍可使用它们。例如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">prefix=$(git rev-parse --show-prefix)cd "$(git rev-parse --show-toplevel)"# rev-parse provides the -- needed for 'set'eval "set $(git rev-parse --sq --prefix "$prefix" -- "$@")"</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>--verify</p></div></div><div class="doc-postil"><div class="c-markdown"><p>验证只提供了一个参数，并且可以将其转换为可用于访问对象数据库的原始20字节SHA-1。如果是这样，将其发送到标准输出; 否则，出错。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果要确保输出实际命名对象数据库中的对象并/或可以将其用作所需的特定对象类型，则可以将<code>^{type}</code>剥离运算符添加到参数中。例如，<code>git rev-parse "$VAR^{commit}"</code>将确保<code>$VAR</code>命名为提交ish的现有对象（即，提交或指向提交的带注释的标记）。确保可以使用<code>$VAR</code>任何类型的现有对象的名称<code>git rev-parse "$VAR^{object}"</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-q   --quiet</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只在<code>--verify</code>模式中有意义。如果第一个参数不是有效的对象名称，则不输出错误消息; 而是静静地退出非零状态。成功时，将有效对象名称的SHA-1打印到stdout。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--sq</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通常每个标志和参数输出一行。此选项使输出成为单行，并且适用于shell的消耗。当你期望你的参数包含空格和换行符时（例如使用镐<code>-S</code>时<code>git diff-*</code>）很有用。与<code>--sq-quote</code>选项相反，命令输入仍然像往常一样解释。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--short=length</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--verify</code>与之相同，但将对象名缩短为至少包含<code>length</code>字符的唯一前缀。最小长度是4，默认值是<code>core.abbrev</code>配置变量的有效值（请参阅git-config [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--not</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示对象名称时，以前缀为前缀，<code>^</code>并<code>^</code>从已有对象名称中删除前缀。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--abbrev-ref=(strict|loose)</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对象名称的非含糊短名称。选项core.warnAmbiguousRefs用于选择严格的缩写模式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--symbolic</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通常，对象名称以SHA-1形式输出（可能带有<code>^</code>前缀）; 该选项使它们以尽可能接近原始输入的形式输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--symbolic-full-name</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这与--symbolic类似，但它省略了不是参考的输入（即分支或标签名称;或者更明确地消除“头部/主”形式的歧义，当您想命名“主”分支时，标签“master”），并将其显示为完整的refnames（例如“refs / heads / master”）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>对象的选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>--all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示在中找到的所有参考<code>refs/</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--branches=pattern   --tags=pattern   --remotes=pattern</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示所有分支，标签，或远程跟踪分支，分别为（即，裁判发现<code>refs/heads</code>，<code>refs/tags</code>或<code>refs/remotes</code>分别）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>pattern</code>给出a，则只显示匹配给定shell glob的引用。如果模式不包含匹配字符（<code>?</code>，，<code>*</code>或<code>[</code>），则通过追加将其转换为前缀匹配<code>/*</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--glob=pattern</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示与shell glob模式匹配的所有参考<code>pattern</code>。如果模式没有开始<code>refs/</code>，则会自动添加前缀。如果模式不包含匹配字符（<code>?</code>，，<code>*</code>或<code>[</code>），则通过追加将其转换为前缀匹配<code>/*</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--exclude=&lt;glob-pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不包括裁判匹配<code>&lt;glob-pattern&gt;</code>，未来<code>--all</code>，<code>--branches</code>，<code>--tags</code>，<code>--remotes</code>，或<code>--glob</code>原本考虑。这个选项排除累积模式到下一个的重复<code>--all</code>，<code>--branches</code>，<code>--tags</code>，<code>--remotes</code>，或<code>--glob</code>选择（其他选项或参数不清除积累的模式）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>给予不应该开始的模式<code>refs/heads</code>，<code>refs/tags</code>或<code>refs/remotes</code>当应用到<code>--branches</code>，<code>--tags</code>或<code>--remotes</code>分别，他们必须开始<code>refs/</code>在应用于<code>--glob</code>或<code>--all</code>。如果尾随<code>/*</code>是有意的，则必须明确给出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--disambiguate=&lt;prefix&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示名称以给定前缀开头的每个对象。&lt;prefix&gt;的长度必须至少为4个十六进制数字，以避免错误地列出存储库中的每个对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>文件选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>--local-env-vars</p></div></div><div class="doc-postil"><div class="c-markdown"><p>列出存储库本地的GIT_ *环境变量（例如GIT_DIR或GIT_WORK_TREE，但不包括GIT_EDITOR）。仅列出变量的名称，而不是它们的值，即使它们已设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--git-dir</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示<code>$GIT_DIR</code>是否已定义。否则，显示.git目录的路径。显示的路径相对于当前工作目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>$GIT_DIR</code>未定义，并且未检测到当前目录位于Git存储库或工作树中，则向stderr发送消息并以非零状态退出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--absolute-git-dir</p></div></div><div class="doc-postil"><div class="c-markdown"><p>就像<code>--git-dir</code>，但它的输出始终是规范化的绝对路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--git-common-dir</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示<code>$GIT_COMMON_DIR</code>是否已定义，否则<code>$GIT_DIR</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--is-inside-git-dir</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当前工作目录位于存储库目录下方时，打印“true”，否则为“false”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--is-inside-work-tree</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当前工作目录位于存储库的工作树内时，打印“true”，否则为“false”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--is-bare-repository</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当存储库是裸打印“真”，否则“假”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--resolve-git-dir &lt;path&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>检查&lt;path&gt;是否是有效的存储库或指向有效存储库的gitfile，并打印存储库的位置。如果&lt;path&gt;是一个gitfile，那么将打印解析的实际存储库的路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--git-path &lt;path&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>解析“$ GIT_DIR / &lt;path&gt;”并考虑其他路径重定位变量，例如$ GIT_OBJECT_DIRECTORY，$ GIT_INDEX_FILE ...。例如，如果$ GIT_OBJECT_DIRECTORY设置为/ foo / bar，则“git rev-parse --git-path objects / abc”返回/ foo / bar / abc。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--show-cdup</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当从子目录调用该命令时，显示相对于当前目录的顶级目录的路径（通常是一系列“../”或空字符串）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--show-prefix</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当从子目录调用该命令时，显示当前目录相对于顶级目录的路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--show-toplevel</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示顶级目录的绝对路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--show-superproject-working-tree显示使用当前存储库作为其子模块的超级项目工作树（如果存在）的根的绝对路径。如果当前存储库未被任何项目用作子模块，则不输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--shared-index-path</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在分割索引模式下显示共享索引文件的路径，如果不在分割索引模式下则显示空白。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>其他选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>--since=datestring   --after=datestring</p></div></div><div class="doc-postil"><div class="c-markdown"><p>解析日期字符串，并输出相应的--max-age =参数<code>git rev-list</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--until=datestring   --before=datestring</p></div></div><div class="doc-postil"><div class="c-markdown"><p>解析日期字符串，并输出相应的--min-age =参数<code>git rev-list</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;args&gt;…</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要解析的标志和参数。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>指定修订</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>修订参数<code>&lt;rev&gt;</code>通常（但不一定）命名提交对象。它使用所谓的<code>extended SHA-1</code>语法。以下是拼写对象名称的各种方法。列表附近列出的名称包含在提交中的树和blob。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;sha1&gt;</em>, e.g. <em style="font-style: italic;">dae86e1950b1277e545cee180551750029cfe735</em>, <em style="font-style: italic;">dae86e</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>完整的SHA-1对象名称（40字节的十六进制字符串）或存储库中唯一的前导子字符串。例如，dae86e1950b1277e545cee180551750029cfe735和dae86e都会命名相同的提交对象，前提是存储库中没有其他对象，其对象名称以dae86e开头。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;describeOutput&gt;</em>, e.g. <em style="font-style: italic;">v1.7.4.2-679-g3bee7fb</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>输出来自<code>git describe</code>; 即最接近的标记，可选地后跟破折号和多个提交，后跟短划线，a <code>g</code>和缩写对象名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;refname&gt;</em>, e.g. <em style="font-style: italic;">master</em>, <em style="font-style: italic;">heads/master</em>, <em style="font-style: italic;">refs/heads/master</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>符号参考名称。例如<code>master</code>通常意味着引用的提交对象<code>refs/heads/master</code>。如果你碰巧有两个<code>heads/master</code>和<code>tags/master</code>，你可以明确地说<code>heads/master</code>要告诉Git的你的意思是哪一个。当模棱两可时，<code>&lt;refname&gt;</code>通过在以下规则中进行第一次匹配来消除a ：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>如果<code>$GIT_DIR/&lt;refname&gt;</code>存在，那就是你的意思（这通常是有用的，只有为<code>HEAD</code>，<code>FETCH_HEAD</code>，<code>ORIG_HEAD</code>，<code>MERGE_HEAD</code>和<code>CHERRY_PICK_HEAD</code>）;</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>否则，<code>refs/&lt;refname&gt;</code>如果存在;</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>否则，<code>refs/tags/&lt;refname&gt;</code>如果存在;</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>否则，<code>refs/heads/&lt;refname&gt;</code>如果存在;</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>否则，<code>refs/remotes/&lt;refname&gt;</code>如果存在;</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>否则，<code>refs/remotes/&lt;refname&gt;/HEAD</code>如果存在。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p><code>HEAD</code>命名您在工作树中基于更改的提交。<code>FETCH_HEAD</code>记录您在上次<code>git fetch</code>调用时从远程存储库中获取的分支。<code>ORIG_HEAD</code>是通过命令创建的，这些命令<code>HEAD</code>以激烈的方式移动您的行为，记录<code>HEAD</code>它们在操作之前的位置，以便您可以轻松地将分支的顶端更改回到运行之前的状态。<code>MERGE_HEAD</code>记录您在运行时正在合并到您的分支中的提交<code>git merge</code>。<code>CHERRY_PICK_HEAD</code>记录您在运行时正在挑选的提交<code>git cherry-pick</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，<code>refs/*</code>上述任何情况都可能来自<code>$GIT_DIR/refs</code>目录或<code>$GIT_DIR/packed-refs</code>文件。虽然未指定ref名称编码，但首选UTF-8，因为某些输出处理可能采用UTF-8中的ref名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">@</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>@</code> alone is a shortcut for <code>HEAD</code>.</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;refname&gt;@{&lt;date&gt;}</em>, e.g. <em style="font-style: italic;">master@{yesterday}</em>, <em style="font-style: italic;">HEAD@{5 minutes ago}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后面跟着<code>@</code>带括号的括号中的后缀（例如<code>{yesterday}</code>，<code>{1 month 2 weeks 3 days 1 hour 1 second ago}</code>或<code>{1979-02-26 18:30:00}</code>）的后缀指定前一个时间点的ref的值。该后缀只能在ref名称后面使用，并且ref必须具有现有的日志（<code>$GIT_DIR/logs/&lt;ref&gt;</code>）。请注意，这会在给定的时间查看<strong>当地</strong>裁判的状态; 例如<code>master</code>上周您当地的分支机构。如果您想查看某些时间内提交的内容，请参阅<code>--since</code>和<code>--until</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;refname&gt;@{&lt;n&gt;}</em>, e.g. <em style="font-style: italic;">master@{1}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后缀为<code>@</code>带括号的后缀（例如<code>{1}</code>，<code>{15}</code>）指定了该ref的第n个前置值。例如<code>master@{1}</code>，<code>master</code>while <code>master@{5}</code>是第5个先前值的即时先验值<code>master</code>。该后缀只能在ref名称后面使用，并且ref必须具有现有的日志（<code>$GIT_DIR/logs/&lt;refname&gt;</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">@{&lt;n&gt;}</em>, e.g. <em style="font-style: italic;">@{1}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以使用<code>@</code>带有空引用部分的构造来获取当前分支的reflog条目。例如，如果您在分支上，<code>blabla</code>则<code>@{1}</code>意味着与之相同<code>blabla@{1}</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">@{-&lt;n&gt;}</em>, e.g. <em style="font-style: italic;">@{-1}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>该构造<code>@{-&lt;n&gt;}</code>意味着在当前之前检出的第n个分支/提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;branchname&gt;@{upstream}</em>, e.g. <em style="font-style: italic;">master@{upstream}</em>, <em style="font-style: italic;">@{u}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>@{upstream}</code>branchname（简称<code>&lt;branchname&gt;@{u}</code>）的后缀是指由branchname指定的分支设置为在（使用<code>branch.&lt;name&gt;.remote</code>and <code>branch.&lt;name&gt;.merge</code>）配置的基础上构建的分支。缺少的branchname默认为当前的。当用大写拼写时，这些后缀也是可接受的，无论大小写是什么，它们都表示相同的事物。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;branchname&gt;@{push}</em>, e.g. <em style="font-style: italic;">master@{push}</em>, <em style="font-style: italic;">@{push}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>@{push}</code>如果在检出时<code>git push</code>运行<code>branchname</code>（或当前<code>HEAD</code>没有指定branchname），后缀将报告分支“我们将推送到哪里” 。由于我们的推送目标位于远程存储库中，当然，我们会报告与该分支对应的本地跟踪分支（即，某处<code>refs/remotes/</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这里有一个例子可以使它更加清晰：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git config push.default current
$ git config remote.pushdefault myfork
$ git checkout -b mybranch origin/master

$ git rev-parse --symbolic-full-name @{upstream}refs/remotes/origin/master

$ git rev-parse --symbolic-full-name @{push}refs/remotes/myfork/mybranch</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在示例中请注意，我们建立了一个三角形工作流程，我们从一个位置拉出并推送到另一个位置。在非三角形工作流程中，与之<code>@{push}</code>相同<code>@{upstream}</code>，并且不需要它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当拼写成大写字母时，这个后缀也是可以接受的，无论大小写是什么意思都是相同的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^</em>, e.g. <em style="font-style: italic;">HEAD^, v1.5.1^0</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>^</code>修订参数的后缀表示该提交对象的第一个父代。<code>^&lt;n&gt;</code>意味着第n个父母（即<code>&lt;rev&gt;^</code>相当于<code>&lt;rev&gt;^1</code>）。作为一个特殊规则，<code>&lt;rev&gt;^0</code>意味着提交本身，并在<code>&lt;rev&gt;</code>引用提交对象的标记对象的对象名称时使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;~&lt;n&gt;</em>, e.g. <em style="font-style: italic;">master~3</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>~&lt;n&gt;</code>修订参数的后缀表示作为指定提交对象的第n代祖先的提交对象，仅在第一个父代之后。即<code>&lt;rev&gt;~3</code>相当于<code>&lt;rev&gt;^^^</code>哪个相当于<code>&lt;rev&gt;^1^1^1</code>。请参阅下面的表格来说明此表格的用法。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^{&lt;type&gt;}</em>, e.g. <em style="font-style: italic;">v0.99.8^{commit}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个后缀<code>^</code>跟在括号内的对象类型名称意味着以<code>&lt;rev&gt;</code>递归方式解引用对象，直到<code>&lt;type&gt;</code>找到类型的对象或者对象不能被解除引用（在这种情况下，barf）。例如，如果<code>&lt;rev&gt;</code>是commit-ish，则<code>&lt;rev&gt;^{commit}</code>描述相应的提交对象。同样，如果<code>&lt;rev&gt;</code>是树型，则<code>&lt;rev&gt;^{tree}</code>描述相应的树型对象。<code>&lt;rev&gt;^0</code>是短暂的<code>&lt;rev&gt;^{commit}</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>rev^{object}</code>可以用来确定<code>rev</code>存在的对象的名称，而不需要<code>rev</code>作为标签，也不需要解引用<code>rev</code>; 因为一个标签已经是一个对象，所以即使一次到达一个对象也不需要解除引用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>rev^{tag}</code>可以用来确保<code>rev</code>识别现有的标签对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^{}</em>, e.g. <em style="font-style: italic;">v0.99.8^{}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个后缀<code>^</code>跟一个空括号对意味着对象可以是一个标签，并递归地引用标签，直到找到一个非标签对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^{/&lt;text&gt;}</em>, e.g. <em style="font-style: italic;">HEAD^{/fix nasty bug}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后缀<code>^</code>的修正参数，其次，它包含用斜线为首的文本的一对括号，是一样的<code>:/fix nasty bug</code>下面的语法不同之处在于它返回最年轻的匹配提交其是从可到达<code>&lt;rev&gt;</code>之前<code>^</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">:/&lt;text&gt;</em>, e.g. <em style="font-style: italic;">:/fix nasty bug</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个冒号，后跟一个斜线，后跟一个文本，命名提交消息与指定正则表达式匹配的提交。该名称返回可从任何ref访问的最年轻匹配提交。正则表达式可以匹配提交消息的任何部分。要匹配以字符串开头的消息，可以使用例如<code>:/^foo</code>。特殊序列<code>:/!</code>保留给修饰符以匹配内容。<code>:/!-foo</code>执行否定匹配，同时<code>:/!!foo</code>匹配文字<code>!</code>字符，然后匹配<code>foo</code>。任何以其他序列开始的序列<code>:/!</code>现在都被保留。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;:&lt;path&gt;</em>, e.g. <em style="font-style: italic;">HEAD:README</em>, <em style="font-style: italic;">:README</em>, <em style="font-style: italic;">master:./README</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个后缀<code>:</code>后面跟着一个路径的名称是由冒号前部分命名的tree-ish对象中给定路径上的blob或树。<code>:path</code>（在冒号前有一个空白部分）是下面描述的语法的特例：记录在给定路径索引处的内容。以当前工作目录开始<code>./</code>或<code>../</code>相对于当前工作目录的路径。给定的路径将被转换为相对于工作树的根目录。这对于从具有与工作树相同树结构的提交或树来处理blob或树是非常有用的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">:&lt;n&gt;:&lt;path&gt;</em>, e.g. <em style="font-style: italic;">:0:README</em>, <em style="font-style: italic;">:README</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个冒号，后跟一个阶段号（0到3）和一个冒号，后跟一个路径，在给定路径的索引中命名一个blob对象。缺少的阶段编号（以及后面的冒号）命名为0阶段编号。在合并期间，阶段1是共同的祖先，阶段2是目标分支的版本（通常是当前分支），阶段3是来自正在合并的分支的版本。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以下是Jon Loeliger的插图。提交节点B和C都是提交节点A的父节点。父提交按从左到右的顺序排列。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">A =      = A^0B = A^   = A^1     = A~1C = A^2  = A^2D = A^^  = A^1^1   = A~2E = B^2  = A^^2F = B^3  = A^^3G = A^^^ = A^1^1^1 = A~3H = D^2  = B^^2    = A^^^2  = A~2^2I = F^   = B^3^    = A^^3^J = F^2  = B^3^2   = A^^3^2</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>指定范围</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>历史遍历命令，例如<code>git log</code>对一组提交进行操作，而不仅仅是一次提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于这些命令，使用上一节中描述的符号来指定单个修订，意味着<code>reachable</code>来自给定提交的一组提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提交的可达集是提交本身和祖先链中的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>提交排除</h3></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">^&lt;rev&gt;</em> (caret) Notation</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要排除提交可达的提交，使用前缀<code>^</code>符号。例如，<code>^r1 r2</code>意味着提交可达，<code>r2</code>但不包括从<code>r1</code>（即<code>r1</code>其祖先）可达的。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>虚线表示法</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>The <em style="font-style: italic;">..</em> (two-dot) Range Notation</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该<code>^r1 r2</code>组操作似乎经常有它的简写。当你有两个提交<code>r1</code>并且<code>r2</code>（根据上面指定版本中所述的语法命名）时，你可以要求提交从r2到达的提交，但不包括从r1到达的那些提交，<code>^r1 r2</code>它可以写为<code>r1..r2</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>The <em style="font-style: italic;">…</em> (three dot) Symmetric Difference Notation</p></div></div><div class="doc-postil"><div class="c-markdown"><p>类似的符号<code>r1...r2</code>被称为和的对称差，<code>r1</code>并被<code>r2</code>定义为<code>r1 r2 --not $(git merge-base --all r1 r2)</code>。它是从<code>r1</code>（左侧）或<code>r2</code>（右侧）中的任一个可达的提交集合，但不是来自两者。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在这两个简写符号中，可以省略一端，并将其默认为HEAD。例如，<code>origin..</code>是一个简写，<code>origin..HEAD</code>并问“自从我从原始分支分出后，我做了什么？” 同样，它<code>..origin</code>也是一种速记，<code>HEAD..origin</code>并问道：“我从他们身上分离出来后，起源究竟发生了什么？” 请注意，<code>..</code>这意味着<code>HEAD..HEAD</code>哪个空白区域可以从HEAD到达和无法到达。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>Other &lt;rev&gt;^ Parent Shorthand Notations</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>还有三个其他的shorthands，对于合并提交，对于由提交和它的父提交形成的集合进行命名特别有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该<code>r1^@</code>符号表示的所有家长<code>r1</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该<code>r1^!</code>表示包括提交<code>r1</code>但排除其所有父母。这个符号本身表示单个提交<code>r1</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该<code>&lt;rev&gt;^-&lt;n&gt;</code>符号包括<code>&lt;rev&gt;</code>但不包括&lt;N&gt;个亲本（即，简写<code>&lt;rev&gt;^&lt;n&gt;..&lt;rev&gt;</code>），其中<code>&lt;n&gt;</code>= 1，如果没有给出。这对合并提交通常很有用，您可以通过合并提交<code>&lt;commit&gt;^-</code>来获取合并提交中合并的分支中的所有提交<code>&lt;commit&gt;</code>（包括<code>&lt;commit&gt;</code>它自己）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>虽然<code>&lt;rev&gt;^&lt;n&gt;</code>是关于指定一个单一的提交父母，但这三个符号也考虑到它的父母。例如，你可以说<code>HEAD^2^@</code>，但是你不能说<code>HEAD^@^2</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>修订范围摘要</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含可从&lt;rev&gt;（即&lt;rev&gt;及其祖先）访问的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">^&lt;rev&gt;</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>排除可从&lt;rev&gt;（即&lt;rev&gt;及其祖先）访问的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev1&gt;..&lt;rev2&gt;</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含可从&lt;rev2&gt;访问的提交，但不包括可从&lt;rev1&gt;访问的提交。当&lt;rev1&gt;或&lt;rev2&gt;被省略时，它默认为<code>HEAD</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev1&gt;...&lt;rev2&gt;</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含可从&lt;rev1&gt;或&lt;rev2&gt;访问的提交，但排除可从两者访问的提交。当&lt;rev1&gt;或&lt;rev2&gt;被省略时，它默认为<code>HEAD</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^@</em>, e.g. <em style="font-style: italic;">HEAD^@</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个后缀<code>^</code>后跟一个符号与列出所有父母的<code>&lt;rev&gt;</code>意思相同（意思是，包括任何可从其父母获得的东西，但不包括承诺本身）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^!</em>, e.g. <em style="font-style: italic;">HEAD^!</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个后缀<code>^</code>后跟一个感叹号的方式与提交相同<code>&lt;rev&gt;</code>，然后它的所有父母前缀<code>^</code>以排除它们（和它们的祖先）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^-&lt;n&gt;</em>, e.g. <em style="font-style: italic;">HEAD^-, HEAD^-2</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>相当于<code>&lt;rev&gt;^&lt;n&gt;..&lt;rev&gt;</code>，<code>&lt;n&gt;</code>如果没有给出，则= 1。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这里有一些使用上面的Loeliger插图的例子，仔细地说明了符号的扩展和选择中的每一步：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">Args   Expanded arguments    Selected commits
D                            G H D
D F                          G H I J D F^G D                         H D^D B                         E I J F B^D B C                       E I J F B C
C                            I J F C
B..C   = ^B C                C
B...C  = B ^F C              G H D E B C
B^-    = B^..B= ^B^1 B              E I J F B
C^@    = C^1= F                   I J F
B^@    = B^1 B^2 B^3= D E F               D G H E F I J
C^!    = C ^C^@= C ^C^1= C ^F                C
B^!    = B ^B^@= B ^B^1 ^B^2 ^B^3= B ^D ^E ^F          B
F^! D  = F ^I ^J D           G H D F</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>Parseopt</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>在<code>--parseopt</code>模式下，<code>git rev-parse</code>帮助按摩选项，使shell脚本拥有与C builtins相同的设施。它作为一个选项标准化器（例如拆分单个交换机聚合值），有点像<code>getopt(1)</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>它接受标准输入的解析和理解选项的规范，并在标准输出上回显一个适合于<code>sh(1)</code> <code>eval</code>用规范化参数替换参数的字符串。如果发生错误，它会在标准错误流上输出使用情况，并以代码129退出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>注意：确保在传递结果时引用结果<code>eval</code>。见下面的例子。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>输入格式</h3></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git rev-parse --parseopt</code>输入格式完全基于文本。它有两部分，由仅包含一行的行分隔<code>--</code>。分隔符之前的行（应该是一个或多个）用于使用。分隔符后面的行描述了选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>每行选项都有以下格式：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">&lt;opt-spec&gt;&lt;flags&gt;*&lt;arg-hint&gt;? SP+ help LF</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>&lt;opt-spec&gt;</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>它的格式是短选项字符，然后是用逗号分隔的长选项名称。这两个部分都不是必需的，但至少需要一个。可能不包含任何<code>&lt;flags&gt;</code>字符。<code>h,help</code>，<code>dry-run</code>并且<code>f</code>是正确的例子<code>&lt;opt-spec&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>&lt;flags&gt;</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>&lt;flags&gt;</code> are of <code>*</code>, <code>=</code>, <code>?</code> or <code>!</code>.</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>如果选项带有参数，请使用<code>=</code>。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>使用<code>?</code>意味着选项接受一个可选参数。您可能想要使用该<code>--stuck-long</code>模式来明确地解析可选参数。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>使用<code>*</code>意味着该选项不应该在所生成的使用上市<code>-h</code>的说法。它显示为<code>--help-all</code>在gitcli [7]中记录。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>使用<code>!</code>不使提供相应的否定长选项。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p><code>&lt;arg-hint&gt;</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>&lt;arg-hint&gt;</code>，如果指定，则用作帮助输出中参数的名称，用于带有参数的选项。<code>&lt;arg-hint&gt;</code>由第一个空格终止。通常使用短划线来分隔多词论证提示中的单词。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在删除空格之后，该行的其余部分将用作与该选项关联的帮助。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>空白行被忽略，并且不符合此规格的行被用作选项组标题（用空格开始行以有意地创建此类行）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>例子</h3></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">OPTS_SPEC="\
some-command [options] &lt;args&gt;...some-command does foo and bar!--h,help    show the help

foo       some nifty option --foo
bar=      some cool option --bar with an argument
baz=arg   another cool option --baz with a named argument
qux?path  qux may take a path argument but has meaning by itself

  An option group Header
C?        option C with an optional argument"

eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>用法文本</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>"$@"</code>是<code>-h</code>或<code>--help</code>在上述例子中，下面的用法文本将被显示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">usage: some-command [options] &lt;args&gt;...

    some-command does foo and bar!    -h, --help            show the help    --foo                 some nifty option --foo    --bar ...             some cool option --bar with an argument    --baz &lt;arg&gt;           another cool option --baz with a named argument    --qux[=&lt;path&gt;]        qux may take a path argument but has meaning by itself

An option group Header    -C[...]               option C with an optional argument</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>SQ-报价</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>在<code>--sq-quote</code>模式中，<code>git rev-parse</code>标准输出上的回声适合单线<code>sh(1)</code> <code>eval</code>。这条线是通过标准化后面的参数来完成的<code>--sq-quote</code>。除了引用参数外，没有其他任何事情完成了。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果希望命令输入<code>git rev-parse</code>在输出被shell引用之前仍照常解释，请参阅<code>--sq</code>选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>例子</h3></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ cat &gt;your-git-script.sh &lt;&lt;\EOF
#!/bin/sh
args=$(git rev-parse --sq-quote "$@")   # quote user-supplied arguments
command="git frotz -n24 $args"          # and use it inside a handcrafted
                                        # command line
eval "$command"EOF

$ sh your-git-script.sh "a b'c"</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>打印当前提交的对象名称：$ git rev-parse --verify HEAD</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>从$ REV shell变量中的版本打印提交对象名称：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git rev-parse --verify $ REV ^ {commit}</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果$ REV为空或者不是有效的修订版，这将会出错。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>与上面类似：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git rev-parse --default master --verify $REV</p></div></div><div class="doc-postil"><div class="c-markdown"><p>但如果$ REV为空，则会打印来自主服务器的提交对象名称。</p></div></div></div>