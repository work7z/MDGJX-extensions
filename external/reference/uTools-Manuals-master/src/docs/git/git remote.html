<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>Name</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-remote  - 管理追踪存储库的集合</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git remote [-v | --verbose]git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;git remote rename &lt;old&gt; &lt;new&gt;git remote remove &lt;name&gt;git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…
git remote get-url [--push] [--all] &lt;name&gt;git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;git remote [-v | --verbose] show [-n] &lt;name&gt;…
git remote prune [-n | --dry-run] &lt;name&gt;…
git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>管理您追踪分支的一组存储库（“远程”）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-v   --verbose</p></div></div><div class="doc-postil"><div class="c-markdown"><p>稍微详细一点，并在名称后显示远程 URL 。注意：这必须放在<code>remote</code>和之间<code>subcommand</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>命令</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>没有参数，显示现有遥控器的列表。几个子命令可用于在遥控器上执行操作。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">add</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>在 &lt;url&gt; 处添加一个名为 &lt;name&gt; 的存储库。该命令<code>git fetch &lt;name&gt;</code>然后可用于创建和更新远程跟踪分支&lt;name&gt; / &lt;branch&gt;。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>-f</code>选项，<code>git fetch &lt;name&gt;</code>在远程信息设置完成后立即运行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>--tags</code>选项，<code>git fetch &lt;name&gt;</code>从远程存储库导入每个标记。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>--no-tags</code>选项，<code>git fetch &lt;name&gt;</code>不会从远程存储库导入标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，只有取回分支上的标签被导入（参见 git-fetch [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>-t &lt;branch&gt;</code>选项，而不是远程的默认 glob refspec 来跟踪<code>refs/remotes/&lt;name&gt;/</code>命名空间下的所有分支，将<code>&lt;branch&gt;</code>创建仅用于跟踪的 refspec 。您可以给<code>-t &lt;branch&gt;</code>多个分支追踪多个分支，而无需抓取所有分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>-m &lt;master&gt;</code>选项，符号引用<code>refs/remotes/&lt;name&gt;/HEAD</code>被设置为指向远程的<code>&lt;master&gt;</code>分支。另请参阅 set-head 命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当创建获取镜像时<code>--mirror=fetch</code>，参考将不会存储在<code>refs/remotes/</code>命名空间中，而是<code>refs/</code>将远程中的所有内容直接镜像到<code>refs/</code>本地存储库中。这个选项在裸存储库中才有意义，因为提取会覆盖任何本地提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当创建一个推式镜像时<code>--mirror=push</code>，它<code>git push</code>总是表现得好像<code>--mirror</code>被传递一样。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">rename</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>将名为 &lt;old&gt; 的远程重命名为 &lt;new&gt; 。远程的所有远程跟踪分支和配置设置都会更新。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果 &lt;old&gt; 和 &lt;new&gt; 相同，并且 &lt;old&gt; 是<code>$GIT_DIR/remotes</code>或者下的文件<code>$GIT_DIR/branches</code>，则将远程转换为配置文件格式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">remove</em>   <em style="font-style: italic;">rm</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>删除名为 &lt;name&gt; 的远程。远程的所有远程跟踪分支和配置设置均被删除。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">set-head</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置或删除<code>refs/remotes/&lt;name&gt;/HEAD</code>指定远程的默认分支（即 symbolic-ref 的目标）。有一个远程的默认分支不是必需的，但允许指定远程的名称来代替特定的分支。例如，如果默认分支for <code>origin</code>设置为<code>master</code>，则<code>origin</code>可以在通常指定的任何位置指定<code>origin/master</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>-d</code> 或 <code>--delete</code>，符号 ref <code>refs/remotes/&lt;name&gt;/HEAD</code>被删除。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>-a</code>或<code>--auto</code>，远程被查询来确定它<code>HEAD</code>，然后
 symbolic-ref  <code>refs/remotes/&lt;name&gt;/HEAD</code>被设置为同一分支。例如，如果远程<code>HEAD</code>正指向<code>next</code>“ <code>git remote set-head origin -a</code>”将设置符号 -REF <code>refs/remotes/origin/HEAD</code>到<code>refs/remotes/origin/next</code>。这只有在<code>refs/remotes/origin/next</code>已经存在的情况下才有效; 如果不是，它必须先取得。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用于显式<code>&lt;branch&gt;</code>设置符号引用<code>refs/remotes/&lt;name&gt;/HEAD</code>。例如，“GIT 中远程设置头原点主”将设置符号 -REF <code>refs/remotes/origin/HEAD</code>到<code>refs/remotes/origin/master</code>。这只有在<code>refs/remotes/origin/master</code>已经存在的情况下才有效; 如果不是，它必须先取得。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">set-branches</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>更改已命名远程所跟踪分支的列表。这可以用于在远程初始设置后跟踪可用远程分支的一个子集。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定的分支将被解释为与命令行中的<code>-t</code>选项一起指定<code>git remote add</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>随着<code>--add</code>的，而不是替换当前跟踪的分支列表，添加到列表中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">get-url</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>检索远程的 URL 。这里的配置<code>insteadOf</code>和<code>pushInsteadOf</code>扩展。默认情况下，仅列出第一个 URL 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>--push</code>，查询推送 URL 而不是获取 URL 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与<code>--all</code>，远程的所有 URL 将被列出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">set-url</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>更改远程的 URL 。为匹配 regex &lt;oldurl&gt; 的远程 &lt;name&gt; 设置第一个 URL（如果没有给出 &lt;oldurl&gt; ，则为第一个 URL ）为
 &lt;newurl&gt; 。如果 &lt;oldurl&gt; 与任何 URL 都不匹配，则会发生错误并且没有任何更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用时<code>--push</code>，推送网址将被操纵，而不是抓取网址。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>随着<code>--add</code>，而不是改变现有的 URL ，新的 URL 添加。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用<code>--delete</code>，而不是改变现有的 URL ，所有匹配正则表达式
 &lt;URL&gt; URL 被用于远程 &lt;name&gt; 删除。试图删除所有非推送网址是一个错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，即使可以设置不同的推送网址和提取网址，仍必须引用相同的地方。您推送到推送网址的内容应该是您立即从提取网址获取的内容。如果您试图从一个地方（例如上游）获取数据并推送到另一个地方（例如您的发布存储库），请使用两个单独的遥控器。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">show</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>给出关于远程 &lt;name&gt; 的一些信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过<code>-n</code>选项，远程头不首先被查询<code>git ls-remote &lt;name&gt;</code>; 取而代之的是使用缓存的信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">prune</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>删除 &lt;name&gt; 下的所有陈旧的远程追踪分支。这些陈旧的分支已从 &lt;name&gt; 引用的远程存储库中删除，但仍在本地“remotes / &lt;name&gt;”中可用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>--dry-run</code>选项，报告将修改哪些分支，但不实际修改它们。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">update</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>按遥控器 &lt;group&gt; 的定义，获取存储库中一组指定遥控器的更新。如果未在命令行中指定命名组，则将使用配置参数
 remotes.default ; 如果没有定义 remotes.default ，那么没有配置参数 remote. &lt;name&gt; .skipDefaultUpdate 设置为 true 的所有遥控器都将被更新。（请参阅 git-config [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>--prune</code>选项，修剪所有更新的遥控器。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>讨论</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>远程配置使用<code>remote.origin.url</code>和<code>remote.origin.fetch</code>配置变量来实现。（请参阅 git-config [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>添加一个新的远程，获取并签出一个分支 $ git remote origin $ git branch -r origin / HEAD  - &gt; origin / master origin / master $ git remote add staging git：//git.kernel.org/。 ../gregkh/staging.git $ git 远程原点暂存 $ git fetch staging ...从git：//git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging *新的分支主控 - &gt; staging / staging-next $ git branch -r origin / HEAD  - &gt; origin / master origin / master staging / master staging / master staging / master staging / master staging / master staging / staging-linus staging / staging-next $ git checkout -b临时分段/主...</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>模仿<code>git clone</code>但只追踪选定的分支</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ mkdir project.git $ cd project.git $ git init $ git remote add -f -t master -m master origin git://example.com/git.git/ $ git merge origin</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-fetch [1] git-branch [1] git-config [1]</p></div></div></div>