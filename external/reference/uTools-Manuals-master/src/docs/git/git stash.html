<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>Name</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-stash  - 将变化存储在脏的工作目录中</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git stash list [&lt;options&gt;]git stash show [&lt;stash&gt;]git stash drop [-q|--quiet] [&lt;stash&gt;]git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]git stash branch &lt;branchname&gt; [&lt;stash&gt;]git stash save [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]             [-u|--include-untracked] [-a|--all] [&lt;message&gt;]git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]             [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;]]             [--] [&lt;pathspec&gt;…]]git stash clear
git stash create [&lt;message&gt;]git stash store [-m|--message &lt;message&gt;] [-q|--quiet] &lt;commit&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>git stash</code>时要录制工作目录和索引的当前状态，但想回到干净的工作目录。该命令保存您的本地修改，并恢复工作目录以匹配<code>HEAD</code>提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过此命令隐藏的修改可以使用<code>git stash list</code>，检查<code>git stash show</code>和恢复（可能在不同的提交之上）<code>git stash apply</code>。<code>git stash</code>没有任何参数的调用相当于<code>git stash save</code>。默认情况下，存储列为“WIP on <code>branchname</code>...”，但在创建存储时，可以在命令行上提供更多描述性消息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您创建的最新储藏器存储在<code>refs/stash</code>; 旧的存储在这个引用的reflog中可以找到，并且可以使用通常的reflog语法来命名（例如<code>stash@{0}</code>，最近创建的存储，<code>stash@{1}</code>是之前的存储，<code>stash@{2.hours.ago}</code>也是可能的）。通过指定存储索引也可以引用Stache（例如，整数<code>n</code>等价于<code>stash@{n}</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>save -p|--patch-k|--no-keep-index] -u|--include-untracked -q|--quiet   push -p|--patch-k|--no-keep-index] -u|--include-untracked -q|--quiet --</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将您的本地修改保存为新的<code>stash entry</code>并将它们回滚到 HEAD（在工作树和索引中）。&lt;message&gt;部分是可选的，并给出说明以及隐藏状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为了快速制作快照，您可以省略“推送”。在此模式下，不允许使用非选项参数来防止拼写错误的子命令产生不需要的存储条目。对此的两个例外是<code>stash -p</code>作为 alias <code>stash push -p</code>和 pathspecs，它们在<code>--</code>消除歧义之后使用双连字符。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当指定 pathspec 时<code>git stash push</code>，新存储条目仅记录与 pathspec匹配的文件的已修改状态。索引条目和工作树文件然后仅回滚到 HEAD中的这些文件的状态，从而留下与 pathspec 完全不匹配的文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果使用该<code>--keep-index</code>选项，则已添加到索引的所有更改均保持不变。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果使用该<code>--include-untracked</code>选项，则所有未跟踪的文件也会被隐藏起来，然后进行清理<code>git clean</code>，使工作目录处于非常干净的状态。如果使用该<code>--all</code>选项，则除了未跟踪文件之外，还会隐藏和清除被忽略的文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>--patch</code>，您可以交互式地从 HEAD 和工作树之间的差异中选择区块来隐藏。存储条目的构建方式使其索引状态与存储库的索引状态相同，其工作树仅包含交互式选择的更改。所选的更改将从您的工作树中回滚。请参阅 git-add [1]的“交互模式”部分了解如何操作该<code>--patch</code>模式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该<code>--patch</code>选项意味着<code>--keep-index</code>。您可以使用<code>--no-keep-index</code>来覆盖此。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>list &lt;options&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>列出您当前拥有的存储条目。每个<code>stash entry</code>列表都以其名称列出（例如，<code>stash@{0}</code>是最新的条目，<code>stash@{1}</code>是之前的条目等等），条目的当前分支的名称以及条目所基于的提交的简短描述。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">stash@{0}: WIP on submit: 6ebd0e2... Update git-stash documentation
stash@{1}: On master: 9cc0589... Add git-stash</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令使用适用于该<code>git log</code>命令的选项来控制显示内容和方式。参见 git-log [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>show &lt;stash&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示存储条目中记录的更改，作为隐藏内容和提交首次创建存储条目时的提交之间的差异。当没有<code>&lt;stash&gt;</code>给出时，它显示最新的一个。默认情况下，该命令显示diffstat，但它将接受已知的任何格式<code>git diff</code>（例如，<code>git stash show -p stash@{1}</code>以补丁形式查看第二个最新条目）。您可以使用 stash.showStat 和/或 stash.showPatch 配置变量来更改默认行为。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pop --index &lt;stash&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从存储列表中删除一个单独的存储状态并将其应用于当前工作树状态的顶部，即进行反操作<code>git stash save</code>。工作目录必须与索引匹配。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>应用状态可能会因冲突而失败; 在这种情况下，它不会从存储列表中删除。您需要<code>git stash drop</code>手动解决冲突，然后手动调用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果使用该<code>--index</code>选项，则尝试不仅恢复工作树的更改，而且还恢复索引的更改。但是，如果发生冲突（存储在索引中，因此您不能再像原来那样应用更改），这可能会失败。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当没有<code>&lt;stash&gt;</code>给出时，<code>stash@{0}</code>假定，否则<code>&lt;stash&gt;</code>必须是表格的参考<code>stash@{&lt;revision&gt;}</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>apply --index &lt;stash&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>像<code>pop</code>，但不要从存储列表中删除状态。不像<code>pop</code>，<code>&lt;stash&gt;</code>可能是任何看起来像由<code>stash save</code>or 创建的提交<code>stash create</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>branch &lt;branchname&gt; &lt;stash&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>创建并检出<code>&lt;branchname&gt;</code>从<code>&lt;stash&gt;</code>最初创建的提交开始的新分支，将记录的更改应用<code>&lt;stash&gt;</code>到新的工作树和索引。如果成功了，并且<code>&lt;stash&gt;</code>是表单的参考<code>stash@{&lt;revision&gt;}</code>，则会丢弃该表单<code>&lt;stash&gt;</code>。如果没有<code>&lt;stash&gt;</code>给出，则应用最新的一个。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您运行的分支由于冲突而<code>git stash save</code>发生了足够多的分支<code>git stash apply</code>失败，这很有用。由于存储条目应用于<code>git stash</code>运行时HEAD提交的顶部，因此它将恢复原始存储状态而不产生冲突。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>clear</p></div></div><div class="doc-postil"><div class="c-markdown"><p>删除所有的存储条目。请注意，这些条目将会被修剪，并且可能无法恢复（请参阅<code>Examples</code>下面的可能策略）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>drop -q|--quiet</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从存储条目列表中删除单个存储条目。如果没有<code>&lt;stash&gt;</code>给出，它将删除最新的一个。即<code>stash@{0}</code>，否则<code>&lt;stash&gt;</code>必须是表单的有效存储日志引用<code>stash@{&lt;revision&gt;}</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>create</p></div></div><div class="doc-postil"><div class="c-markdown"><p>创建一个存储条目（这是一个常规的提交对象）并返回它的对象名称，而不将它存储在ref命名空间的任何位置。这旨在用于脚本。这可能不是你想要使用的命令; 见上面的“保存”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>store</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将通过<code>git stash create</code>（这是一个悬挂的合并提交）创建的给定的存储存储在存储引用中，更新存储引用日志。这旨在用于脚本。这可能不是你想要使用的命令; 见上面的“保存”。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>讨论</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>存储条目表示为其记录工作目录状态的提交，其第一个父<code>HEAD</code>项是创建条目时的提交。第二个父节点的树在创建条目时记录索引的状态，并将其作为提交的子节点<code>HEAD</code>。血统图看起来像这样：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">       .----W      /    /-----H----I</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>提交的地方<code>H</code>在于<code>HEAD</code>提交，<code>I</code>它记录了索引的状态，并且<code>W</code>是一个提交，用于记录工作树的状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>拉进一棵脏的树</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当你处于某种事情的中间时，你会发现上游的变化可能与你正在做的事情有关。当您的本地更改与上游的更改不冲突时，一个简单的<code>git pull</code>将让您前进。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>但是，在某些情况下，您的本地更改与上游更改发生冲突，并<code>git pull</code>拒绝覆盖更改。在这种情况下，您可以隐藏您的更改，执行拉动操作，然后取消摆放，如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git pull ...file foobar not up to date, cannot merge.$ git stash
$ git pull
$ git stash pop</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>中断的工作流程</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当你处于某种事情的中间时，你的老板进来并要求你立即解决问题。传统上，您会提交一个临时分支来存储您的更改，然后返回到原始分支以进行紧急修复，如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash"># ... hack hack hack ...$ git checkout -b my_wip
$ git commit -a -m "WIP"$ git checkout master
$ edit emergency fix
$ git commit -a -m "Fix in a hurry"$ git checkout my_wip
$ git reset --soft HEAD^# ... continue hacking ...</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以使用<code>git stash</code>以简化上述内容，如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash"># ... hack hack hack ...$ git stash
$ edit emergency fix
$ git commit -a -m "Fix in a hurry"$ git stash pop
# ... continue hacking ...</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>测试部分提交</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以<code>git stash save --keep-index</code>在您想要在工作树中进行两项或更多项提交时使用，并且您希望在提交前测试每项更改：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash"># ... hack hack hack ...$ git add --patch foo            # add just first part to the index
$ git stash save --keep-index    # save all other changes to the stash
$ edit/build/test first part
$ git commit -m 'First part'     # commit fully tested change
$ git stash pop                  # prepare to work on all other changes
# ... repeat above five steps until one commit remains ...$ edit/build/test remaining parts
$ git commit foo -m 'Remaining parts'</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>恢复被错误清除/丢弃的存储条目</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您错误地放下或清除存储条目，则无法通过正常安全机制恢复。但是，您可以尝试使用以下咒语来获取仍在您的存储库中但不能再访问的存储条目列表：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git fsck --unreachable |grep commit | cut -d\  -f3 |xargs git log --merges --no-walk --grep=WIP</code></pre></div></div></div>