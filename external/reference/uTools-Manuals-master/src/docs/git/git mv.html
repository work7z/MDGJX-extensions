<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-mv  - 移动或重命名文件，目录或符号链接</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git mv &lt;options&gt;… &lt;args&gt;…</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>移动或重命名文件，目录或符号链接。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git mv [-v] [-f] [-n] [-k] &lt;source&gt; &lt;destination&gt;git mv [-v] [-f] [-n] [-k] &lt;source&gt; ... &lt;destination directory&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在第一种形式中，它将 &lt;source&gt; 重命名为 &lt;destination&gt; ，它必须存在，并且可以是文件，符号链接或目录。在第二种形式中，最后一个参数必须是现有目录; 给定的源将被移动到这个目录中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>成功完成后更新索引，但仍必须提交更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-f   --force</p></div></div><div class="doc-postil"><div class="c-markdown"><p>即使目标存在，也要强制重命名或移动文件</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-k</p></div></div><div class="doc-postil"><div class="c-markdown"><p>跳过移动或重命名会导致错误情况的操作。当源既不存在也不受 Git 控制时，或者除非<code>-f</code>给出，否则会覆盖现有文件时发生错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-n   --dry-run</p></div></div><div class="doc-postil"><div class="c-markdown"><p>没做什么; 只显示会发生什么</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-v   --verbose</p></div></div><div class="doc-postil"><div class="c-markdown"><p>报告移动文件的名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>子模块</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>使用 gitfile 移动子模块（意味着它们使用 Git 1.7.8 或更高版本进行克隆）将更新 gitfile 和 core.worktree 设置，以使子模块在新位置工作。它还会尝试更新 gitmodules [5] 文件中的 submodule 。&lt;name&gt; .path 设置并对该文件执行阶段操作（除非使用了-n ）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Bugs</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>每次超级项目更新移动填充的子模块时（例如，在移动之前和之后在提交之间切换时）旧的子模块检出将保留在旧位置，并且新的位置将出现空目录。要在新位置再次填充子模块，用户必须在之后运行 “git submodule update” 。删除旧目录仅在使用 gitfile 时才是安全的，否则子模块的历史记录也会被删除。当递归子模块更新已经实施时，这两个步骤都将被废弃。</p></div></div></div>