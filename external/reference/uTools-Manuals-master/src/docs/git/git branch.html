<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>Name</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-branch  - 列出，创建或删除分支</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git branch [--color[=&lt;when&gt;] | --no-color] [-r | -a]        [--list] [-v [--abbrev=&lt;length&gt; | --no-abbrev]]        [--column[=&lt;options&gt;] | --no-column] [--sort=&lt;key&gt;]        [(--merged | --no-merged) [&lt;commit&gt;]]        [--contains [&lt;commit]] [--no-contains [&lt;commit&gt;]]        [--points-at &lt;object&gt;] [--format=&lt;format&gt;] [&lt;pattern&gt;…]git branch [--set-upstream | --track | --no-track] [-l] [-f] &lt;branchname&gt; [&lt;start-point&gt;]git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]git branch --unset-upstream [&lt;branchname&gt;]git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt;git branch (-d | -D) [-r] &lt;branchname&gt;…
git branch --edit-description [&lt;branchname&gt;]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--list</code>给出，或者如果没有非选项参数，则列出现有分支; 当前分支将突出显示星号。选项<code>-r</code>会导致远程追踪分支被列出，选项<code>-a</code>显示本地和远程分支。如果<code>&lt;pattern&gt;</code>给出a，则将其用作外壳通配符，以将输出限制为匹配的分支。如果给出多个模式，则显示一个分支，如果它匹配任何模式。请注意，提供时<code>&lt;pattern&gt;</code>，您必须使用<code>--list</code>; 否则该命令被解释为分支创建。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与<code>--contains</code>，仅显示包含指定提交的分支（换句话说，其提示提交的分支是指定提交的后代），将其<code>--no-contains</code>反转。使用时<code>--merged</code>，只会将分支合并到指定的提交中（即，其提交提交可从指定的提交中获得的分支）将被列出。随着<code>--no-merged</code>唯一分支机构不合并到一个名为承诺将陆续上市。如果缺少&lt;commit&gt;参数，则默认为<code>HEAD</code>（即当前分支的尖端）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>命令的第二种形式创建一个名为&lt;branchname&gt;的新分支头，它指向当前<code>HEAD</code>或&lt;start-point&gt;（如果给出）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，这将创建新的分支，但不会将工作树切换到它; 使用“git checkout &lt;newbranch&gt;”切换到新分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当一个本地分支从一个远程跟踪分支启动时，Git设置分支（特别是<code>branch.&lt;name&gt;.remote</code>和<code>branch.&lt;name&gt;.merge</code>配置条目），以便<code>git pull</code>从远程跟踪分支适当合并。此行为可能通过全局<code>branch.autoSetupMerge</code>配置标志进行更改。该设置可以通过使用<code>--track</code>和<code>--no-track</code>选项来覆盖，并在稍后使用<code>git branch --set-upstream-to</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>-m</code>或<code>-M</code>选项，&lt;oldbranch&gt;将被重命名为&lt;newbranch&gt;。如果&lt;oldbranch&gt;具有相应的reflog，则将其重命名为匹配&lt;newbranch&gt;，并且会创建reflog条目以记住分支重命名。如果&lt;newbranch&gt;存在，-M必须用于强制重命名发生。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>带有<code>-d</code>或<code>-D</code>选项，<code>&lt;branchname&gt;</code>将被删除。您可以指定多个分支进行删除。如果分支当前有reflog，则reflog也将被删除。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>-r</code>连同<code>-d</code>删除远程跟踪分支。请注意，如果远程跟踪分支不再存在于远程存储库中，或者<code>git fetch</code>已配置为不再获取它们，则仅删除远程跟踪分支是有意义的。另请参阅<code>prune</code>git-remote [1] 的子命令，以清除所有过时的远程跟踪分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-d   --delete</p></div></div><div class="doc-postil"><div class="c-markdown"><p>删除分支。该分支必须完全合并到其上游分支中，或者<code>HEAD</code>如果没有上游设置为<code>--track</code>或<code>--set-upstream</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-D</p></div></div><div class="doc-postil"><div class="c-markdown"><p>快捷键<code>--delete --force</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-l   --create-reflog</p></div></div><div class="doc-postil"><div class="c-markdown"><p>创建分支的reflog。这将激活对分支ref的所有更改的记录，从而可以使用基于日期的sha1表达式，如“&lt;branchname&gt; @ {yesterday}”。请注意，在非裸仓库中，configlog <code>core.logAllRefUpdates</code>选项通常默认启用reflog 。否定形式<code>--no-create-reflog</code>只会覆盖较早的形式<code>--create-reflog</code>，但目前并不否定这种设置<code>core.logAllRefUpdates</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-f   --force</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果&lt;branchname&gt;已存在，请将&lt;branchname&gt;重置为&lt;startpoint&gt;。没有<code>-f</code> <code>git branch</code>拒绝改变现有的分支。结合<code>-d</code>（或<code>--delete</code>），允许删除分支，而不考虑其合并状态。结合<code>-m</code>（或<code>--move</code>），即使新分支名称已存在，也允许重命名分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-m   --move</p></div></div><div class="doc-postil"><div class="c-markdown"><p>移动/重命名分支和相应的reflog。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-M</p></div></div><div class="doc-postil"><div class="c-markdown"><p>快捷键<code>--move --force</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--color=&lt;when&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>颜色分支突出显示当前，本地和远程跟踪分支。该值必须始终（默认），永不，或自动。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-color</p></div></div><div class="doc-postil"><div class="c-markdown"><p>关闭分支颜色，即使配置文件将默认设置为颜色输出。和...一样<code>--color=never</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-i   --ignore-case</p></div></div><div class="doc-postil"><div class="c-markdown"><p>排序和过滤分支不区分大小写。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--column=&lt;options&gt;   --no-column</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在列中显示分支列表。有关选项语法，请参阅配置变量column.branch。<code>--column</code>与<code>--no-column</code>不带选项相当于<code>always</code>和<code>never</code>分别。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项仅适用于非详细模式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-r   --remotes</p></div></div><div class="doc-postil"><div class="c-markdown"><p>列出或删除（如果与-d一起使用）远程跟踪分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-a   --all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>列出远程追踪分行和当地分行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--list</p></div></div><div class="doc-postil"><div class="c-markdown"><p>列出分支。使用可选项<code>&lt;pattern&gt;...</code>，例如<code>git branch --list 'maint-*'</code>，仅列出与模式匹配的分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这不应与此混淆<code>git branch -l &lt;branchname&gt;</code>，它会创建一个以<code>&lt;branchname&gt;</code>reflog 命名的分支。详情见<code>--create-reflog</code>上文。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-v   -vv   --verbose</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在列表模式下，显示sha1并为每个头提交主题行，以及与上游分支（如果有）的关系。如果给出两次，也打印上游分支的名称（另请参阅<code>git remote show &lt;remote&gt;</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-q   --quiet</p></div></div><div class="doc-postil"><div class="c-markdown"><p>创建或删除分支时更安静，抑制非错误消息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--abbrev=&lt;length&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>改变输出列表中sha1的最小显示长度。默认值是7，可以由<code>core.abbrev</code>config选项覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-abbrev</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在输出列表中显示完整的sha1，而不是缩写它们。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-t   --track</p></div></div><div class="doc-postil"><div class="c-markdown"><p>创建新分支时，设置<code>branch.&lt;name&gt;.remote</code>和<code>branch.&lt;name&gt;.merge</code>配置条目以将起点分支标记为新分支的“上游”。这个配置会告诉git显示in <code>git status</code>和in两个分支之间的关系<code>git branch -v</code>。此外，它在<code>git pull</code>没有参数的情况下指示新分支签出时从上游撤出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当起始点是远程跟踪分支时，此行为是默认行为。<code>false</code>如果需要<code>git checkout</code>，<code>git branch</code>可以将branch.autoSetupMerge配置变量设置为并且始终表现得像<code>--no-track</code>给定的一样。<code>always</code>如果您想在起点为本地或远程跟踪分支时想要此行为，请将其设置为。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-track</p></div></div><div class="doc-postil"><div class="c-markdown"><p>即使branch.autoSetupMerge配置变量为true，也不要设置“上游”配置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--set-upstream</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果指定的分支尚不存在或者<code>--force</code>已经给出，则完全相同<code>--track</code>。否则，<code>--track</code>在创建分支时设置配置，除非分支指向的地方不更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-u &lt;upstream&gt;   --set-upstream-to=&lt;upstream&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置&lt;branchname&gt;的跟踪信息，以便&lt;upstream&gt;被视为&lt;branchname&gt;的上游分支。如果未指定&lt;branchname&gt;，则默认为当前分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--unset-upstream</p></div></div><div class="doc-postil"><div class="c-markdown"><p>删除&lt;branchname&gt;的上游信息。如果未指定分支，则默认为当前分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--edit-description</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打开一个编辑器，编辑文本解释分支是干什么用的，通过其他各种命令使用（例如<code>format-patch</code>，<code>request-pull</code>和<code>merge</code>（如果启用））。可以使用多行解释。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--contains &lt;commit&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只列出包含指定提交的分支（如果未指定，则为HEAD）。意味着<code>--list</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-contains &lt;commit&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只列出不包含指定提交的分支（如果未指定，则为HEAD）。意味着<code>--list</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--merged &lt;commit&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅列出可从指定提交中获得提示的分支（如果未指定，则为HEAD）。暗示<code>--list</code>，不符合<code>--no-merged</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-merged &lt;commit&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅列出提示无法从指定提交中获得的分支（如果未指定，则为HEAD）。暗示<code>--list</code>，不符合<code>--merged</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;branchname&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要创建或删除的分支的名称。新的分支名称必须通过由git-check-ref-format [1]定义的所有检查。其中一些检查可能会限制分支名称中允许的字符。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;start-point&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>新的分支头将指向这个提交。它可以作为分支名称，提交标识或标签给出。如果省略此选项，则将使用当前的HEAD。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;oldbranch&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要重命名的现有分支的名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;newbranch&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>现有分支的新名称。与&lt;branchname&gt;相同的限制适用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--sort=&lt;key&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>根据给定的关键字进行排序。前缀<code>-</code>按值的降序进行排序。您可以多次使用--sort = &lt;key&gt;选项，在这种情况下，最后一个键变为主键。支持的密钥与中的密钥相同<code>git for-each-ref</code>。排序顺序默认为基于完整的refname（包括<code>refs/...</code>前缀）排序。这将首先列出分离的HEAD（如果存在），然后列出当地分支和最终远程跟踪分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--points-at &lt;object&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只列出给定对象的分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--format &lt;format&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>%(fieldname)</code>从显示的分支ref 中插入的字符串以及它指向的对象。格式与git-for-each-ref [1]的格式相同。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>从已知标签开始开发</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6$ cd my2.6$ git branch my2.6.14 v2.6.14   (1)$ git checkout my2.6.14</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>这一步和下一步可以合并成一个单步执行“checkout -b my2.6.14 v2.6.14”。删除一个不需要的分支$ git clone git：//git.kernel.org/.../git.git my.git $ cd my.git $ git branch -d -r origin / todo origin / html origin / man（1 ）$ git branch -D test（2）</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>2. 删除远程追踪分支“todo”，“html”和“man”。下一个<code>fetch</code>或<code>pull</code>将再次创建它们，除非您将它们配置为不再。参见git-fetch [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>3. 即使“主”分支（或当前选中的分支）没有提交来自测试分支的所有提交，也要删除“测试”分支。注意如果您正在创建要立即签出的分支，则它更易于使用其Git的checkout命令<code>-b</code>选项来创建一个分支，并检查它与单一command.The选项<code>--contains</code>，<code>--no-contains</code>，<code>--merged</code>和<code>--no-merged</code>服务四个相关但不同的目的：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>4. <code>--contains &lt;commit&gt;</code> 用于查找所有需要特别注意的分支，因为这些分支包含指定的&lt;commit&gt;。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>--no-contains &lt;commit&gt;</code> 是相反的，即不包含指定的&lt;commit&gt;的分支。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>--merged</code> 用于查找可以安全删除的所有分支，因为这些分支完全由HEAD包含。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>--no-merged</code> 用于查找合并到HEAD中的候选分支，因为这些分支未被HEAD完全包含。</p></li></ul></div></div></div>