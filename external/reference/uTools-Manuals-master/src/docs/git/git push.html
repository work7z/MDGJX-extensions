<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>Name</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-push  - 更新远程引用以及关联的对象</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;]           [--repo=&lt;repository&gt;] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]           [-u | --set-upstream] [--push-option=&lt;string&gt;]           [--[no-]signed|--sign=(true|false|if-asked)]           [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]]]           [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…]]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>使用本地引用更新远程引用，同时发送完成给定引用所需的对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以在每次进入存储库时通过在存储库中设置有趣的事情<code>hooks</code>。请参阅 git-receive-pack [1] 的文档。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当命令行未指定将<code>&lt;repository&gt;</code>参数推<code>branch.*.remote</code>送到何处时，将查阅当前分支的配置以确定推送的位置。如果配置丢失，则默认为<code>origin</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当在命令行中没有指定，可以把什么<code>&lt;refspec&gt;...</code>参数或<code>--all</code>，<code>--mirror</code>，<code>--tags</code>选项，该命令将查找默认<code>&lt;refspec&gt;</code>通过咨询<code>remote.*.push</code>配置，如果没有找到它，荣誉<code>push.default</code>配置来决定推什么（请查看 git-config[1]为）<code>push.default</code> 的意思。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果命令行和配置均未指定要推送的内容，则使用默认行为，该行为对应于以下<code>simple</code>值<code>push.default</code>：当前分支被推送到相应的上游分支，但作为安全措施，如果上游分公司不具有与本地名称相同的名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;repository&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>作为推送操作目标的“远程”存储库。此参数可以是 URL（请参阅下面的 GIT URLS 部分）或远程名称（请参阅下面的 REMOTES 部分）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;refspec&gt;…</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定源对象要更新的目标引用。一个 &lt;refspec&gt; 参数的格式是一个可选的 plus <code>+</code>，后面是源对象 &lt;src&gt; ，后面是一个冒号<code>:</code>，后面是目标 ref &lt;dst&gt; 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;src&gt; 通常是您想要推送的分支的名称，但它可以是任意的“SHA-1表达式”，例如<code>master~4</code> <code>或</code> <code>HEAD</code>（请参阅
 gitrevisions [7] ）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;dst&gt; 通过这个推送来告诉远程端的哪个 ref 被更新。任意表达式不能在这里使用，必须命名实际的引用。如果<code>git push [&lt;repository&gt;]</code>没有任何<code>&lt;refspec&gt;</code>参数设置为<code>&lt;src&gt;</code>使用<code>remote.&lt;repository&gt;.push</code>配置变量更新目标中的某个 ref  ，<code>:&lt;dst&gt;</code>则可以省略部分 - 这样的推送将更新<code>&lt;src&gt;</code>通常<code>&lt;refspec&gt;</code>在命令行上没有任何更新的 ref 。否则，缺少<code>:&lt;dst&gt;</code>意味着更新相同的参考作为<code>&lt;src&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>由 &lt;src&gt; 引用的对象用于更新远程端的 &lt;dst&gt; 引用。默认情况下，只有当 &lt;dst&gt; 不是标签（带注释或轻量级标签）时才允许使用，并且只有在它可以快速转发 &lt;dst&gt; 时才允许使用。通过具有可选的领导<code>+</code>，你可以让 Git 更新 &lt;DST&gt; REF 即使是默认不允许的（比如，它不是一个快进。）这并<strong>不会</strong>试图合并&lt;来源&gt;为
 &lt;DST&gt; 。有关详细信息，请参阅下面的示例。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>tag &lt;tag&gt;</code> means the same as <code>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code>.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>推送一个空的 &lt;src&gt;允许你从远程仓库中删除 &lt;dst&gt; ref 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>特殊 refspec <code>:</code>（或<code>+:</code>允许非快进更新）指示 Git 推送“匹配”分支：对于本地存在的每个分支，如果远程已存在的同名分支已经存在，则更新远程端侧。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>推送所有分支（即参考下<code>refs/heads/</code>）; 不能与其他
 &lt;refspec&gt; 一起使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--prune</p></div></div><div class="doc-postil"><div class="c-markdown"><p>删除没有本地副本的远程分支。例如，<code>tmp</code>如果具有相同名称的本地分支不再存在，则远程分支将被删除。这也尊重
 refspecs ，例如<code>git push --prune remote refs/heads/*:refs/tmp/*</code>，<code>refs/tmp/foo</code>如果<code>refs/heads/foo</code>不存在，将确保远程将被删除。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--mirror</p></div></div><div class="doc-postil"><div class="c-markdown"><p>代替命名每个裁判推的，指定了下的所有参考文献<code>refs/</code>（包括但不限于<code>refs/heads/</code>，<code>refs/remotes/</code>和<code>refs/tags/</code>）被镜像到远程存储库。新创建的本地参考将被推送到远端，本地更新的参考将在远端强制更新，删除的参考将从远端移除。如果<code>remote.&lt;remote&gt;.mirror</code>设置了配置选项，这是默认值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-n   --dry-run</p></div></div><div class="doc-postil"><div class="c-markdown"><p>做除了实际发送更新之外的其他事</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--porcelain</p></div></div><div class="doc-postil"><div class="c-markdown"><p>生成机器可读的输出。每个 ref 的输出状态行将被制表符分隔并发送到 stdout 而不是 stderr 。将给出参考文献的完整符号名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--delete</p></div></div><div class="doc-postil"><div class="c-markdown"><p>所有列出的 ref 都从远程存储库中删除。这与用冒号前缀所有引用相同。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--tags</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>refs/tags</code>除了在命令行中明确列出的 refspecs 之外，所有
 refs 都将被推送。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--follow-tags</p></div></div><div class="doc-postil"><div class="c-markdown"><p>推送所有没有此选项时将被推送的引用，并且推送<code>refs/tags</code>远程引用中缺少的带注释的标签，但指向可从所推送的引用访问的提交标识。这也可以通过配置变量来指定<code>push.followTags</code>。有关更多信息，请参阅<code>push.followTags </code>git-config [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-signed   --sign=(true|false|if-asked)</p></div></div><div class="doc-postil"><div class="c-markdown"><p>GPG - 签署推送请求以更新接收端的 refs，以便通过钩子检查和/或记录。如果<code>false</code>或者<code>--no-signed</code>，不会尝试签名。如果<code>true</code>或者<code>--signed</code>，如果服务器不支持签名推送，推送将失败。如果设置为<code>if-asked</code>，则当且仅当服务器支持签名推送时签名。如果实际的呼叫<code>gpg --sign</code>失败，推送也会失败。有关接收端的详细信息，请参阅 git-receive-pack [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-atomic</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果可用，请在远程端使用原子事务。要么所有的参考文献都被更新，要么出错，没有参考文献被更新。如果服务器不支持原子推送，推送将失败。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-o   --push-option</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将给定的字符串传送给服务器，服务器将它们传递给预接收以及接收后挂接。给定的字符串不能包含 NUL 或 LF 字符。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--receive-pack=&lt;git-receive-pack&gt;   --exec=&lt;git-receive-pack&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git-receive-pack</code>远程端程序的路径。通过 ssh 推送到远程存储库时有用，而且您没有默认 $ PATH 目录中的程序。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-force-with-lease   --force-with-lease=&lt;refname&gt;   --force-with-lease=&lt;refname&gt;:&lt;expect&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通常，“git push”拒绝更新一个不是本地 ref 的祖先的远程 ref ，用于覆盖它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果远程 ref 的当前值是期望值，则此选项将覆盖此限制。否则，“git push”会失败。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>想象一下，你必须重新发布你已经发布的内容。您将不得不绕过“必须快进”规则，以便用最新发布的历史记录替换您最初发布的历史记录。如果其他人在重新装修时建立在原始历史的基础上，则遥控器分支的尖端可能会随着承诺而前进，而盲目推动<code>--force</code>则会失去她的工作。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个选项允许你说你期望你正在更新的历史是你重新设计和想要取代的。如果远程引用仍然指向你指定的提交，你可以确定没有其他人对引用做任何事情。这就像在 ref 上“租赁”而不显式锁定它，只有当“租约”仍然有效时才更新远程参考。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--force-with-lease</code> 单独的，没有指定细节，将通过要求它们的当前值与我们对它们的远程跟踪分支相同来保护将被更新的所有远程参考。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--force-with-lease=&lt;refname&gt;</code>，而不指定期望值，如果它将要更新，将通过要求它的当前值与我们为它的远程跟踪分支相同来保护指定的 ref（单独）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--force-with-lease=&lt;refname&gt;:&lt;expect&gt;</code>将保护指定的
 ref（单独），如果它将被更新，则通过要求其当前值与指定值相同<code>&lt;expect&gt;</code>（其可以不同于我们针对 refname 的远程跟踪分支），或者当使用这种形式时，我们甚至不需要有这样的远程追踪分支）。如果<code>&lt;expect&gt;</code>是空字符串，那么命名的 ref 必须不存在。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，除此之外的所有形式<code>--force-with-lease=&lt;refname&gt;:&lt;expect&gt;</code>明确指定 ref 的预期当前值仍然是实验性的，并且随着我们获得此功能的经验，它们的语义可能会改变。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>“--no-force-with-lease”将在命令行中取消之前的所有--force-with-lease。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>安全的一般注意事项：无预期值提供这个选项，即作为<code>--force-with-lease</code>或<code>--force-with-lease=&lt;refname&gt;</code>任何事情非常糟糕交互隐含运行<code>git fetch</code>遥控器上的在后台推到，例如<code>git fetch origin</code>在一个你存储库的 cronjob 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>它提供的保护措施<code>--force</code>是确保您的工作不基于的后续更改不会被破坏，但如果某些后台进程正在更新后台中的 refs ，则会被轻微击败。除了远程追踪信息外，我们没有任何东西可以作为启发式参考，您预计会看到并愿意诋毁。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您的编辑器或其他系统正在<code>git fetch</code>后台运行，则可以采取以下措施来简化此操作：只需设置另一个远程设备：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git remote add origin-push $(git config remote.origin.url)git fetch origin-push</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>现在当后台进程运行时<code>git fetch origin</code>，引用<code>origin-push</code>将不会被更新，因此命令如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git push --force-with-lease origin-push</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>除非您手动运行，否则会失败<code>git fetch origin-push</code>。这种方法当然完全被运行的东西击败<code>git fetch --all</code>，在这种情况下，你需要禁用它或者做一些更乏味的事情，比如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git fetch              # update 'master' from remote
git tag base master    # mark our base point
git rebase -i master   # rewrite some commits
git push --force-with-lease=master:base master:master</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>base</code>即为上游代码的版本创建一个标签，这些代码是您已经看到并愿意覆盖的版本，然后重写历史记录，最后<code>master</code>在远程版本仍在时强制推送更改<code>base</code>，无论您的本地<code>remotes/origin/master</code>更新为背景。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-f   --force</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通常，该命令拒绝更新远程 ref ，该远程 ref 不是用于覆盖它的本地 ref 的祖先。另外，当使用<code>--force-with-lease</code>选项时，该命令拒绝更新当前值与预期值不匹配的远程参考。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该标志会禁用这些检查，并可能导致远程存储库丢失提交; 小心使用它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，<code>--force</code>适用于所有推入的 ref，因此使用它<code>push.default</code>设置为<code>matching</code>或配置有多个推送目标，<code>remote.*.push</code>可能会覆盖当前分支以外的引用（包括严格位于其远程对象之后的本地引用）。要强制只推送一个分支，可以使用<code>+</code>refspec前面的一个按钮（例如<code>git push origin +master</code>强制推送<code>master</code>分支）。有关<code>&lt;refspec&gt;...</code>详情，请参阅上面的部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--repo=&lt;repository&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项等同于 &lt;repository&gt; 参数。如果两者都指定，则命令行参数优先。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-u   --set-upstream</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于最新或成功推送的每个分支，添加无参数 git-pull [1] 和其他命令使用的上游（跟踪）引用。有关更多信息，请参阅<code>branch.&lt;name&gt;.merge</code> git-config [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-thin</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项被传递给 git-send-pack [1]。当发送方和接收方共享许多相同的对象时，精简传输可显着减少发送的数据量。默认值是 --thin 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-q   --quiet</p></div></div><div class="doc-postil"><div class="c-markdown"><p>抑制所有输出，包括更新的引用列表，除非发生错误。进度未报告给标准错误流。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-v   --verbose</p></div></div><div class="doc-postil"><div class="c-markdown"><p>运行详细。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--progress</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定了 -q 。即使标准错误流未定向到终端，此标志也会强制进度状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-  no-recurse-submodules --recurse-submodules = check | on-demand | only | no</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可用于确保所推送的版本所使用的所有子模块提交在远程跟踪分支上可用。如果<code>check</code>使用，Git 将验证子模块的至少一个远程模块上是否有可供推送中修改的所有子模块提交。如果缺少任何提交，推送将被中止并以非零状态退出。如果<code>on-demand</code>使用了所有在修订中被更改的子模块将被推送。如果按需无法推送所有必需的修订，它也会被中止并以非零状态退出。如果<code>only</code>使用了所有子模块，则在超级项目处于未放置状态时将递归推送所有子模块。值<code>no</code>或使用<code>--no-recurse-submodules</code> 可用于在不需要子模块递归时覆盖 push.recurseSubmodules 配置变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-verify</p></div></div><div class="doc-postil"><div class="c-markdown"><p>切换预推钩（见 githooks [5]）。默认值是 - 验证，使钩子有机会阻止推送。使用 --no-verify ，挂钩完全被旁路。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-4   --ipv4</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅使用 IPv4 地址，忽略 IPv6 地址。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-6   --ipv6</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅使用 IPv6 地址，忽略 IPv4 地址。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Git 网址</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>通常，URL 包含有关传输协议，远程服务器地址和存储库路径的信息。根据传输协议，这些信息可能不存在。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 支持 ssh，git，http 和 https 协议（另外，ftp 和 ftps 可用于提取，但效率低下，不推荐使用;不要使用它）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>本地传输（即 git：// URL）不进行身份验证，因此在不安全的网络上应谨慎使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以下语法可以与它们一起使用：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>ssh://user@host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>git://host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>https://host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>ftps://host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>ssh 协议也可以使用另一种类似 scp 的语法：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>user@host.xz：path / to / repo.git /只有在第一个冒号前没有斜线时才能识别此语法。这有助于区分包含冒号的本地路径。例如，本地路径<code>foo:bar</code>可以被指定为绝对路径或<code>./foo:bar</code>避免被误解为 ssh url 。ssh 和 git 协议还支持用户名扩展：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>ssh://user@host.xz:port/~user/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>git://host.xz:port/~user/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>user@host.xz:/~user/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>对于本地支持的本地存储库，可以使用以下语法：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>file:///path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>这两种语法大多是相同的，除了克隆时，前者意味着 --local 选项。有关详细信息，请参阅 git-clone [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当 Git 不知道如何处理某个传输协议时，它会尝试使用<code>remote-&lt;transport&gt;</code>远程助手（如果存在）。要显式请求远程助手，可以使用以下语法：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>&lt;transport&gt;::&lt;address&gt;where &lt;address&gt; may be a path, a server and path, or an arbitrary URL-like string recognized by the specific remote helper being invoked. See gitremote-helpers[1] for details.If there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:        [url "&lt;actual url base&gt;"]
                insteadOf = &lt;other url base&gt;For example, with this:        [url "git://git.host.xz/"]
                insteadOf = host.xz:/path/to/
                insteadOf = work:a URL like "work:repo.git" or like "host.xz:/path/to/repo.git" will be rewritten in any context that takes a URL to be "git://git.host.xz/repo.git".If you want to rewrite URLs for push only, you can create a configuration section of the form:        [url "&lt;actual url base&gt;"]
                pushInsteadOf = &lt;other url base&gt;For example, with this:        [url "ssh://example.org/"]
                pushInsteadOf = git://example.org/a URL like "git://example.org/path/to/repo.git" will be rewritten to "ssh://example.org/path/to/repo.git" for pushes, but pulls will still use the original URL.RemotesThe name of one of the following can be used instead of a URL as <code>&lt;repository&gt;</code> argument:</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>a remote in the Git configuration file: <code>$GIT_DIR/config</code>,</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>a file in the <code>$GIT_DIR/remotes</code> directory, or</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>a file in the <code>$GIT_DIR/branches</code> directory.</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>All of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default.</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>Named remote in configuration file</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>You can choose to provide the name of a remote which you had previously configured using git-remote[1], git-config[1] or even by a manual edit to the <code>$GIT_DIR/config</code> file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        [remote "&lt;name&gt;"]
                url = &lt;url&gt;
                pushurl = &lt;pushurl&gt;
                push = &lt;refspec&gt;
                fetch = &lt;refspec&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>The <code>&lt;pushurl&gt;</code> is used for pushes only. It is optional and defaults to <code>&lt;url&gt;</code>.</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>Named file in <code>$GIT_DIR/remotes</code></h3></div></div><div class="doc-postil"><div class="c-markdown"><p>You can choose to provide the name of a file in <code>$GIT_DIR/remotes</code>. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        URL: one of the above URL format
        Push: &lt;refspec&gt;
        Pull: &lt;refspec&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>Push:</code> lines are used by <code>git push</code> and <code>Pull:</code> lines are used by <code>git pull</code> and <code>git fetch</code>. Multiple <code>Push:</code> and <code>Pull:</code> lines may be specified for additional branch mappings.</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>Named file in <code>$GIT_DIR/branches</code></h3></div></div><div class="doc-postil"><div class="c-markdown"><p>You can choose to provide the name of a file in <code>$GIT_DIR/branches</code>. The URL in this file will be used to access the repository. This file should have the following format:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        &lt;url&gt;#&lt;head&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>&lt;url&gt;</code> is required; <code>#&lt;head&gt;</code> is optional.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Depending on the operation, git will use one of the following refspecs, if you don’t provide one on the command line. <code>&lt;branch&gt;</code> is the name of this file in <code>$GIT_DIR/branches</code> and <code>&lt;head&gt;</code> defaults to <code>master</code>.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git fetch uses:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        refs/heads/&lt;head&gt;:refs/heads/&lt;branch&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>git push uses:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        HEAD:refs/heads/&lt;head&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>Output</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>The output of "git push" depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh).</p></div></div><div class="doc-postil"><div class="c-markdown"><p>The status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash"> &lt;flag&gt; &lt;summary&gt; &lt;from&gt; -&gt; &lt;to&gt; (&lt;reason&gt;)</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>If --porcelain is used, then each line of the output is of the form:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash"> &lt;flag&gt; \t &lt;from&gt;:&lt;to&gt; \t &lt;summary&gt; (&lt;reason&gt;)</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>The status of up-to-date refs is shown only if --porcelain or --verbose option is used.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>flag</p></div></div><div class="doc-postil"><div class="c-markdown"><p>A single character indicating the status of the ref:</p></div></div><div class="doc-postil"><div class="c-markdown"><p>(space)</p></div></div><div class="doc-postil"><div class="c-markdown"><p>for a successfully pushed fast-forward;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>+</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>for a successful forced update;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>-</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>for a successfully deleted ref;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>*</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>for a successfully pushed new ref;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>!</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>for a ref that was rejected or failed to push; and</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>=</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>for a ref that was up to date and did not need pushing.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>summary</p></div></div><div class="doc-postil"><div class="c-markdown"><p>For a successfully pushed ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to <code>git log</code> (this is <code>&lt;old&gt;..&lt;new&gt;</code> in most cases, and <code>&lt;old&gt;...&lt;new&gt;</code> for forced non-fast-forward updates).</p></div></div><div class="doc-postil"><div class="c-markdown"><p>For a failed update, more details are given:</p></div></div><div class="doc-postil"><div class="c-markdown"><p>rejected</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote rejected</p></div></div><div class="doc-postil"><div class="c-markdown"><p>The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: <code>receive.denyCurrentBranch</code> (for pushes to the checked out branch), <code>receive.denyNonFastForwards</code> (for forced non-fast-forward updates), <code>receive.denyDeletes</code> or <code>receive.denyDeleteCurrent</code>. See git-config[1].</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote failure</p></div></div><div class="doc-postil"><div class="c-markdown"><p>The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>from</p></div></div><div class="doc-postil"><div class="c-markdown"><p>The name of the local ref being pushed, minus its <code>refs/&lt;type&gt;/</code> prefix. In the case of deletion, the name of the local ref is omitted.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>to</p></div></div><div class="doc-postil"><div class="c-markdown"><p>The name of the remote ref being updated, minus its <code>refs/&lt;type&gt;/</code> prefix.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>reason</p></div></div><div class="doc-postil"><div class="c-markdown"><p>A human-readable explanation. In the case of successfully pushed refs, no explanation is needed. For a failed ref, the reason for failure is described.</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Note about fast-forwards</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>In contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">      B     / ---X---A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>Further suppose that the other person already pushed changes leading to A back to the original repository from which you two obtained the original commit X.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>But if you try to push, you will attempt to update the branch (that now points at A) with commit B. This does <code>not</code> fast-forward. If you did so, the changes introduced by commit A will be lost, because everybody will now start building on top of B.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>The command by default does not allow an update that is not a fast-forward to prevent such loss of history.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>If you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>You can perform "git pull", resolve potential conflicts, and "git push" the result. A "git pull" will create a merge commit C between commits A and B.</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">      B---C     /   / ---X---A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>Updating A with the resulting merge commit will fast-forward and your push will be accepted.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Alternatively, you can rebase your change between X and B on top of A, with "git pull --rebase", and push the result back. The rebase will create a new commit D that builds the change between X and B on top of A.</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">      B   D     /   / ---X---A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>Again, updating A with this commit will fast-forward and your push will be accepted.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with "git commit --amend" to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run "git push --force" to overwrite it. In other words, "git push --force" is a method reserved for a case where you do mean to lose history.</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Examples</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git push</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>Works like <code>git push &lt;remote&gt;</code>, where &lt;remote&gt; is the current branch’s remote (or <code>origin</code>, if no remote is configured for the current branch).</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git push origin</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>Without additional configuration, pushes the current branch to the configured upstream (<code>remote.origin.merge</code> configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>The default behavior of this command when no &lt;refspec&gt; is given can be configured by setting the <code>push</code> option of the remote, or the <code>push.default</code> configuration variable.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>For example, to default to pushing only the current branch to <code>origin</code> use <code>git config remote.origin.push HEAD</code>. Any valid &lt;refspec&gt; (like the ones in the examples below) can be configured as the default for <code>git push origin</code>.</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git push origin :</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>Push "matching" branches to <code>origin</code>. See &lt;refspec&gt; in the OPTIONS section above for a description of "matching" branches.</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git push origin master</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>Find a ref that matches <code>master</code> in the source repository (most likely, it would find <code>refs/heads/master</code>), and update the same ref (e.g. <code>refs/heads/master</code>) in <code>origin</code> repository with it. If <code>master</code> did not exist remotely, it would be created.</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git push origin HEAD</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>A handy way to push the current branch to the same name on the remote.</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git push mothership master:satellite/master dev:satellite/dev</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>Use the source ref that matches <code>master</code> (e.g. <code>refs/heads/master</code>) to update the ref that matches <code>satellite/master</code> (most probably <code>refs/remotes/satellite/master</code>) in the <code>mothership</code> repository; do the same for <code>dev</code> and <code>satellite/dev</code>.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>This is to emulate <code>git fetch</code> run on the <code>mothership</code> using <code>git push</code> that is run in the opposite direction in order to integrate the work done on <code>satellite</code>, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd).</p></div></div><div class="doc-postil"><div class="c-markdown"><p>After running this <code>git push</code> on the <code>satellite</code> machine, you would ssh into the <code>mothership</code> and run <code>git merge</code> there to complete the emulation of <code>git pull</code> that were run on <code>mothership</code> to pull changes made on <code>satellite</code>.</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git push origin HEAD:master</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>Push the current branch to the remote ref matching <code>master</code> in the <code>origin</code> repository. This form is convenient to push the current branch without thinking about its local name.</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git push origin master:refs/heads/experimental</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>Create the branch <code>experimental</code> in the <code>origin</code> repository by copying the current <code>master</code> branch. This form is only needed to create a new branch or tag in the remote repository when the local name and the remote name are different; otherwise, the ref name on its own will work.</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git push origin :experimental</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>Find a ref that matches <code>experimental</code> in the <code>origin</code> repository (e.g. <code>refs/heads/experimental</code>), and delete it.</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git push origin +dev:master</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>Update the origin repository’s master branch with the dev branch, allowing non-fast-forward updates. <strong>This can leave unreferenced commits dangling in the origin repository.</strong> Consider the following situation, where a fast-forward is not possible:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">            o---o---o---A---B  origin/master
                     \
                      X---Y---Z  dev</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>The above command would change the origin repository to</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">                      A---B  (unnamed branch)                     /
            o---o---o---X---Y---Z  master</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>Commits A and B would no longer belong to a branch with a symbolic name, and so would be unreachable. As such, these commits would be removed by a <code>git gc</code> command on the origin repository.</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Security</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>The known attack vectors are as follows:</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>The victim sends "have" lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn’t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to "merge" X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.</p></li></ol></div></div></div>