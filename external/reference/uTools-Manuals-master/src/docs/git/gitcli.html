<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcli  -  Git 命令行界面和约定</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcli</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>本手册介绍了在整个 Git CLI 中使用的约定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>许多命令都采用修订（通常是 “commits” ，但有时是 “ tree-ish ” ，取决于上下文和命令）和路径作为它们的参数。这是规则：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>修订首先是路径。例如在<code>git diff v1.0 v2.0 arch/x86 include/asm-x86</code>，<code>v1.0</code>并且<code>v2.0</code>是修改，<code>arch/x86</code>并且<code>include/asm-x86</code>是路径。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>当一个论证可能会被误解为一个修订或一条路径时，他们可以通过放在<code>--</code>它们之间来消除歧义。例如<code>git diff -- HEAD</code>，“我的工作树中有一个名为 HEAD 的文件，请在索引中的版本I和我在该文件的工作树中显示的内容之间显示更改”，而不是“显示 HEAD 提交与工作之间的差异树整体“。你可以说<code>git diff HEAD --</code>要问后者。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>在没有歧义的情况下<code>--</code>，Git 会做出合理的猜测，但会出错并要求您在模棱两可时消除歧义。例如，如果你有一个在你的工作树叫 HEAD 的文件，<code>git diff HEAD</code>是模糊的，而你不得不说要么<code>git diff HEAD --</code>或<code>git diff -- HEAD</code>消除歧义。在编写预期处理随机用户输入的脚本时，最好明确哪些参数是通过<code>--</code>在适当的位置进行消除歧义来明确的。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>许多命令允许在路径中使用通配符，但是您需要保护它们免受 shell 的影响。这两个意思是不同的东西：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git checkout -- *.c $ git checkout -- \*.c</p></div></div><div class="doc-postil"><div class="c-markdown"><p>前者允许 shell 扩展 fileglob ，并且要求工作树中的 dot-C 文件被索引中的版本覆盖。后者传递<code>*.c</code>给 Git，并且您要求索引中匹配模式的路径被检出到您的工作树上。跑步后<code>git add hello.c; rm hello.c</code>，你会<code>not</code>看到<code>hello.c</code>你的工作树与前者，但后者，你会。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>就像文件系统<code>.</code>（句点）引用当前目录一样，在Git 中使用<code>.</code>作为存储库名称（一个点存储库）是一个相对路径，并且表示您当前的存储库。这里是关于您应该遵循的“标志”的规则当你在编写 Git 时：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>它的最好使用的 Git 的非虚线形式的命令，这意味着你应该更喜欢<code>git foo</code>到<code>git-foo</code>。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>拆分短选项分隔单词（喜欢<code>git foo -a -b</code>到<code>git foo -ab</code>，后者甚至可能不工作）。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>当一个命令行选项带有参数时，请使用该<code>stuck</code>表单。换句话说，写出<code>git foo -oArg</code>代替<code>git foo -o Arg</code>短期期权，而<code>git foo --long-opt=Arg</code>不是<code>git foo --long-opt Arg</code>长期期权。采用可选选项参数的选项必须写入<code>stuck</code>表单中。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>当您为某个命令提供修订参数时，请确保该参数与工作树中文件的名称不混淆。例如，不要写，<code>git log -1 HEAD</code>而要写<code>git log -1 HEAD --</code>; 如果您碰巧<code>HEAD</code>在工作树中调用了一个文件，则前者不起作用。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>许多命令允许将一个长选项<code>--option</code>仅缩写为其唯一的前缀（例如，如果没有其他选项的名称以该名称开头<code>opt</code>，则可以拼写<code>--opt</code>来调用该<code>--option</code>标志），但是在编写脚本时应该将其完全拼出; 后来的 Git 版本可能会引入一个新的选项，其名称共享相同的前缀，例如<code>--optimize</code>，用于创建一个过去不再唯一的简短前缀。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h2>增强的选项解析器</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>从 Git 1.5.4 系列和更进一步，许多 Git 命令（不是所有的这些在编写时）都带有一个增强的选项解析器。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这里是这个选项解析器提供的工具列表。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>Magic 选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>具有增强的选项分析器的命令都可以理解一些神奇的命令行选项：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-h</p></div></div><div class="doc-postil"><div class="c-markdown"><p>给出了一个完美的打印使用该命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git describe -h
usage: git describe [options] &lt;commit-ish&gt;*
   or: git describe [options] --dirty    --contains            find the tag that comes after the commit    --debug               debug search strategy on stderr    --all                 use any ref    --tags                use any tag, even unannotated    --long                always use long format    --abbrev[=&lt;n&gt;]        use &lt;n&gt; digits to display SHA-1s</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>--help-all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有些 Git 命令会使用仅用于管道的选项或已弃用的选项，并且这些选项对于默认用法是隐藏的。该选项提供了完整的选项列表。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>否定选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>具有较长选项名称的选项可以通过前缀来取消<code>--no-</code>。例如，<code>git branch</code>有选项<code>--track</code>是<code>on</code>默认。您可以使用<code>--no-track</code>来覆盖该行为。这也是<code>--color</code>和<code>--no-color</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>汇总短期选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>支持增强选项解析器的命令允许您汇总短选项。这意味着你可以例如使用<code>git rm -rf</code>或<code>git clean -fdx</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>缩写长选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>支持增强选项解析器的命令接受长选项的唯一前缀，就像它完全拼出一样，但谨慎使用此选项。例如，<code>git commit --amen</code>你的行为就像你输入的一样<code>git commit --amend</code>，但是只有当 Git 的一个更新版本引入了另一个共享相同前缀的选项时，这是正确的，例如<code>git commit --amenity</code>选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>从选项中分离参数</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以在命令行中将强制选项参数作为单独的单词写入选项。这意味着以下所有用途都有效：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git foo --long-opt=Arg
$ git foo --long-opt Arg
$ git foo -oArg
$ git foo -o Arg</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然而，这是<strong>不</strong>允许与可选的值，其中，所述开关<code>stuck</code>，必须使用形式：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git describe --abbrev HEAD     # correct
$ git describe --abbrev=10 HEAD  # correct
$ git describe --abbrev 10 HEAD  # NOT WHAT YOU MEANT</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>注意经常混淆的选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>许多可用于工作树中和/或索引中的文件的命令可以采用<code>--cached</code>和/或<code>--index</code>选择。有时候人们错误地认为，因为索引最初称为缓存，这两个是同义词。他们<strong>不是</strong> - 这两个选项意味着非常不同的事情。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>该<code>--cached</code>选项用于询问通常对工作树中的文件起作用的命令，以便<strong>仅</strong>与索引一起工作。例如，<code>git grep</code>如果在没有提交的情况下使用，指定从哪个提交中查找字符串，通常用于工作树中的文件，但使用该<code>--cached</code>选项时，它会在索引中查找字符串。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>--index</code>选项用于要求，通常在工作中的文件工作树的命令<strong>还</strong>影响指数。例如，<code>git stash apply</code>通常会将存储条目中记录的更改合并到工作树中，但是通过该<code>--index</code>选项，它也会将更改合并到索引中。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git apply</code>命令可以<code>--cached</code>和<code>--index</code>（但不能同时）一起使用。通常，该命令只影响工作树中的文件，但是<code>--index</code>，它会对文件及其索引条目进行修补，而且<code>--cached</code>，它仅修改索引条目。</p></div></div></div>