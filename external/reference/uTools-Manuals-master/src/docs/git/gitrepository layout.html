<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>gitrepository-layout - Git Repository Layout</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>$GIT_DIR/*</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>一个 Git 仓库有两种不同的风格：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>一个<code>.git</code>目录在工作树的根;</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>一个<code>&lt;project&gt;.git</code>是<code>bare</code>存储库的目录（即没有自己的工作树），通常用于与其他人交换历史记录，方法是将其推入并从中取回。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p><strong>注意</strong>：您也可以在工作树的根目录中有一个纯文本文件<code>.git</code>，其中包含<code>gitdir: &lt;path&gt;</code>指向具有存储库的实际目录。此机制通常用于子模块签出的工作树，以允许您在包含超级项目的情况下访问<code>git checkout</code>没有子模块的分支。将<code>checkout</code>有权删除整个子模块工作树，又不失子模块库。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些东西可能存在于 Git 仓库中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>objects</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与此存储库关联的对象存储。通常一个对象存储是自给自足的（即，在其中找到的对象所引用的所有对象也可以在其中找到），但有几种方法可以违反它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>1. 通过创建浅度克隆，您可以拥有一个不完整但本地可用的存储库。参见 git-clone [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>2. 您可以使用<code>objects/info/alternates</code>或<code>$GIT_ALTERNATE_OBJECT_DIRECTORIES</code>机制来<code>borrow</code>从其他对象存储的对象。具有这种不完整对象存储库的存储库不适合被发布以用于哑输送，但是只要<code>objects/info/alternates</code>对象所存储的点存储于其中，则其他就可以。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置了 $ GIT_COMMON_DIR 并且将使用 “$ GIT_COMMON_DIR / objects” ，则该目录将被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>objects/0-9a-f</p></div></div><div class="doc-postil"><div class="c-markdown"><p>新创建的对象存储在其自己的文件中。这些对象使用 sha1 对象名称的前两个字符显示在256个子目录中，以将目录条目<code>objects</code>本身的数量保持为可管理的数量。在这里找到的对象通常被称为<code>unpacked</code>（或<code>loose</code>）对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>objects/pack</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打包（在压缩格式中存储多个对象的文件以及允许它们随机访问的索引文件）可在此目录中找到。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>objects/info</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关对象存储的其他信息记录在此目录中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>objects/info/packs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个文件是为了帮助笨拙的传输发现在这个对象存储中可用的包。无论何时添加或删除包，<code>git update-server-info</code>都应该运行以保持该文件最新，如果存储库针对哑传输发布的话。<code>git repack</code>这是默认情况下。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>objects/info/alternates</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此文件记录此对象存储借用对象的备用对象存储的路径，每行一个路径名。请注意，不仅本地 Git 工具在本地使用它，而且 HTTP fetcher 也会尝试远程使用它; 如果在替代文件中有相对路径（相对于对象数据库，而不是存储库！），这通常会起作用，但如果使用绝对路径，它将不起作用，除非文件系统和 Web URL 中的绝对路径相同。另见<code>objects/info/http-alternates</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>objects/info/http-alternates</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该文件将 URL 记录到此对象存储借用对象的备用对象存储中，以便在通过 HTTP 获取存储库时使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>refs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>引用存储在此目录的子目录中。该<code>git prune</code>命令知道保留可从此目录及其子目录中找到的引用可访问的对象。如果设置了 $ GIT_COMMON_DIR 并且将使用 “$ GIT_COMMON_DIR / refs” ，则该目录将被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>refs/heads/<code>name</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录树枝的树枝提交对象 <code>name</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>refs/tags/<code>name</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录任何对象名称（不一定是提交对象，或指向提交对象的标记对象）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>refs/remotes/<code>name</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录从远程存储库复制的分支的树形提交对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>refs/replace/<code>&lt;obj-sha1&gt;</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录替换对象的 SHA-1 <code>&lt;obj-sha1&gt;</code>。这与 info / grafts 类似，并且由 git-replace [1] 在内部使用和维护。这些参考文献可以在库之间进行交换，而移植不是。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>packed-refs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录与 refs / heads /，refs / tags / 相同的信息，并以更高效的方式记录朋友。参见 git-pack-refs [1] 。如果设置了 $ GIT_COMMON_DIR 并且将使用 “$ GIT_COMMON_DIR / packed-refs” ，那么该文件将被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>HEAD</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>refs/heads/</code>描述当前活动分支的命名空间的 symref（参见词汇表）。如果存储库不与任何工作树（即<code>bare</code>存储库）相关联，这并没有多大意义，但有效的 Git 存储库<strong>必须</strong>具有 HEAD 文件; 一些瓷器可能会用它来猜测储存库的指定“默认”分支（通常<code>master</code>）。如果指定的分支<code>name</code>尚未（尚未）存在，则是合法的。在一些传统设置中，它是一个符号链接，而不是指向当前分支的 symref 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>HEAD 还可以直接记录特定的提交，而不是作为 symref 指向当前分支。<code>detached HEAD.</code>有关详细信息，此类状态通常称为参阅 git-checkout [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>config</p></div></div><div class="doc-postil"><div class="c-markdown"><p>存储库特定的配置文件。如果设置了 $ GIT_COMMON_DIR 并且将使用 “$ GIT_COMMON_DIR / config” ，则忽略此文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>branches</p></div></div><div class="doc-postil"><div class="c-markdown"><p>存储用于指定 URL 的简写方式<code>git fetch</code>，<code>git pull</code>以及<code>git push</code>。一个文件可以存储为<code>branches/&lt;name&gt;</code>，然后<code>name</code>可以给这些命令代替<code>repository</code>参数。有关详细信息，请参阅 git-fetch [1] 中的 REMOTES 部分。这种机制是传统的，不太可能在现代仓库中找到。如果设置了 $ GIT_COMMON_DIR 并且将使用 “$ GIT_COMMON_DIR / branches” ，则该目录将被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>hooks</p></div></div><div class="doc-postil"><div class="c-markdown"><p>钩子是各种 Git 命令使用的定制脚本。<code>git init</code>运行时会安装一些示例挂钩，但默认情况下它们都被禁用。要启用，<code>.sample</code>后缀必须通过重命名从文件名中删除。阅读 githooks [5] 了解每个钩子的更多细节。如果设置了 $ GIT_COMMON_DIR 并且将使用 “$ GIT_COMMON_DIR / hooks” ，则该目录将被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>index</p></div></div><div class="doc-postil"><div class="c-markdown"><p>存储库的当前索引文件。它通常在空仓库中找不到。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sharedindex.&lt;SHA-1&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>共享索引部分，由 $ GIT_DIR / index 和其他临时索引文件引用。仅在分割索引模式下有效。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>info</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关存储库的其他信息记录在此目录中。如果设置了 $ GIT_COMMON_DIR 并且将使用 “$ GIT_COMMON_DIR / info” ，则该目录将被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>info/refs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个文件有助于常用的传输发现这个仓库中可用的参考文献。如果存储库针对哑传输发布，则<code>git update-server-info</code>每次创建或修改标签或分支时都应该重新生成该文件。这通常是从<code>hooks/update</code>挂钩中完成的，挂钩<code>git-receive-pack</code>在您<code>git push</code>进入存储库时由命令运行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>info/grafts</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个文件记录假提交上代信息，假装一个提交具有不同于提交实际创建的父集。每行一条记录通过列出由空格分隔并以换行符结尾的40字节十六进制对象名称来描述提交及其假父代。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，移植机制已过时，并可能导致在库之间传输对象时出现问题; 请参阅 git-replace [1] 以获得更灵活和更强大的系统来完成同样的任务。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>info/exclude</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该文件按照 Porcelains 中的惯例存储排除模式列表。<code>.gitignore</code>是每个目录的忽略文件。<code>git status</code>，<code>git add</code>，<code>git rm</code>并且<code>git clean</code>看着它，但核心的 Git 命令不看它。另见：gitignore [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>info/sparse-checkout</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该文件存储稀疏切换分支模式。另请参阅：git-read-tree [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remotes</p></div></div><div class="doc-postil"><div class="c-markdown"><p>商店简写为使用通过远程仓库进行交互时，URL 和默认 refnames <code>git fetch</code>，<code>git pull</code>和<code>git push</code>命令。有关详细信息，请参阅 git-fetch [1] 中的 REMOTES 部分。这种机制是传统的，不太可能在现代仓库中找到。如果设置了 $ GIT_COMMON_DIR 并且将使用 “$ GIT_COMMON_DIR / remotes” ，则该目录将被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>logs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对 ref 进行的更改记录存储在此目录中。有关更多信息，请参阅 git-update-ref [1] 。如果设置了 $ GIT_COMMON_DIR 并且将使用 “$ GIT_COMMON_DIR / logs” ，则该目录将被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>logs/refs/heads/<code>name</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录对分支提示进行的所有更改<code>name</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>logs/refs/tags/<code>name</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录对名为<code>name</code>的标签所做的所有更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>shallow</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这与<code>info/grafts</code>浅层克隆机制类似，但在内部使用和维护。请参阅<code>--depth</code> git-clone [1] 和 git-fetch [1] 的选项。如果设置了 $ GIT_COMMON_DIR 并且将使用 “$ GIT_COMMON_DIR / shallow” ，则该文件将被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>commondir</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果此文件存在，$ GIT_COMMON_DIR（请参阅 git [1] ）将被设置为此文件中指定的路径（如果未明确设置）。如果指定的路径是相对的，则相对于 $ GIT_DIR 。如果没有 “commondir” 指向的存储库，commondir 存储库是不完整的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>modules</p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含子模块的 git-repository 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>worktrees</p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含链接工作树的管理数据。每个子目录都包含链接工作树的工作树相关部分。如果设置了 $ GIT_COMMON_DIR ，则该目录将被忽略，在这种情况下，将使用 “$ GIT_COMMON_DIR / worktrees” 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>worktrees/&lt;id&gt;/gitdir</p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含指向此处的 .git 文件的绝对路径的文本文件。这用于检查链接的存储库是否已被手动删除，并且不需要保留该目录。每次访问链接存储库时都应更新此文件的 mtime 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>worktrees/&lt;id&gt;/locked</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果此文件存在，则链接的工作树可能位于便携式设备上并且不可用。这个文件的存在防止<code>worktrees/&lt;id&gt;</code>被自动或手动修剪<code>git worktree prune</code>。该文件可能包含一个字符串，解释存储库被锁定的原因。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>worktrees/&lt;id&gt;/link</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果此文件存在，则它是到链接的 .git 文件的硬链接。它用于检测是否手动删除链接的存储库。</p></div></div></div>