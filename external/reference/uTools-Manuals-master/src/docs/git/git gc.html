<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-gc  - 清理不必要的文件并优化本地存储库</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git gc [--aggressive] [--auto] [--quiet] [--prune=&lt;date&gt; | --no-prune] [--force]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>在当前存储库中运行许多内务处理任务，例如压缩文件修订（以减少磁盘空间并提高性能）并移除可能由之前<code>git add</code>调用创建的不可达对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>鼓励用户在每个存储库中定期运行此任务，以保持良好的磁盘空间利用率和良好的操作性能。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一些git命令可能会自动运行<code>git gc</code>; <code>--auto</code>详细信息请参阅下面的标志。如果您知道自己在做什么，并且所有您想要的都是永久禁用此行为而无需进一步考虑，请执行以下操作：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git config --global gc.auto 0</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>--aggressive</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通常<code>git gc</code>运行速度很快，同时提供良好的磁盘空间利用率和性能 此选项将导致<code>git gc</code>更积极地优化存储库，但花费更多时间。这种优化的效果是持久的，所以这个选项只需要偶尔使用; 每隔几百个变更集左右。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--auto</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用此选项，<code>git gc</code>检查是否需要进行任何清洁工作; 如果没有，它会退出而不执行任何工作。一些git命令<code>git gc --auto</code>在执行可能会产生许多松散对象的操作之后运行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果存储库中的松散对象太多或包装太多，则需要进行内务处理。如果松散对象的数量超过了<code>gc.auto</code>配置变量的值，则所有松散对象都将使用组合到一个包中<code>git repack -d -l</code>。将值设置<code>gc.auto</code>为0将禁用自动填充松散物体。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果包装数量超过了价值<code>gc.autoPackLimit</code>，那么现有包装（标有<code>.keep</code>文件的包装除外）将通过使用<code>-A</code>选项合并到一个包装中<code>git repack</code>。设置<code>gc.autoPackLimit</code>为0将禁用自动合并包装。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--prune=&lt;date&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>修剪比日期更旧的松散对象（默认为2周前，可由配置变量覆盖<code>gc.pruneExpire</code>）。--prune =不管年龄大小，都修剪松散的物体，并且如果另一个进程同时写入存储库，则会增加腐败风险; 请参阅下面的“注意事项”。--prune默认打开。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-prune</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要修剪任何松动的物体。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--quiet</p></div></div><div class="doc-postil"><div class="c-markdown"><p>取消所有进度报告。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--force</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git gc</code>即使可能有另一个<code>git gc</code>实例在此存储库上运行，也强制运行。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>组态</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>可选配置变量<code>gc.reflogExpire</code>可以设置为指示每个分支的reflog中的历史条目应该在此存储库中保持可用的时间。该设置表示为一段时间，例如<code>90 days</code>或<code>3 months</code>。它默认为<code>90 days</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可选配置变量<code>gc.reflogExpireUnreachable</code>可设置为指示不属于当前分支的历史请求日志条目在此存储库中保持可用的时间。这些类型的条目通常是由于使用<code>git commit --amend</code>或<code>git rebase</code>而创建的，并且是在修改或重新发生之前的提交。由于这些更改不是当前项目的一部分，因此大多数用户都希望尽快过期。该选项默认为<code>30 days</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>上述两个配置变量可以赋予一个模式。例如，这会将非默认到期值设置为远程跟踪分支：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[gc "refs/remotes/*"]
        reflogExpire = never
        reflogExpireUnreachable = 3 days</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>可选的配置变量<code>gc.rerereResolved</code>指示您先前解决的冲突合并记录的保存期限。这默认为60天。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可选的配置变量<code>gc.rerereUnresolved</code>表示保留了多久没有解决的冲突合并记录。这默认为15天。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可选的配置变量<code>gc.packRefs</code>确定是否<code>git gc</code>运行<code>git pack-refs</code>。可以将其设置为“notbare”，以便在所有非裸回购库中启用它，或者可以将其设置为布尔值。这默认为true。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可选配置变量<code>gc.aggressiveWindow</code>控制在指定--aggressive选项时优化存储库中对象的增量压缩所花费的时间。值越大，优化增量压缩花费的时间就越多。有关更多详细信息，请参阅git-repack [1]中--window'选项的文档。这默认为250。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>同样，可选的配置变量<code>gc.aggressiveDepth</code>控制git-repack [1]中的--depth选项。默认值为50。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可选的配置变量<code>gc.pruneExpire</code>控制未修剪的松散对象在修剪之前必须经过多久。默认值是“2周前”。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>注意</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git gc</code>尽量不要删除在存储库中任何位置引用的对象。特别是，它不仅会保存当前一组分支和标记所引用的对象，还会保留由索引引用的对象，远程跟踪分支，<code>git filter-branch</code>refs / original /中保存的引用或reflogs（可引用分支中的提交后来修改或倒带）。如果您希望某些对象被删除而不是，请检查所有这些位置，并决定在您的情况下删除这些引用是否有意义。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>另一方面，当<code>git gc</code>与另一个进程同时运行时，可能会删除另一个进程正在使用但尚未创建引用的对象。这可能会导致其他进程失败或者可能会损坏存储库，如果其他进程稍后添加对已删除对象的引用。Git有两个功能可以显着缓解这个问题：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p><code>--prune</code>保留修改时间比日期更新的任何对象以及可从其访问的所有对象。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>将对象添加到数据库的大多数操作都会更新对象的修改时间（如果该对象已存在，以便应用＃1）。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>然而，这些功能并不能提供完整的解决方案，因此，同时运行命令的用户必须忍受一些腐败风险（实践中似乎很低），除非他们关闭自动垃圾收集<code>git config gc.auto 0</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Hooks</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>该<code>git gc --auto</code>命令将运行该<code>pre-auto-gc</code>钩子。有关更多信息，请参阅githooks [5]。</p></div></div></div>