<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-cvsserver  -  Git 的 CVS 服务器模拟器</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>SSH:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">export CVS_SERVER="git cvsserver"cvs -d :ext:user@server/path/repo.git co &lt;HEAD_name&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>pserver（/etc/inetd.conf）：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">cvspserver stream tcp nowait nobody /usr/bin/git-cvsserver git-cvsserver pserver</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>用法：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git-cvsserver [options] [pserver|server] [&lt;directory&gt; …]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>所有这些选项显然只有在服务器端强制执行时才有意义。它们已经被实现为尽可能地与 git-daemon [1] 选项类似。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--base-path &lt;path&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>预先<code>path</code>申请 CVSROOT</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--strict-paths</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要允许递归到子目录中</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--export-all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要<code>gitcvs.enabled</code>在配置中检查。如果要使用此选项，还必须指定允许的目录列表（请参见下文）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-V   --version</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打印版本信息并退出</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-h   -H   --help</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打印使用情况信息并退出</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;directory&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以指定允许的目录列表。如果没有给出目录，则全部允许。这是一个额外的限制，gitcvs 访问仍然需要<code>gitcvs.enabled</code>配置选项启用，除非<code>--export-all</code>被给予。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>此应用程序是 Git 的 CVS 仿真层。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>它功能强大。但是并非所有方法都已实施，对于已实施的方法，并非所有交换机都已实施。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用 CLI CVS 客户端和 Eclipse CVS 插件完成了测试。大多数功能都可以与这两个客户端正常工作。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>限制</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>CVS 客户端不能标记，分支或执行 Git 合并。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git-cvsserver</code>将 Git 分支映射到 CVS 模块。这与大多数 CVS 用户所期望的完全不同，因为在 CVS 中，模块通常代表一个或多个目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>安装</h2></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>如果您要通过 pserver 提供 CVS 访问，请在 /etc/inetd.conf 中添加一行，如 cvspserver stream tcp nowait nobody git-cvsserver pserver</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>注意：某些 inetd 服务器允许您指定独立于 argv0 值的可执行文件的名称。在这种情况下，/etc/inetd.conf 中的正确行看起来像</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">  cvspserver stream tcp nowait nobody /usr/bin/git-cvsserver git-cvsserver pserver</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>pserve 默认只提供匿名访问。要提交，您必须创建 pserver 帐户，只需在要让 cvsserver 允许写入的存储库的配置文件中添加 gitcvs.authdb 设置，例如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">  [gitcvs]         authdb = /etc/cvsserver/passwd</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这些文件的格式是用户名后跟加密的密码，例如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">  myuser:$1Oyx5r9mdGZ2    myuser:$1$BA)@$vbnMJMDym7tA32AamXrm./</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以使用<code>htpasswd</code> Apache 提供的工具来生成这些文件，但是 Apache 的 MD5 加密方法与大多数 C 库的 crypt（）函数所使用的方法不同，因此不要使用 -m 选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>或者，你可以用 perl 的 crypt（）运算符产生密码：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">  perl -e 'my ($user, $pass) = @ARGV; printf "%s:%s\n", $user, crypt($user, $pass)' $USER password</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后通过 pserver 方法提供您的密码，例如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">  cvs -d:pserver:someuser:somepassword &lt;at&gt; server/path/repo.git co &lt;HEAD\_name&gt;</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>除了在 PATH 中使用 Git 工具之外，SSH 访问不需要任何特殊设置。如果您的客户端不接受 CVS_SERVER 环境变量，则可以重命名<code>git-cvsserver</code>为<code>cvs</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>注意：较新的 CVS 版本（&gt; = 1.12.11）也支持直接在 CVSROOT 中指定 CVS_SERVER</p></div></div><div class="doc-postil"><div class="c-markdown"><p>cvs -d ":ext;CVS_SERVER=git cvsserver:user@server/path/repo.git" co &lt;HEAD_name&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这有一个好处，它将被保存在你的<code>CVS/Root</code>文件中，你不必担心总是设置正确的环境变量。受限制的 SSH 用户<code>git-shell</code>不需要用 CVS_SERVER 覆盖缺省值（而且不应该）<code>git-shell</code>理解<code>cvs</code>为意味着<code>git-cvsserver</code>并假装另一端运行得<code>cvs</code>更好。</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>对于您想要从 CVS 访问的每个回购，您需要编辑回购中的配置并添加以下部分。gitcvs enabled = 1＃可选，用于调试 logFile = / path / to / logfile</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>注意：您需要确保要调用的每个用户<code>git-cvsserver</code>都有对日志文件和数据库的写入权限（请参阅 Database Backend 。如果您想通过 SSH 提供写入权限，用户当然也需要对 Git 的写入权限存储库本身。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您还需要确保每个存储库都是 “bare”（没有 Git 索引文件）<code>cvs commit</code>才能工作。请参阅 gitcvs-migration [7]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于特定的访问方法，所有配置变量也可以被覆盖。有效的方法名称是 “ext”（用于 SSH 访问）和 “pserver” 。以下示例配置将禁用 pserver 访问，同时仍允许通过 SSH 进行访问。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">  [gitcvs]         enabled=0     [gitcvs "ext"]         enabled=1</pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>如果您没有直接在 checkout 命令中指定 CVSROOT / CVS_SERVER ，将其自动保存在<code>CVS/Root</code>文件中，那么您需要在您的环境中明确设置它们。CVSROOT 应该按照正常进行设置，但目录应该指向适当的 Git 仓库。如上所述，对于<code>not</code>限制为 SSH 的客户端<code>git-shell</code>，应将 CVS_SERVER 设置为<code>git-cvsserver</code>。export CVSROOT =：ext：user @ server：/var/git/project.git export CVS_SERVER =“git cvsserver”</p></li><li><p>对于将进行提交的 SSH 客户端，请确保其服务器端 .ssh /environment 文件（或 .bashrc 等，根据其特定的外壳）为 GIT_AUTHOR_NAME ，GIT_AUTHOR_EMAIL ，GIT_COMMITTER_NAME 和 GIT_COMMITTER_EMAIL 导出适当的值。对于登录 shell 为 bash 的 SSH 客户端，.bashrc 可能是一个合理的选择。</p></li><li><p>客户现在应该能够检查项目。使用 CVS <code>module</code>名称来表明<code>head</code>你想要签出的 Git 。这也设置了新检出目录的名称，除非您另有说明<code>-d &lt;dir_name&gt;</code>。例如，这将检查<code>master</code>分支到<code>project-master</code>目录：cvs co -d project-master master</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><h2>数据库后端</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git-cvsserver</code>每个 Git 头部（即 CVS 模块）使用一个数据库来存储关于存储库的信息以保持一致的 CVS 修订号。数据库需要在每次提交后更新（即写入）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果提交是通过使用<code>git</code>（而不是使用<code>git-cvsserver</code>）直接完成的，则更新将需要在下一个存储库访问时发生<code>git-cvsserver</code>，与访问方法和请求的操作无关。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这意味着，即使您只提供读访问权限（例如通过使用pserver方法），也<code>git-cvsserver</code>应该具有对数据库的写访问权限以便可靠地工作（否则，您需要确保数据库在任何时候<code>git-cvsserver</code>执行都是最新的） 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，它使用 Git 目录中的 SQLite 数据库，名为<code>gitcvs.&lt;module_name&gt;.sqlite</code>。请注意，SQLite 后端在写入数据库文件的同一目录中创建临时文件，因此它可能不足以授予用户<code>git-cvsserver</code>对数据库文件的写入访问权限，但不授予它们对目录的写入访问权限。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在跟踪发生变化的分支后，数据库不能以一致的形式可靠地重新生成。示例：对于合并分支，<code>git-cvsserver</code>仅跟踪开发的一个分支，并且在<code>git merge</code>增量更新的数据库跟踪与从头开始重新生成的数据库不同的分支之后，会导致 CVS 修订版编号不一致。<code>git-cvsserver</code>没有办法知道哪个分支它会选择如果它已经逐步运行预合并。因此，如果您必须完全或部分（从旧备份）重新生成数据库，则应该怀疑预先存在的 CVS 沙箱。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以使用以下配置变量来配置数据库后端：</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>配置数据库后端</h3></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git-cvsserver</code>使用 Perl DBI 模块。如果更改这些变量，请阅读它的文档，尤其是关于<code>DBI-&gt;connect()</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.dbName</p></div></div><div class="doc-postil"><div class="c-markdown"><p>数据库名称。确切的含义取决于选定的数据库驱动程序，对于 SQLite 这是一个文件名。支持变量替换（见下文）。不能包含分号（<code>;</code>）。默认：<code>%Ggitcvs.%m.sqlite</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.dbDriver</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用的 DBI 驱动程序。你可以在这里指定任何可用的驱动程序，但它可能不起作用。cvsserver 已经过测试<code>DBD::SQLite</code>，报告可以使用<code>DBD::Pg</code>，并且报告<strong>不能</strong>使用<code>DBD::mysql</code>。请将此视为实验性功能。不能包含冒号（<code>:</code>）。默认：<code>SQLite</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.dbuser</p></div></div><div class="doc-postil"><div class="c-markdown"><p>数据库用户。只有在设置时才有用<code>dbDriver</code>，因为 SQLite 没有数据库用户的概念。支持变量替换（见下文）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.dbPass</p></div></div><div class="doc-postil"><div class="c-markdown"><p>数据库密码。只有在设置时才有用<code>dbDriver</code>，因为 SQLite 没有数据库密码的概念。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.dbTableNamePrefix</p></div></div><div class="doc-postil"><div class="c-markdown"><p>数据库表名称前缀。支持变量替换（见下文）。任何非字母字符将被替换为下划线。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>所有变量也可以根据访问方法设置，参见上文。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>变量替代</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>在<code>dbDriver</code>和<code>dbUser</code>你可以使用以下变量：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>%G</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 目录名称</p></div></div><div class="doc-postil"><div class="c-markdown"><p>%g</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 的目录名，其中除字母数字以外的所有字符<code>.</code>，并<code>-</code>与更换<code>_</code>（这应该更容易地在文件名中使用的目录名称，如果想）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>%m</p></div></div><div class="doc-postil"><div class="c-markdown"><p>CVS 模块 / Git 头名称</p></div></div><div class="doc-postil"><div class="c-markdown"><p>%a</p></div></div><div class="doc-postil"><div class="c-markdown"><p>访问方法（“ext” 或 “pserver” 之一）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>%u</p></div></div><div class="doc-postil"><div class="c-markdown"><p>正在运行的用户的名称<code>git-cvsserver</code>。如果不能确定名称，则使用数字 uid 。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>环境</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>在某些情况下，这些变量可以避免使用命令行选项，从而通过 git-shell 更容易地限制使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>GIT_CVSSERVER_BASE_PATH 取代了 --base-path 的参数。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>GIT_CVSSERVER_ROOT 指定单目录白名单。如上所述，存储库仍必须配置为允许通过 git-cvsserver 进行访问。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当设置这些环境变量时，可能不会使用相应的命令行参数。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Eclipse cvs 客户端笔记</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>要使用 Eclipse CVS 客户端进行结帐，请执行以下操作：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>选择“创建新项目→从 CVS 签出”</p></li><li><p>创建一个新的位置。有关如何选择正确协议的详细信息，请参阅下面的注释。</p></li><li><p>浏览<code>modules</code>可用。它会给你一个存储库中头的列表。你将无法从那里浏览树。只有头部。</p></li><li><p>挑选<code>HEAD</code>时，它会询问什么分支/标签退房。取消“启动提交向导”以避免提交 .project 文件。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>协议说明：如果您通过 pserver 使用匿名访问，请选择该选项。那些使用 SSH 访问的应该选择<code>ext</code>协议，并<code>ext</code>在首选项→团队→ CVS → ExtConnection 窗格中配置访问权限。将 CVS_SERVER 设置为“ <code>git cvsserver</code>”。请注意，密码支持在使用时不好<code>ext</code>，你一定会想要设置 SSH 密钥。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>或者，您可以使用 Eclipse 提供的非标准 extssh 协议。在这种情况下，CVS_SERVER 将被忽略，并且您将不得不用服务器上的 cvs 实用程序替换<code>git-cvsserver</code>或操作您的服务器，<code>.bashrc</code>以便<code>cvs</code>有效地调用呼叫<code>git-cvsserver</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>已知客户端工作</h2></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>CVS 1.12.9在 Debian 上</p></li><li><p>MacOSX 上的 CVS 1.11.17（来自 Fink 包）</p></li><li><p>MacOSX 上的 Eclipse 3.0,3.1.2（请参阅 Eclipse CVS 客户端注释）</p></li><li><p>TortoiseCVS</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h2>支持的操作</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>支持正常使用所需的所有操作，包括checkout ，diff ，status ，update ，log ，add ，remove ，commit 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>大多数读取 CVS 标签或版本号（通常是 -r ）的 CVS 命令参数都可以工作，并且还支持任何 git refspec（标签，分支，提交 ID 等）。但是，对于非默认分支的 CVS 修订版编号没有很好地模拟，并且 CVS 日志根本不显示标签或分支。（非主分支 CVS 修订版本号与 CVS 修订版号相似，但实际上它们直接编码了一个 git commit ID ，而不是代表自分支点以来修订版的数目。）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，有两种方法可以检出特定的分支。如本页其他地方所述，cvs checkout 的 “module” 参数被解释为分支名称，并且它将成为主分支。它仍然是给定沙箱的主要分支，即使您暂时使用 cvs update -r 使另一个分支变得粘稠。另外，即使模块仍然是 “main” 分支，-r 参数可以指示其他分支实际结帐。权衡（当前实施）：每个新的“模块”在磁盘上为给定模块创建一个新的数据库历史数据库，创建数据库后，对该主要分支的操作很快。或者，-r 不会占用额外的磁盘空间，但对于许多操作（如 cvs update ）可能会明显较慢。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果你想参考一个 git refspec ，它有 CVS 不允许的字符，你有两个选择。首先，它可能只是将 git refspec 直接提供给适当的 CVS -r 参数; 一些 CVS 客户似乎没有对这个论点做太多的理智检查。其次，如果失败，您可以使用特殊字符转义机制，它只使用在 CVS 标记中有效的字符。（下划线（<code>"_"</code>），短划线（<code>"-"</code>），一个或两个字符以及短划线（<code>"-"</code>））的4或5个字符的序列可以根据一个或两个字母对各种字符进行编码：<code>"s"</code>for slash（<code>"/"</code>），<code>"p"</code>for period（<code>"."</code>） ，<code>"u"</code>用于下划线（<code>"_"</code>），或者任何字节值（通常是 ASCII 码，或者可能是 UTF-8 编码字符的一部分）的两个十六进制数字。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>传统监控操作不受支持（编辑，监视和相关）。此阶段不支持导出和标记（标记和分支）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>CRLF 行结束转换</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，服务器将<code>-k</code>所有文件的模式留空，这会导致 CVS 客户端将它们视为文本文件，并受某些平台上的行尾转换影响。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以通过设置<code>gitcvs.usecrlfattr</code>配置变量使服务器使用行尾转换属性来设置<code>-k</code>的模式。请参阅 gitattributes [5] 以获取有关行尾转换的更多信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>或者，如果<code>gitcvs.usecrlfattr</code>config未启用或者属性不允许自动检测文件名，则服务器使用<code>gitcvs.allBinary</code>config作为默认设置。如果<code>gitcvs.allBinary</code>已设置，则未指定的文件将默认为<code>-kb</code>模式。否则，该<code>-k</code>模式留空。但是如果<code>gitcvs.allBinary</code>设置为“猜测”，则<code>-k</code>根据文件的内容猜测正确的模式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为了达到最佳一致性<code>cvs</code>，最好通过设置<code>gitcvs.usecrlfattr</code>为 true 来覆盖默认值，<code>gitcvs.allBinary</code>“猜测”。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2><strong>Dependencies</strong></h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git-cvsserver</code> 依赖于 DBD :: SQLite 。</p></div></div></div>