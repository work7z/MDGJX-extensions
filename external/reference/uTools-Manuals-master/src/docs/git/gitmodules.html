<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><p><strong>名称</strong></p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitmodules  - 定义子模块属性</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>$GIT_WORK_DIR/.gitmodules</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>.gitmodules</code>文件位于 Git 工作树的顶层目录中，是一个文本文件，其语法与 git-config [1] 的要求相匹配。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>文件包含每个子模块的一个子部分，并且子部分值是子模块的名称。名称被设置为子模块已被添加的路径，除非它是用<code>--name</code>选项自定义的<code>git submodule add</code>。每个子模块部分还包含以下必需的键：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.path</p></div></div><div class="doc-postil"><div class="c-markdown"><p>定义相对于 Git 工作树的顶级目录的路径，其中子模块预计将签出。路径名称不能以<code>/</code>。所有子模块路径在 .gitmodules 文件中必须是唯一的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.url</p></div></div><div class="doc-postil"><div class="c-markdown"><p>定义可从中克隆子模块存储库的URL。这可能是一个准备好传递给 git-clone [1] 或者（如果它以./或../开头）相对于超级项目的源存储库的位置的绝对 URL。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>另外，还有一些可选的键：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.update</p></div></div><div class="doc-postil"><div class="c-markdown"><p>定义指定子模块的默认更新过程，即通过超级项目中的 “git submodule update” 命令更新子模块的方式。这仅用于<code>git submodule init</code>初始化相同名称的配置变量。这里允许的值是<code>checkout</code>，<code>rebase</code>，<code>merge</code>或<code>none</code>。有关<code>update</code>它们的含义，请参阅 git-submodule [1] 中的命令说明。请注意，<code>!command</code>出于安全原因，表单在此处被故意忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.branch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用于跟踪上游子模块中更新的远程分支名称。如果该选项未指定，则默认为<code>master</code>。特殊值<code>.</code>用于指示子模块中分支的名称应与当前存储库中当前分支的名称相同。有关<code>--remote</code>详细信息，请参阅
 git-submodule [1] 中的文档。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.fetchRecurseSubmodules</p></div></div><div class="doc-postil"><div class="c-markdown"><p>选项可用于控制此子模块的递归提取。如果此选项也存在于超级项目的 .git / config 子模块条目中，那么该设置将覆盖. gitmodules 中的设置。通过在 “git fetch” 和 “git pull” 中使用 “--no-recurse-submodules” 选项，可以在命令行上覆盖这两个设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.ignore</p></div></div><div class="doc-postil"><div class="c-markdown"><p>定义在什么情况下，“git status” 和 diff 系列显示已修改的子模块。支持以下值：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>子模块永远不会被视为已修改（但仍会显示在状态的输出中，并在已上载时进行提交）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>dirty</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对子模块工作树的所有更改都将被忽略，只会考虑子模块的 HEAD 与其在超级项目中记录的状态之间的差异。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>untracked</p></div></div><div class="doc-postil"><div class="c-markdown"><p>子模块中只有未跟踪的文件将被忽略。承诺的差异和修改被跟踪的文件将显示出来。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>none</p></div></div><div class="doc-postil"><div class="c-markdown"><p>没有对子模块的修改被忽略，所有提交的差异以及对跟踪和未跟踪文件的修改都会显示出来。这是默认选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">If this option is also present in the submodules entry in .git/configof the superproject, the setting there will override the one found in.gitmodules.Both settings can be overridden on the command line by using the"--ignore-submodule" option. The 'git submodule' commands are not
affected by this setting.</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.shallow</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置为 true 时，此子模块的克隆将作为浅层克隆（历史深度为1）执行，除非用户明确要求使用非浅层克隆。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>考虑下面的 .gitmodules 文件：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[submodule "libfoo"]
        path = include/foo
        url = git://foo.com/git/lib.git</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[submodule "libbar"]
        path = include/bar
        url = git://bar.com/git/lib.git</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这定义了两个子模块，<code>libfoo</code>和<code>libbar</code>。这些预计的路径要被检出的<code>include/foo</code>和<code>include/bar</code>，并为两个子模块被指定一个URL可以用于克隆子模块。</p></div></div></div>