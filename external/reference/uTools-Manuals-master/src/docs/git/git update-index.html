<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名字</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-update-index  - 将工作树中的文件内容注册到索引</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git update-index             [--add] [--remove | --force-remove] [--replace]             [--refresh] [-q] [--unmerged] [--ignore-missing]             [(--cacheinfo &lt;mode&gt;,&lt;object&gt;,&lt;file&gt;)…]             [--chmod=(+|-)x]             [--[no-]assume-unchanged]             [--[no-]skip-worktree]             [--ignore-submodules]             [--[no-]split-index]             [--[no-|test-|force-]untracked-cache]             [--really-refresh] [--unresolve] [--again | -g]             [--info-only] [--index-info]             [-z] [--stdin] [--index-version &lt;n&gt;]             [--verbose]             [--] [&lt;file&gt;…]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>修改索引或目录缓存。提到的每个文件都更新到索引中，并清除任何<code>unmerged</code>或<code>needs updating</code>状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>另请参阅 git-add [1] ，以更友好的方式对索引执行一些最常见的操作。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git update-index</code>处理文件的方式可以使用各种选项进行修改：</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>--add</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果指定的文件不在索引中，则会添加它。默认行为是忽略新文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--remove</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果指定的文件在索引中但缺失，则将其删除。默认行为是忽略已删除的文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--refresh</p></div></div><div class="doc-postil"><div class="c-markdown"><p>查看当前索引，并通过检查 stat（）信息来检查是否需要合并或更新。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-q</p></div></div><div class="doc-postil"><div class="c-markdown"><p>quiet。如果--refresh发现索引需要更新，则默认行为是错误的。<code>git update-index</code>无论如何，这个选项会继续。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ignore-submodules</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要尝试更新子模块。此选项仅在通过 --refresh 之前通过。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--unmerged</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果 --refresh 在索引中发现未合并的更改，则默认行为是错误的。<code>git update-index</code>无论如何，这个选项会继续。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ignore-missing</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在 --refresh 时忽略丢失的文件</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--cacheinfo &lt;mode&gt;,&lt;object&gt;,&lt;path&gt;   --cacheinfo &lt;mode&gt; &lt;object&gt; &lt;path&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>直接将指定的信息插入索引。为了向后兼容，您还可以将这三个参数作为三个单独的参数，但鼓励新用户使用单参数表单。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--index-info</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从标准输入读取索引信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--chmod=(+|-)x</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置更新文件的执行权限。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-assume-unchanged</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当指定此标志时，为路径记录的对象名称不会更新。相反，该选项设置/取消路径的“假定不变”位。当“假设不变”位打开时，用户承诺不更改文件，并允许 Git 假定工作树文件与索引中记录的内容匹配。如果你想改变工作树文件，你需要取消设置该位以告诉 Git 。当在一个非常缓慢的 lstat（2）系统调用的文件系统（例如 cifs ）上处理大项目时，这有时会很有帮助。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果需要在索引中修改此文件，例如合并提交时，Git 将失败（正常）因此，如果假设未跟踪的文件在上游发生更改，则需要手动处理该情况。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--really-refresh</p></div></div><div class="doc-postil"><div class="c-markdown"><p>喜欢<code>--refresh</code>，但无条件地检查统计信息，而不考虑“假定不变”设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-skip-worktree</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当指定其中一个标志时，为路径记录的对象名称不会更新。相反，这些选项设置和取消设置路径的 “skip-worktree” 位。有关更多信息，请参见下面的 “Skip-worktree bit” 部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-g   --again</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git update-index</code>在索引条目与<code>HEAD</code>提交不同的路径上运行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--unresolve</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果文件被意外清除，则在合并期间恢复文件<code>unmerged</code>或<code>needs updating</code>状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--info-only</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要在对象数据库中为所有跟随此标志的 &lt;file&gt; 参数创建对象; 只需将他们的对象 ID 插入索引。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--force-remove</p></div></div><div class="doc-postil"><div class="c-markdown"><p>即使工作目录仍然有这样的文件，也可以从索引中删除文件。（暗示 --remove。）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--replace</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，当<code>path</code>索引中存在文件时，<code>git update-index</code>拒绝尝试添加<code>path/file</code>。同样，如果文件<code>path/file</code>存在，<code>path</code>则不能添加文件。使用 --replace 标志，与添加的条目发生冲突的现有条目将自动删除警告消息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--stdin</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要从命令行获取路径列表，请从标准输入读取路径列表。路径由 LF 分隔（即每行一个路径）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--verbose</p></div></div><div class="doc-postil"><div class="c-markdown"><p>报告索引中正在添加和删除的内容。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--index-version &lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将结果索引写入指定的磁盘格式版本中。支持的版本是2,3和4.当前的默认版本是2或3，取决于是否使用了额外的功能，例如<code>git add -N</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>版本4执行简单的路径名压缩，可减少大型存储库中的索引大小30％-50％，从而缩短加载时间。版本4相对年轻（2012年10月首次发布于1.8.0）。其他 Git 实现，如 JGit 和 libgit2 可能还不支持它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-z</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只对<code>--stdin</code>或有意义<code>--index-info</code>; 路径用 NUL 字符而不是 LF 分隔。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--split-index   --no-split-index</p></div></div><div class="doc-postil"><div class="c-markdown"><p>启用或禁用拆分索引模式。如果分割索引模式已经启用并<code>--split-index</code>再次提供，则 $ GIT_DIR / index 中的所有更改将被推回到共享索引文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项会随<code>core.splitIndex</code>配置变量的值生效（请参阅 git-config [1] ）。但是当更改与配置的值相反时会发出警告，因为配置的值将在下次读取索引时生效，并且这将消除该选项的预期效果。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--untracked-cache   --no-untracked-cache</p></div></div><div class="doc-postil"><div class="c-markdown"><p>启用或禁用未跟踪的缓存功能。<code>--test-untracked-cache</code>启用之前请使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项会随<code>core.untrackedCache</code>配置变量的值生效（请参阅 git-config [1] ）。但是当更改与配置的值相反时会发出警告，因为配置的值将在下次读取索引时生效，并且这将消除该选项的预期效果。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--test-untracked-cache</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只对工作目录执行测试以确保可以使用未跟踪的缓存。如果你真的想使用它，你必须使用<code>--untracked-cache</code>或者之后<code>--force-untracked-cache</code>的<code>core.untrackedCache</code>配置变量手动启用未跟踪的缓存。如果测试失败，退出代码为1，并显示一条消息说明哪些功能无法正常工作，否则退出代码为0并打印 OK 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--force-untracked-cache</p></div></div><div class="doc-postil"><div class="c-markdown"><p>和...一样<code>--untracked-cache</code>。提供与在旧版本的 Git 的向后兼容性<code>--untracked-cache</code>用来暗示<code>--test-untracked-cache</code>，但此选项将无条件地启用该扩展。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要将更多的参数解释为选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要采取行动的文件。请注意，开头的文件将<code>.</code>被丢弃。这包括<code>./file</code>和<code>dir/./file</code>。如果你不想要这个，那么使用更清晰的名字。这同样适用于目录结尾<code>/</code>和路径<code>//</code></p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Using --refresh</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--refresh</code>不会计算新的 sha1 文件或将索引更新为模式/内容更改。但它<strong>确实</strong>做的是“重赛”与索引文件的统计信息，这样就可以刷新指数尚未修改的文件，但在统计项是过时的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，你想在做完之后这样做<code>git read-tree</code>，将 stat 索引详细信息与正确的文件关联起来。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Using --cacheinfo or --info-only</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--cacheinfo</code>用于注册不在当前工作目录中的文件。这对于最小检出合并很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设你有一个路径为 mode 和 sha1 的文件，说：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git update-index --cacheinfo &lt;mode&gt;,&lt;sha1&gt;,&lt;path&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--info-only</code>用于注册文件而不将其放置在对象数据库中。这对于仅状态存储库很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这两个<code>--cacheinfo</code>和<code>--info-only</code>的行为类似：该指数已经更新，但对象数据库是没有的。<code>--cacheinfo</code>对象位于数据库中但文件不在本地可用时非常有用。<code>--info-only</code>文件可用时非常有用，但不希望更新对象数据库。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Using --index-info</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--index-info</code>是一种更强大的机制，可让您从标准输入中提供多个条目定义，并专门为脚本设计。它可以采用三种格式的输入：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>模式SP sha1 TAB 路径第一种格式是“git-apply --index-info”报告的内容，并且用于在3路合并时重建用于伪合并基础树的部分树。</p></li><li><p>模式 SP 类型 SP sha1 TAB 路径第二种格式是将<code>git ls-tree</code>输出填充到索引文件中。</p></li><li><p>模式 SP sha1 SP 阶段 TAB 路径此格式用于将更高阶段放入索引文件并匹配<code>git ls-files --stage</code>输出。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>要将更高级的条目放置到索引中，首先应通过为路径输入 mode = 0 条目来删除路径，然后以第三种格式提供必要的输入行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，从这个索引开始：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git ls-files -s100644 8a1218a1024a212bb3db30becd860315f9f3ac52 0       frotz</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以将以下输入提供给<code>--index-info</code>：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git update-index --index-info0 0000000000000000000000000000000000000000        frotz100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1        frotz100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2        frotz</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>输入的第一行提供0作为删除路径的模式; 只要格式良好，SHA-1 无关紧要。然后第二行和第三行输入该路径的阶段1和阶段2条目。在上述之后，我们最终得出这个结论：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git ls-files -s100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1        frotz100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2        frotz</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>使用“假定不变”位</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 中的许多操作都依赖于您的文件系统来<code>lstat(2)</code>实现高效的实现，因此<code>st_mtime</code>可以便宜地检查工作树文件的信息，以查看文件内容是否已从记录在索引文件中的版本发生更改。不幸的是，一些文件系统效率不高<code>lstat(2)</code>。如果你的文件系统是其中的一个，你可以将“假设不变”位设置为你没有改变的路径，以便 Git 不要这样检查。请注意，在路径上设置此位并不意味着Git 会检查文件的内容以查看它是否已更改 - 它使 Git 忽略任何检查并假定它<strong>未</strong>更改。当你修改工作树文件时，你必须在修改它们之前或之后，通过删除“假定不变”位来明确告诉 Git 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为了设置“不变”位，使用<code>--assume-unchanged</code>选项。要取消设置，请使用<code>--no-assume-unchanged</code>。要查看哪些文件具有“假定不变”位，请使用<code>git ls-files -v</code>（请参阅 git-ls-files [1] ）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令查看<code>core.ignorestat</code>配置变量。如果这是真的，路径与更新<code>git update-index paths...</code>，并与其他 Git 的更新路径命令，同时更新索引和工作树（例如<code>git apply --index</code>，<code>git checkout-index -u</code>和<code>git read-tree -u</code>）被自动标记为“假设不变”。请注意，如果找到工作树文件与索引匹配（假如您想将它们标记为“假定不变”），则“假设不变”位<strong>未</strong>设置。<code>git update-index --refreshgit update-index --really-refresh</code></p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>To update and refresh only the files already checked out:</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git checkout-index -n -f -a &amp;&amp; git update-index --ignore-missing --refresh</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在与低效的文件系统<code>core.ignorestat</code>设置</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git update-index --really-refresh              (1)$ git update-index --no-assume-unchanged foo.c   (2)$ git diff --name-only                           (3)$ edit foo.c
$ git diff --name-only                           (4)M foo.c
$ git update-index foo.c                         (5)$ git diff --name-only                           (6)$ edit foo.c
$ git diff --name-only                           (7)$ git update-index --no-assume-unchanged foo.c   (8)$ git diff --name-only                           (9)M foo.c</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>强制 lstat（2）为匹配索引的路径设置“不变”位。</p></li><li><p>标记要编辑的路径。</p></li><li><p>这会执行 lstat（2）并查找与路径匹配的索引。</p></li><li><p>这会执行 lstat（2）并发现索引与路径<strong>不</strong>匹配。</p></li><li><p>注册新版本以索引集“假定不变”位。</p></li><li><p>并假定它不变。</p></li><li><p>即使在你编辑它之后。</p></li><li><p>你可以在事后了解这个变化。</p></li><li><p>现在它检查 lstat（2）并发现它已被更改。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><h2>跳过工作树位</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>Skip-worktree 位可以在一个（长）句子中定义：当读取一个条目时，如果它被标记为 skip-worktree ，那么 Git 会假装它的工作目录版本是最新的并且读取索引版本。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>详细说来，“reading” 是指检查文件是否存在，读取文件属性或文件内容。工作目录版本可能存在或不存在。如果存在，其内容可能与索引版本匹配。写作不受此位影响，内容安全仍然是第一要务。请注意，Git <code>can</code>更新工作目录文件，即标记为 skip-worktree ，如果这样做是安全的（即工作目录版本与索引版本匹配）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>虽然这个位看起来与假定不变的位相似，但它的目标不同于假设 - 未改变的位。当两者都设置时，跳过工作树也优先于假定 - 不变的位。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>分割索引</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>此模式专为具有非常大的索引的存储库而设计，旨在减少重复写入这些索引所需的时间。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在这种模式下，索引被分成两个文件，$ GIT_DIR / index 和 $ GIT_DIR / sharedindex。&lt;SHA-1&gt; 。在 $ GIT_DIR / index（分割索引）中累计更改，而共享索引文件包含所有索引条目并保持不变。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当分割索引中的条目数达到由 splitIndex.maxPercentChange 配置变量（请参阅 git-config [1] ）指定的水平时，分割索引中的所有更改将被推回到共享索引文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>每次创建新的共享索引文件时，如果旧共享索引文件的修改时间比 splitIndex.sharedIndexExpire 配置变量（请参阅 git-config [1] ）指定的修改时间早，则会删除旧共享索引文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为避免删除仍在使用的共享索引文件，每次创建或读取基于共享索引文件的新拆分索引时，都会将其修改时间更新为当前时间。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>未追踪缓存</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>该缓存旨在加速涉及确定未跟踪文件的命令，如<code>git status</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该功能通过记录正在工作的树目录的 mtime，然后省略读取目录和统计调用来针对 mtime 未更改的目录中的文件。为此<code>st_mtime</code>，如果目录中的文件被添加，修改或删除，底层操作系统和文件系统必须更改目录字段。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以测试文件系统是否支持该<code>--test-untracked-cache</code>选项。<code>--untracked-cache</code>用于在 Git 的旧版本中隐式执行该测试的选项，但不再是这种情况。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果要启用（或禁用）此功能，使用<code>core.untrackedCache</code>配置变量（请参阅 git-config [1] ）比在每个存储库中使用<code>--untracked-cache</code>选项更容易<code>git update-index</code>，尤其是如果您希望跨所有存储库使用此配置变量，因为您可以将配置变量设置为<code>true</code>（或<code>false</code>）<code>$HOME/.gitconfig</code>一次，并使其影响您所触摸的所有存储库。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>core.untrackedCache</code>配置变量发生变化时，在下一次命令读取索引时，未追踪的缓存将添加到索引中或从索引中删除; 而在<code>--[no-|force-]untracked-cache</code>使用时，未跟踪的缓存立即添加到索引或从索引中删除。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>组态</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令授予<code>core.filemode</code>配置变量。如果您的存储库位于可执行位不可靠的文件系统上，则应将其设置为<code>false</code>（请参阅 git-config [1]）。这会导致该命令忽略文件系统中索引和文件模式中记录的文件模式差异，如果它们仅在可执行位上不同。在这样一个不幸的文件系统上，你可能需要使用<code>git update-index --chmod=</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>非常相似，如果<code>core.symlinks</code>配置变量设置为<code>false</code>（参见 git-config [1]），符号链接将作为纯文件检出，并且此命令不会修改从符号链接到常规文件的记录文件模式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令查看<code>core.ignorestat</code>配置变量。参见<code>Using "assume unchanged" bit</code>上面的部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令还查看<code>core.trustctime</code>配置变量。当 inode 更改时间通过 Git 外部的某些东西（文件系统搜寻器和备份系统使用 ctime 标记处理的文件）定期修改时（参见 git-config [1] ），它会很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>未跟踪的缓存扩展可以通过<code>core.untrackedCache</code>配置变量启用（请参阅 git-config [1] ）。</p></div></div></div>