<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>gitrevisions  - 指定 Git 的修订和范围</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>gitrevisions</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>许多 Git 命令都将修订参数作为参数。根据命令的不同，它们表示特定的提交，或者对于遍历修订图形的命令（例如 git-log [1]），可以提交可访问的所有提交。对于遍历修订图的命令，还可以明确指定一系列修订。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>另外，一些 Git 命令（例如 git-show [1]）也会使用修改参数来表示其他对象而不是提交，例如 blob （“文件”）或树（“文件目录”）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>指定修订</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>修订参数<code>&lt;rev&gt;</code>通常（但不一定）命名提交对象。它使用所谓的<code>extended SHA-1</code>语法。以下是拼写对象名称的各种方法。列表附近列出的名称包含在提交中的树和 blob 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;sha1&gt;</em>, e.g. <em style="font-style: italic;">dae86e1950b1277e545cee180551750029cfe735</em>, <em style="font-style: italic;">dae86e</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>完整的 SHA-1 对象名称（40字节的十六进制字符串）或存储库中唯一的前导子字符串。例如，
 dae86e1950b1277e545cee180551750029cfe735 和 dae86e 都会命名相同的提交对象，前提是存储库中没有其他对象，并且其对象名称以 dae86e 开头。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;describeOutput&gt;</em>, e.g. <em style="font-style: italic;">v1.7.4.2-679-g3bee7fb</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>输出来自<code>git describe</code>; 即最接近的标记，可选地后跟破折号和多个提交，后跟短划线， <code>g</code>和缩写对象名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;refname&gt;</em>, e.g. <em style="font-style: italic;">master</em>, <em style="font-style: italic;">heads/master</em>, <em style="font-style: italic;">refs/heads/master</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>符号参考名称。例如，<code>master</code>通常意味着由引用的提交对象<code>refs/heads/master</code>。如果你碰巧有两个<code>heads/master</code>和<code>tags/master</code>，你可以明确地说<code>heads/master</code>要告诉Git的你的意思是哪一个。当模棱两可时，<code>&lt;refname&gt;</code>通过在以下规则中进行第一次匹配来消除：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>如果<code>$GIT_DIR/&lt;refname&gt;</code>存在，那就是你的意思（这通常只有为<code>HEAD</code>，<code>FETCH_HEAD</code>，<code>ORIG_HEAD</code>，<code>MERGE_HEAD</code>和<code>CHERRY_PICK_HEAD</code>是有用的）;</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>2. 否则，如果存在<code>refs/&lt;refname&gt;</code>;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>3. 否则，如果存在<code>refs/tags/&lt;refname&gt;</code>;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>4. 否则，如果存在<code>refs/heads/&lt;refname&gt;</code>;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>5. 否则，如果存在<code>refs/remotes/&lt;refname&gt;</code>;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>6. 否则，如果存在<code>refs/remotes/&lt;refname&gt;/HEAD</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>HEAD</code>命名您在工作树中基于更改的提交。<code>FETCH_HEAD</code>记录您在上次<code>git fetch</code>调用时从远程存储库中获取的分支。<code>ORIG_HEAD</code>是通过命令创建的，这些命令<code>HEAD</code>以激烈的方式移动您的行为，记录<code>HEAD</code>它们在操作之前的位置，以便您可以轻松地将分支的顶端更改回到运行之前的状态。<code>MERGE_HEAD</code>记录您在运行时正在合并到您的分支中的提交<code>git merge</code>。<code>CHERRY_PICK_HEAD</code>记录您在运行时正在挑选的提交<code>git cherry-pick</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，<code>refs/*</code>上述任何情况都可能来自<code>$GIT_DIR/refs</code>目录或<code>$GIT_DIR/packed-refs</code>文件。尽管未指定 ref 名称编码，但首选 UTF-8，因为某些输出处理可能采用 UTF-8 中的 ref 名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">@</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>单独<code>@</code>是一个<code>HEAD</code>的捷径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;refname&gt;@{&lt;date&gt;}</em>, e.g. <em style="font-style: italic;">master@{yesterday}</em>, <em style="font-style: italic;">HEAD@{5 minutes ago}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后面跟着<code>@</code>带括号中的后缀（例如<code>{yesterday}</code>，<code>{1 month 2 weeks 3 days 1 hour 1 second ago}</code>或<code>{1979-02-26 18:30:00}</code>）的后缀指定前一个时间点的 ref 的值。后缀只能在 ref 名称后面使用，并且 ref 必须具有现有的日志（<code>$GIT_DIR/logs/&lt;ref&gt;</code>）。请注意，这会在给定的时间查看<strong>当地</strong>裁判的状态; 例如<code>master</code>上周您当地的分支机构。如果您想查看某些时间内提交的内容，请参阅<code>--since</code>和<code>--until</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;refname&gt;@{&lt;n&gt;}</em>, e.g. <em style="font-style: italic;">master@{1}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后缀为<code>@</code>带括号的后缀（例如<code>{1}</code>，<code>{15}</code>）指定了 ref 的第n个前置值。例如<code>master@{1}</code>，<code>master</code>while <code>master@{5}</code>是第5个先前值的即时先验值<code>master</code>。该后缀只能在 ref 名称后面使用，并且 ref 必须具有现有的日志（<code>$GIT_DIR/logs/&lt;refname&gt;</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">@{&lt;n&gt;}</em>, e.g. <em style="font-style: italic;">@{1}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以使用带有<code>@</code>空引用部分的构造来获取当前分支的 reflog 条目。例如，如果您在分支上，<code>blabla</code>则<code>@{1}</code>意味着与之相同<code>blabla@{1}</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">@{-&lt;n&gt;}</em>, e.g. <em style="font-style: italic;">@{-1}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>构造<code>@{-&lt;n&gt;}</code>意味着在当前之前检出的第n个分支/提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;branchname&gt;@{upstream}</em>, e.g. <em style="font-style: italic;">master@{upstream}</em>, <em style="font-style: italic;">@{u}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>@{upstream} </code>branchname （简称<code>&lt;branchname&gt;@{u}</code>）的后缀是指由 branchname 指定的分支设置为在（使用<code>branch.&lt;name&gt;.remote</code>和<code>branch.&lt;name&gt;.merge</code>）配置的基础上构建的分支。缺少的 branchname 默认为当前的。当用大写拼写时，这些后缀也是可接受的，无论大小写是什么，它们都表示相同的事物。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;branchname&gt;@{push}</em>, e.g. <em style="font-style: italic;">master@{push}</em>, <em style="font-style: italic;">@{push}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果在检出<code>@{push}</code>时<code>git push</code>运行<code>branchname</code>（或当前<code>HEAD</code>没有指定branchname），后缀将报告分支 “where we would push to” 。由于我们的推送目标位于远程存储库中，当然，我们会报告与该分支对应的本地跟踪分支（即，某处<code>refs/remotes/</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这里有一个例子可以使它更加清晰：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git config push.default current
$ git config remote.pushdefault myfork
$ git checkout -b mybranch origin/master

$ git rev-parse --symbolic-full-name @{upstream}refs/remotes/origin/master

$ git rev-parse --symbolic-full-name @{push}refs/remotes/myfork/mybranch</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在示例中请注意，我们建立了一个三角形工作流程，我们从一个位置拉出并推送到另一个位置。在非三角形工作流程中，<code>@{upstream}</code>与<code>@{push}</code>相同，这里不需要它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当拼写成大写字母时，这个后缀也是可以接受的，无论大小写意思都是相同的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^</em>, e.g. <em style="font-style: italic;">HEAD^, v1.5.1^0</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>修订参数的后缀<code>^</code>表示提交对象的第一个父代。<code>^&lt;n&gt;</code>意味着第n个父母（即<code>&lt;rev&gt;^</code>相当于<code>&lt;rev&gt;^1</code>）。作为一个特殊规则，<code>&lt;rev&gt;^0</code>意味着提交本身，并在<code>&lt;rev&gt;</code>引用提交对象的标记对象的对象名称时使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;~&lt;n&gt;</em>, e.g. <em style="font-style: italic;">master~3</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>修订参数的后缀<code>~&lt;n&gt;</code>表示作为指定提交对象的第n代父类的提交对象，仅在第一个父代之后。即<code>&lt;rev&gt;~3</code>相当于<code>&lt;rev&gt;^^^，</code>同样相当于<code>&lt;rev&gt;^1^1^1</code>。请参阅下面的表格来说明此表格的用法。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^{&lt;type&gt;}</em>, e.g. <em style="font-style: italic;">v0.99.8^{commit}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后缀<code>^</code>跟在括号内的对象类型名称意味着以<code>&lt;rev&gt;</code>递归方式解引用对象，直到<code>&lt;type&gt;</code>找到类型的对象或者对象不能被解除引用（在这种情况下，barf）。例如，如果<code>&lt;rev&gt;</code>是 commit-ish，则<code>&lt;rev&gt;^{commit}</code>描述相应的提交对象。同样，如果<code>&lt;rev&gt;</code>是树形，则<code>&lt;rev&gt;^{tree}</code>描述相应的树形对象。<code>&lt;rev&gt;^0</code>是短暂的<code>&lt;rev&gt;^{commit}</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>rev^{object}</code>可以用来确定<code>rev</code>存在的对象的名称，而不需要<code>rev</code>作为标签，也不需要解引用<code>rev</code>; 因为一个标签已经是一个对象，所以即使一次到达一个对象也不需要解除引用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>rev^{tag}</code>可以用来确保<code>rev</code>识别现有的标签对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^{}</em>, e.g. <em style="font-style: italic;">v0.99.8^{}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后缀<code>^</code>跟一个空括号对意味着对象可以是一个标记，并递归地引用该标记，直到找到一个非标记对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^{/&lt;text&gt;}</em>, e.g. <em style="font-style: italic;">HEAD^{/fix nasty bug}</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后缀<code>^</code>的修正参数，其次，它包含用斜线为首的文本的一对括号，是一样的<code>:/fix nasty bug</code>下面的语法不同之处在于它返回最年轻的匹配提交其是从<code>^</code>可到达<code>&lt;rev&gt;</code>之前。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">:/&lt;text&gt;</em>, e.g. <em style="font-style: italic;">:/fix nasty bug</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个冒号，跟一个斜线，后跟一个文本，命名提交消息与指定正则表达式匹配的提交。名称返回可从任何ref访问的最新匹配提交。正则表达式可以匹配提交消息的任何部分。要匹配以字符串开头的消息，可以使用例如<code>:/^foo</code>。特殊序列<code>:/!</code>保留给修饰符以匹配内容。<code>:/!-foo</code>执行否定匹配，同时<code>:/!!foo</code>匹配文字<code>!</code>字符，然后匹配<code>foo</code>。任何以其他序列开始的序列<code>:/!</code>现在都被保留。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;:&lt;path&gt;</em>, e.g. <em style="font-style: italic;">HEAD:README</em>, <em style="font-style: italic;">:README</em>, <em style="font-style: italic;">master:./README</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后缀<code>:</code>后面跟着一个路径的名称是由冒号前部分命名的 tree-ish 对象中给定路径上的 blob 树。<code>:path</code>（在冒号前有一个空白部分）是下面描述的语法的特例：记录在给定路径索引处的内容。以当前工作目录开始<code>./</code>或<code>../</code>相对于当前工作目录的路径。给定的路径将被转换为相对于工作树的根目录。这对于从具有与工作树相同树结构的提交或树来处理 blob 树是非常有用的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">:&lt;n&gt;:&lt;path&gt;</em>, e.g. <em style="font-style: italic;">:0:README</em>, <em style="font-style: italic;">:README</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个冒号，后跟一个阶段号（0到3）和一个冒号，后跟一个路径，在给定路径的索引中命名一个 blob 
 对象。缺少的阶段编号（以及后面的冒号）命名为0阶段编号。在合并期间，阶段1是共同的父类，阶段2是目标分支的版本（通常是当前分支），阶段3是来自正在合并的分支的版本。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以下是 Jon Loeliger 的插图。提交节点 B 和 C 都是提交节点 A 的父节点。父代提交按从左到右的顺序排列。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">G   H   I   J
 \ /    \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">A =      = A^0
B = A^   = A^1     = A~1
C = A^2  = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2
F = B^3  = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2  = B^^2    = A^^^2  = A~2^2
I = F^   = B^3^    = A^^3^
J = F^2  = B^3^2   = A^^3^2</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>指定范围</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>历史遍历命令，例如<code>git log</code>对一组提交进行操作，而不仅仅是一次提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于这些命令，使用上一节中描述的符号来指定单个修订，意味着<code>reachable</code>来自给定提交的一组提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提交的可达集是提交本身和祖先链中的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>提交排除项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">^&lt;rev&gt;</em> (caret) Notation</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要排除提交可达的提交，使用前缀<code>^</code>符号。例如，<code>^r1 r2</code>意味着提交可达，<code>r2</code>但不包括从<code>r1</code>（即<code>r1</code>其祖先）可达的。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>虚线表示法</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>（双点）范围标识</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>^r1 r2</code>组操作似乎经常有它的简写。当你有两个提交<code>r1</code>并且<code>r2</code>（根据上面指定版本中所述的语法命名）时，你可以要求提交从r2到达的提交，但不包括那些从r1可到达的提交，<code>^r1 r2</code>它可以写为<code>r1..r2</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>（三点）对称差符号</p></div></div><div class="doc-postil"><div class="c-markdown"><p>类似的符号<code>r1...r2</code>被称为和的对称差，<code>r1</code>被<code>r2</code>定义为<code>r1 r2 --not $(git merge-base --all r1 r2)</code>。它是从<code>r1</code>（左侧）或<code>r2</code>（右侧）中的任一个可达的提交集合，但不是来自两者。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在这两个简写符号中，可以省略一端，并将其默认为 HEAD 。例如，<code>origin..</code>是一个简写，<code>origin..HEAD</code>并问“自从我从原始分支分出后，我做了什么？” 同样，它<code>..origin</code>也是一种速记，<code>HEAD..origin</code>并问道：“我从他们身上分离出来后，起源究竟发生了什么？” 请注意，<code>..</code>这意味着<code>HEAD..HEAD</code>空白区域可以从 HEAD 到达和无法到达。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>Other &lt;rev&gt;^ Parent Shorthand Notations</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>还有三个其他的shorthands，对于合并提交，对于由提交和它的父代提交形成的集合进行命名特别有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>r1^@</code>符号表示的所有父代<code>r1</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>r1^!</code>表示包括提交<code>r1</code>但排除其所有父代。这个符号本身表示单个提交<code>r1</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>&lt;rev&gt;^-&lt;n&gt;</code>符号包括<code>&lt;rev&gt;</code>但不包括&lt;N&gt;个亲本（即，简写<code>&lt;rev&gt;^&lt;n&gt;..&lt;rev&gt;</code>），其中<code>&lt;n&gt;</code>= 1，如果没有给出。这对合并提交通常很有用，您可以通过合并提交<code>&lt;commit&gt;^-</code>来获取合并提交中合并的分支中的所有提交<code>&lt;commit&gt;</code>（包括<code>&lt;commit&gt;</code>它自己）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>虽然<code>&lt;rev&gt;^&lt;n&gt;</code>是关于指定一个单一的承诺父母，这三种表示法也考虑其父母。例如，你可以说<code>HEAD^2^@</code>，但是你不能说<code>HEAD^@^2</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>修订范围摘要</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含从&lt;rev&gt;（即&lt;rev&gt;及其祖先）访问的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">^&lt;rev&gt;</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>排除从&lt;rev&gt;（即&lt;rev&gt;及其祖先）访问的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev1&gt;..&lt;rev2&gt;</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含从&lt;rev2&gt;访问的提交，但不包括从&lt;rev1&gt;访问的提交。当&lt;rev1&gt;或&lt;rev2&gt;被省略时，它默认为<code>HEAD</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev1&gt;...&lt;rev2&gt;</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含从&lt;rev1&gt;或&lt;rev2&gt;访问的提交，但排除可从两者访问的提交。当&lt;rev1&gt;或&lt;rev2&gt;被省略时，它默认为<code>HEAD</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^@</em>, e.g. <em style="font-style: italic;">HEAD^@</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后缀<code>^</code>后跟一个符号与列出所有父母的<code>&lt;rev&gt;</code>意思相同（意思是，包括任何可从其父母获得的东西，但不包括承诺本身）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^!</em>, e.g. <em style="font-style: italic;">HEAD^!</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>后缀<code>^</code>后跟一个感叹号的方式与提交相同<code>&lt;rev&gt;</code>，然后它的所有父母前缀<code>^</code>以排除它们（和它们的祖先）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><em style="font-style: italic;">&lt;rev&gt;^-&lt;n&gt;</em>, e.g. <em style="font-style: italic;">HEAD^-, HEAD^-2</em></p></div></div><div class="doc-postil"><div class="c-markdown"><p>相当于<code>&lt;rev&gt;^&lt;n&gt;..&lt;rev&gt;</code>，<code>&lt;n&gt;</code>如果没有给出，则= 1。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这里有一些使用上面的 Loeliger 插图的例子，仔细地说明了符号的扩展和选择中的每一步：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">Args   Expanded arguments    Selected commits
D                            G H D
D F                          G H I J D F^G D                         H D^D B                         E I J F B^D B C                       E I J F B C
C                            I J F C
B..C   = ^B C                C
B...C  = B ^F C              G H D E B C
B^-    = B^..B= ^B^1 B              E I J F B
C^@    = C^1= F                   I J F
B^@    = B^1 B^2 B^3= D E F               D G H E F I J
C^!    = C ^C^@= C ^C^1= C ^F                C
B^!    = B ^B^@= B ^B^1 ^B^2 ^B^3= B ^D ^E ^F          B
F^! D  = F ^I ^J D           G H D F</code></pre></div></div></div>