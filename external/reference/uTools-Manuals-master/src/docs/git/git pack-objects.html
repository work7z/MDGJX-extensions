<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称（Name）</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-pack-objects  - 创建一个打包的对象存档</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git pack-objects [-q | --progress | --all-progress] [--all-progress-implied]        [--no-reuse-delta] [--delta-base-offset] [--non-empty]        [--local] [--incremental] [--window=&lt;n&gt;] [--depth=&lt;n&gt;]        [--revs [--unpacked | --all]] [--stdout | base-name]        [--shallow] [--keep-true-parents] &lt; object-list</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>从标准输入读取对象列表，并将具有指定基本名称的一个或多个打包归档文件写入磁盘，或将打包归档文件写入标准输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打包归档是在两个存储库之间传输一组对象以及访问高效的归档格式的有效方式。在打包的压缩文件中，一个对象或者以压缩整体存储，或者与其他对象不同。后者通常被称为三角洲。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>压缩存档格式（.pack）被设计为独立的，因此可以在没有任何进一步信息的情况下将其解压缩。因此，三角洲依赖的每个对象必须出现在包中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>生成一个包索引文件（.idx），以便快速，随机地访问包中的对象。将索引文件（.idx）和打包归档文件（.pack）放在$ GIT_OBJECT_DIRECTORY（或$ GIT_ALTERNATE_OBJECT_DIRECTORIES 上的任何目录）的 pack /子目录中，可以使 Git 从包归档中读取。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git unpack-objects</code>命令可以读取打包的归档文件，并将包中包含的对象展开为“一个文件一个对象”格式; 这通常是通过智能拉取命令完成的，当一个组件被即时创建以便其同伴进行有效的网络传输时。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>base-name</p></div></div><div class="doc-postil"><div class="c-markdown"><p>写入成对的文件（.pack 和 .idx），使用&lt;base-name&gt;确定创建的文件的名称。使用此选项时，一对中的两个文件将写入&lt;base-name&gt;  -  &lt;SHA-1&gt;。{pack，idx}文件。&lt;SHA-1&gt;是基于包内容的散列，并被写入命令的标准输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--stdout</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将包内容（将写入.pack 文件的内容）写入标准输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--revs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从标准输入读取修订参数，而不是单个对象名称。修改参数的处理方式<code>git rev-list</code>与<code>--objects</code>标志使用其<code>commit</code>参数来构建输出对象列表的方式相同。结果列表中的对象已打包。除了修订版本，<code>--not</code>或者<code>--shallow &lt;SHA-1&gt;</code>线路也被接受。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--unpacked</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这意味着<code>--revs</code>。处理从标准输入中读取的修订参数列表时，请将打包的对象限制为尚未打包的对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这意味着<code>--revs</code>。除了从标准输入中读取的修订参数列表之外，假设所有的ref <code>refs/</code>都被指定为包括在内。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--include-tag</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果它们引用的对象包含在生成的包文件中，请包含未标记的注释标记。将新标记发送到本地 Git 客户端可能会很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--window=&lt;n&gt;   --depth=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这两个选项会影响包中包含的对象如何使用增量压缩进行存储。对象首先在内部按类型，大小和可选名称进行排序，并与--window 中的其他对象进行比较，以查看使用增量压缩是否节省空间。 - 深度限制最大深度; 使得它太深，会影响解包方的性能，因为需要多次应用增量数据才能获得必要的对象。--window 的默认值是10，--depth 是50。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--window-memory=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此选项提供额外的限制<code>--window</code>; 窗口大小将动态缩小，以便不占用<code>&lt;n&gt;</code>内存中的多个字节。在大型和小型对象混合使用的存储库中，这对于不会用大型窗口内存不足的情况很有用，但仍可以利用大型窗口来查看较小的对象。大小可以加上“k”，“m”或“g”后缀。<code>--window-memory=0</code>使内存使用无限。默认值取自<code>pack.windowMemory</code>配置变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--max-pack-size=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在不常见的情况下，您可能无法在文件系统上创建大于特定大小的文件，并且可以使用此选项告诉命令将输出包文件拆分为多个独立的包文件，每个包文件不大于给定大小。大小可以加上“k”，“m”或“g”后缀。允许的最小尺寸限制为1 MiB。此选项可防止创建位图索引。默认值是无限的，除非配置变量<code>pack.packSizeLimit</code>被设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--honor-pack-keep</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此标志会导致已经在本地包中具有.keep 文件的对象被忽略，即使它本来被打包。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--incremental</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个标志会导致一个包中已有的对象被忽略，即使它本来被打包。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--local</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该标志会导致从备用对象库中借用的对象被忽略，即使它本来被打包。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--non-empty</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果它至少包含一个对象，则只创建一个打包归档文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--progress</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定-q。即使标准错误流未定向到终端，此标志也会强制进度状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--all-progress</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果指定了--stdout，则会在对象计数和压缩阶段显示进度报告，但在写入阶段会禁止进度报告。原因在于，在某些情况下，输出流直接链接到另一个命令，该命令可能希望在处理传入包数据时显示其自身的进度状态。该标志与--progress 相似，只是它强制执行写入阶段的进度报告，即使使用了--stdout 也是如此。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--all-progress-implied</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这用于暗示进展显示被激活时的进度。不像--all-progress 这个标志实际上并没有强制任何进度显示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-q</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该标志使命令不报告其在标准错误流上的进度。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-reuse-delta</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在具有现有包的存储库中创建打包归档时，该命令将重新使用现有的变化量。这有时会导致稍微不理想的包装。该标志告诉命令不要重复使用现有的增量，而是从头开始计算它们。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-reuse-object</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该标志告诉命令根本不重复使用现有对象数据，包括未分类的对象，强制重新压缩所有内容。这意味着 - 不重用 - 增量。仅适用于需要对打包数据进行不同压缩级别的批量执行的模糊情况。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--compression=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定生成包中新压缩数据的压缩级别。如果未指定，则包压缩级别首先由 pack.compression 确定，然后通过 core.compression 确定，默认为-1，否则 zlib 默认值（如果两者均未设置）。如果您想要强制所有数据的统一压缩级别，请添加--no-reuse-object，而不考虑源。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--thin</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过省略发件人和收件人之间的公共对象来创建“瘦”包，以减少网络传输。这个选项只有在与--stdout 结合使用时才有意义。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>注意：精简包通过省略必需的对象来违反打包的归档格式，因此 Git 无法使其自包含。使用<code>git index-pack --fix-thin</code>（参见 git-index-pack [1]）来恢复自包含的属性。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--shallow</p></div></div><div class="doc-postil"><div class="c-markdown"><p>优化将使用浅仓库提供给客户端的包。这个选项与--thin 相结合，可以以速度为代价产生更小的包装。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--delta-base-offset</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打包归档可以将 delta 的基本对象表示为20字节的对象名称或流中的偏移量，但古代版本的 Git 不理解后者。默认情况下，<code>git pack-objects</code>只使用以前的格式以获得更好的兼容性。该选项允许命令使用后一种格式来实现紧凑性。根据平均增量链长度的不同，这个选项通常会使得到的包文件缩小3-5％。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>注意：当他们将对象放到你的版本库中时，默认情况下，在现代 Git 中，瓷器命令<code>git gc</code>（参见 git-gc [1]）<code>git repack</code>（参见 git-repack [1]）将传入此选项。所以<code>git bundle</code>当它创建一个 bundle 时（参见 git-bundle [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--threads=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定搜索最佳增量匹配时产生的线程数。这要求使用 pthread 编译包对象，否则该选项将被忽略并显示警告。这是为了减少多处理器机器的打包时间。然而，增量搜索窗口所需的内存量乘以线程数量。指定0将导致 Git 自动检测 CPU 的数量并相应地设置线程数量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--index-version=&lt;version&gt;,&lt;offset&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这仅供测试套件使用。它允许强制生成的包索引的版本，并强制位于给定偏移量之上的对象上的64位索引条目。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--keep-true-parents</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有了这个选项，被移植物掩盖的父类仍然包装。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>也可以看看</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-rev-list[1] git-repack[1] git-prune-packed[1]</p></div></div></div>