<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-config  - 获取并设置存储库或全局选项</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] name [value [value_regex]]git config [&lt;file-option&gt;] [type] --add name value
git config [&lt;file-option&gt;] [type] --replace-all name value [value_regex]git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] --get name [value_regex]git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] --get-all name [value_regex]git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] [--name-only] --get-regexp name_regex [value_regex]git config [&lt;file-option&gt;] [type] [-z|--null] --get-urlmatch name URL
git config [&lt;file-option&gt;] --unset name [value_regex]git config [&lt;file-option&gt;] --unset-all name [value_regex]git config [&lt;file-option&gt;] --rename-section old_name new_name
git config [&lt;file-option&gt;] --remove-section name
git config [&lt;file-option&gt;] [--show-origin] [-z|--null] [--name-only] -l | --list
git config [&lt;file-option&gt;] --get-color name [default]git config [&lt;file-option&gt;] --get-colorbool name [stdout-is-tty]git config [&lt;file-option&gt;] -e | --edit</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以使用此命令查询/设置/替换/取消设置选项。名称实际上是由点分隔的部分和键，并且该值将被转义。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过使用该<code>--add</code>选项可以将多行添加到选项。如果您想要更新或取消可能出现在多行上的选项，则<code>value_regex</code>需要提供 POSIX 正则表达式。只有与正则表达式匹配的现有值才会更新或取消设置。如果要处理与正则表达式<strong>不</strong>匹配的行，只需在前面添加一个感叹号（另请参阅示例）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>类型说明符可以是<code>--int</code>或者<code>--bool</code>，以<code>git config</code>确保变量具有给定类型并将该值转换为规范形式（对于int为简单十进制数，对于 bool 为 “true” 或 “false” 字符串），或者<code>--path</code>，它做了一些路径扩展（见<code>--path</code>下文）。如果没有传入类型说明符，则不会对该值执行检查或转换。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>读取时，值从系统中，默认情况下，全局和本地资源库的配置文件，并选择阅读<code>--system</code>，<code>--global</code>，<code>--local</code>和<code>--file &lt;filename&gt;</code>可以用来告诉命令只从该位置（查看文件）来读取。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>书写时，新的值写入到默认，并选择存储库本地配置文件<code>--system</code>，<code>--global</code>，<code>--file &lt;filename&gt;</code>可以用来告诉命令写入到该位置（你可以说<code>--local</code>那不过是默认值）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个命令在发生错误时将失败并显示非零状态。一些退出代码是：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>该部分或键无效（ret = 1），</p></li><li><p>没有提供部分或名称（ret = 2），</p></li><li><p>配置文件无效（ret = 3），</p></li><li><p>配置文件不能被写入（ret = 4），</p></li><li><p>你尝试去掉一个不存在的选项（ret = 5），</p></li><li><p>您尝试取消设置/设置多行匹配的选项（ret = 5）或</p></li><li><p>您尝试使用无效的正则表达式（ret = 6）。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>成功时，该命令返回退出代码0。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>--replace-all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认行为是最多替换一行。这将替换与该键匹配的所有行（以及可选的 value_regex ）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--add</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在选项中添加新行而不更改任何现有值。这与提供<code>^$</code> value_regex in 相同<code>--replace-all</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--get</p></div></div><div class="doc-postil"><div class="c-markdown"><p>获取给定键的值（可选用与值匹配的正则表达式进行过滤）。如果未找到该键，则返回错误代码1，如果找到多个键值，则返回上一个值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--get-all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>像 get 一样，但返回多值键的所有值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--get-regexp</p></div></div><div class="doc-postil"><div class="c-markdown"><p>像--get-all一样，但将该名称解释为正则表达式并写出键名称。正则表达式匹配目前是区分大小写的，并且针对小节和变量名称小写的密钥的规范化版本进行，但小节名称不是。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--get-urlmatch name URL</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当给定一个由两部分组成的名称 section.key 时，会返回部分 &lt;url&gt; .key 的值，该部分的 &lt;url&gt; 部分与给定 URL 匹配的最佳部分将返回（如果不存在此类键，则使用 section.key 的值作为后备）。当仅给出该部分作为名称时，请为该部分中的所有键执行此操作并列出它们。如果找不到值，则返回错误代码1。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--global</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于编写选项：写入全局<code>~/.gitconfig</code>文件而不是存储库<code>.git/config</code>，<code>$XDG_CONFIG_HOME/git/config</code>如果此文件存在且<code>~/.gitconfig</code>文件不存在，则写入文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>阅读选项：只能从全局文件读取<code>~/.gitconfig</code>，<code>$XDG_CONFIG_HOME/git/config</code>而不能从所有可用文件中读取。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>另请参阅文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--system</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于编写选项：写入系统范围<code>$(prefix)/etc/gitconfig</code>而不是存储库<code>.git/config</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于阅读选项：只能从系统范围内读取，<code>$(prefix)/etc/gitconfig</code>而不能从所有可用文件中读取。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>另请参阅文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--local</p></div></div><div class="doc-postil"><div class="c-markdown"><p>编写选项：写入存储库<code>.git/config</code>文件。这是默认行为。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>阅读选项：只能从存储库中读取，<code>.git/config</code>而不能从所有可用文件中读取。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>另请参阅文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-f config-file   --file config-file</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用给定的配置文件而不是 GIT_CONFIG 指定的配置文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--blob blob</p></div></div><div class="doc-postil"><div class="c-markdown"><p>类似于<code>--file</code>使用给定的 blob 而不是文件。例如，您可以使用<code>master:.gitmodules</code>从<code>.gitmodules</code>主分支中的文件读取值。请参阅 gitrevisions [7]中的“指定修订”一节以获取拼写 blob 名称拼写方法的更完整列表。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--remove-section</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从配置文件中删除给定的部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--rename-section</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将给定部分重命名为新名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--unset</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从配置文件中删除与密钥匹配的行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--unset-all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从配置文件中删除所有与密钥匹配的行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-l   --list</p></div></div><div class="doc-postil"><div class="c-markdown"><p>列出在配置文件中设置的所有变量及其值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--bool</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git config</code> 将确保输出为“真”或“假”</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--int</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git config</code>将确保输出是一个简单的十进制数。在输出前，可选值后缀为<code>k</code>，<code>m</code>或<code>g</code>在配置文件中将使该值乘以1024,1048576或1073741824。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--bool-or-int</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git config</code> 将确保输出匹配 --bool 或 --int 的格式，如上所述。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--path</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git-config</code>将扩展为指定用户的主目录<code>~</code>的值<code>$HOME</code>和<code>~user</code>主目录。此设置在设置值时不起作用（但您可以<code>git config bla ~/</code>从命令行使用 shell 来扩展）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-z   --null</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于输出值和/或键的所有选项，始终使用空字符（而不是换行符）结束值。使用换行符作为键和值之间的分隔符。这允许安全地解析输出而不会被例如包含换行符的值混淆。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--name-only</p></div></div><div class="doc-postil"><div class="c-markdown"><p>输出<code>--list</code>或<code>--get-regexp</code>的配置变量的名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--show-origin</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用原点类型（文件，标准输入，blob，命令行）和实际原点（配置文件路径，ref 或 blob id，如果适用）扩大所有查询配置选项的输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--get-colorbool name stdout-is-tty</p></div></div><div class="doc-postil"><div class="c-markdown"><p>找到<code>name</code>（例如<code>color.diff</code>）的颜色设置并输出“true”或“false”。<code>stdout-is-tty</code>应该是“真”或“假”，并且在配置时称为“自动”时将其考虑在内。如果<code>stdout-is-tty</code>缺少，则检查命令本身的标准输出，如果要使用颜色，则退出状态0，否则退出状态1。当颜色设置为<code>name</code>未定义时，该命令将<code>color.ui</code>用作回退。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--get-color name default</p></div></div><div class="doc-postil"><div class="c-markdown"><p>查找为<code>name</code>（例如<code>color.diff.new</code>）配置的颜色并将其作为 ANSI 颜色转义序列输出到标准输出。<code>default</code>如果没有配置颜色，则使用可选参数<code>name</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-e   --edit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打开一个编辑器来修改指定的配置文件; 或者<code>--system</code>，<code>--global</code>或者存储库（默认）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-includes</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>include.*</code>查找值时，请在配置文件中遵守指令。默认为<code>off</code>当一个特定的文件中给出（例如，使用<code>--file</code>，<code>--global</code>等），<code>on</code>搜索所有配置文件时。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>Files</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>如果没有明确设置<code>--file</code>，有四个文件<code>git config</code>将搜索配置选项：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>$(prefix)/etc/gitconfig</p></div></div><div class="doc-postil"><div class="c-markdown"><p>系统范围的配置文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>$XDG_CONFIG_HOME/git/config</p></div></div><div class="doc-postil"><div class="c-markdown"><p>第二个用户特定的配置文件。如果 $ XDG_CONFIG_HOME 未设置或为空，<code>$HOME/.config/git/config</code>将被使用。此文件中设置的任何单值变量都将被任何内容覆盖<code>~/.gitconfig</code>。如果你有时使用旧版本的 Git ，不建立这个文件是一个好主意，因为对这个文件的支持最近被添加了。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>~/.gitconfig</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用户特定的配置文件。也称为“全局”配置文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>$GIT_DIR/config</p></div></div><div class="doc-postil"><div class="c-markdown"><p>存储库特定的配置文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果没有其他选项，所有阅读选项将读取所有可用的这些文件。如果全局配置文件或全系统配置文件不可用，它们将被忽略。如果存储库配置文件不可用或不可读，<code>git config</code>将以非零错误代码退出。但是，在任何情况下都不会发布错误消息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些文件按照上面给出的顺序读取，其中最后一个值优先于先前读取的值。当多个值被采用时，将使用来自所有文件的密钥的所有值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用该<code>-c</code>选项运行任何 git 命令时，您可以覆盖单个配置参数。有关详细信息，请参阅 git [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>所有编写选项将默认写入存储库特定的配置文件。请注意，这也会影响诸如<code>--replace-all</code>和的选项<code>--unset</code>。<em style="font-style: italic;"><strong>git config</strong></em> <strong>一次只能更改一个文件</strong>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以通过命令行选项或环境变量来覆盖这些规则。在<code>--global</code>和<code>--system</code>选项将限制分别用于全球或全系统文件的文件。该<code>GIT_CONFIG</code>环境变量有类似的效果，但您可以指定任何你想要的文件名。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>环境</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>GIT_CONFIG</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从给定文件取代 .git / config 的配置。使用 “--global” 选项将强制使用 〜/ .gitconfig 。使用 “--system” 选项将强制使用 $（prefix）/ etc / gitconfig 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>GIT_CONFIG_NOSYSTEM</p></div></div><div class="doc-postil"><div class="c-markdown"><p>是否跳过从系统范围的 $（prefix）/ etc / gitconfig 文件读取设置。有关详细信息，请参阅 git [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>另请参阅文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>给定一个像这样的 .git / config ：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">#
# This is the config file, and
# a '#' or ';' character indicates
# a comment
#</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">; core variables[core]        ; Don't trust file modes
        filemode = false</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">; Our diff algorithm[diff]
        external = /usr/local/bin/diff-wrapper
        renames = true</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">; Proxy settings[core]
        gitproxy=proxy-command for kernel.org
        gitproxy=default-proxy ; for all the rest</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">; HTTP[http]
        sslVerify[http "https://weak.example.com"]
        sslVerify = false
        cookieFile = /tmp/cookie.txt</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以将 filemode 设置为 true</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config core.filemode true</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>假设的代理命令条目实际上有一个后缀来辨别它们适用的 URL 。以下是如何将 kernel.org 的条目更改为 “ssh” 。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config core.gitproxy '"ssh" for kernel.org' 'for kernel.org$'</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这确保只有 kernel.org 的键/值对被替换。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要删除重命名的条目，请执行</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config --unset diff.renames</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果你想删除一个多变量的条目（比如上面的 core.gitproxy ），你必须提供一个匹配正好一行的正则表达式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要查询给定键的值，请执行</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config --get core.filemode</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>或</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config core.filemode</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>或者，查询多变量：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config --get core.gitproxy "for kernel.org$"</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您想知道多变量的所有值，请执行以下操作：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config --get-all core.gitproxy</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果你喜欢危险的生活，你可以用一个新的 core.gitproxy 替换<strong>掉所有的</strong> core.gitproxy</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config --replace-all core.gitproxy ssh</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>但是，如果您只想替换默认代理的行，即没有 “for ...” 后缀的行，请执行如下操作：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config core.gitproxy ssh '! for '</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>要实际上只将值与感叹号匹配，您必须</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config section.key value '[!]'</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>要添加新代理，而不更改任何现有代理，请使用</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config --add core.gitproxy '"proxy-command" for example.com'</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在脚本中使用来自配置的自定义颜色的示例：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">#!/bin/sh
WS=$(git config --get-color color.diff.whitespace "blue reverse")RESET=$(git config --get-color "" "reset")echo "${WS}your whitespace color or blue reverse${RESET}"</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>对于<code>https://weak.example.com，http.sslVerify</code>中的网址设置为 false ，而为所有其他网址设置<code>true</code>：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">% git config --bool --get-urlmatch http.sslverify https://good.example.comtrue% git config --bool --get-urlmatch http.sslverify https://weak.example.comfalse% git config --get-urlmatch http https://weak.example.com
http.cookieFile /tmp/cookie.txt
http.sslverify false</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>配置文件</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 配置文件包含许多影响 Git 命令行为的变量。<code>.git/config</code>每个存储库中的文件都用于存储该存储库的配置，并<code>$HOME/.gitconfig</code>用于将每个用户的配置存储为该<code>.git/config</code>文件的后备值。该文件<code>/etc/gitconfig</code>可用于存储系统范围的默认配置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>配置变量由 Git 管道和瓷器使用。变量分为多个部分，其中变量本身的完全限定变量名称是最后一个以点分隔的部分，部分名称是最后一个点之前的所有内容。变量名称不区分大小写，仅允许字母数字字符<code>-</code>，并且必须以字母字符开头。一些变量可能会出现多次; 我们说那个变量是多值的。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>句法</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>语法相当灵活和宽容; 空格大多被忽略。在<code>#</code>和<code>;</code>字符开头的注释行的末尾，空行被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该文件由部分和变量组成。一节以方括号中的节的名称开始，并一直持续到下一节开始。部分名称不区分大小写。只有字母数字字符，<code>-</code>并且<code>.</code>在部分名称中是允许的。每个变量必须属于某个部分，这意味着在首次设置变量之前必须有一个部分标题。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>部分可以进一步分为小节。要开始一个小节，请在节标题中将其名称放在双引号中，用空格与节名称分隔，如下例所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        [section "subsection"]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>小节名称区分大小写，可以包含除换行符以外的任何字符（双引号<code>"</code>和反斜线可以通过分别将它们转义为<code>\"</code>和<code>\\</code>）来包含。节标题不能跨越多行。变量可能直接属于某个部分或给定的子部分。你可以有<code>[section]</code>，如果你有<code>[section "subsection"]</code>，但你并不需要。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>还有一个不赞成的<code>[section.subsection]</code>语法。使用该语法，子部分名称将转换为小写，并且也将区分大小写。这些小节名称遵循与节名称相同的限制。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>所有其他行（以及段落标题后面的行的其余部分）都以表单的形式被识别为设置变量<code>name = value</code>（或者简单<code>name</code>地说，这个变量就是布尔值 “true” ）。变量名称不区分大小写，仅允许字母数字字符<code>-</code>，并且必须以字母字符开头。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>定义一个值的行可以通过以<code>\</code>结尾来继续到下一行; 反引号和行结束被剥离。领先后的空格<code>name =</code>中，第一个注释字符后，该行剩余部分<code>#</code>或<code>;</code>和该行的尾部空格被丢弃，除非它们是双引号括起来。价值范围内的内部空白是逐字保留的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在双引号内，必须转义双引号<code>"</code>和反斜线<code>\</code>字符：use <code>\"</code>for <code>"</code> and <code>\\</code>for <code>\</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以下转义序列（旁边<code>\"</code>和<code>\\</code>）被识别：<code>\n</code>换行符（NL），<code>\t</code>水平制表符（HT，TAB）和<code>\b</code>退格符（BS）。其他char转义序列（包括八进制转义序列）无效。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>包括</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>在<code>include</code>与<code>includeIf</code>部分允许您包括来自其他来源的配置指令。这些部分的行为彼此完全相同，<code>includeIf</code>只是如果部分条件未评估为真，部分可能会被忽略; 请参阅下面的“有条件包含”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以通过将特殊<code>include.path</code>（或<code>includeIf.*.path</code>）变量设置为要包含的文件的名称来包含另一个配置文件。该变量将路径名作为其值，并受波浪扩展影响。这些变量可以多次给出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含文件的内容会立即插入，就好像它们已经在 include 指令的位置找到一样。如果变量的值是相对路径，则路径被认为是相对于在其中找到 include 指令的配置文件。见下面的例子。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>有条件的包括</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以通过将<code>includeIf.&lt;condition&gt;.path</code>变量设置为要包含的文件的名称，从另一个条件包含配置文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>条件以关键字后跟冒号开头，一些数据的格式和含义取决于关键字。支持的关键字是：</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>gitdir</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>关键字<code>gitdir:</code>后面的数据用作全局模式。如果 .git 目录的位置与模式匹配，则满足包含条件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>.git 位置可以自动发现，也可以来自<code>$GIT_DIR</code>环境变量。如果存储库是通过 .git 文件（例如，从子模块或链接的工作树）自动发现的，那么 .git 位置将是 .git 目录的最终位置，而不是 .git 文件所在的位置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该模式可以包含标准通配符通配符和另外两个，<code>**/</code>并且<code>/**</code>可以匹配多个路径组件。详情请参阅 gitignore [5] 。为了方便：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>如果模式开头是<code>~/</code>，<code>~</code>将被替换为环境变量<code>HOME</code>的内容。</p></li><li><p>如果模式开始是<code>./</code>，则将其替换为包含当前配置文件的目录。</p></li><li><p>如果模式不以任何启动<code>~/</code>，<code>./</code>或者<code>/</code>，<code>**/</code>将被自动加上。例如，模式<code>foo/bar</code>变成<code>**/foo/bar</code>并且将匹配<code>/any/path/to/foo/bar</code>。</p></li><li><p>如果模式结束<code>/</code>，<code>**</code>将自动添加。例如，模式<code>foo/</code>变成<code>foo/**</code>。换句话说，它会递归匹配 “foo” 和里面的所有内容。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p><code>gitdir/i</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>这与<code>gitdir</code>除了不区分大小写匹配相同（例如对大小写不敏感的文件系统）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>关于通过<code>gitdir</code>和<code>gitdir/i</code>匹配的更多注意事项：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>$GIT_DIR</code>匹配前不解析符号链接。</p></li><li><p>符号链接和实际路径版本的路径都将在外部匹配<code>$GIT_DIR</code>。例如，如果〜/ Git 是一个符号链接到/ mnt /存储/ git 的，都<code>gitdir:~/git</code>和<code>gitdir:/mnt/storage/git</code>匹配。v2.13.0中此功能的最初版本并不是这种情况，它只与实际路径版本相匹配。希望与此功能的初始版本兼容的配置需要仅指定实际路径版本或两个版本。</p></li><li><p>请注意，“../”不是特别的，并且会直接匹配，这不太可能是您想要的。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h3>例</h3></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash"># Core variables[core]        ; Don't trust file modes
        filemode = false</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash"># Our diff algorithm[diff]
        external = /usr/local/bin/diff-wrapper
        renames = true</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[branch "devel"]
        remote = origin
        merge = refs/heads/devel</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash"># Proxy settings[core]
        gitProxy="ssh" for "kernel.org"
        gitProxy=default-proxy ; for the rest</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[include]
        path = /path/to/foo.inc ; include by absolute path
        path = foo.inc ; find "foo.inc" relative to the current file
        path = ~/foo.inc ; find "foo.inc" in your `$HOME` directory</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">; include if $GIT_DIR is /path/to/foo/.git[includeIf "gitdir:/path/to/foo/.git"]
        path = /path/to/foo.inc</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">; include for all repositories inside /path/to/group[includeIf "gitdir:/path/to/group/"]
        path = /path/to/foo.inc</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">; include for all repositories inside $HOME/to/group[includeIf "gitdir:~/to/group/"]
        path = /path/to/foo.inc</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">; relative paths are always relative to the including; file (if the condition is true); their location is not; affected by the condition[includeIf "gitdir:/path/to/group/"]
        path = foo.inc</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>值</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>许多变量的值被视为一个简单的字符串，但有些变量会接受特定类型的值，并且有关如何拼写它们的规则。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>boolean</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当称取一个布尔值的变量，许多同义词接受<code>true</code>和<code>false</code>; 这些都是不区分大小写的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>true</p></div></div><div class="doc-postil"><div class="c-markdown"><p>布尔真正的文字是<code>yes</code>，<code>on</code>，<code>true</code>，和<code>1</code>。另外，没有定义的变量<code>= &lt;value&gt;</code>被视为是真的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>false</p></div></div><div class="doc-postil"><div class="c-markdown"><p>布尔值 false 文字是<code>no</code>，<code>off</code>，<code>false</code>，<code>0</code>和空字符串。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>--bool</code>类型说明符将值转换为规范形式时，<code>git config</code>将确保输出为“true”或“false”（拼写为小写）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>integer</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定各种大小的许多变量的值可以后缀为<code>k</code>，<code>M</code>...以表示“将数字缩放1024”，“由1024x1024”等。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color</p></div></div><div class="doc-postil"><div class="c-markdown"><p>采用颜色的变量的值是颜色列表（最多两个，一个用于前景，一个用于背景）和属性（尽可能多），用空格分隔。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>接受基本的颜色<code>normal</code>，<code>black</code>，<code>red</code>，<code>green</code>，<code>yellow</code>，<code>blue</code>，<code>magenta</code>，<code>cyan</code>和<code>white</code>。第一种颜色是前景; 第二个是背景。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>颜色也可以用0到255之间的数字给出; 这些使用 ANSI 256色模式（但请注意，并非所有终端都可以支持此模式）。如果你的终端支持它，你也可以指定24位的 RGB 值，如十六进制<code>#ff0ab3</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>接受的属性<code>bold</code>，<code>dim</code>，<code>ul</code>，<code>blink</code>，<code>reverse</code>，<code>italic</code>，和<code>strike</code>（用于打叉或“删除线”字母）。任何属性相对于颜色的位置（之前，之后或之间）无关紧要。特定属性可以用前缀被关闭<code>no</code>或<code>no-</code>（例如，<code>noreverse</code>，<code>no-ul</code>等等）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个空的颜色字符串根本不产生颜色效果。这可以用来避免在完全禁用颜色的情况下着色特定元素。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于 git 的预定义颜色槽，这些属性意味着在彩色输出中每个项目的开始处重置。因此，即使在同一输出行上的前一个事物（例如，在<code>log --decoratebold</code>输出中的分支名称列表之前的开放圆括号）设置为使用其他属性进行绘制，设置<code>color.decorate.branch</code>为<code>black</code>将以明文形式<code>black</code>绘制该分支名称。然而，自定义日志格式可能会做更复杂和分层的着色，否定形式可能在那里很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>路径</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该接受的路径名值的变量可以给出以“开始的字符串<code>~/</code>”或“ <code>~user/</code>”，和通常的波浪线扩展发生这样的字符串：<code>~/</code>扩展到的值<code>$HOME</code>，和<code>~user/</code>被指定的用户的主目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>变量</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，此列表不全面，不一定完整。对于特定于命令的变量，您可以在相应的手册页中找到更详细的说明。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>其他与 git 相关的工具可能会使用自己的变量。在发明新变量以供您自己的工具使用时，请确保它们的名称与 Git 本身和其他常用工具使用的名称不冲突，并在文档中对其进行描述。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>advice.*</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些变量控制旨在帮助新用户的各种可选帮助消息。所有的<code>advice.*</code>变量默认为<code>true</code>，你可以通过设置这些变量来告诉 Git 你不需要帮助来处理这些<code>false</code>：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pushUpdateRejected</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置这个变量<code>false</code>，如果要禁用<code>pushNonFFCurrent</code>，<code>pushNonFFMatching</code>，<code>pushAlreadyExists</code>，<code>pushFetchFirst</code>，和<code>pushNeedsForce</code>同时进行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pushNonFFCurrent</p></div></div><div class="doc-postil"><div class="c-markdown"><p>由于对当前分支的非快进更新，git-push [1] 失败时显示的建议。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pushNonFFMatching</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当您运行 git-push [1] 并<code>matching refs</code>显式推送（即您使用<code>:</code>或指定了不是您当前分支的 refspec ）时显示的建议，并导致非快进错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pushAlreadyExists</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当 git-push [1] 拒绝不符合快速转发资格的更新时显示（例如，标签）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pushFetchFirst</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当 git-push [1] 拒绝试图覆盖指向我们没有的对象的远程参考的更新时显示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pushNeedsForce</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当 git-push [1] 拒绝尝试覆盖指向非 commit-ish 对象的远程 ref 的更新或使远程 ref 位于非 commit-ish 对象时显示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>statusHints</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在 git-status [1] 的输出中显示如何从当前状态开始，在 git-commit [1] 中写入提交消息时显示的模板中以及 git-checkout [1] 显示的帮助消息中显示方向。切换分支时。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>statusUoption</p></div></div><div class="doc-postil"><div class="c-markdown"><p>建议考虑使用<code>-u</code> git-status [1]选项，当命令需要2秒钟以上才能枚举未跟踪的文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>commitBeforeMerge</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当 git-merge [1] 拒绝合并以避免覆盖本地更改时显示建议。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>resolveConflict</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在冲突阻止执行操作时由各种命令显示的建议。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>implicitIdentity</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当您的信息从系统用户名和域名中被猜出时，提供关于如何设置您的身份配置的建议。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>detachedHead</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当您使用 git-checkout [1] 移至分离 HEAD 状态时，显示的建议指示如何在事实之后创建本地分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>amWorkDir</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在 git-am [1] 未能应用时显示补丁文件位置的建议。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>rmHints</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果 git-rm [1] 输出失败，请指示如何从当前状态继续。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>addEmbeddedRepo</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当你意外地在另一个 git 仓库中添加了一个 git 仓库时，建议做些什么。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.fileMode</p></div></div><div class="doc-postil"><div class="c-markdown"><p>告诉 Git 工作树中的文件的可执行位是否被尊重。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当标记为可执行的文件被签出时，某些文件系统会丢失可执行文件位，或检出可执行文件位置不可执行的文件。git-clone [1] 或 git-init [1] 探测文件系统，看它是否正确处理可执行位，并根据需要自动设置此变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>但是，存储库可能位于正确处理文件模式的文件系统上，并且该变量<code>true</code>在创建时设置为，但后来可以从其他丢失文件模式的环境访问（例如，通过 CIFS 挂载导出 ext4 ，访问创建的 Cygwin 用于 Windows 或 Eclipse 的 Git 仓库）。在这种情况下，可能需要将此变量设置为<code>false</code>。参见 git-update-index [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>缺省值为 true（当 core.filemode 未在配置文件中指定时）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.hideDotFiles</p></div></div><div class="doc-postil"><div class="c-markdown"><p>（仅限Windows）如果为 true，则将新创建的目录和名称以点开头的文件标记为隐藏。如果<code>dotGitOnly</code>只有<code>.git/</code>目录被隐藏，但没有以点开头的其他文件。默认模式是<code>dotGitOnly</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.ignoreCase</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则此选项启用各种解决方法，以使 Git 能够更好地处理不区分大小写的文件系统，如 FAT 。例如，如果一个目录列表在 Git 期望 “Makefile” 时发现 “makefile” ，Git 会认为它是真正的同一个文件，并继续记住它为 “Makefile” 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>缺省值为 false，除非 git-clone [1] 或 git-init [1] 将在创建存储库时探测并设置 core.ignoreCase为true（如果适用）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.precomposeUnicode</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此选项仅适用于 Git 的 Mac OS 实施。当 core.precomposeUnicode = true 时，Git 恢复由 Mac OS 完成的文件名的 Unicode 分解。在 Mac OS 和 Linux 或 Windows 之间共享存储库时，这非常有用。（需要 Git for Windows 1.7.10 或更高版本，或者在 Cygwin 1.7 下使用 Git ）。如果为 false ，则 Git 将文件名处理为完全透明，这与旧版 Git 向后兼容。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.protectHFS</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true ，则不允许签出<code>.git</code>在 HFS +文件系统上认为等效的路径。默认为<code>true</code>在 Mac OS 和<code>false</code>其他地方。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.protectNTFS</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true ，则不允许签出会导致 NTFS 文件系统问题的路径，例如与8.3“short”名称冲突。默认<code>true</code>在 Windows 和<code>false</code>其他地方。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.trustctime</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 false ，索引和工作树之间的 ctime 差异将被忽略; 当 inode 更改时间由 Git（文件系统搜寻器和某些备份系统）之外的某些东西定期修改时，这一点很有用。参见 git-update-index [1]。默认情况下为真。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.splitIndex</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则将使用索引的分割索引功能。参见 git-update-index [1]。默认为 False。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.untrackedCache</p></div></div><div class="doc-postil"><div class="c-markdown"><p>确定如何处理索引的未跟踪缓存功能。如果此变量未设置或设置为，它将被保留<code>keep</code>。如果设置为，它将自动添加<code>true</code>。如果设置为，它会自动删除<code>false</code>。在设置之前<code>true</code>，您应该检查您的系统上的 mtime 是否正常工作。参见 git-update-index [1] 。<code>keep</code>默认。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.checkStat</p></div></div><div class="doc-postil"><div class="c-markdown"><p>确定在索引和工作树之间匹配哪些统计字段。用户可以将其设置为<code>default</code>或<code>minimal</code>。默认（或明确<code>default</code>）是检查所有字段，包括 mtime 和 ctime 的第二部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.quotePath</p></div></div><div class="doc-postil"><div class="c-markdown"><p>命令，输出路径（例如<code>ls-files</code>，<code>diff</code>），将引用中的路径名“异常”的字符通过以相同的方式 C 逸出控制字符（例如，用反斜杠包围在双引号的路径名和避开这些字符<code>\t</code>用于TAB，<code>\n</code>对于LF，<code>\\</code>用于反斜杠）或值大于0x80的字节（例如<code>\302\265</code>UTF-8中的 “micro” 的八进制）。如果此变量设置为 false ，则高于0x80的字节不再被视为“异常”。无论此变量的设置如何，双引号，反斜杠和控制字符总是会被转义。一个简单的空间字符不被认为是“不寻常的”。许多命令可以使用该<code>-z</code>选项完全逐字输出路径名。默认值是 true 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.eol</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>text</code>在 core.autocrlf 为 false 时，设置在工作目录中用于具有属性设置的文件的行结束类型。替代品是<code>lf</code>，<code>crlf</code>并且<code>native</code>，它使用平台的本地行结束。默认值是<code>native</code>。请参阅 gitattributes [5] 了解有关换行结束的更多信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.safecrlf</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true ，则使 Git 检查<code>CRLF</code>在行末换算处于活动状态时转换是否可逆。Git 将验证命令是直接还是间接地修改工作树中的文件。例如，提交文件后检出相同的文件应该在工作树中产生原始文件。如果当前设置不是这样<code>core.autocrlf</code>，Git 将拒绝该文件。变量可以设置为“警告”，在这种情况下，Git 只会警告不可逆的转换，但会继续操作。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>CRLF 转换承担破坏数据的轻微机会。当它被启用时，Git 会在提交期间将 CRLF 转换为 LF ，并在结帐期间将LF转换为 CRLF 。在提交之前包含 LF 和 CRLF 混合的文件无法由 Git 重新创建。对于文本文件，这是正确的做法：它纠正行结束，以便我们在存储库中只有 LF 行结束符。但对于意外分类为文本的二进制文件，转换可能会破坏数据。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您提前认识到这种腐败，可以通过在 .gitattributes 中明确设置转换类型来轻松修复它。提交后立即在工作树中保留原始文件，并且此文件尚未损坏。你可以明确地告诉 Git 这个文件是二进制的，Git 会适当地处理这个文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不幸的是，用混合行结束清除文本文件的理想效果和破坏二进制文件的不良效果无法区分。在这两种情况下，CRLF 都以不可逆的方式被移除。对于文本文件，这是正确的，因为 CRLF 是行结束符，而对于二进制文件，转换 CRLF 会破坏数据。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，这个安全检查并不意味着一个结帐时会产生的不同的设置与原始文件的文件<code>core.eol</code>和<code>core.autocrlf</code>，但只适用于当前的一个。例如，一个带有文本文件的文件<code>LF</code>将被接受，<code>core.eol=lf</code>并且随后可以被检出<code>core.eol=crlf</code>，在这种情况下，生成的文件将包含<code>CRLF</code>，尽管包含原始文件<code>LF</code>。但是，在这两种工作树中，行结束都是一致的，即全部<code>LF</code>或全部<code>CRLF</code>，但从不混合。该<code>core.safecrlf</code>机制会报告具有混合行结尾的文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.autocrlf</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将此变量设置为 “true” 与将<code>text</code>所有文件和 core.eol 中的属性设置为 “auto” 为 “crlf” 相同。如果你想<code>CRLF</code>在你的工作目录中有行结尾并且存储库有 LF 行结束符，那么设置为 true 。该变量可以设置为<code>input</code>，在这种情况下不执行输出转换。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.symlinks</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 false ，则将符号链接检出为包含链接文本的小纯文件。git-update-index [1] 和 git-add [1] 不会将记录类型更改为常规文件。在不支持符号链接的 FAT 等文件系统上很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>缺省值为 true ，除了创建存储库时，git-clone [1] 或 git-init [1] 将探测并设置 core.symlinks为false（如果适用）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.gitProxy</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>command host port</code>当使用 Git 协议进行抓取时，执行（as ）“代理命令” 而不是建立与远程服务器的直接连接。如果变量值处于 “COMMAND for DOMAIN” 格式中，则该命令仅应用于以指定域字符串结尾的主机名。这个变量可以设置多次，并按照给定的顺序进行匹配; 第一场比赛获胜。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可以被<code>GIT_PROXY_COMMAND</code>环境变量覆盖（它总是普遍适用，没有特殊的 “for” 处理）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>特殊的字符串<code>none</code>可以用作代理命令来指定没有代理用于给定的域模式。这对排除防火墙内的服务器使用代理非常有用，而默认为外部域的通用代理。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.sshCommand</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置了这个变量，<code>git fetch</code>和<code>git push</code>将使用指定的命令而不是<code>ssh</code>当他们需要连接到远程系统时。该命令与<code>GIT_SSH_COMMAND</code>环境变量的形式相同，并且在设置环境变量时被覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.ignoreStat</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，Git 将避免使用 lstat（）调用来检测文件是否已更改，方法是为索引文件和工作树中相同更新的跟踪文件设置“假定 - 不变”位。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当文件在 Git 之外被修改时，用户将需要显式地修改已修改的文件（例如参见<code>Examples</code> git-update-index [1] 中的部分）。Git 通常不会检测到这些文件的变化。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这对于 lstat（）调用非常慢的系统非常有用，例如 CIFS / Microsoft Windows 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认为 False 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.preferSymlinkRefs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用符号链接代替 HEAD 和其他符号参考文件的默认 “symref” 格式。有时需要使用旧的脚本来处理 HEAD ，这是一个符号链接。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.bare</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果该属性值为 true ，则假定该存储库为<code>bare</code>并且没有与其关联的工作目录。如果是这种情况，需要工作目录的许多命令将被禁用，例如 git-add [1] 或 git-merge [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当创建仓库时，这个设置会被 git-clone [1] 或者 git-init [1] 自动猜到。默认情况下，以 “/.git” 结尾的存储库被假定为不是空（空=假），而所有其他存储库被假定为空（空=真）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.worktree</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将路径设置为工作树的根目录。如果<code>GIT_COMMON_DIR</code>设置了环境变量，core.worktree 将被忽略，不用于确定工作树的根。这可以被<code>GIT_WORK_TREE</code>环境变量和<code>--work-tree</code>命令行选项覆盖。该值可以是绝对路径，也可以是相对于 .git 目录的路径，该目录由 --git-dir 或 GIT_DIR 指定，或者自动发现。如果指定了 --git-dir 或 GIT_DIR ，但没有指定 --work-tree ， GIT_WORK_TREE 和 core.worktree ，则当前工作目录被视为工作树的顶层。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，即使将该变量设置在目录的 “.git” 子目录中的配置文件中，其值也不同于后者目录（例如 “/path/to/.git/config” 将 core.worktree 设置为“/不同/路径”），这很可能是错误配置。在 “/ path / to” 目录中运行 Git 命令仍然使用 “/ different / path” 作为工作树的根目录，除非你知道自己在做什么，否则会引起混淆（例如，你正在创建只读的快照相同的索引指向与存储库常用工作树不同的位置）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.logAllRefUpdates</p></div></div><div class="doc-postil"><div class="c-markdown"><p>启用 reflog 。<code>$GIT_DIR/logs/&lt;ref&gt;</code>通过附加新的和旧的 SHA-1 ，日期/时间和更新原因，但只有当文件存在时，才会将 ref &lt;ref&gt; 的更新记录到文件“ ”中。如果这个配置变量设置为<code>true</code>，缺少“ <code>$GIT_DIR/logs/&lt;ref&gt;</code>”文件是自动创建的分支头（即下<code>refs/heads/</code>），远程裁判（即下<code>refs/remotes/</code>），注意裁判（即下<code>refs/notes/</code>），和符号 ref <code>HEAD</code>。如果它被设置为<code>always</code>，那么会自动为任何下方的 ref 创建缺失的 reflog <code>refs/</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此信息可用于确定“2天前”分支的提示是什么。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，此值在具有与其关联的工作目录的存储库中为 true ，在裸存储库中默认为 false 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.repositoryFormatVersion</p></div></div><div class="doc-postil"><div class="c-markdown"><p>标识存储库格式和布局版本的内部变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.sharedRepository</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>group</code>（或<code>true</code>）时，存储库可以在一个组中的多个用户之间共享（确保所有文件和对象都是可写组的）。当<code>all</code>（或<code>world</code>或<code>everybody</code>）时，存储库将为所有用户可读，另外还可以分组。当<code>umask</code>（或<code>false</code>）时，Git 将使用由 umask（2）报告的权限。何时<code>0xxx</code>，哪里<code>0xxx</code>是八进制数，存储库中的文件将具有此模式值。<code>0xxx</code>将覆盖用户的 umask 值（而其他选项将只覆盖用户的 umask 值的所需部分）。示例：<code>0660</code>将使所有者和组能够进行 repo 读/写，但其他人无法访问（相当于<code>group</code>除非umask是例如<code>0022</code>）。<code>0640</code>是一个组可读但不可分组写的存储库。请参阅 git-init [1]。默认为False。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.warnAmbiguousRefs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，Git 会警告您，如果您传递的 ref 名称不明确，并且可能与存储库中的多个 ref 匹配。默认情况下为真。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.compression</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个整数-1..9，表示默认的压缩级别。-1是 zlib 的默认值。0代表没有压缩，1..9代表不同的速度/尺寸折衷，9代表最慢。如果设置，则会为其他压缩变量（如<code>core.looseCompression</code>和）提供默认值<code>pack.compression</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.looseCompression</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个整数-1..9，表示不在包文件中的对象的压缩级别。-1是 zlib 的默认值。0代表没有压缩，1..9代表不同的速度/尺寸折衷，9代表最慢。如果未设置，则默认为 core.compression 。如果没有设置，默认为1（最佳速度）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.packedGitWindowSize</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在单个映射操作中映射到内存中的包文件的字节数。较大的窗口大小可能允许您的系统更快速地处理较小数量的大型文件包文件。由于增加了对操作系统内存管理器的调用，较小的窗口大小会对性能产生负面影响，但可能会在访问大量大型文件包时提高性能。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果在编译时设置 NO_MMAP ，则默认值为1 MiB ，否则在32位平台上为32 MiB ，在64位平台上为1 GiB 。这对所有用户/操作系统都应该是合理的。你可能不需要调整这个值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>常见的单元后缀<code>k</code>，<code>m</code>或<code>g</code>支持。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.packedGitLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从包文件同时映射到内存的最大字节数。如果 Git 需要一次访问超过这么多字节来完成操作，它将取消映射现有区域以回收进程中的虚拟地址空间。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>32位平台上的默认值为256 MiB ，64位平台上的默认值为32 TiB（实际无限制）。对于所有用户/操作系统来说，这应该是合理的，但最大的项目除外。你可能不需要调整这个值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>常见的单元后缀<code>k</code>，<code>m</code>或<code>g</code>支持。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.deltaBaseCacheLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为了缓存可能被多个分类对象引用的基础对象而预留的最大字节数。通过将整个解压缩的基础对象存储在缓存中，Git 可以避免多次拆包和解压缩常用的基础对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>所有平台上的默认值为96 MiB 。对于所有用户/操作系统来说，这应该是合理的，但最大的项目除外。你可能不需要调整这个值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>常见的单元后缀<code>k</code>，<code>m</code>或<code>g</code>支持。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.bigFileThreshold</p></div></div><div class="doc-postil"><div class="c-markdown"><p>大于此大小的文件将被缩减存储，而不会尝试增量压缩。在不进行增量压缩的情况下存储大文件可以避免过多的内存使用量，但会增加磁盘使用量。此外，大于此大小的文件始终视为二进制文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>所有平台上的默认值为512 MiB 。对于大多数项目来说，这应该是合理的，因为源代码和其他文本文件仍然可以进行 delta 压缩，但是较大的二进制媒体文件不会。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>常见的单元后缀<code>k</code>，<code>m</code>或<code>g</code>支持。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.excludesFile</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除<code>.gitignore</code>（（每个目录）和）之外，指定文件的路径名，该文件包含用于描述不打算跟踪的路径的模式<code>.git/info/exclude</code>。默认为<code>$XDG_CONFIG_HOME/git/ignore</code>。如果<code>$XDG_CONFIG_HOME</code>未设置或为空，<code>$HOME/.config/git/ignore</code>则代替使用。见gitignore [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.askPass</p></div></div><div class="doc-postil"><div class="c-markdown"><p>交互式地询问密码的一些命令（例如 svn 和 http 接口）可以被告知使用通过该变量的值给出的外部程序。可以被<code>GIT_ASKPASS</code>环境变量覆盖。如果没有设置，则回退到<code>SSH_ASKPASS</code>环境变量的值，否则，提示一个简单的密码。应该给外部程序一个合适的提示符作为命令行参数，并在其 STDOUT 上写入密码。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.attributesFile</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除了<code>.gitattributes</code>（ per-directory ）之外<code>.git/info/attributes</code>，Git 会查看此文件的属性（请参阅 gitattributes [5] ）。路径扩展的制作方式与以前相同<code>core.excludesFile</code>。它的默认值是<code>$XDG_CONFIG_HOME/git/attributes</code>。如果<code>$XDG_CONFIG_HOME</code>未设置或为空，<code>$HOME/.config/git/attributes</code>则代替使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.hooksPath</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，Git 会在<code>$GIT_DIR/hooks</code>目录中查找你的钩子。将其设置为不同的路径，例如<code>/etc/git/hooks</code>，Git 将尝试在该目录中找到您的挂钩，例如，<code>/etc/git/hooks/pre-receive</code>而不是在 <code>$GIT_DIR/hooks/pre-receive</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>路径可以是绝对路径或相对路径。相对于挂钩运行的目录采取相对路径（请参阅 githooks [5] 的“描述”部分）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个配置变量在你希望集中配置你的 Git 钩子而不是在每个存储库上配置它们的情况下是有用的，或者作为一个更灵活和集中的替代方法来使<code>init.templateDir</code>你有一个你已经改变了默认钩子的地方。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.editor</p></div></div><div class="doc-postil"><div class="c-markdown"><p>诸如此类的命令<code>commit</code>以及<code>tag</code>允许您通过启动编辑器来编辑消息的命令会在设置时使用此变量的值，并且<code>GIT_EDITOR</code>未设置环境变量。参见 git-var [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.commentChar</p></div></div><div class="doc-postil"><div class="c-markdown"><p>诸如<code>commit</code>和<code>tag</code>可让您编辑消息的命令考虑以该字符注释开头的行，并在编辑器返回后将其删除（默认<code>#</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为“auto”，<code>git-commit</code>将选择不是现有提交消息中任何行的开始字符的字符。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.packedRefsTimeout</p></div></div><div class="doc-postil"><div class="c-markdown"><p>尝试锁定<code>packed-refs</code>文件时要重试的时间长度（以毫秒为单位）。值0意味着根本不会重试; -1意味着无限期地尝试。默认值是1000（即，重试1秒）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sequence.editor</p></div></div><div class="doc-postil"><div class="c-markdown"><p>文本编辑器用于<code>git rebase -i</code>编辑 rebase 指令文件。该值用于在 shell 中进行解释。它可以被<code>GIT_SEQUENCE_EDITOR</code>环境变量覆盖。未配置时，将使用默认的提交消息编辑器。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.pager</p></div></div><div class="doc-postil"><div class="c-markdown"><p>供 Git 命令使用的文本查看器（例如，<code>less</code>）。该值旨在由 shell 解释。首选项的顺序是<code>$GIT_PAGER</code>环境变量，然后是<code>core.pager</code>配置，然后<code>$PAGER</code>是编译时（通常<code>less</code>）选择的默认值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>LESS</code>环境变量未设置时，Git 将其设置为<code>FRX</code>（如果<code>LESS</code>设置了环境变量，则 Git 根本不会更改它）。如果你想有选择地覆盖 Git 的默认设置<code>LESS</code>，你可以设置<code>core.pager</code>为例如<code>less -S</code>。这将通过 Git 传递给 shell ，该命令将最终命令转换为<code>LESS=FRX less -S</code>。环境不会设置该<code>S</code>选项，但命令行会执行此操作，从而减少截断长行的问题。同样，设置<code>core.pager</code>为<code>less -+F</code>将<code>F</code>从命令行中禁用环境指定的选项，取消激活“如果一个屏幕退出”行为<code>less</code>。人们可以特别激活某些特定命令的标志：例如，设置<code>pager.blame</code>为<code>less -S</code>启用行截断仅用于<code>git blame</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>同样，当<code>LV</code>环境变量未设置时，Git 将其设置为<code>-c</code>。您可以通过<code>LV</code>使用另一个值或设置<code>core.pager</code>为导出来覆盖此设置<code>lv +c</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.whitespace</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用逗号分隔的常见空白问题列表需要注意。<code>git diff</code>将<code>color.diff.whitespace</code>用来突出显示它们，并将<code>git apply --whitespace=error</code>它们视为错误。你可以用前缀<code>-</code>来禁用它们中的任何一个（例如<code>-trailing-space</code>）：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>blank-at-eol</code> 将行末尾的空格视为错误（默认情况下启用）。</p></li><li><p><code>space-before-tab</code> 将行的最初缩进部分中的制表符之前出现的空格字符视为错误（默认情况下启用）。</p></li><li><p><code>indent-with-non-tab</code> 将用空格字符缩进的行代替等效的制表符作为错误（默认情况下未启用）。</p></li><li><p><code>tab-in-indent</code> 将行的初始缩进部分中的制表符视为错误（默认情况下未启用）。</p></li><li><p><code>blank-at-eof</code> 将在文件末尾添加的空行视为错误（默认情况下启用）。</p></li><li><p><code>trailing-space</code>是一种短手为覆盖<code>blank-at-eol</code>和<code>blank-at-eof</code>。</p></li><li><p><code>cr-at-eol</code>将行结束处的回车符视为行结束符的一部分，即使用它，<code>trailing-space</code>如果此回车符之前的字符不是空格（默认情况下未启用），则不会触发。</p></li><li><p><code>tabwidth=&lt;n&gt;</code>告诉标签占据多少个字符位置; 这<code>indent-with-non-tab</code>与 Git 修复<code>tab-in-indent</code>错误有关。默认的标签宽度是8.允许的值是1到63。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>core.fsyncObjectFiles</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个布尔值将<code>fsync()</code>在写入目标文件时启用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这是一个浪费时间和精力的文件系统，它可以正确地命令数据写入，但对于不使用日记功能（传统 UNIX 文件系统）的文件系统或只有日志元数据而不是文件内容（ OS X的HFS +或 Linux 带有 “data = writeback” 的 ext3 ）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.preloadIndex</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为类似的操作启用并行索引预加载 <code>git diff</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>这可以加快像操作<code>git diff</code>和<code>git status</code>特别是像 NFS 有弱缓存语义，因此相对较高的 IO 延迟的文件系统。启用后，Git 将并行执行与文件系统数据的索引比较，从而允许重叠 IO 。默认为 true 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.createObject</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以将其设置为<code>link</code>，在这种情况下，将使用硬链接并删除源，以确保创建对象不会覆盖现有对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在某些文件系统/操作系统组合上，这是不可靠的。将此配置设置设置为<code>rename</code>此处; 但是，这将删除确保现有对象文件不会被覆盖的检查。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.notesRef</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示提交消息时，还会显示存储在给定 ref 中的注释。参考资料必须完全合格。如果给定的 ref 不存在，这不是错误，但意味着不应打印任何注释。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该设置默认为 “refs / notes / commits” ，并且可以被<code>GIT_NOTES_REF</code>环境变量覆盖。参见 git-notes [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.sparseCheckout</p></div></div><div class="doc-postil"><div class="c-markdown"><p>启用“sparse checkout”功能。有关更多信息，请参阅 git-read-tree [1] 中的 “Sparse checkout” 一节。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>core.abbrev</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置长度对象名称缩写为。如果未指定或设置为 “auto” ，则根据存储库中的打包对象的近似数量计算适当的值，这对于缩写对象名称在一段时间内保持唯一性来说足够了。最小长度是4。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>add.ignoreErrors   add.ignore-errors (deprecated)</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git add</code>当由于索引错误而无法添加某些文件时，告诉继续添加文件。相当于<code>--ignore-errors</code> git-add [1] 的选项。<code>add.ignore-errors</code>已被弃用，因为它不遵循配置变量的通常命名约定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>alias.*</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git [1] 命令包装的命令别名 - 例如在定义 “alias.last = cat-file commit HEAD” 之后，调用 “git last” 等同于 “git cat-file commit HEAD” 。为避免混淆和脚本使用的麻烦，隐藏现有 Git 命令的别名将被忽略。参数用空格分开，支持常用的 shell 引用和转义。引用对或反斜杠可用于引用它们。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果别名扩展以感叹号为前缀，则将其视为 shell 命令。例如，定义 “alias.new =！gitk  -  all  -  not ORIG_HEAD” ，调用 “git new” 相当于运行shell命令 “gitk  -  all  -  not ORIG_HEAD” 。请注意，shell 命令将从存储库的顶级目录中执行，该目录可能不一定是当前目录。<code>GIT_PREFIX</code>被设置为<code>git rev-parse --show-prefix</code>从原始当前目录运行返回。参见 git-rev-parse [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>am.keepcr</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，那么 git-am 会调用 git-mailsplit 来获取带有参数的 mbox 格式的补丁<code>--keep-cr</code>。在这种情况下，git-mailsplit 不会<code>\r</code>从以<code>\r\n</code>。结尾的行中删除。可以通过<code>--no-keep-cr</code>从命令行提供来覆盖。参见 git-am [1] ，git-mailsplit [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>am.threeWay</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，<code>git am</code>如果修补程序不能干净地应用，将会失败。当设置为true时，<code>git am</code>如果补丁记录了它应该应用到的斑点的标识，并且我们在本地提供了这些斑点（相当于<code>--3way</code>从命令行提供选项），则此设置将告诉回退3路合并。默认为<code>false</code>。见 git-am [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>apply.ignoreWhitespace</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置为<code>change</code>时，将以与选项相同的方式告诉<code>git apply</code>忽略空白中的更改<code>--ignore-space-change</code>。当设置为：no，none，never 时，false  表示<code>git apply</code>尊重所有空白区别。参见 git-apply [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>apply.whitespace</p></div></div><div class="doc-postil"><div class="c-markdown"><p>讲述<code>git apply</code>如何处理空格，以同样的方式作为<code>--whitespace</code>选项。参见 git-apply [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>branch.autoSetupMerge</p></div></div><div class="doc-postil"><div class="c-markdown"><p>告诉<code>git branch</code>和<code>git checkout</code>设置新分支，以便 git-pull [1] 将从起点分支适当合并。请注意，即使未设置此选项，也可以使用<code>--track</code>和<code>--no-track</code>选项为每个分支选择此行为。有效的设置是：<code>false</code>- 没有自动设置完成; <code>true</code> - 当起始点是远程跟踪分支时，自动设置完成; <code>always</code> - 当起始点是本地分支或远程跟踪分支时，自动设置完成。该选项默认为 true 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>branch.autoSetupRebase</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当一个新的分支被创建<code>git branch</code>或<code>git checkout</code>跟踪另一个分支时，这个变量告诉 Git 设置 pull 来代替合并（参见 “branch。&lt;name&gt; .rebase” ）。何时<code>never</code>，rebase 永远不会自动设置为 true 。何时<code>local</code>，其他地方分行的追踪分行的 rebase 设置为 true 。<code>remote</code>对于远程跟踪分支的跟踪分支，当 rebase 设置为 true 时。何时<code>always</code>，所有跟踪分支的 rebase 将设置为 true 。有关如何设置分支以跟踪其他分支的详细信息，请参阅 “branch.autoSetupMerge” 。该选项默认为从不。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>branch.&lt;name&gt;.remote</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在分支&lt;名称&gt;上时，它会告知<code>git fetch</code>以及<code>git push</code>从哪个远程获取/推送。推送到远程可能会覆盖<code>remote.pushDefault</code>（对于所有分支机构）。推送到当前分支的远程可能会被进一步覆盖<code>branch.&lt;name&gt;.pushRemote</code>。如果没有配置远程设备，或者您不在任何分支上，则默认为<code>origin</code>进行抓取和<code>remote.pushDefault</code>推送。此外，<code>.</code>（一段时间）是当前的本地存储库（一个点存储库），请参见<code>branch.&lt;name&gt;.merge</code>下面的最终注释。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>branch.&lt;name&gt;.pushRemote</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在分支 &lt;name&gt; 上时，它将覆盖<code>branch.&lt;name&gt;.remote</code>推送。它也覆盖<code>remote.pushDefault</code>从分支 &lt;name&gt; 推送。当你从一个地方（例如你的上游）拉到另一个地方（例如你自己的发布库）时，你需要设置<code>remote.pushDefault</code>指定远程推送到所有分支，并使用这个选项覆盖特定的科。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>branch.&lt;name&gt;.merge</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与branch。&lt;name&gt; .remote 一起定义给定分支的上游分支。它告诉<code>git fetch</code>/ <code>git pull</code>/ <code>git rebase</code>该分支合并，也可以影响<code>git push</code>（见 push.default ）。当在分支 &lt;name&gt; 中时，它告诉<code>git fetch</code>默认refspec被标记为在 FETCH_HEAD 中合并。该值的处理方式与 refspec 的远程部分相同，并且必须匹配从 “branch。&lt;name&gt; .remote” 给出的来自远程的 ref 。合并信息由<code>git pull</code>（首先调用<code>git fetch</code>）查找用于合并的默认分支使用。如果没有这个选项，<code>git pull</code>默认情况下合并第一个获取的 refspec 。指定多个值以获得章鱼合并。如果你想设置<code>git pull</code>以便它从本地存储库中的另一个分支合并到 &lt;name&gt; 中，可以将分支。&lt;name&gt; .merge 指向所需的分支，并使用分支的相对路径设置<code>.</code>（句点）。&lt;name&gt; .remote 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>branch.&lt;name&gt;.mergeOptions</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置合并到分支 &lt;name&gt; 的默认选项。语法和支持的选项与 git-merge [1] 的相同，但包含空白字符的选项值目前不受支持。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>branch.&lt;name&gt;.rebase</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则在获取的分支上重新分支分支 &lt;name&gt; ，而不是在运行 “git pull” 时将默认分支与默认分支合并。请参阅 “pull.rebase” 以非分支特定的方式执行此操作。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当保存时，也会传递<code>--preserve-merges</code>到，<code>git rebase</code>以便本地提交的合并提交不会因运行而变得平坦<code>git pull</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当值为时<code>interactive</code>，rebase 以交互模式运行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><strong>注意</strong>：这是一个可能危险的操作; 你<strong>不</strong>，除非你理解的含义使用它（请查看 git-rebase[1]了解详细信息）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>branch.&lt;name&gt;.description</p></div></div><div class="doc-postil"><div class="c-markdown"><p>分支描述，可以用编辑<code>git branch --edit-description</code>。分支描述将自动添加到格式补丁封面信或请求摘要中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>browser.&lt;tool&gt;.cmd</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定要调用指定浏览器的命令。指定的命令在 shell 中使用作为参数传递的 URL 进行评估。（请参阅 git-web {litdd} 浏览[1]。）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>browser.&lt;tool&gt;.path</p></div></div><div class="doc-postil"><div class="c-markdown"><p>覆盖可能用于浏览 HTML 帮助的指定工具的路径（请参阅<code>-w</code> git-help [1] 中的选项）或 gitweb 中的工作存储库（请参阅 git-instaweb [1] ）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>clean.requireForce</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个布尔值使 git-clean 除非给出 -f ，-i 或 -n ，否则不会执行任何操作。默认为 true 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.branch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在 git-branch [1] 的输出中启用/禁用颜色的布尔值。可以设置为<code>always</code>，<code>false</code>（或<code>never</code>）或<code>auto</code>（或<code>true</code>），在这种情况下，颜色仅在输出到终端时使用。如果未设置，则使用该值<code>color.ui</code>（<code>auto</code>默认情况下）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.branch.&lt;slot&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用自定义颜色进行分支着色。<code>&lt;slot&gt;</code>是<code>current</code>（当前分支），<code>local</code>（本地分支），<code>remote</code>（远程跟踪分支在 refs / remotes / ），<code>upstream</code>（上游跟踪分支），<code>plain</code>（其他参考）之一。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.diff</p></div></div><div class="doc-postil"><div class="c-markdown"><p>是否使用 ANSI 转义序列为补丁添加颜色。如果设置为<code>always</code>，git-diff [1]，git-log [1] 和 git-show [1] 将为所有补丁使用颜色。如果设置为<code>true</code>或<code>auto</code>，则这些命令仅在输出到终端时才使用颜色。如果未设置，则使用该值<code>color.ui</code>（<code>auto</code>默认情况下）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这不会影响 git-format-patch [1] 或<code>git-diff-*</code>管道命令。可以使用该<code>--color[=&lt;when&gt;]</code>选项在命令行上覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.diff.&lt;slot&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用自定义颜色进行差异着色。<code>&lt;slot&gt;</code>指定补丁的哪个部分使用指定的颜色，并且是<code>context</code>（上下文文本 - <code>plain</code>是历史同义词），<code>meta</code>（元信息），<code>frag</code>（ hunk 标题），<code>func</code>（ hunk 标题中的功能），<code>old</code>（删除的行），<code>new</code>（添加的行），<code>commit</code>（提交标题）或<code>whitespace</code>（突出显示空白错误）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.decorate.&lt;slot&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用自定义颜色进行<code>git log --decorate</code>输出。<code>&lt;slot&gt;</code>是以下之一<code>branch</code>，<code>remoteBranch</code>，<code>tag</code>，<code>stash</code>或<code>HEAD</code>为本地分支机构，远程跟踪分支，标签，分别藏匿和 HEAD 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.grep</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置为<code>always</code>时，始终突出显示匹配项。何时<code>false</code>（或<code>never</code>），永远不会。设置为<code>true</code>或时<code>auto</code>，仅在输出写入终端时使用颜色。如果未设置，则使用该值<code>color.ui</code>（<code>auto</code>默认情况下）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.grep.&lt;slot&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用自定义颜色进行 grep 着色。<code>&lt;slot&gt;</code>指定使用指定颜色的线的哪一部分，并且是其中之一</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>context</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>上下文行中不匹配的文本（使用<code>-A</code>时<code>-B</code>，或<code>-C</code>）</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>filename</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>文件名前缀（不使用时<code>-h</code>）</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>function</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>功能名称行（使用时<code>-p</code>）</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>linenumber</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>行号前缀（使用时<code>-n</code>）</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>match</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>匹配的文本（同设定<code>matchContext</code>和<code>matchSelected</code>）</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>matchContext</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>匹配上下文行中的文本</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>matchSelected</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>匹配选定行中的文本</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>selected</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>选定行中不匹配的文本</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>separator</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>上的线之间的字段分离器（<code>:</code>，<code>-</code>，和<code>=</code>）和厚片之间（<code>--</code>）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.interactive</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置为时<code>always</code>，总是使用交互式提示和显示的颜色（例如 “git-add --interactive” 和 “git-clean --interactive” 使用的颜色）。当错误（或<code>never</code>），从不。设置为<code>true</code>或时<code>auto</code>，仅在输出到终端时才使用颜色。如果未设置，则使用该值<code>color.ui</code>（<code>auto</code>默认情况下）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.interactive.&lt;slot&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用自定义的颜色<code>git add --interactive</code>和<code>git clean --interactive</code>输出。<code>&lt;slot&gt;</code>可以是<code>prompt</code>，<code>header</code>，<code>help</code>或<code>error</code>，用于从交互式命令四个不同类型的正常输出的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.pager</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当传呼机正在使用时启用/禁用彩色输出的布尔值（默认值为 true ）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.showBranch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在 git-show-branch [1] 的输出中启用/禁用颜色的布尔值。可以设置为<code>always</code>，<code>false</code>（或<code>never</code>）或<code>auto</code>（或<code>true</code>），在这种情况下，颜色仅在输出到终端时使用。如果未设置，则使用该值<code>color.ui</code>（<code>auto</code>默认情况下）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.status</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在 git-status [1] 的输出中启用/禁用颜色的布尔值。可以设置为<code>always</code>，<code>false</code>（或<code>never</code>）或<code>auto</code>（或<code>true</code>），在这种情况下，颜色仅在输出到终端时使用。如果未设置，则使用该值<code>color.ui</code>（<code>auto</code>默认情况下）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.status.&lt;slot&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用自定义颜色进行状态着色。<code>&lt;slot&gt;</code>是<code>header</code>（状态消息的标题文本），<code>added</code>或<code>updated</code>（已添加但未提交的<code>changed</code>文件），（已更改但未添加到索引中的<code>untracked</code>文件），（未由 Git 跟踪的文件），<code>branch</code>（当前分支），<code>nobranch</code>（<code>no branch</code>警告显示的颜色，默认为红色）<code>localBranch</code>或<code>remoteBranch</code>（当分支和跟踪信息以状态短格式显示时，分别为本地和远程分支名称）或<code>unmerged</code>（未合并更改的文件）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>color.ui</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此变量确定变量的默认值，例如<code>color.diff</code>和<code>color.grep</code>控制每个命令系列的颜色使用。随着更多命令学习配置以设置<code>--color</code>选项的默认值，其范围将扩大。将其设置为<code>false</code>或者<code>never</code>如果您希望 Git 命令不使用颜色，除非通过某些其他配置或<code>--color</code>选项明确启用。将它设置为<code>always</code>你希望不希望所有的输出机消费使用的颜色，来<code>true</code>或<code>auto</code>（这是因为 Git 的1.8.4默认值），如果你希望在写入到终端，输出使用的颜色。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>column.ui</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定是否应以列的形式输出支持的命令。该变量由用空格或逗号分隔的令牌列表组成：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项控制何时启用该功能（默认为<code>never</code>）：</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>always</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>始终显示在列中</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>never</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>从不显示在列中</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>auto</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果输出到终端，则以列显示</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项控制布局（默认为<code>column</code>）。将上述任何暗示<code>always</code>，如果没有的<code>always</code>，<code>never</code>或<code>auto</code>指定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>column</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>在行之前填充列</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>row</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>在列之前填充行</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>plain</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示在一列中</p></div></div><div class="doc-postil"><div class="c-markdown"><p>最后，这些选项可以与布局选项（默认为<code>nodense</code>）结合使用：</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>dense</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>制造不同尺寸的列以利用更多的空间</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>nodense</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>制作相同大小的列</p></div></div><div class="doc-postil"><div class="c-markdown"><p>column.branch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定是否<code>git branch</code>在列中输出分支列表。详情请参阅<code>column.ui</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>column.clean</p></div></div><div class="doc-postil"><div class="c-markdown"><p>列出项目时指定布局<code>git clean -i</code>，它总是以列显示文件和目录。详情请参阅<code>column.ui</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>column.status</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定是否<code>git status</code>在列中输出未跟踪文件。详情请参阅<code>column.ui</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>column.tag</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定是否<code>git tag</code>在列中输出标签列表。详情请参阅<code>column.ui</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>commit.cleanup</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此设置将覆盖该<code>--cleanup</code>选项的默认值<code>git commit</code>。有关详细信息，请参阅 git-commit [1] 。如果您始终想要<code>#</code>在日志消息中保留以注释字符开头的行，那么更改默认值可能很有用，在这种情况下您会这样做<code>git config commit.cleanup whitespace</code>（请注意，您必须自己移除<code>#</code>以提交日志模板开头的帮助行，如果你这样做）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>commit.gpgSign</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个布尔值，指定是否所有提交都应该进行 GPG 签名。在执行诸如 rebase 之类的操作时使用此选项可能会导致大量提交被签名。使用代理可能会很方便，以避免多次输入您的 GPG 密码。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>commit.status</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用编辑器准备提交消息时，在提交消息模板中启用/禁用包含状态信息的布尔值。默认为 true 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>commit.template</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定要用作新提交消息模板的文件的路径名。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>commit.verbose</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个 boolean 或 int 来指定详细级别<code>git commit</code>。请参阅 git-commit [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>credential.helper</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定需要用户名或密码凭证时调用的外部助手; 帮助者可以咨询外部存储器以避免提示用户输入凭证。请注意，可能会定义多个助手。有关详细信息，请参阅 gitcredentials [7] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>credential.useHttpPath</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在获取凭证时，请考虑 http 或 https URL 的“路径”组件非常重要。默认为 false 。请参阅 gitcredentials [7] 了解更多信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>credential.username</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果没有为网络身份验证设置用户名，则默认使用此用户名。请参阅凭证。&lt;context&gt;.* 以下和 gitcredentials [7] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>credential.&lt;url&gt;.*</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以上任何 credential.* 选项都可以选择性地应用于某些凭证。例如，“credential.https：//example.com.username” 将只为 https 连接到 example.com 设置默认用户名。有关 URL 如何匹配的详细信息，请参阅 gitcredentials [7] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>credentialCache.ignoreSIGHUP</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Tell git-credential-cache—daemon to ignore SIGHUP, instead of quitting.</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.autoRefreshIndex</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在使用<code>git diff</code>与工作树文件进行比较时，不要将仅统计更改视为已更改。相反，静静地运行<code>git update-index --refresh</code>以更新其工作树中的内容与索引中的内容匹配的路径的缓存统计信息。该选项默认为 true 。请注意，这仅影响<code>git diff</code>瓷器，而不影响较低等级的<code>diff</code>命令<code>git diff-files</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.dirstat</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以逗号分隔的<code>--dirstat</code>参数列表，指定<code>--dirstat</code>选项的默认行为，以 git-diff [1] <code>and friends. The defaults can be overridden on the command line (using</code> --dirstat = &lt; param1，param2，... &gt; <code>). The fallback defaults (when not changed by</code>diff.dirstat <code>) are</code>更改，非累积，3`。以下参数可用：</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>changes</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过计算已从源中删除或添加到目标的行来计算 dirstat 数字。这会忽略文件中纯代码移动的数量。换句话说，重新排列文件中的行数不会与其他更改一样多。这是没有给出参数时的默认行为。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>lines</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过执行常规基于行的差异分析来计算 dirstat 数字，并且将移除/添加的行数相加。（对于二进制文件，取而代之的是计算64字节的块，因为二进制文件没有自然的行概念）。这是一种<code>--dirstat</code>比<code>changes</code>行为更为昂贵的行为，但它可以像其他更改一样对文件中的重新排列的行进行计数。结果输出与您从其他<code>--*stat</code>选项中获得的结果一致。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>files</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过计算更改的文件数量来计算 dirstat 数字。dirstat 分析中每个更改的文件都相同。这是计算上最便宜的<code>--dirstat</code>行为，因为它根本不需要查看文件内容。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>cumulative</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>计数父目录的子目录中的更改。请注意，使用时<code>cumulative</code>，报告的百分比总和可能超过100％。默认（非累积）行为可以用<code>noncumulative</code>参数指定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;limit&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>整数参数指定截断百分比（默认为3％）。输出中不显示贡献小于此百分比的目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>示例：以下内容将计数已更改的文件，同时忽略占已更改文件总数少于10％的目录，并累积父目录中的子目录计数：<code>files,10,cumulative</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.statGraphWidth</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在 --stat  输出中限制图形部分的宽度。如果设置，则适用于所有生成 --stat 输出的命令，格式补丁除外。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.context</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用 &lt;n&gt; 行上下文生成差异，而不是缺省值3.此值由 -U 选项覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.interHunkContext</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示差异 hunk 之间的上下文，直到指定的行数，从而融合彼此接近的 hunk 。该值用作<code>--inter-hunk-context</code>命令行选项的默认值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.external</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果此配置变量已设置，则不会使用内部差异机制执行差异生成，而是使用给定的命令。可以用 'GIT_EXTERNAL_DIFF' 环境变量覆盖。如 git [1] 中的 “git Diffs” 所述，使用参数调用该命令。注意：如果您只想在文件的子集上使用外部差异程序，则可能需要使用 gitattributes [5] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.ignoreSubmodules</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置 --ignore 子模块的默认值。请注意，这仅影响<code>git diff</code>瓷器，而不影响较低等级的<code>diff</code>命令<code>git diff-files</code>。<code>git checkout</code>在报告未提交的更改时也会尊重此设置。将其设置为<code>all</code>禁用通常显示的子模块摘要，<code>git commit</code>并设置<code>git status</code>何时<code>status.submoduleSummary</code>设置，除非使用 --ignore-submodules 命令行选项覆盖子摘要。该<code>git submodule</code>命令不受此设置的影响。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.mnemonicPrefix</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置，则<code>git diff</code>使用与标准 “a /” 和 “b /” 不同的前缀对，具体取决于所比较的内容。当此配置生效时，反向差分输出也会交换前缀的顺序：</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git diff</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>比较（i)ndex 和（w)ork 树;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git diff HEAD</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>比较（c)ommit 和（w)ork 树;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git diff --cached</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>比较（c)ommit 和（i)ndex ;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git diff HEAD:file1 file2</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>比较（o)bject 和（w)ork 树实体;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git diff --no-index a b</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>比较两个非 Git 事物（1）和（2）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.noprefix</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置，<code>git diff</code>则不显示任何源或目标前缀。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.orderFile</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指示如何在差异中排序文件的文件。有关<code>-O</code>详细信息，请参阅 git-diff [1] 选项。如果<code>diff.orderFile</code>是相对路径名，则将其视为相对于工作树的顶部。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.renameLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>执行复制/重命名检测时要考虑的文件数量; 相当于<code>git diff</code>选项<code>-l</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.renames</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 是否以及如何检测重命名。如果设置为 “false” ，则重命名检测被禁用。如果设置为 “true” ，则启用基本重命名检测。如果设置为“复制”或“复制”，Git 也会检测副本。默认为 true 。请注意，这只会影响<code>git diff</code>瓷器，如 git-diff [1] 和 git-log [1] ，而不是像 git-diff-files [1] 这样的低级命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.suppressBlankEmpty</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个布尔值，用于禁止在每个空输出行之前打印空间的标准行为。默认为 false 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.submodule</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定显示子模块差异的格式。“short” 格式只显示范围开始和结束处的提交名称。“日志”格式列出了像 git-submodule [1] <code>summary</code>这样的提交范围。“diff” 格式显示子模块已更改内容的内嵌比较。默认为“short”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.wordRegex</p></div></div><div class="doc-postil"><div class="c-markdown"><p>POSIX 扩展正则表达式用于在执行逐字差异计算时确定什么是“单词”。与正则表达式匹配的字符序列是“单词”，所有其他字符都是可<strong>忽略的</strong>空格。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.&lt;driver&gt;.command</p></div></div><div class="doc-postil"><div class="c-markdown"><p>自定义比较驱动程序命令。有关详细信息，请参阅 gitattributes [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.&lt;driver&gt;.xfuncname</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff 驱动程序应该用来识别大块头的正则表达式。内置模式也可以使用。有关详细信息，请参阅 gitattributes [5] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.&lt;driver&gt;.binary</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将此选项设置为 true 以使 diff 驱动程序将文件视为二进制文件。有关详细信息，请参阅 gitattributes [5] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.&lt;driver&gt;.textconv</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff 驱动程序应调用的命令来生成文件的文本转换版本。转换结果用于生成人类可读的差异。有关详细信息，请参阅 gitattributes [5] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.&lt;driver&gt;.wordRegex</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff 驱动程序应该用来将文本分成一行的正则表达式。有关详细信息，请参阅 gitattributes [5] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.&lt;driver&gt;.cachetextconv</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将此选项设置为 true 可使 diff 驱动程序缓存文本转换输出。有关详细信息，请参阅 gitattributes [5] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.tool</p></div></div><div class="doc-postil"><div class="c-markdown"><p>控制哪些 diff 工具被 git-difftool [1] 使用。此变量覆盖在中配置的值<code>merge.tool</code>。下面的列表显示了有效的内置值。任何其他值都被视为自定义比较工具，并要求定义相应的 difftool 。&lt;tool&gt; .cmd 变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>araxis</p></li><li><p>bc</p></li><li><p>bc3</p></li><li><p>codecompare</p></li><li><p>deltawalker</p></li><li><p>diffmerge</p></li><li><p>diffuse</p></li><li><p>ecmerge</p></li><li><p>emerge</p></li><li><p>examdiff</p></li><li><p>gvimdiff</p></li><li><p>gvimdiff2</p></li><li><p>gvimdiff3</p></li><li><p>kdiff3</p></li><li><p>kompare</p></li><li><p>meld</p></li><li><p>opendiff</p></li><li><p>p4merge</p></li><li><p>tkdiff</p></li><li><p>vimdiff</p></li><li><p>vimdiff2</p></li><li><p>vimdiff3</p></li><li><p>winmerge</p></li><li><p>xxdiff</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.indentHeuristic</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将此选项设置<code>true</code>为启用实验启发式方法，可以改变差异边界以使修补程序更易于阅读。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.algorithm</p></div></div><div class="doc-postil"><div class="c-markdown"><p>选择一种差异算法。变体如下：</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>default</code>, <code>myers</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>基本 diff 算法。目前，这是默认设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>minimal</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>花费额外的时间来确保生成最小可能的差异。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>patience</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>生成补丁时使用“耐心差异”算法。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>histogram</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>该算法将耐心算法扩展为“支持低出现率的通用元素”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>diff.wsErrorHighlight</p></div></div><div class="doc-postil"><div class="c-markdown"><p>突出显示空白的错误<code>context</code>，<code>old</code>或者<code>new</code>把差异线。多个值以逗号分隔，<code>none</code>重置以前的值，<code>default</code>将列表重置为<code>new</code>并<code>all</code>简写为<code>old,new,context</code>。空白错误使用了颜色<code>color.diff.whitespace</code>。命令行选项<code>--ws-error-highlight=&lt;kind&gt;</code>覆盖此设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>difftool.&lt;tool&gt;.path</p></div></div><div class="doc-postil"><div class="c-markdown"><p>覆盖给定工具的路径。如果您的工具不在 PATH 中，这非常有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>difftool.&lt;tool&gt;.cmd</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定用于调用指定的 diff 工具的命令。指定的命令在 shell 中用以下可用变量评估：<code>LOCAL</code>设置为包含 diff 预映像<code>REMOTE</code>内容的临时文件的名称，并设置为包含 diff 后映像内容的临时文件的名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>difftool.prompt</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在每次调用 diff 工具前提示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>fastimport.unpackLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果通过 git-fast-import [1] 导入的对象数量低于此限制，则这些对象将被解压缩为松散的对象文件。但是，如果导入对象的数量等于或超过此限制，那么该包将作为一个包进行存储。从快速导入存储包可以使导入操作更快完成，特别是在慢速文件系统上。如果未设置，<code>transfer.unpackLimit</code>则使用其值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>fetch.recurseSubmodules</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项可以设置为布尔值或设置为<code>on-demand</code>。将其设置为布尔变量时，会将抓取和拉动的行为更改为设置为 true 时无条件地递归到子模块中，或者在设置为 false 时将其无法递归。设置为<code>on-demand</code>（默认值）时，只有在其超级项目检索用于更新子模块参考的提交时，提取和拉取才会递归到已填充的子模块中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>fetch.fsckObjects</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果它设置为 true ，git-fetch-pack 将检查所有提取的对象。如果格式错误的对象或链接断开，它将中止。中止的结果只是悬挂的对象。默认为 false 。如果未设置，<code>transfer.fsckObjects</code>则使用其值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>fetch.unpackLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果通过 Git 本地传输获取的对象数量低于此限制，则这些对象将被解包为松散的对象文件。但是，如果接收到的对象数量等于或超过此限制，则在添加任何缺少的增量基数后，接收的数据包将作为一个包存储。从推存储包可以使推送操作更快完成，特别是在慢速文件系统上。如果未设置，<code>transfer.unpackLimit</code>则使用其值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>fetch.prune</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true ，那么 fetch 将自动运行，就像<code>--prune</code>在命令行上给出选项一样。另见<code>remote.&lt;name&gt;.prune</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>fetch.output</p></div></div><div class="doc-postil"><div class="c-markdown"><p>控制如何打印参考更新状态。有效值是<code>full</code>和<code>compact</code>。默认值是<code>full</code>。有关详细信息，请参见 git-fetch [1] 中的 OUTPUT 部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.attach</p></div></div><div class="doc-postil"><div class="c-markdown"><p>启用多部分/混合附件作为默认值<code>format-patch</code>。该值也可以是一个双引号字符串，它将启用附件作为默认值并将该值设置为边界。请参阅 git-format-patch [1] 中的 --attach 选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.from</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提供<code>--from</code> format-patch 选项的默认值。接受布尔值，或名称和电子邮件地址。如果为 false ，format-patch 默认为<code>--no-from</code>，直接在补丁邮件的 “From：” 字段中使用提交作者。如果为 true ，format-patch 将默认为<code>--from</code>：在补丁邮件的“发件人：”字段中使用提交者标识，如果不同，则在补丁邮件正文中包含“发件人：”字段。如果设置为非布尔值，format-patch 将使用该值而不是提交者标识。默认为 false 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.numbered</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个布尔值，可以启用或禁用补丁主题中的序列号。它默认为“自动”，只有在有多个补丁时才启用它。通过将其设置为 “true” 或 “false” ，可以启用或禁用所有消息。请参阅 git-format-patch [1] 中的 --numbered 选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.headers</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要通过邮件提交的补丁包含的其他电子邮件标题。参见 git-format-patch [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.to   format.cc</p></div></div><div class="doc-postil"><div class="c-markdown"><p>其他收件人将包含在通过邮件提交的补丁中。请参阅 git-format-patch [1] 中的 --to 和 --cc 选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.subjectPrefix</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format-patch 的默认设置是输出带有<code>[PATCH]</code>主题前缀的文件。使用此变量来更改该前缀。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.signature</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format-patch 的默认值是输出包含 Git 版本号的签名。使用此变量来更改该默认值。将此变量设置为空字符串（“”）以抑制签名生成。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.signatureFile</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与 format.signature 一样工作，除了由该变量指定的文件内容将用作签名。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.suffix</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format-patch 的默认值是输出带有后缀的文件<code>.patch</code>。使用此变量来更改该后缀（如果需要，请确保包含点）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.pretty</p></div></div><div class="doc-postil"><div class="c-markdown"><p>log / show / whatchanged 命令的默认漂亮格式，请参阅 git-log [1]，git-show [1]，git-whatchanged [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.thread</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认的线程风格<code>git format-patch</code>。可以是布尔值或<code>shallow</code>or <code>deep</code>。<code>shallow</code>线程使得每一封邮件都可以回复该系列的头部，头部从封面信件，<code>--in-reply-to</code>第一个补丁邮件中按顺序选择。<code>deep</code>线程使每个邮件回复到前一个邮件。一个真正的布尔值是相同的<code>shallow</code>，而一个错误的值会禁用线程。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.signOff</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>-s/--signoff</code>默认情况下允许启用 format-patch 选项的布尔值。<strong>注意：</strong>将Signed-off-by：行添加到补丁应该是有意识的行为，并且意味着您证明您有权在相同的开源许可下提交此项工作。请参阅<code>SubmittingPatches</code>文档以作进一步讨论。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.coverLetter</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个布尔值，用于控制是否在调用 format-patch 时生成封面字母，但另外可以设置为“auto”，以便仅在存在多个修补程序时才生成封面字母。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.outputDirectory</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置一个自定义目录来存储结果文件，而不是当前的工作目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>format.useAutoBase</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--base=auto</code>默认情况下允许启用 format-patch 选项的布尔值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>filter.&lt;driver&gt;.clean</p></div></div><div class="doc-postil"><div class="c-markdown"><p>签入时用于将工作树文件的内容转换为斑点的命令。有关详细信息，请参阅 gitattributes [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>filter.&lt;driver&gt;.smudge</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用于在签出时将 blob 对象的内容转换为工作树文件的命令。有关详细信息，请参阅 gitattributes [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>fsck.&lt;msg-id&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>允许覆盖特定消息标识的消息类型（错误，警告或忽略），例如<code>missingEmail</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为了方便起见，fsck 在错误/警告前添加了消息 ID，例如“missingEmail：invalid author / committer line  -  missing email”意味着该设置<code>fsck.missingEmail = ignore</code>将隐藏该问题。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此功能旨在支持使用旧版存储库，而这些存储库在不发生破坏性更改的情况下无法修复。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>fsck.skipList</p></div></div><div class="doc-postil"><div class="c-markdown"><p>已知以非致命方式破坏的对象名称的排序列表（即每行一个 SHA-1）的路径应被忽略。如果尽早提交包含可安全忽略的错误（如无效的提交者电子邮件地址）的应用程序，则应接受已建立的项目，此功能非常有用。注意：使用此设置不能跳过损坏的对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.aggressiveDepth</p></div></div><div class="doc-postil"><div class="c-markdown"><p>深度参数用于由 delta 压缩算法使用<code>git gc --aggressive</code>。默认值为50。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.aggressiveWindow</p></div></div><div class="doc-postil"><div class="c-markdown"><p>窗口大小参数用于由 delta 压缩算法使用<code>git gc --aggressive</code>。这默认为250。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.auto</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果存储库中的这些松散对象的数量大约超过了这个数量，<code>git gc --auto</code>则会将它们打包。一些 Porcelain 命令使用此命令不时执行轻量级垃圾回收。默认值为6700.将其设置为0将禁用它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.autoPackLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>*.keep</code>存储库中存在多个未标记文件的包，则会<code>git gc --auto</code>将它们合并到一个更大的包中。默认值为50.将其设置为0将禁用它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.autoDetach</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请<code>git gc --auto</code>立即返回，并在后台运行，如果系统支持它。默认值是 true。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.logExpiry</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果文件 gc.log 存在，则<code>git gc --auto</code>不会运行，除非该文件比<code>gc.logExpiry</code>旧版本更老。默认是“1.day”。请参阅<code>gc.pruneExpire</code>更多指定其值的方法。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.packRefs</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git pack-refs</code>在存储库中运行会使其无法通过1.5.1.2之前的Git版本在诸如HTTP之类的哑传输上进行克隆。这个变量决定了是否<code>git gc</code>运行<code>git pack-refs</code>。可以将其设置为<code>notbare</code>在所有非裸回购库中启用它，或者可以将其设置为布尔值。默认是<code>true</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.pruneExpire</p></div></div><div class="doc-postil"><div class="c-markdown"><p>什么时候<code>git gc</code>运行，它会调用<code>prune --expire 2.weeks.ago</code>。用此配置变量覆盖宽限期。值“now”可用于禁用此宽限期并且总是立即修剪不可到达的对象，或者可以使用“never”来抑制修剪。此功能有助于防止在<code>git gc</code>与另一个写入存储库的进程同时运行时发生损坏; 请参阅git-gc [1]的“NOTES”部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.worktreePruneExpire</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>git gc</code>运行时，它调用<code>git worktree prune --expire 3.months.ago</code>。此配置变量可用于设置不同的宽限期。值“now”可用于禁用宽限期并<code>$GIT_DIR/worktrees</code>立即修剪，或者“never”可用于抑制修剪。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.reflogExpire   gc.&lt;pattern&gt;.reflogExpire</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git reflog expire</code>删除比此时早的reflog条目; 默认为90天。值“now”立即使所有条目到期，并且“never”完全禁止到期。在中间，使用“&lt;pattern&gt;”（例如“refs / stash”），该设置仅适用于匹配&lt;pattern&gt;的ref。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.reflogExpireUnreachable   gc.&lt;pattern&gt;.reflogExpireUnreachable</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git reflog expire</code>删除比这次更早的reflog条目，并且不能从当前提示中获得; 默认为30天。值“now”立即使所有条目到期，并且“never”完全禁止到期。在中间使用“&lt;pattern&gt;”（例如“refs / stash”），该设置仅适用于匹配&lt;pattern&gt;的ref。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.rerereResolved</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您以前解决的冲突合并记录在<code>git rerere gc</code>运行时会保留这么多天。缺省值是60天。参见git-rerere [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gc.rerereUnresolved</p></div></div><div class="doc-postil"><div class="c-markdown"><p>运行时，您尚未解决的冲突合并记录会保留多天<code>git rerere gc</code>。默认值是15天。参见git-rerere [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.commitMsgAnnotation</p></div></div><div class="doc-postil"><div class="c-markdown"><p>追加此字符串到每个提交消息。设置为空字符串以禁用此功能。默认为“通过git-CVS模拟器”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.enabled</p></div></div><div class="doc-postil"><div class="c-markdown"><p>是否为此存储库启用了 CVS 服务器接口。参见git-cvsserver [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.logFile</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指向 CVS 服务器接口的日志文件的路径...记录各种东西。参见git-cvsserver [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.usecrlfattr</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则服务器将查找文件的行尾转换属性以确定<code>-k</code>要使用的模式。如果这些属性强制 Git 将文件视为文本，则该<code>-k</code>模式将保留为空，以便 CVS 客户端将其视为文本。如果他们禁止文本转换，文件将被设置为<code>-kb</code>模式，这会抑制客户端可能执行的任何换行。如果属性不允许确定文件类型，则<code>gitcvs.allBinary</code>使用该属性。见gitattributes [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.allBinary</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>gitcvs.usecrlfattr</code>不解决使用正确的<code>-kb</code>模式，则使用此选项。如果为true，则所有未解析的文件将以模式发送到客户端<code>-kb</code>。这会导致客户端将它们视为二进制文件，这会压制任何换行符，否则可能会这样做。或者，如果它被设置为“猜测”，则检查文件的内容以确定它是否是二进制的，类似于<code>core.autocrlf</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.dbName</p></div></div><div class="doc-postil"><div class="c-markdown"><p>数据库由 git-cvsserver 用来缓存来自 Git 仓库的修订信息。确切的含义取决于使用的数据库驱动程序，对于 SQLite（这是默认驱动程序），这是一个文件名。支持变量替换（详情请参阅git-cvsserver [1]）。不能包含分号（<code>;</code>）。默认：<code>%Ggitcvs.%m.sqlite</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.dbDriver</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用 Perl DBI 驱动程序。你可以在这里指定任何可用的驱动程序，但它可能不起作用。git-cvsserver已经过测试<code>DBD::SQLite</code>，报告可以使用<code>DBD::Pg</code>，并报告<strong>不能</strong>使用<code>DBD::mysql</code>。实验功能。不能包含双冒号（<code>:</code>）。默认：<code>SQLite</code>。参见git-cvsserver [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.dbUser, gitcvs.dbPass</p></div></div><div class="doc-postil"><div class="c-markdown"><p>数据库用户和密码。只有在设置时才有用<code>gitcvs.dbDriver</code>，因为SQLite 没有数据库用户和/或密码的概念。<code>gitcvs.dbUser</code>支持变量替换（详见git-cvsserver [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs.dbTableNamePrefix</p></div></div><div class="doc-postil"><div class="c-markdown"><p>数据库表名称前缀。用于所使用的任何数据库表的名称，允许单个数据库用于多个存储库。支持变量替换（详情请参阅 git-cvsserver [1]）。任何非字母字符将被替换为下划线。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>所有 gitcvs 变量，除了<code>gitcvs.usecrlfattr</code>和<code>gitcvs.allBinary</code>也可以被指定为<code>gitcvs.&lt;access_method&gt;.&lt;varname&gt;</code>（其中<code>access_method</code>是“ext”和“pserver”之一），使它们仅适用于给定的访问方法。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitweb.category   gitweb.description   gitweb.owner   gitweb.url</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关说明，请参阅gitweb [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gitweb.avatar   gitweb.blame   gitweb.grep   gitweb.highlight   gitweb.patches   gitweb.pickaxe   gitweb.remote_heads   gitweb.showSizes   gitweb.snapshot</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关说明，请参阅gitweb.conf [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>grep.lineNumber</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为true，则<code>-n</code>默认启用选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>grep.patternType</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置默认的匹配行为。使用值<code>basic</code>，<code>extended</code>，<code>fixed</code>，或<code>perl</code>将启用<code>--basic-regexp</code>，<code>--extended-regexp</code>，<code>--fixed-strings</code>，或<code>--perl-regexp</code>相应的选项，而值<code>default</code>将返回到默认匹配行为。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>grep.extendedRegexp</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true，则<code>--extended-regexp</code>默认启用选项。当该<code>grep.patternType</code>选项设置为非。时，该选项将被忽略<code>default</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>grep.threads</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要使用的 grep 工作线程数。请参阅<code>grep.threads</code>git-grep [1] 以获取更多信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>grep.fallbackToNoIndex</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true，则回退到 git grep --no-index，如果 git grep 在git 存储库之外执行。默认为 false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gpg.program</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在制作或验证 PGP 签名时使用此自定义程序而不是“ <code>gpg</code>” <code>$PATH</code>。该程序必须支持与 GPG 相同的命令行界面，即验证分离的签名，“ <code>gpg --verify $file - &lt;$signature</code>”已运行，并且该程序应通过以代码0退出来发出良好的签名，并生成 ASCII 装甲的分离签名时，“ <code>gpg -bsau $key</code>” 的标准输入将与要签名的内容一起提供，程序应将结果发送至其标准输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.commitMsgWidth</p></div></div><div class="doc-postil"><div class="c-markdown"><p>定义 git-gui [1] 中提交消息窗口的宽度。“75”是默认值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.diffContext</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定在由 git-gui [1] 进行的 diff 调用中应该使用多少上下文行。默认值是“5”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.displayUntracked</p></div></div><div class="doc-postil"><div class="c-markdown"><p>确定 git-gui [1] 是否在文件列表中显示未跟踪文件。默认值是“true”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.encoding</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定用于显示 git-gui [1] 和 gitk [1] 中文件内容的默认编码。可以通过设置<code>encoding</code>相关文件的属性来覆盖它（请参阅gitattributes [5]）。如果未设置此选项，则工具默认为区域设置编码。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.matchTrackingBranch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>确定使用 git-gui [1] 创建的新分支是否应默认跟踪具有匹配名称的远程分支。默认值：“false”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.newBranchTemplate</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在使用 git-gui 创建新分支时用作建议名称[1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.pruneDuringFetch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果git-gui [1]在执行提取时应修剪远程跟踪分支，则为“true”。默认值是“false”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.trustmtime</p></div></div><div class="doc-postil"><div class="c-markdown"><p>确定 git-gui [1] 是否应该信任文件修改时间戳。默认情况下，时间戳不受信任。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.spellingDictionary</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定在 git-gui [1] 中用于拼写检查提交消息的字典。当设置为“无”时，拼写检查被关闭。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.fastCopyBlame</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则<code>git gui blame</code>用于<code>-C</code>替代<code>-C -C</code>原始位置检测。它会以巨大的副本检测为代价，在巨大的存储库上大大加快责任。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.copyBlameThreshold</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定用于<code>git gui blame</code>原始位置检测的阈值，以字母数字字符度量。有关复制检测的更多信息，请参阅 git-blame [1]手册。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>gui.blamehistoryctx</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定从 gitk [1] 中显示所选提交时历史上下文的半径（以天为单位），当<code>Show History Context</code>从中调用菜单项时<code>git gui blame</code>。如果此变量设置为零，则显示整个历史记录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>guitool.&lt;name&gt;.cmd</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定在<code>Tools</code>调用 git-gui [1] 菜单的相应项时执行的 shell 命令行。每个工具都必须使用此选项。该命令从工作目录的根目录开始执行，并且在环境中它接收工具<code>GIT_GUITOOL</code>的名称，当前选择的文件<code>FILENAME</code>的名称为，当前分支的名称为<code>CUR_BRANCH</code>（如果头已分离，<code>CUR_BRANCH</code>则为空）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>guitool.&lt;name&gt;.needsFile</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只有在 GUI 中选择差异时才运行该工具。它保证<code>FILENAME</code>不是空的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>guitool.&lt;name&gt;.noConsole</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以静默方式运行该命令，而不创建窗口来显示其输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>guitool.&lt;name&gt;.noRescan</p></div></div><div class="doc-postil"><div class="c-markdown"><p>工具完成执行后，不要重新扫描工作目录以进行更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>guitool.&lt;name&gt;.confirm</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在实际运行该工具之前显示一个确认对话框。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>guitool.&lt;name&gt;.argPrompt</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从用户请求一个字符串参数，并通过<code>ARGS</code>环境变量将其传递给工具。由于请求参数意味着确认，<code>confirm</code>如果启用该选项，则该选项不起作用。如果该选项设置为<code>true</code>，，<code>yes</code>或<code>1</code>，则该对话框使用内置的通用提示; 否则使用变量的确切值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>guitool.&lt;name&gt;.revPrompt</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从用户请求一个有效的修订，并设置<code>REVISION</code>环境变量。在其他方面，这个选项类似于<code>argPrompt</code>，并且可以与它一起使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>guitool.&lt;name&gt;.revUnmerged</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅显示子<code>revPrompt</code>对话框中的未合并分支。这对类似于合并或重新绑定的工具很有用，但不适用于结帐或重置等工具。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>guitool.&lt;name&gt;.title</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定用于提示对话框的标题。默认值是工具名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>guitool.&lt;name&gt;.prompt</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在<code>argPrompt</code>和之前的小节前面指定要显示在对话框顶部的常规提示字符串<code>revPrompt</code>。默认值包括实际的命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>help.browser</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定将用于以<code>web</code>格式显示帮助的浏览器。请参阅 git-help [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>help.format</p></div></div><div class="doc-postil"><div class="c-markdown"><p>覆盖 git-help [1] 使用的默认帮助格式。值<code>man</code>，<code>info</code>，<code>web</code>和<code>html</code>支持。<code>man</code>是默认值。<code>web</code>并且<code>html</code>是相同的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>help.autoCorrect</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在等待给定的十分之一秒（0.1秒）后，自动纠正并执行错误输入的命令。如果可以从输入的文本中推断出多个命令，则不执行任何操作。如果此选项的值为负数，则会立即执行更正的命令。如果该值为0  - 该命令将仅显示但不执行。这是默认设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>help.htmlPath</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定 HTML 文档所在的路径。支持文件系统路径和 URL。当帮助以<code>web</code>格式显示时，HTML 页面将以此路径作为前缀。这默认为Git安装的文档路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.proxy</p></div></div><div class="doc-postil"><div class="c-markdown"><p>重写的 HTTP 代理，使用通常被配置<code>http_proxy</code>，<code>https_proxy</code>和<code>all_proxy</code>环境变量（见<code>curl(1)</code>）。除了 curl 理解的语法外，还可以指定一个带有用户名但没有密码的代理字符串，在这种情况下，git将尝试以与其他凭据相同的方式获取一个代理字符串。请参阅gitcredentials [7]了解更多信息。语法就是这样<code>[protocol://][user[:password]@]proxyhost[:port]</code>。这可以在每个远程的基础上被覆盖; 请参阅remote。&lt;name&gt; .proxy</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.proxyAuthMethod</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置对 HTTP 代理进行身份验证的方法。这只有在配置的代理字符串包含用户名部分（即具有表格<code>user@host</code>或<code>user@host:port</code>）的情况下才会生效。这可以在每个远程的基础上被覆盖; 见<code>remote.&lt;name&gt;.proxyAuthMethod</code>。两者都可以被<code>GIT_HTTP_PROXY_AUTHMETHOD</code>环境变量覆盖。可能的值是：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>anyauth</code> - 自动选择合适的认证方法。假设代理使用407状态代码和一个或多个具有支持的认证方法的代理认证头来回答未经身份验证的请求。这是默认设置。</p></li><li><p><code>basic</code>  -  HTTP基本认证</p></li><li><p><code>digest</code> -  HTTP摘要认证; 这可以防止密码以明文形式传输到代理服务器</p></li><li><p><code>negotiate</code>-  GSS协商认证（比较 - 协商选项<code>curl(1)</code>）</p></li><li><p><code>ntlm</code>-  NTLM身份验证（比较--ntlm选项<code>curl(1)</code>）</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>http.emptyAuth</p></div></div><div class="doc-postil"><div class="c-markdown"><p>尝试认证而不寻求用户名或密码。这可用于尝试 GSS 协商身份验证，而无需在 URL 中指定用户名，因为 libcurl 通常需要用户名进行身份验证。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.delegation</p></div></div><div class="doc-postil"><div class="c-markdown"><p>控制 GSSAPI 凭据委派。从版本7.21.7开始，代理在libcurl中默认处于禁用状态。设置参数以告诉服务器当涉及到用户凭证时允许委派什么。与GSS / Kerberos一起使用。可能的值是：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>none</code>  - 不允许任何代表团。</p></li><li><p><code>policy</code>  - 当且仅当在Kerberos服务票据中设置了OK-AS-DELEGATE标志时才委派，这是领域策略的问题。</p></li><li><p><code>always</code>  - 无条件允许服务器委派。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>http.extraHeader</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与服务器通信时传递额外的 HTTP 标头。如果存在多个这样的条目，则将它们全部添加为额外的标题。要允许覆盖从系统配置继承的设置，一个空值会将额外的标题重置为空列表。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.cookieFile</p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含先前存储的 cookie 行的文件的路径名，如果它们与服务器匹配，则应该在Git http会话中使用该行。从中读取 cookie 的文件的文件格式应该是普通的HTTP头文件或Netscape / Mozilla的 cookie 文件格式（请参阅参考资料<code>curl(1)</code>）。请注意，除非设置了http.saveCookies，否则使用http.cookieFile指定的文件仅用作输入。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.saveCookies</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置，则将请求期间收到的 cookie 存储到由 http.cookieFile 指定的文件中。如果 http.cookieFile 未设置，则不起作用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.sslVersion</p></div></div><div class="doc-postil"><div class="c-markdown"><p>协商 SSL 连接时要使用的 SSL 版本，如果要强制使用默认值。可用和默认版本取决于 libcurl 是针对 NSS 还是 OpenSSL 构建的，以及正在使用的加密库的特定配置。在内部设置<code>CURLOPT_SSL_VERSION</code>选项; 请参阅 libcurl 文档以获取有关此选项格式和支持的ssl版本的更多详细信息。其实这个选项的可能值是：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>sslv2</p></li><li><p>sslv3</p></li><li><p>tlsv1</p></li><li><p>tlsv1.0</p></li><li><p>tlsv1.1</p></li><li><p>tlsv1.2</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>可以被<code>GIT_SSL_VERSION</code>环境变量覆盖。要强制 git 使用 libcurl 的默认 ssl 版本并忽略任何明确的 http.sslversion选项，请设置<code>GIT_SSL_VERSION</code>为空字符串。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.sslCipherList</p></div></div><div class="doc-postil"><div class="c-markdown"><p>协商 SSL 连接时使用的 SSL 密码列表。可用的密码取决于 libcurl 是否针对 NSS 或 OpenSSL 构建，以及正在使用的加密库的特定配置。在内部设置<code>CURLOPT_SSL_CIPHER_LIST</code>选项; 请参阅libcurl文档以获取有关此列表格式的更多详细信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可以被<code>GIT_SSL_CIPHER_LIST</code>环境变量覆盖。要强制 git 使用 libcurl
 的默认密码列表并忽略任何明确的http.sslCipherList选项，请设置<code>GIT_SSL_CIPHER_LIST</code>为空字符串。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.sslVerify</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在获取或推送 HTTPS 时是否验证 SSL 证书。可以被<code>GIT_SSL_NO_VERIFY</code>环境变量覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.sslCert</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提取或推送HTTPS时包含SSL证书的文件。可以被<code>GIT_SSL_CERT</code>环境变量覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.sslKey</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在获取或推送 HTTPS 时包含 SSL 私钥的文件。可以被<code>GIT_SSL_KEY</code>环境变量覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.sslCertPasswordProtected</p></div></div><div class="doc-postil"><div class="c-markdown"><p>启用 Git 的密码提示输入 SSL 证书。否则 OpenSSL 会提示用户，可能很多次，如果证书或私钥是加密的。可以被<code>GIT_SSL_CERT_PASSWORD_PROTECTED</code>环境变量覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.sslCAInfo</p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含证书的文件，用于在获取或推送 HTTPS 时验证对等体。可以被<code>GIT_SSL_CAINFO</code>环境变量覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.sslCAPath</p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含带有CA证书的文件的路径，用于在获取或推送HTTPS时验证对等体。可以被<code>GIT_SSL_CAPATH</code>环境变量覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.pinnedpubkey</p></div></div><div class="doc-postil"><div class="c-markdown"><p>https服务的公钥。它可以是 PEM 或 DER 编码的公钥文件的文件名，或者是以公钥<code>sha256//</code>的 base64 编码的 sha256 哈希开头的字符串。另请参阅 libcurl <code>CURLOPT_PINNEDPUBLICKEY</code>。如果设置了此选项但cURL不支持，git将退出并显示错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.sslTry</p></div></div><div class="doc-postil"><div class="c-markdown"><p>尝试在通过常规FTP协议连接时使用AUTH SSL / TLS和加密数据传输。如果FTP服务器出于安全原因需要FTP服务器，或者希望在远程FTP服务器支持时安全地连接，则可能需要这样做。默认值为false，因为它可能会在错误配置的服务器上触发证书验证错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.maxRequests</p></div></div><div class="doc-postil"><div class="c-markdown"><p>并行启动多少个HTTP请求。可以被<code>GIT_HTTP_MAX_REQUESTS</code>环境变量覆盖。缺省值是5。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.minSessions</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请求中保留的卷发会话数（跨槽计数）。在调用http_cleanup（）之前，它们不会以curl_easy_cleanup（）结束。如果未定义USE_CURL_MULTI，则此值将被限制为1.默认为1。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.postBuffer</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将数据发布到远程系统时，智能HTTP传输所使用的缓冲区的最大大小（以字节为单位）。对于大于此缓冲区大小的请求，使用HTTP / 1.1和Transfer-Encoding：chunked来避免在本地创建大量的包文件。默认值是1 MiB，这对大多数请求来说已经足够了。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.lowSpeedLimit, http.lowSpeedTime</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果HTTP传输速度小于<code>http.lowSpeedLimit</code>用于长于<code>http.lowSpeedTime</code>秒，传送被中止。可以通过覆盖<code>GIT_HTTP_LOW_SPEED_LIMIT</code>和<code>GIT_HTTP_LOW_SPEED_TIME</code>环境变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.noEPSV</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过curl禁止使用EPSV ftp命令的布尔值。这对于一些不支持EPSV模式的“差”ftp服务器可能会有所帮助。可以被<code>GIT_CURL_FTP_NO_EPSV</code>环境变量覆盖。默认值为false（卷曲将使用EPSV）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.userAgent</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提供给 HTTP 服务器的 HTTP USER_AGENT 字符串。默认值表示客户端 Git 的版本，例如 git / 1.7.1。此选项允许您将此值覆盖为更常见的值，例如 Mozilla / 4.0。例如，如果通过限制HTTP连接的防火墙连接到一组通用的 USER_AGENT 字符串（但不包括像git / 1.7.1那样的字符串），这可能是必要的。可以被<code>GIT_HTTP_USER_AGENT</code>环境变量覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.followRedirects</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git 是否应该遵循 HTTP 重定向。如果设置为<code>true</code>，git将透明地遵循由它遇到的服务器发出的任何重定向。如果设置为<code>false</code>，git会将所有重定向视为错误。如果设置为<code>initial</code>，git只会将重定向追踪到远程的初始请求，而不是后续的后续HTTP请求。由于git使用重定向的URL作为后续请求的基础，这通常就足够了。默认是<code>initial</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>http.&lt;url&gt;.*</p></div></div><div class="doc-postil"><div class="c-markdown"><p>上面的任何 http。*选项都可以选择性地应用于某些 URL。要使配置键匹配 URL，需要按照以下顺序将配置键的每个元素与 URL 的元素进行比较：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>Scheme（例如，<code>https</code>in <code>https://example.com/</code>）。该字段必须与配置密钥和URL完全匹配。</p></li><li><p>主机/域名（例如，<code>example.com</code>in <code>https://example.com/</code>）。该字段必须在配置密钥和URL之间匹配。可以<code>*</code>将主机名的一部分指定为匹配此级别的所有子域。<code>https://*.example.com/</code>例如会匹配<code>https://foo.example.com/</code>，但不会<code>https://foo.bar.example.com/</code>。</p></li><li><p>端口号（例如，<code>8080</code>in <code>http://example.com:8080/</code>）。该字段必须与配置密钥和URL完全匹配。匹配前，省略的端口号会自动转换为方案的正确默认值。</p></li><li><p>路径（例如，<code>repo.git</code>in <code>https://example.com/repo.git</code>）。配置密钥的路径字段必须与URL的路径字段完全匹配或作为以斜杠分隔的路径元素的前缀。这意味着具有路径<code>foo/</code>匹配URL路径的配置密钥<code>foo/bar</code>。前缀只能匹配斜线（<code>/</code>）边界。较长的匹配优先（因此，带路径的配置键与<code>foo/bar</code>URL路径的匹配性好于<code>foo/bar</code>仅带路径的配置键<code>foo/</code>）。</p></li><li><p>用户名（例如，<code>user</code>in <code>https://user@example.com/repo.git</code>）。如果配置密钥具有用户名，则它必须完全匹配URL中的用户名。如果配置密钥没有用户名，则该配置密钥将匹配具有任何用户名（包括无）的URL，但优先级低于具有用户名的配置密钥。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>上面的列表按优先顺序排列; 与配置键路径相匹配的URL优于匹配其用户名的 URL。例如，如果 URL 是<code>https://user@example.com/foo/bar</code>一个配置密钥匹配项，<code>https://example.com/foo</code>将优先于配置密钥匹配项<code>https://user@example.com</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在尝试任何匹配之前，所有的 URL 都被标准化（如果嵌入在 URL 中，密码部分总是被忽略以便匹配），以便简单拼写不同的等效 URL 可以正确匹配。环境变量设置总是覆盖任何匹配。匹配的 URL 是直接指向Git 命令的 URL。这意味着由于重定向而访问的任何 URL 都不参与匹配。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>ssh.variant</p></div></div><div class="doc-postil"><div class="c-markdown"><p>取决于环境变量的值<code>GIT_SSH</code>或<code>GIT_SSH_COMMAND</code>，或配置设置<code>core.sshCommand</code>，GIT 中自动检测是否需要调整其命令行参数用于与PLINK 或使用的 TortoisePlink，而不是默认值（的OpenSSH）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>配置变量<code>ssh.variant</code>可以设置为覆盖此自动检测; 有效值为<code>ssh</code>，<code>plink</code>，<code>putty</code>或<code>tortoiseplink</code>。任何其他值将被视为正常的ssh。该设置可以通过环境变量覆盖<code>GIT_SSH_VARIANT</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>i18n.commitEncoding</p></div></div><div class="doc-postil"><div class="c-markdown"><p>编码提交消息的字符存储在;  Git 本身并不在乎，但是这些信息是必要的，例如从电子邮件或 gitk 图形历史浏览器（可能在将来其他地方或其他porcelains中）导入提交时。参见例如 git-mailinfo [1]。默认为<code>utf-8</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>i18n.logOutputEncoding</p></div></div><div class="doc-postil"><div class="c-markdown"><p>编码提交消息的字符将转换为运行时<code>git log</code>和朋友。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>imap</p></div></div><div class="doc-postil"><div class="c-markdown"><p>本<code>imap</code>节中的配置变量在 git-imap-send [1] 中进行了描述。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>index.version</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定用于初始化新索引文件的版本。这不会影响现有的存储库。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>init.templateDir</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定将从中复制模板的目录。（请参阅 git-init [1] 的“TEMPLATE DIRECTORY”部分。）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>instaweb.browser</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定将用于在 gitweb 中浏览工作存储库的程序。参见 git-instaweb [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>instaweb.httpd</p></div></div><div class="doc-postil"><div class="c-markdown"><p>HTTP daemon 命令行在您的工作存储库上启动 gitweb。参见 git-instaweb [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>instaweb.local</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则由 git-instaweb [1] 启动的 Web 服务器将绑定到本地IP（127.0.0.1）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>instaweb.modulePath</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用 git-instaweb [1] 而不是/ usr / lib / apache2 / modules的默认模块路径。仅在 httpd 是 Apache 时使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>instaweb.port</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将 gitweb httpd 绑定到的端口号。参见 git-instaweb [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>interactive.singleKey</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在交互式命令中，允许用户使用单个键提供单字母输入（即不输入）。目前，这被<code>--patch</code>git-add [1]，git-checkout [1]，git-commit [1]，git-reset [1 ]和 git-stash [1]使用。请注意，如果便携式按键输入不可用，则此设置将被忽略; 需要Perl模块Term :: ReadKey。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>interactive.diffFilter</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当一个交互式命令（比如<code>git add --patch</code>）显示一个彩色差异时，git 会通过由该配置变量定义的shell命令来传递 diff。该命令可以进一步标记用于人类消费的差异，前提是它保留与原始差异中的行的一一对应关系。默认为禁用（不过滤）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>log.abbrevCommit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则使 git-log [1]，git-show [1] 和 git-whatchanged [1]假定<code>--abbrev-commit</code>。您可以使用覆盖此选项<code>--no-abbrev-commit</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>log.date</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置命令的默认日期时间模式<code>log</code>。为 log.date 设置一个值与使用<code>git log</code>'s <code>--date</code>选项类似。有关详细信息，请参阅 git-log [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>log.decorate</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打印 log 命令显示的任何提交的 ref 名称。如果<code>short</code>被指定，裁判名称前缀<code>refs/heads/</code>，<code>refs/tags/</code>并且<code>refs/remotes/</code>将不被打印。如果<code>full</code>指定，将打印完整的参考名称（包括前缀）。如果<code>auto</code>被指定，那么如果输出到达终端，则 ref 名称显示为如果<code>short</code>给定，否则不显示 ref 名称。这与<code>--decorate</code>选项相同<code>git log</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>log.follow</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>true</code>，<code>git log</code>将作为如果<code>--follow</code>当单个&lt;path&gt;在给定的使用选项。这与它具有相同的限制<code>--follow</code>，即它不能用于跟踪多个文件，并且在非线性历史记录上不能很好地工作。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>log.graphColors</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以逗号分隔的颜色列表，可用于绘制历史线条<code>git log --graph</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>log.showRoot</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则初始提交将显示为一个大创建事件。这相当于针对空树的差异。诸如 git-log [1] 或 git-whatchanged [1] 之类的工具通常会隐藏根提交，现在将显示它。默认情况下为真。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>log.showSignature</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则使 git-log [1]，git-show [1] 和 git-whatchanged [1]假定<code>--show-signature</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>log.mailmap</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则使 git-log [1]，git-show [1] 和 git-whatchanged [1]假定<code>--use-mailmap</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>mailinfo.scissors</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，默认情况下会使 git-mailinfo [1]（因此git-am [1]）起作用，就像在命令行上提供了--scissors选项一样。激活时，此功能可在剪刀线（即主要由“&gt; 8”，“8”和“ - ”）组成的剪刀线之前移除消息体中的所有内容。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>mailmap.file</p></div></div><div class="doc-postil"><div class="c-markdown"><p>扩充邮件地图文件的位置。位于存储库根目录中的默认邮件地图首先被加载，然后被加载，然后被该变量指向的邮件地图文件。邮件地图文件的位置可能位于存储库子目录中，或者位于存储库本身之外的某个位置。参见 git-shortlog [1]和git-blame [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>mailmap.blob</p></div></div><div class="doc-postil"><div class="c-markdown"><p>就像<code>mailmap.file</code>，但是将该值视为对存储库中 blob 的引用。如果两个<code>mailmap.file</code>和<code>mailmap.blob</code>给出，两者都分析，从项目<code>mailmap.file</code>采取优先次序。在裸仓库中，默认为<code>HEAD:.mailmap</code>。在非裸仓库中，它默认为空。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>man.viewer</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定可用于以<code>man</code>格式显示帮助的程序。请参阅 git-help [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>man.&lt;tool&gt;.cmd</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定命令来调用指定的 man 查看器。指定的命令在shell中使用作为参数传递的手册页进行评估。（请参阅git-help [1]。）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>man.&lt;tool&gt;.path</p></div></div><div class="doc-postil"><div class="c-markdown"><p>覆盖可能用于以<code>man</code>格式显示帮助的给定工具的路径。请参阅 git-help [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.conflictStyle</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定在合并时将冲突的区块写入工作树文件的样式。默认值是“合并”，它显示了一个<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>冲突标记，一侧<code>=======</code>发生的变化，一个标记，另一侧发生的变化，然后是<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记。另一种样式“diff3”在<code>|||||||</code>标记之前添加了一个标记和原始文本<code>=======</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.defaultToUpstream</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果在没有任何提交参数的情况下调用合并，则使用存储在其远程跟踪分支中的上次观察值合并为当前分支配置的上游分支。查询<code>branch.&lt;current branch&gt;.merge</code>名称为远程命名的远程分支的值<code>branch.&lt;current branch&gt;.remote</code>，然后将它们映射<code>remote.&lt;remote&gt;.fetch</code>到其对应的远程跟踪分支，并合并这些跟踪分支的提示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.ff</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，Git 在合并作为当前提交的后代的提交时不会创建额外的合并提交。相反，当前分支的尖端被快速转发。当设置为<code>false</code>，这个变量告诉Git在这种情况下创建一个额外的合并提交（相当于<code>--no-ff</code>从命令行提供选项）。设置<code>only</code>为时，只允许进行这种快进合并（相当于<code>--ff-only</code>从命令行提供选项）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.branchdesc</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除了分支名称之外，还可以使用与它们关联的分支描述文本填充日志消息。默认为 false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.log</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除了分支名称之外，还可以在日志消息中最多填写指定数量的来自要合并的实际提交的单行描述。默认为 false，true 为20的同义词。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.renameLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在合并期间执行重命名检测时要考虑的文件数量; 如果未指定，则默认为 diff.renameLimit 的值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.renormalize</p></div></div><div class="doc-postil"><div class="c-markdown"><p>告诉 Git 存储库中文件的规范表示已经随时间而改变（例如，较早的提交记录具有 CRLF 行尾的文本文件，但最近使用LF行结尾）。在这样的存储库中，Git 可以在提交之前将提交中记录的数据转换为规范形式，然后再执行合并以减少不必要的冲突。有关更多信息，请参阅gitattributes [5]中的“合并具有不同签入/签出属性的分支”部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.stat</p></div></div><div class="doc-postil"><div class="c-markdown"><p>是否在合并结束时在 ORIG_HEAD 和合并结果之间打印 diffstat。默认情况下为真。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.tool</p></div></div><div class="doc-postil"><div class="c-markdown"><p>控制哪个合并工具由 git-mergetool [1] 使用。下面的列表显示了有效的内置值。任何其他值都被视为自定义合并工具，并要求定义相应的mergetool。&lt;tool&gt; .cmd变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>araxis</p></li><li><p>bc</p></li><li><p>bc3</p></li><li><p>codecompare</p></li><li><p>deltawalker</p></li><li><p>diffmerge</p></li><li><p>diffuse</p></li><li><p>ecmerge</p></li><li><p>emerge</p></li><li><p>examdiff</p></li><li><p>gvimdiff</p></li><li><p>gvimdiff2</p></li><li><p>gvimdiff3</p></li><li><p>kdiff3</p></li><li><p>meld</p></li><li><p>opendiff</p></li><li><p>p4merge</p></li><li><p>tkdiff</p></li><li><p>tortoisemerge</p></li><li><p>vimdiff</p></li><li><p>vimdiff2</p></li><li><p>vimdiff3</p></li><li><p>winmerge</p></li><li><p>xxdiff</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.verbosity</p></div></div><div class="doc-postil"><div class="c-markdown"><p>控制递归合并策略显示的输出量。如果检测到冲突，级别0只输出最终的错误消息。1级只输出冲突，2个输出冲突和文件更改。5级及以上输出调试信息。缺省值是2级。可以由<code>GIT_MERGE_VERBOSITY</code>环境变量覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.&lt;driver&gt;.name</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为自定义低级合并驱动程序定义一个人类可读的名称。有关详细信息，请参阅 gitattributes [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.&lt;driver&gt;.driver</p></div></div><div class="doc-postil"><div class="c-markdown"><p>定义实现自定义低级别合并驱动程序的命令。有关详细信息，请参阅gitattributes [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>merge.&lt;driver&gt;.recursive</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在执行公共祖先之间的内部合并时，命名一个低级合并驱动程序。有关详细信息，请参阅 gitattributes [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>mergetool.&lt;tool&gt;.path</p></div></div><div class="doc-postil"><div class="c-markdown"><p>覆盖给定工具的路径。如果您的工具不在 PATH 中，这非常有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>mergetool.&lt;tool&gt;.cmd</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定命令来调用指定的合并工具。在 shell 中使用以下可用变量评估指定的命令：<code>BASE</code>是包含要合并的文件的公共基础的临时文件的名称（如果可用）; <code>LOCAL</code>是包含当前分支上文件内容的临时文件的名称; <code>REMOTE</code>是包含来自合并分支的文件内容的临时文件的名称; <code>MERGED</code>包含合并工具应将写入成功合并结果的文件的名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>mergetool.&lt;tool&gt;.trustExitCode</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于自定义合并命令，指定是否可以使用合并命令的退出代码来确定合并是否成功。如果未设置为 true，则检查合并目标文件时间戳，如果文件已更新，则假定合并已成功，否则将提示用户指示合并成功。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>mergetool.meld.hasOutput</p></div></div><div class="doc-postil"><div class="c-markdown"><p>旧版本<code>meld</code>不支持该<code>--output</code>选项。Git 会尝试通过检查输出来检测是否<code>meld</code>支持。配置将使 Git 跳过这些检查并改为使用配置的值。设置要告诉 Git 的无条件使用选项，使用避免。<code>--outputmeld --helpmergetool.meld.hasOutputmergetool.meld.hasOutputtrue--outputfalse--output</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>mergetool.keepBackup</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在执行合并之后，具有冲突标记的原始文件可以保存为具有<code>.orig</code>扩展名的文件。如果这个变量被设置为<code>false</code>那么这个文件不会被保留。默认为<code>true</code>（即保留备份文件）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>mergetool.keepTemporaries</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在调用自定义合并工具时，Git 使用一组临时文件传递给该工具。如果该工具返回一个错误并将该变量设置为<code>true</code>，则这些临时文件将被保留，否则它们将在该工具退出后被删除。默认为<code>false</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>mergetool.writeToTemp</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 的写入临时<code>BASE</code>，<code>LOCAL</code>以及<code>REMOTE</code>默认的文件冲突的版本在worktree。设置时，Git 会尝试使用这些文件的临时目录<code>true</code>。默认为<code>false</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>mergetool.prompt</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在每次调用合并解决程序之前提示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>notes.mergeStrategy</p></div></div><div class="doc-postil"><div class="c-markdown"><p>解决笔记冲突时默认选择哪种合并策略。必须是一<code>manual</code>，<code>ours</code>，<code>theirs</code>，<code>union</code>，或<code>cat_sort_uniq</code>。默认为<code>manual</code>。有关每种策略的更多信息，请参阅 git-notes [1]的“注释合并策略”部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>notes.&lt;name&gt;.mergeStrategy</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在将注释合并到 refs / notes / &lt;name&gt; 时选择哪种合并策略。这覆盖了更一般的“notes.mergeStrategy”。有关可用策略的更多信息，请参阅 git-notes [1] 中的“NOTES MERGE策略”部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>notes.displayRef</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示提交消息时显示备注的（完全限定）refname。这个变量的值可以设置为一个 glob，在这种情况下，所有匹配的ref都会显示出来。您也可以多次指定此配置变量。对于不存在的 ref，将发出警告，但不匹配任何 ref 的 glob 默默无视。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该设置可以用<code>GIT_NOTES_DISPLAY_REF</code>环境变量覆盖，该变量必须是以冒号分隔的参考或球体列表。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>“core.notesRef”的有效值（可能被 GIT_NOTES_REF 覆盖）也隐式添加到要显示的 ref 列表中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>notes.rewrite.&lt;command&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当用&lt;command&gt;（当前<code>amend</code>或者<code>rebase</code>）重写提交并且该变量被设置<code>true</code>为时，Git会自动将笔记从原始文件复制到重写的提交中。默认为<code>true</code>，但请参阅下面的“notes.rewriteRef”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>notes.rewriteMode</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在重写过程中复制笔记时（请参阅“notes.rewrite。&lt;command&gt;”选项），确定如果目标提交已经有笔记要执行的操作。必须是一个<code>overwrite</code>，<code>concatenate</code>，<code>cat_sort_uniq</code>，或<code>ignore</code>。默认为<code>concatenate</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该设置可以用<code>GIT_NOTES_REWRITE_MODE</code>环境变量覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>notes.rewriteRef</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在重写过程中复制备注时，指定应该复制其备注的（完全限定）参考。ref 可以是一个 glob，在这种情况下，所有匹配参考中的备注都将被复制。您也可以多次指定此配置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>没有默认值; 您必须配置此变量以启用音符重写。将其设置<code>refs/notes/commits</code>为启用默认提交备注的重写。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该设置可以用<code>GIT_NOTES_REWRITE_REF</code>环境变量覆盖，该变量必须是以冒号分隔的参考或球体列表。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.window</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当命令行没有给出窗口大小时，git-pack-objects [1]使用的窗口大小。默认为10。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.depth</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当命令行没有给出最大深度时，git-pack-objects [1] 使用的最大增量深度。默认为50。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.windowMemory</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在命令行中未给出限制时，包装窗口内存的 git-pack-objects [1] 中的每个线程占用的最大内存大小。该值可以后缀“k”，“m”或“g”。当未配置（或明确设置为0）时，不会有任何限制。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.compression</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个整数-1..9，表示包文件中对象的压缩级别。-1是zlib的默认值。0代表没有压缩，1..9代表不同的速度/尺寸折衷，9代表最慢。如果未设置，则默认为 core.compression。如果没有设置，默认为-1，默认为zlib，这是“速度和压缩之间的默认折衷（当前等同于级别6）”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，更改压缩级别不会自动重新压缩所有现有对象。您可以通过将-F选项传递给 git-repack [1] 来强制再压缩。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.deltaCacheSize</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用于缓存 git-pack-objects [1] 中的增量的最大内存（以字节为单位），然后将它们写出到一个包中。该缓存用于加速写入对象阶段，因为一旦找到所有对象的最佳匹配，就不必重新计算最终的增量结果。在内存紧张的机器上重新包装大型软件仓库可能会受到严重影响，特别是如果此缓存将系统推入交换。值为0意味着没有限制。1字节的最小尺寸可以用于虚拟地禁用该缓存。默认为256 MiB。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.deltaCacheLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>增量的最大大小，即缓存在 git-pack-objects [1] 中。该缓存用于加速写入对象阶段，因为一旦找到所有对象的最佳匹配，就不必重新计算最终的增量结果。默认为1000。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.threads</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定搜索最佳增量匹配时产生的线程数。这要求用 pthread 编译 git-pack-objects [1]，否则这个选项会被忽略并带有警告。这是为了减少多处理器机器的打包时间。然而，增量搜索窗口所需的内存量乘以线程数量。指定0将导致Git自动检测CPU的数量并相应地设置线程数量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.indexVersion</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定默认包装索引版本。对于1.5.2之前的 Git 版本使用的旧版包装索引，有效值为1，对于包装容量大于4 GB的新包装索引，有效值为2，并且对重新包装损坏的包装提供适当的保护。版本2是默认值。请注意，强制执行版本2，并且只要相应的包大于2 GB，就会忽略此配置选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您有一个旧的 Git 不理解版本2 <code>*.idx</code>文件，通过非本地协议（例如“http”）克隆或获取将从另一端复制<code>*.pack</code>文件和相应<code>*.idx</code>文件的可能会给您一个无法访问的存储库与你的老版本的Git。<code>*.pack</code>但是，如果文件小于2 GB，则可以使用* .pack文件上的git-index-pack [1]来重新生成该<code>*.idx</code>文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.packSizeLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>包的最大尺寸。此设置仅影响重新包装到文件，即 git：//协议不受影响。它可以被<code>--max-pack-size</code>git-repack [1]选项覆盖。达到此限制会导致创建多个包装文件; 这反过来又防止了位图的创建。允许的最小尺寸限制为1 MiB。默认值是无限的。常见的单元后缀<code>k</code>，<code>m</code>或<code>g</code>支持。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.useBitmaps</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则 git 在打包到标准输出时（例如，在获取的服务器端期间）将使用包位图（如果可用）。默认为true。除非您正在调试包位图，否则通常不需要关闭此功能。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.writeBitmaps (deprecated)</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这是一个不赞成的同义词<code>repack.writeBitmaps</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pack.writeBitmapHashCache</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为true，git 将在位图索引中包含一个“散列缓存”部分（如果写入的话）。这个缓存可以用来提供 git 的 delta 启发式，可能会导致位图对象和非位图对象之间更好的增量（例如，在较旧的位图包和自上次gc以来推送的对象之间提供提取时）。缺点是每个对象的磁盘空间消耗4个字节，JGi t的位图实现不理解它，如果在同一个存储库上使用 Git和JGit，会导致它投诉。默认为false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pager.&lt;cmd&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果值是布尔值，则在写入 tty 时打开或关闭特定 Git 子命令输出的分页。否则，使用由值的指定的寻呼机打开子命令的分页<code>pager.&lt;cmd&gt;</code>。如果<code>--paginate</code>或<code>--no-pager</code>在命令行上指定，则优先于此选项。要为所有命令，设置禁用分页<code>core.pager</code>或<code>GIT_PAGER</code>到<code>cat</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pretty.&lt;name&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--git-log [1]中指定的 --pretty = format 字符串的别名。这里定义的任何别名都可以像内置的漂亮格式一样使用。例如，运行<code>git config pretty.changelog "format:* %H %s"</code>会导致调用<code>git log --pretty=changelog</code>等同于运行<code>git log "--pretty=format:* %H %s"</code>。请注意，与内置格式同名的别名将被忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>protocol.allow</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置，为所有没有明确规定策略的协议提供用户定义的默认策略（<code>protocol.&lt;name&gt;.allow</code>）。默认情况下，如果未设置，已知安全协议（http，https，git，ssh，文件）具有默认策略<code>always</code>，则已知危险协议（ext）具有默认策略<code>never</code>，并且所有其他协议具有默认策略<code>user</code>。支持的策略：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>always</code>  - 协议总是可以使用的。</p></li><li><p><code>never</code>  - 协议永远不能使用。</p></li><li><p><code>user</code>- 只有在<code>GIT_PROTOCOL_FROM_USER</code>未设置或值为1时才能使用协议。当您希望协议可以被用户直接使用但不希望被执行克隆/获取的命令使用时，应使用此策略/推命令没有用户输入，例如递归子模块初始化。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>protocol.&lt;name&gt;.allow</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>&lt;name&gt;</code>clone / fetch / push 命令设置要由协议使用的策略。请参阅<code>protocol.allow</code>上面的可用政策。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git 目前使用的协议名称为：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>file</code>：任何本地基于文件的路径（包括<code>file://</code>URL或本地路径）</p></li><li><p><code>git</code>：通过直接TCP连接（或代理，如果已配置）的匿名git协议</p></li><li><p><code>ssh</code>：git over ssh（包括<code>host:path</code>语法<code>ssh://</code>，等）。</p></li><li><p><code>http</code>：通过http的git，“智能http”和“哑巴http”。请注意，这<code>not</code>包括<code>https</code>; 如果你想配置两者，你必须单独做。</p></li><li><p>任何外部助手都按其协议命名（例如，用于<code>hg</code>允许<code>git-remote-hg</code>助手）</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>pull.ff</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，Git在合并作为当前提交的后代的提交时不会创建额外的合并提交。相反，当前分支的尖端被快速转发。当设置为<code>false</code>，这个变量告诉Git在这种情况下创建一个额外的合并提交（相当于<code>--no-ff</code>从命令行提供选项）。设置<code>only</code>为时，只允许进行这种快进合并（相当于<code>--ff-only</code>从命令行提供选项）。此设置<code>merge.ff</code>在拔取时覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pull.rebase</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为true，则rebase分支位于提取分支的顶部，而不是在运行“git pull”时合并默认分支和默认分支。请参阅“分支。&lt;名称&gt; .rebase”以每个分支为基础进行设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当保存时，也会传递<code>--preserve-merges</code>到，<code>git rebase</code>以便本地提交的合并提交不会因运行而变得平坦<code>git pull</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当值为时<code>interactive</code>，rebase 以交互模式运行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><strong>注意</strong>：这是一个可能危险的操作; ，不要用它除非你理解的含义才能使用（请查看git-变基[1]了解详细信息）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pull.octopus</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一次拉多个分支时使用的默认合并策略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>pull.twohead</p></div></div><div class="doc-postil"><div class="c-markdown"><p>拉动单个分支时使用的默认合并策略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>push.default</p></div></div><div class="doc-postil"><div class="c-markdown"><p>定义<code>git push</code>如果没有明确给出 refspec 就应该采取的行动。不同的值非常适合特定的工作流程; 例如，在一个纯粹的中央工作流程（即提取源等于推送目的地），<code>upstream</code>可能是你想要的。可能的值是：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>nothing</code> - 除非明确给出refspec，否则不要推送任何东西（错误输出）。这主要是针对那些想要通过始终明确避免错误的人。</p></li><li><p><code>current</code> - 推送当前分支以更新接收端具有相同名称的分支。适用于中央和非中央工作流程。</p></li><li><p><code>upstream</code>- 将当前分支推回到其更改通常集成到当前分支（称为<code>@{upstream}</code>）的分支中。这种模式只有在您推送到您通常需要的同一个存储库（例如中央工作流程）时才有意义。</p></li><li><p><code>tracking</code>- 这是一个不赞成的同义词<code>upstream</code>。</p></li><li><p><code>simple</code>- 在集中式工作流程中，<code>upstream</code>如果上游分支的名称与本地名称不同，则可以像增加安全性一样拒绝推送。当推送到与通常从中拉出的远程不同的远程时，按照<code>current</code>。这是最安全的选择，适合初学者。该模式已成为Git 2.0中的默认模式。</p></li><li><p><code>matching</code> - 推送两端同名的所有分支。这使得你正在推动记住设置将要推出的分支（例如，如果你总是推存储库<code>maint</code>和<code>master</code>有其他分支机构，你推到会有这两个分支的库，和当地的<code>maint</code>和<code>master</code>将在那里推）。要有效地使用这种模式，你必须确保<code>all</code>你推出的分支在运行之前已经准备好被推出<code>git push</code>，因为这种模式的重点在于让您一次推送所有分支。如果您通常只完成一个分支的工作并推出结果，而其他分支未完成，则此模式不适合您。此外，此模式不适合推入共享的中央存储库，因为其他人可能会在该处添加新的分支，或者更新您的控制之外的现有分支的提示。这曾经是默认的，但从Git 2.0开始（这<code>simple</code>是新的默认设置）。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>push.followTags</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--follow-tags</code>默认设置为 true 启用选项。您可以在推送时通过指定覆盖此配置<code>--no-follow-tags</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>push.gpgSign</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可能被设置为布尔值或字符串<code>if-asked</code>。一个真正的值会导致所有推送被GPG签名，就好像<code>--signed</code>被传递给 git-push [1]一样。<code>if-asked</code>如果服务器支持该字符串，该字符串将导致推送被签名，就像<code>--signed=if-asked</code>传递给它一样<code>git push</code>。假值可能会覆盖来自低优先级配置文件的值。一个明确的命令行标志总是会覆盖这个配置选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>push.recurseSubmodules</p></div></div><div class="doc-postil"><div class="c-markdown"><p>确保远程跟踪分支上提供了要推送的修订版所使用的所有子模块提交。如果该值是<code>check</code>Git，那么 Git 将验证所有要修改的子模块提交在子模块的至少一个远程模块上可用。如果任何提交丢失，推送将被中止并以非零状态退出。如果该值是，<code>on-demand</code>那么将推送修订中要更改的所有子模块。如果按需无法推送所有必需的修订，它也会被中止并以非零状态退出。如果该值<code>no</code>是保留推送时忽略子模块的默认行为。您可以在推送时通过指定覆盖此配置<code>--recurse-submodules=check|on-demand|no</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>rebase.stat</p></div></div><div class="doc-postil"><div class="c-markdown"><p>是否显示自上次变基期以来上游变化的差异。默认为 False。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>rebase.autoSquash</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--autosquash</code>默认设置为 true 启用选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>rebase.autoStash</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置为 true 时，在操作开始之前自动创建临时存储条目，并在操作结束后应用它。这意味着你可以在肮脏的工作树上运行 rebase。但是，谨慎使用：成功重新绑定后的最终隐藏应用程序可能会导致不平凡的冲突。默认为 false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>rebase.missingCommitsCheck</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为“警告”，git rebase -i 将在一些提交被删除时（例如，一行被删除）打印警告，但是 rebase 仍然会继续。如果设置为“错误”，它将打印先前的警告并停止重设，<code>git rebase --edit-todo</code>然后可用于纠正错误。如果设置为“忽略”，则不进行检查。要删除没有警告或错误的提交，请使用<code>drop</code>待办事项列表中的命令。默认为“忽略”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>rebase.instructionFormat</p></div></div><div class="doc-postil"><div class="c-markdown"><p>格式字符串，如 git-log [1] 中所指定的，用于交互式重新绑定期间的指令列表。该格式将自动具有格式前面的长提交哈希。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.advertiseAtomic</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，git-receive-pack 会向其客户端通告原子推送功能。如果您不想公布此功能，请将此变量设置为 false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.advertisePushOptions</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当设置为 true 时，git-receive-pack 会将推送选项功能通告给它的客户端。默认为 False。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.autogc</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，从 git-push 接收数据并更新引用后，git-receive-pack将运行“git-gc --auto”。您可以通过将此变量设置为 false 来停止它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.certNonceSeed</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过将此变量设置为字符串，<code>git receive-pack</code>将接受<code>git push --signed</code>并通过使用由 HMAC 保护的“nonce”使用此字符串作为密钥来验证它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.certNonceSlop</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>git push --signed</code>发送一个推送证书时，这个推送证书由在此数秒钟内为同一个存储库提供服务的接收包发布的“随机数”，将证书中发现的“随机数”导出<code>GIT_PUSH_CERT_NONCE</code>到挂钩（而不是接收包问包括发送方）。这可能允许写入检查<code>pre-receive</code>并且<code>post-receive</code>更容易一些。而不是检查<code>GIT_PUSH_CERT_NONCE_SLOP</code>环境变量的记录是由多少秒nonce是陈旧的，以决定他们是否要接受证书，他们只能检查<code>GIT_PUSH_CERT_NONCE_STATUS</code>是<code>OK</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.fsckObjects</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果它设置为 true，git-receive-pack 将检查所有收到的对象。如果格式错误的对象或链接断开，它将中止。中止的结果只是悬挂的对象。默认为 false。如果未设置，<code>transfer.fsckObjects</code>则使用其值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.fsck.&lt;msg-id&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>receive.fsckObjects</code>被设置为 true 时，误差可以通过配置切换到警告，反之亦然<code>receive.fsck.&lt;msg-id&gt;</code>设置其中<code>&lt;msg-id&gt;</code>是 fsck 的消息ID和值为之一<code>error</code>，<code>warn</code>或<code>ignore</code>。为了方便起见，fsck在错误/警告前添加了消息ID，例如“missingEmail：invalid author / committer line  -  missing email”意味着该设置<code>receive.fsck.missingEmail = ignore</code>将隐藏该问题。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此功能旨在支持使用传统存储库时不会推送时间<code>receive.fsckObjects = true</code>，允许主机接受存在某些已知问题但仍捕获其他问题的存储库。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.fsck.skipList</p></div></div><div class="doc-postil"><div class="c-markdown"><p>已知以非致命方式破坏的对象名称的排序列表（即每行一个SHA-1）的路径应被忽略。如果尽早提交包含可安全忽略的错误（如无效的提交者电子邮件地址）的应用程序，则应接受已建立的项目，此功能非常有用。注意：使用此设置不能跳过损坏的对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.keepAlive</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从客户端收到包后，在处理包时<code>receive-pack</code>可能没有输出（如果<code>--quiet</code>指定），导致某些网络断开 TCP 连接。通过设置此选项，如果<code>receive-pack</code>在此阶段中不传输任何数据达<code>receive.keepAlive</code>数秒钟，它将发送一个短保持数据包。默认值是5秒; 设置为0将完全禁用Keepalive。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.unpackLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果在推送中收到的对象数量低于此限制，则对象将被解压缩为松散的对象文件。但是，如果接收到的对象数量等于或超过此限制，则在添加任何缺少的增量基数后，接收的数据包将作为一个包存储。从推存储包可以使推送操作更快完成，特别是在慢速文件系统上。如果未设置，<code>transfer.unpackLimit</code>则使用其值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.maxInputSize</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果传入包的大小大于此限制，那么 git-receive-pack 将会出错，而不是接受包文件。如果没有设置或设置为0，那么大小是无限的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.denyDeletes</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true，git-receive-pack 将拒绝删除 ref 的 ref更新。使用它来防止通过推送删除这样的引用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.denyDeleteCurrent</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true，那么 git-receive-pack 将拒绝一个 ref更新，它会删除非裸仓库的当前检出分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.denyCurrentBranch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true 或“拒绝”，git-receive-pack将拒绝对非裸仓库的当前签出分支的 ref更新。这样的推送是潜在的危险，因为它会使HEAD 与索引和工作树不同步。如果设置为“警告”，则将这种推送警告打印到标语，但允许推送继续。如果设置为 false 或“忽略”，则允许在没有消息的情况下推送。默认为“拒绝”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>另一种选择是“updateInstead”，如果推入当前分支，它将更新工作树。此选项用于同步工作目录，当通过交互式 ssh 无法轻松访问一个工作目录时（例如实时网站，因此要求工作目录清洁）。在虚拟机内部进行开发以在不同的操作系统上测试和修复代码时，此模式也会派上用场。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，如果工作树或索引与 HEAD 有任何不同，“updateInstead”将拒绝推送，但<code>push-to-checkout</code>可以使用挂钩来自定义此操作。见githooks [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.denyNonFastForwards</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true，那么 git-receive-pack 会拒绝不是快进的 ref 更新。即使强制推送，也可以通过推送来阻止这种更新。该配置变量在初始化共享存储库时设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.hideRefs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个变量是相同的<code>transfer.hideRefs</code>，但只适用于<code>receive-pack</code>（并且因此影响推送，但不提取）。尝试更新或删除隐藏参考<code>git push</code>被拒绝。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.updateServerInfo</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true，git-receive-pack 在从 git-push 接收数据并更新
 refs 后将运行 git-update-server-info。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>receive.shallowUpdate</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true，则当新引用需要新的浅根时，可以更新.git / shallow。否则，这些裁判将被拒绝。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.pushDefault</p></div></div><div class="doc-postil"><div class="c-markdown"><p>遥控器默认为推送。覆盖<code>branch.&lt;name&gt;.remote</code>所有分支，并由<code>branch.&lt;name&gt;.pushRemote</code>特定分支覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.url</p></div></div><div class="doc-postil"><div class="c-markdown"><p>远程存储库的 URL。请参阅git-fetch [1]或git-push [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.pushurl</p></div></div><div class="doc-postil"><div class="c-markdown"><p>远程存储库的推送网址。见 git-push [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.proxy</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于需要 curl（http，https和ftp）的遥控器，用于该遥控器的代理的URL。设置为空字符串以禁用该远程代理。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.proxyAuthMethod</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于需要 curl（http，https和ftp）的遥控器，用于对正在使用的代理（可能设置<code>remote.&lt;name&gt;.proxy</code>）进行认证的方法。看<code>http.proxyAuthMethod</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.fetch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-fetch [1]的默认设置“refspec”。参见git-fetch [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.push</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-push [1]的默认设置“refspec”。见git-push [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.mirror</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则推送到此远程将自动运行，就像<code>--mirror</code>在命令行上给出选项一样。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.skipDefaultUpdate</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，那么当使用 git-fetch [1] 或<code>update</code>git-remote [1] 的子命令进行更新时，该远程将默认跳过。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.skipFetchAll</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，那么当使用 git-fetch [1] 或<code>update</code>git-remote [1] 的子命令进行更新时，该远程将默认跳过。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.receivepack</p></div></div><div class="doc-postil"><div class="c-markdown"><p>推送时在远端执行的默认程序。请参阅选项 - 接收 git-push [1] 的包。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.uploadpack</p></div></div><div class="doc-postil"><div class="c-markdown"><p>获取时在远程端执行的默认程序。查看选项 --upload-pack的 git-fetch-pack [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.tagOpt</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果将此值设置为 --no-tags，则从远程&lt;名称&gt;获取时将禁用自动标记跟踪。将它设置为 --tags 将从远程&lt;name&gt;中获取每个标记，即使它们不能从远程分支头到达。将这些标志直接传递给 git-fetch [1] 可以覆盖此设置。查看选项--tags 和 --no-tags的git-fetch [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.vcs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将其设置为&lt;vcs&gt;值将使 Git 通过 git-remote- &lt;vcs&gt; helper与远程进行交互。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remote.&lt;name&gt;.prune</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置为 true 时，默认从此远程访存将删除远程中不再存在的任何远程跟踪引用（就像<code>--prune</code>在命令行上给出该选项一样）。覆盖<code>fetch.prune</code>设置，如果有的话。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>remotes.&lt;group&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>由“git remote update &lt;group&gt;”获取的遥控器列表。见 git-remote [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>repack.useDeltaBaseOffset</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，git-repack [1]创建使用 delta-base 偏移量的包。如果您需要使用比版本1.4.4更高的 Git 来共享您的存储库，请直接或通过诸如 http 之类的哑协议来共享您的存储库，那么您需要将此选项设置为“false”并重新打包。通过本地协议从旧的Git版本访问不受此选项的影响。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>repack.packKeptObjects</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true，则<code>git repack</code>表示好像<code>--pack-kept-objects</code>已通过。有关详细信息，请参阅 git-repack [1]。默认为<code>false</code>正常，但是<code>true</code>如果正在写入位图索引（通过<code>--write-bitmap-index</code>或<code>repack.writeBitmaps</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>repack.writeBitmaps</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，git会在将所有对象打包到磁盘时写入一个位图索引（例如，当<code>git repack -a</code>运行时）。此索引可以加速为克隆和提取创建的后续包的“计数对象”阶段，但需要花费一些磁盘空间和花费在初始重新包装上的额外时间。如果创建多个包文件，这不起作用。默认为false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>rerere.autoUpdate</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置为 true 时，<code>git-rerere</code>使用先前记录的分辨率干净地解决冲突后，使用结果内容更新索引。默认为 false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>rerere.enabled</p></div></div><div class="doc-postil"><div class="c-markdown"><p>激活已解决冲突的记录，以便相同的冲突块可以自动解决，如果再次遇到冲突块。默认情况下，如果在该<code>rr-cache</code>目录下有一个目录，则启用 git-rerere [1] <code>$GIT_DIR</code>，例如，如果以前在资源库中使用了“rerere”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sendemail.identity</p></div></div><div class="doc-postil"><div class="c-markdown"><p>配置标识。给出时，导致<code>sendemail.&lt;identity&gt;</code>子<code>sendemail</code>部分中的值优先于部分中的值。默认标识是的值<code>sendemail.identity</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sendemail.smtpEncryption</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关说明，请参阅 git-send-email [1]。请注意，此设置不受该<code>identity</code>机制的约束。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sendemail.smtpssl (deprecated)</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>sendemail.smtpEncryption = ssl</code>已弃用的别名。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sendemail.smtpsslcertpath</p></div></div><div class="doc-postil"><div class="c-markdown"><p>ca证书的路径（目录或单个文件）。将其设置为空字符串以禁用证书验证。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sendemail.&lt;identity&gt;.*</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>sendemail.*</code>通过命令行或命令行选择的身份特定版本的参数优先于选择此身份的参数<code>sendemail.identity</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sendemail.aliasesFile   sendemail.aliasFileType   sendemail.annotate   sendemail.bcc   sendemail.cc   sendemail.ccCmd   sendemail.chainReplyTo   sendemail.confirm   sendemail.envelopeSender   sendemail.from   sendemail.multiEdit   sendemail.signedoffbycc   sendemail.smtpPass   sendemail.suppresscc   sendemail.suppressFrom   sendemail.to   sendemail.smtpDomain   sendemail.smtpServer   sendemail.smtpServerPort   sendemail.smtpServerOption   sendemail.smtpUser   sendemail.thread   sendemail.transferEncoding   sendemail.validate   sendemail.xmailer</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关说明，请参阅git-send-email [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sendemail.signedoffcc（已弃用）</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>endemail.signedoffbycc</code>已弃用的别名。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sendemail.smtpBatchSize</p></div></div><div class="doc-postil"><div class="c-markdown"><p>每个连接发送的消息数量，之后会发生重新登录。如果值为0或未定义，则在一个连接中发送所有消息。另请参阅<code>--batch-size</code>git-send-email [1] 的选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>sendemail.smtpReloginDelay</p></div></div><div class="doc-postil"><div class="c-markdown"><p>秒重新连接到SMTP服务器之前等待。另请参阅<code>--relogin-delay</code>git-send-email [1] 的选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>showbranch.default</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-show-branch [1]的默认分支集合。参见git-show-branch [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>splitIndex.maxPercentChange</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用拆分索引功能时，这将指定拆分索引可以包含的条目的百分比，与写入新共享索引之前拆分索引和共享索引中的条目总数相比。值应该介于0和100之间。如果值为0，则总是写入新的共享索引，如果为100，则永远不会写入新的共享索引。默认情况下，该值为20，因此如果分割索引中的条目数大于条目总数的20％，则会写入新的共享索引。参见git-update-index [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>splitIndex.sharedIndexExpire</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用拆分索引功能时，自从该变量指定时间以来未修改的共享索引文件将在创建新的共享索引文件时被删除。值“now”立即使所有条目到期，并且“never”完全禁止到期。默认值是“2.weeks.ago”。请注意，每次基于它创建或读取新的分割索引文件时，都会将共享索引文件修改（用于过期）。参见 git-update-index [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>status.relativePaths</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，git-status [1]显示相对于当前目录的路径。设置此变量以<code>false</code>显示相对于存储库根目录的路径（这是v1.5.4之前的Git的默认值）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>status.short</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置为 true 以在 git-status [1]中默认启用--short。--no-short选项优先于此变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>status.branch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置为 true 以在 git-status [1]中默认启用--branch。--no-branch选项优先于此变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>status.displayCommentPrefix</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true，git 的状态[1]将插入每条输出线之前注释前缀（开始<code>core.commentChar</code>，即<code>#</code>由默认值）。这是 Git 1.8.4和之前的 git-status [1]的行为。默认为 false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>status.showStash</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为 true，git-status [1] 将显示当前隐藏的条目数量。默认为false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>status.showUntrackedFiles</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，git-status [1] 和 git-commit [1] 显示当前未被Git跟踪的文件。仅包含未跟踪文件的目录仅以目录名称显示。显示未跟踪的文件意味着Git需要lstat（）整个存储库中的所有文件，这在某些系统上可能会很慢。所以，这个变量控制着命令如何显示未跟踪文件。可能的值是：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>no</code>  - 不显示未跟踪的文件。</p></li><li><p><code>normal</code>  - 显示未跟踪的文件和目录。</p></li><li><p><code>all</code>  - 显示未跟踪目录中的单个文件。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>如果未指定此变量，则默认为<code>normal</code>。这个变量可以用 git-status [1]和git-commit [1] 的 -u | --untracked-files选项覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>status.submoduleSummary</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认为false。如果将其设置为非零数字或true（与-1或无限制数字相同），则将启用子模块摘要，并显示修改子模块的提交摘要（请参阅--git -summary-limit选项）子模块[1]）。请注意，对于所有子模块，汇总输出命令将被<code>diff.ignoreSubmodules</code>设置为<code>all</code>或仅针对其中的子模块<code>submodule.&lt;name&gt;.ignore=all</code>。该规则的唯一例外是状态和提交将显示暂存的子模块更改。要查看忽略子模块的摘要，可以使用--ignore-submodules = dirty命令行选项或<code>git submodule summary</code>命令，该命令显示类似的输出，但不遵守这些设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>stash.showPatch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为true，则<code>git stash show</code>没有选项的命令将以补丁形式显示隐藏条目。默认为false。请参阅<code>show</code>git-stash [1]中的命令说明。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>stash.showStat</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置为true，则<code>git stash show</code>没有选项的命令将显示存储条目的diffstat。默认为true。请参阅<code>show</code>git-stash [1]中的命令说明。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.url</p></div></div><div class="doc-postil"><div class="c-markdown"><p>子模块的 URL。这个变量通过 .gitmodules 文件复制到 git config <code>git submodule init</code>。用户可以在通过获取子模块之前更改配置的 URL <code>git submodule update</code>。如果子模块 &lt;name&gt; .active 或submodule.active 都未设置，则将此变量的存在用作后备，以指示子模块是否对 git 命令感兴趣。有关详细信息，请参阅 git-submodule [1]和gitmodules [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.update</p></div></div><div class="doc-postil"><div class="c-markdown"><p>子模块的默认更新过程。该变量由<code>git submodule init</code>gitmodules [5]文件填充。请参阅<code>update</code>git-submodule [1]中的命令说明。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.branch</p></div></div><div class="doc-postil"><div class="c-markdown"><p>子模块的远程分支名称，由<code>git submodule update --remote</code>。设置此选项以覆盖<code>.gitmodules</code>文件中找到的值。有关详细信息，请参阅git-submodule [1]和gitmodules [5]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.fetchRecurseSubmodules</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项可用于控制此子模块的递归提取。它可以通过使用 --no-recurse-submodules命令行选项“git fetch”和“git pull”来覆盖。该设置将覆盖 gitmodules [5]文件中的设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.ignore</p></div></div><div class="doc-postil"><div class="c-markdown"><p>定义在什么情况下，“git status”和 diff 系列显示已修改的子模块。当设置为“全部”时，它永远不会被视为已修改（但它仍会显示在状态的输出中，并在已执行时进行提交），“脏”将忽略对子模块工作树的所有更改，并且只会带来差异考虑子模块的 HEAD 和超级项目中记录的提交之间的关系。“未跟踪”还会让子模块在工作树中显示修改过的跟踪文件。使用“none”（未设置此选项时的默认值）还显示在更改后的工作树中未追踪文件的子模块。此设置将覆盖此子模块的 .gitmodules 中的任何设置，两个设置都可以在命令行上使用“<code>git submodule</code> 命令不受此设置的影响。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.&lt;name&gt;.active</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指示子模块是否对git命令感兴趣的布尔值。此配置选项优先于
 submodule.active  配置选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.active</p></div></div><div class="doc-postil"><div class="c-markdown"><p>重复字段，其中包含一个用于匹配子模块路径的 pathspec，以确定子模块是否对 git 命令感兴趣。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.recurse</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定默认情况下，命令是否递归到子模块中。这适用于所有有<code>--recurse-submodules</code>选项的命令。默认为 false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.fetchJobs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定同时获取/克隆多少个子模块。正整数允许多达并行获取的子模块的数量。值为0会给出一些合理的默认值。如果未设置，则默认为1。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.alternateLocation</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定克隆子模块时子模块如何获得替代。可能的值是<code>no</code>，<code>superproject</code>。默认情况下<code>no</code>，假定不添加引用。当该值设置为<code>superproject</code>要克隆的子模块时，计算其相对于超级项目替代项的替代位置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>submodule.alternateErrorStrategy</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定如何通过经由计算得到的子模块的交替来处理错误<code>submodule.alternateLocation</code>。可能的值是<code>ignore</code>，<code>info</code>，<code>die</code>。默认是<code>die</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>tag.forceSignAnnotated</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个布尔值，指定创建的带注释的标签是否应该由GPG签名。如果<code>--annotate</code>在命令行中指定，则优先于此选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>tag.sort</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该变量控制git-tag [1]显示标签时的排序顺序。如果没有提供“--sort = &lt;value&gt;”选项，则此变量的值将用作默认值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>tar.umask</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个变量可以用来限制tar归档项的权限位。默认值是0002，这将关闭世界写入位。特殊值“user”表示将使用归档用户的umask。请参阅umask（2）和git-archive [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>transfer.fsckObjects</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当设置<code>fetch.fsckObjects</code>或未<code>receive.fsckObjects</code>设置时，将使用此变量的值。默认为false。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>transfer.hideRefs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>字符串<code>receive-pack</code>和<code>upload-pack</code>用于决定哪些引用从他们的初始广告中省略。使用多个定义来指定多个前缀字符串。排除了此变量的值中列出的层次结构下的 ref，并在响应<code>git push</code>或时隐藏<code>git fetch</code>。见<code>receive.hideRefs</code>及<code>uploadpack.hideRefs</code>此配置的具体方案版本。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您也可以<code>!</code>在ref名称的前面添加一个否定条目，并将其明确地公开，即使先前的条目将其标记为隐藏。如果您有多个 hideRefs 值，则稍后的条目会覆盖较早的条目（并且更具体的配置文件中的条目会覆盖较不特定的条目）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果正在使用命名空间，则在与<code>transfer.hiderefs</code>模式匹配之前，命名空间前缀会从每个引用中剥离。例如，如果<code>refs/heads/master</code>在中指定<code>transfer.hideRefs</code>并且当前命名空间是<code>foo</code>，则<code>refs/namespaces/foo/refs/heads/master</code>在广告中将被省略，<code>refs/heads/master</code>并且<code>refs/namespaces/bar/refs/heads/master</code>仍然被广告为所谓的“有”行。为了在裁剪之前匹配裁判<code>^</code>，请在裁判名称前添加一个裁判。如果合并<code>!</code>和<code>^</code>，<code>!</code>必须先指定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>即使你隐藏了引用，客户仍然可以通过 gitnamespaces [7] 手册页的“安全”部分描述的技术窃取目标对象; 最好将私人数据保存在单独的存储库中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>transfer.unpackLimit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当设置<code>fetch.unpackLimit</code>或未<code>receive.unpackLimit</code>设置时，将使用此变量的值。默认值是100。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>uploadarchive.allowUnreachable</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果为 true，则允许客户端使用<code>git archive --remote</code>请求任何树，无论是否可以从 ref 参考中获得。有关更多详细信息，请参阅 git-upload-archive [1]的“安全性”部分中的讨论。默认为<code>false</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>uploadpack.hideRefs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这个变量是相同的<code>transfer.hideRefs</code>，但只适用于<code>upload-pack</code>（并且因此只影响提取，不推进）。尝试获取隐藏参考<code>git fetch</code>将失败。另见<code>uploadpack.allowTipSHA1InWant</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>uploadpack.allowTipSHA1InWant</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>uploadpack.hideRefs</code>有效时，允许<code>upload-pack</code>接受一个提取请求，要求在隐藏参考的顶端提供一个对象（默认情况下，这样的请求被拒绝）。另见<code>uploadpack.hideRefs</code>。即使这是错误的，客户端也可以通过gitnamespaces [7]手册页的“安全”部分中描述的技术窃取对象; 最好将私人数据保存在单独的存储库中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>uploadpack.allowReachableSHA1InWant</p></div></div><div class="doc-postil"><div class="c-markdown"><p>允许<code>upload-pack</code>接受一个提取请求，要求提供可从任何参考提示中获得的对象。但是，请注意，计算对象可达性的计算成本很高。默认为<code>false</code>。即使这是错误的，客户端也可以通过gitnamespaces [7]手册页的“安全”部分中描述的技术窃取对象; 最好将私人数据保存在单独的存储库中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>uploadpack.allowAnySHA1InWant</p></div></div><div class="doc-postil"><div class="c-markdown"><p>允许<code>upload-pack</code>接受请求任何对象的获取请求。默认为<code>false</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>uploadpack.keepAlive</p></div></div><div class="doc-postil"><div class="c-markdown"><p>何时<code>upload-pack</code>开始<code>pack-objects</code>，在<code>pack-objects</code>准备包装时可能会有一段安静的时间。通常情况下，它会输出进度信息，但如果<code>--quiet</code>用于提取，<code>pack-objects</code>则在包数据开始之前不会输出任何内容。有些客户和网络可能会认为服务器被挂起并放弃。设置此选项将指示<code>upload-pack</code>每隔<code>uploadpack.keepAlive</code>几秒发送一个空的Keepalive数据包。将此选项设置为0将完全禁用 Keepalive 数据包。默认值是5秒。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>uploadpack.packObjectsHook</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置了此选项，<code>upload-pack</code>则将运行时<code>git pack-objects</code>为客户端创建一个packfile，它将运行此shell命令。<code>pack-objects</code>它所<code>would</code>运行的命令和参数（包括<code>git pack-objects</code>开始处）被附加到shell命令中。挂钩的stdin和stdout被视为<code>pack-objects</code>自己运行。也就是说，<code>upload-pack</code>将喂入用于<code>pack-objects</code>钩子的输入，并期望在stdout上完成一个包文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，如果在配置库级配置中看到此配置变量（这是针对从不受信任的存储库中获取的安全措施），则忽略此配置变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>url.&lt;base&gt;.insteadOf</p></div></div><div class="doc-postil"><div class="c-markdown"><p>任何以此值开头的URL都将被重写为启动，而&lt;base&gt;。如果某个站点提供大量存储库并以多种访问方式提供服务，并且某些用户需要使用不同的访问方法，则此功能允许用户指定任何等效的 URL 并让 Git 自动将 URL 重写为对于特定用户来说，这是最好的选择，即使对于网站上从未见过的存储库也是如此。如果多个字符串匹配给定的URL，则使用最长匹配。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，任何协议限制都将应用于重写的URL。如果重写将URL更改为使用自定义协议或远程助手，则可能需要调整<code>protocol.*.allow</code>配置以允许请求。特别是，您希望用于子模块的协议必须设置为<code>always</code>默认值而不是默认值<code>user</code>。请参阅<code>protocol.allow</code>上面的描述。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>url.&lt;base&gt;.pushInsteadOf</p></div></div><div class="doc-postil"><div class="c-markdown"><p>任何以此值开头的网址都不会被推送到; 相反，它将被重写为以&lt;base&gt;开始，并且生成的 URL 将被推送到。在某些站点提供大量存储库并使用多种访问方法（其中一些不允许推送）访问它们的情况下，此功能允许用户指定只能拉的 URL 并让 Git 自动使用适当的 URL 来推送，即使是在网站上一个从未见过的存储库。当多个 pushInsteadOf字符串匹配给定的 URL 时，将使用最长匹配。如果远程有明确的pushurl，Git 会忽略该远程的这个设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>user.email</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您的电子邮件地址将记录在任何新创建的提交中。可以通过覆盖<code>GIT_AUTHOR_EMAIL</code>，<code>GIT_COMMITTER_EMAIL</code>以及<code>EMAIL</code>环境变量。参见git-commit-tree [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>user.name</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您的全名将记录在任何新创建的提交中。可以通过覆盖<code>GIT_AUTHOR_NAME</code>和<code>GIT_COMMITTER_NAME</code>环境变量。参见git-commit-tree [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>user.useConfigOnly</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 的指导，避免试图猜测默认值<code>user.email</code>和<code>user.name</code>，而是只从配置检索值。例如，如果您有多个电子邮件地址，并且希望为每个存储库使用不同的配置，那么将此配置选项设置为<code>true</code>全局配置以及名称，Git 会在提交新提交之前提示您设置电子邮件在一个新克隆的仓库中。默认为<code>false</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>user.signingKey</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果在创建签名标记或提交时 git-tag [1]或 git-commit [1]没有选择您希望它自动使用的密钥，则可以使用此变量覆盖缺省选择。这个选项不变地传递给 gpg 的--local-user参数，所以你可以使用 gpg 支持的任何方法指定一个键。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>versionsort.prereleaseSuffix (deprecated)</p></div></div><div class="doc-postil"><div class="c-markdown"><p>已弃用的别名<code>versionsort.suffix</code>。如果<code>versionsort.suffix</code>已设置，则忽略。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>versionsort.suffix</p></div></div><div class="doc-postil"><div class="c-markdown"><p>即使在git-tag [1]中使用版本排序，具有相同基本版本但不同后缀的标记名仍然按照字典顺序排序，从而导致例如在主版本之后出现预发布标签（例如，“1.0”之后的“1.0-rc1”） 。可以指定该变量来确定具有不同后缀的标签的排序顺序。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过在此变量中指定单个后缀，包含该后缀的任何标记名都将出现在相应的主要版本之前。例如，如果变量设置为“-rc”，则所有“1.0-rcX”标签将出现在“1.0”之前。如果指定多次（每个后缀一次），则配置中后缀的顺序将确定具有这些后缀的标记名的排序顺序。例如，如果“-pre”出现在配置中的“-rc”之前，则所有“1.0-preX”标签将在任何“1.0-rcX”标签之前列出。主释放标签相对于具有各种后缀的标签的位置可以通过指定这些其他后缀之间的空后缀来确定。例如，如果后缀“-rc”，“”，“-ck”和“-bfs”</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果多个后缀匹配相同的标记名，那么该标记名将根据标记名中最早位置开始的后缀进行排序。如果多个不同的匹配后缀从最早的位置开始，那么该标记名将根据这些后缀中最长的那个进行排序。如果它们在多个配置文件中，则不同后缀之间的排序顺序未定义。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>网页浏览器</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定可能由某些命令使用的Web浏览器。目前只有git-instaweb [1]和git-help [1]可以使用它。</p></div></div></div>