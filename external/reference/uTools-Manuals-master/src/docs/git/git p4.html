<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4  - 从 Perforce 存储库导入和提交</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git p4 clone [&lt;sync options&gt;] [&lt;clone options&gt;] &lt;p4 depot path&gt;…
git p4 sync [&lt;sync options&gt;] [&lt;p4 depot path&gt;…]git p4 rebase
git p4 submit [&lt;submit options&gt;] [&lt;master branch name&gt;]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令提供了一种使用 Git 与 p4 存储库交互的方式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用现有的 p4 存储库创建一个新的 Git 存储库<code>git p4 clone</code>，并为其提供一个或多个 p4 depot 路径。将 p4 更改中的新提交合并到<code>git p4 sync</code>。该<code>sync</code>命令还用于包含来自其他 p4 软件仓库路径的新分支。使用提交 Git 回到 p4 <code>git p4 submit</code>。该命令<code>git p4 rebase</code>执行 sync 并将当前分支重新绑定到更新的 p4 远程分支上。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>克隆存储库：$ git p4 clone // depot / path / project</p></li><li><p>在新创建的 Git 仓库中做一些工作：$ cd project $ vi foo.h $ git commit -a -m“edited foo.h”</p></li><li><p>使用 p4 的最近更改更新 Git 存储库，重新定位顶层的工作：$ git p4 rebase</p></li><li><p>提交你的提交到 p4：$ git p4 submit</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h2>命令</h2></div></div><div class="doc-postil"><div class="c-markdown"><h3>Clone</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>通常<code>git p4 clone</code>用于从现有的 p4 存储库创建新的 Git 目录：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git p4 clone //depot/path/project</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这个：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>在名为的子目录中创建一个空的 Git 存储库<code>project</code>。</p></li><li><p>将来自给定 p4 仓库路径的头部修订版的完整内容导入到 Git 分支中的单个提交中<code>refs/remotes/p4/master</code>。</p></li><li><p><code>master</code>从这个远程创建一个本地分支并将其检出。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>要在 Git 中重现整个 p4 历史记录，请<code>@all</code>在软件仓库路径中使用修饰符：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git p4 clone //depot/path/project@all</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>Sync</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>随着 p4 存储库中的开发继续，可以使用以下方法将这些更改包含在 Git 存储库中：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git p4 sync</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>该命令在 p4 中查找新的更改，并将它们作为 Git 提交导入。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>P4 存储库也可以使用以下方式添加到现有的 Git 存储库<code>git p4 sync</code>：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ mkdir repo-git
$ cd repo-git
$ git init
$ git p4 sync //path/in/your/perforce/depot</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这会将指定的软件仓库导入到<code>refs/remotes/p4/master</code>现有的 Git 仓库中。该<code>--branch</code>选项可用于指定用于 p4 内容的不同分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果一个 Git 仓库包含分支<code>refs/remotes/origin/p4</code>，那么它们将在第一次被提取和咨询<code>git p4 sync</code>。由于从 p4 直接导入比从 Git 远程获取更改要慢得多，所以这在多开发人员环境中很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果有多个分支，<code>git p4 sync</code>则会自动使用“ 分支检测”算法尝试将新更改划分到正确的分支中。这可以通过<code>--branch</code>指定只更新一个分支的选项来覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>Rebase</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>一个常见的工作模式是从 p4 仓库获取最新的更改，并将它们与本地未提交的更改合并。通常，p4 存储库是所有代码的最终位置，因此重定位工作流程是有意义的。这个命令<code>git p4 sync</code>之后会<code>git rebase</code>在更新的 p4 更改之前移动本地提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git p4 rebase</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>Submit</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>将来自 Git 存储库的更改提交回 p4 存储库需要单独的 p4 客户端工作区。这应该使用<code>P4CLIENT</code>环境变量或 Git 配置变量来指定<code>git-p4.client</code>。p4 客户端必须存在，但如果客户端根目录尚不存在，它将被创建并填充。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要提交当前 Git 分支但不在分支中的所有更改<code>p4/master</code>，请使用：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git p4 submit</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>要指定除当前分支以外的分支，请使用：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git p4 submit topicbranch</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>上游引用通常是<code>refs/remotes/p4/master</code>，但可以使用<code>--origin=</code>命令行选项覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>p4 的更改将在用户调用时创建<code>git p4 submit</code>。该<code>--preserve-user</code>选项将根据 Git 提交的作者来修改所有权。此选项需要 p4 中的管理员权限，可以使用该权限授予<code>p4 protect</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><h3>常规选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>除克隆以外的所有命令均接受这些选项</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--git-dir &lt;dir&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>设置<code>GIT_DIR</code>环境变量。见 git [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-v   --verbose</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提供更多进度信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>同步选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项可以在初始<code>clone</code>和后续<code>sync</code>操作中使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--branch &lt;ref&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将更改导入 &lt;ref&gt; 而不是 refs / remotes / p4 / master 。如果 &lt;ref&gt; 以 refs /开头，则按原样使用。否则，如果它不以 p4 /开头，则添加该前缀。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，不以 refs /开始的 &lt;ref&gt; 被视为远程跟踪分支的名称（在 refs / remotes / 下）。这种行为可以使用 --import-local 选项来修改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认的 &lt;ref&gt; 是“master”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>本示例将新的远程 “p4 / proj2” 导入到现有的 Git 存储库中：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">    $ git init
    $ git p4 sync --branch=refs/remotes/p4/proj2 //depot/proj2</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>--detect-branches</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用分支检测算法在 p4 中查找新路径。它在“分支检测”中记录如下。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--changesfile &lt;file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>准确导入列出的 p4 更改编号<code>file</code>，每行一个。通常，<code>git p4</code>检查当前 p4 存储库状态并检测它应导入的更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--silent</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要打印任何进度信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--detect-labels</p></div></div><div class="doc-postil"><div class="c-markdown"><p>查询与仓库路径关联的标签的 p4 ，并将它们作为标签添加到 Git 中。由于只有与新的更改列表相关的导入标签才有用。已过时。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--import-labels</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将标签从 p4 导入到 Git 中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--import-local</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，p4 分支存储在<code>refs/remotes/p4/</code>其中，它们将被 git-branch [1] 和其他命令视为远程跟踪分支。这个选项代替了 p4 分支<code>refs/heads/p4/</code>。请注意，未来的同步操作也必须指定<code>--import-local</code>，以便他们可以在 refs / heads 中找到 p4 分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--max-changes &lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>导入大多数<code>n</code>变化，而不是包含在给定修订说明符中的整个变化范围。一个典型的用法将被<code>@all</code>用作修订说明符，然后用于<code>--max-changes 1000</code>仅导入最后的1000个修订版本而不是整个修订历史记录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--changes-block-size &lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将修订说明符（例如，<code>@all</code>转换为特定更改编号列表）时使用的内部块大小。不是使用单个调用来<code>p4 changes</code>查找转换的完整更改列表，而是调用一系列调用<code>p4 changes -m</code>，其中每个调用都请求一个给定大小的更改块。默认块大小为500，通常应该是合适的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--keep-path</p></div></div><div class="doc-postil"><div class="c-markdown"><p>缺省情况下，文件名从 p4 软件仓库路径到 Git 的映射涉及删除整个软件仓库路径。使用此选项，完整的 p4 仓库路径将保留在 Git 中。例如，<code>//depot/main/foo/bar.c</code>从中导入的路径<code>//depot/main/</code>变为<code>foo/bar.c</code>。与此同时<code>--keep-path</code>，Git 路径是<code>depot/main/foo/bar.c</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--use-client-spec</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用客户端规格在 p4 中查找感兴趣的文件列表。请参阅下面的“客户端规格”部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-/ &lt;path&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>克隆或同步时排除选定的软件仓库路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>克隆选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项可以在初始阶段<code>clone</code>与上述<code>sync</code>选项一起使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--destination &lt;directory&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在哪里创建 Git 存储库。如果未提供，则使用 p4 depot 路径中的最后一个组件创建新目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--bare</p></div></div><div class="doc-postil"><div class="c-markdown"><p>执行克隆空项。参见 git-clone [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>提交选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项可以用来修改<code>git p4 submit</code>行为。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--origin &lt;commit&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>确认提交到 p4 的上游位置。默认情况下，这是可从中获得的最新 p4 提交<code>HEAD</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-M</p></div></div><div class="doc-postil"><div class="c-markdown"><p>检测重命名。参见 git-diff [1] 。重命名将使用显式<code>move</code>操作在 p4 中表示。没有对应的选项来检测副本，但移动和副本都有变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--preserve-user</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在提交给 p4 之前，重新创建 p4 更改。该选项需要 p4 管理员权限。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--export-labels</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从 Git 导出标签作为 p4 标签。在 Git 中找到的标签应用于 perforce 工作目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-n   --dry-run</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示将提交给 p4 的提交; 不要在 Git 或 p4 中更改状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--prepare-p4-only</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将提交应用于 p4 工作区，在 p4 中打开，添加和删除文件，就像正常的提交操作一样。不要发布最终的“ p4 提交”，而是要打印一条关于如何手动提交或回复的消息。该选项总是在第一个（最早的）提交之后停止。Git 标签不会导出到 p4 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--shelve</p></div></div><div class="doc-postil"><div class="c-markdown"><p>而不是提交创建一系列搁置的更改表。创建每个搁置后，相关文件将被还原/删除。如果您有多个提交，则会创建多个搁板。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--update-shelve CHANGELIST</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用此提交更新现有的搁置更改列表。意味着 --shelve。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--conflict=(ask|skip|quit)</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将提交应用于 p4 时可能会发生冲突。发生这种情况时，默认行为（“询问”）是提示是否跳过此提交并继续或退出。此选项可用于绕过提示，导致提交冲突自动跳过，或退出尝试提交而不提示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--branch &lt;branch&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提交后，同步该命名分支，而不是默认的 p4 / master 。有关更多信息，请参阅上面的“同步选项”一节。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>改变选项</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项可以用来修改<code>git p4 rebase</code>行为。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--import-labels</p></div></div><div class="doc-postil"><div class="c-markdown"><p>导入 p4 标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>仓库路径语法</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>p4 的贮库路径参数<code>git p4 sync</code>和<code>git p4 clone</code>可以是一个或多个空格分隔 P4 贮库的路径，与在端部的可选 P4 修订说明符：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>"//depot/my/project"</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>#head</code>在树下的更改中导入一个具有所有文件的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>"//depot/my/project@all"</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为该软件仓库路径的历史记录中的每个更改导入一个提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>"//depot/my/project@1,6"</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只导入更改1到6。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>"//depot/proj1@all //depot/proj2@all"</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将来自两个指定软件仓库路径的所有更改导入单个存储库。只包含这些目录下的文件。每个 “proj1” 和 “proj2” 在 Git 中都没有一个子目录。<code>--destination</code>指定多个软件仓库路径时必须使用该选项。修订说明符必须在每个软件仓库路径上指定相同。如果软件仓库路径中有相同名称的文件，则具有该文件最近更新版本的路径就是出现在 Git 中的路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请参阅<code>p4 help revisions</code> p4 修订说明符的完整语法。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>客户端规格</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>p4 客户端规范是使用该<code>p4 client</code>命令维护的，并在其他字段中包含一个视图，指定仓库如何映射到客户端存储库。在<code>clone</code>与<code>sync</code>给定的命令时，可以咨询客户规范<code>--use-client-spec</code>选项，或当 useClientSpec 变量为真。之后<code>git p4 clone</code>，useClientSpec 变量将在存储库配置文件中自动设置。这允许未来的<code>git p4 submit</code>命令正常工作; 提交命令仅查看变量并且没有命令行选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关 p4 视图的完整语法记录在中<code>p4 help views</code>。<code>git p4</code>只知道视图语法的一个子集。它理解多行映射，覆盖<code>+</code>，排除<code>-</code>和空白处的双引号。可能的通配符中<code>git p4</code>只有句柄<code>…</code>，并且只有在路径的末尾。<code>git p4</code>如果遇到未处理的通配符将会投诉。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>存在重叠映射的实现中的错误。如果多个软件仓库路径通过叠加层映射到存储库中的相同位置，则<code>git p4</code>可以选择错误的路径。如果没有专门的客户端规范，这很难解决<code>git p4</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>客户的名字可以以<code>git p4</code>多种方式给出。<code>git-p4.client</code>如果该变量存在，则该变量优先。否则，将使用确定客户端的普通 p4 机制：环境变量 P4CLIENT ，由 P4CONFIG 引用的文件或本地主机名。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>分支检测</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>P4 与 Git 没有相同的分支概念。相反，p4将其内容组织为目录树，根据约定，不同的逻辑分支位于树中的不同位置。该<code>p4 branch</code>命令用于维护树中不同区域之间的映射，并指示相关内容。<code>git p4</code>可以使用这些映射来确定分支关系。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您有一个存储库，其中所有感兴趣的分支都作为单个软件仓库路径的子目录存在，则可以<code>--detect-branches</code>在克隆或同步时使用<code>git p4</code>自动在 p4 中查找子目录，并在 Git 中将其作为分支生成。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，如果 P4 存储库结构是：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">//depot/main/...//depot/branch1/...</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>并且“p4 分支 - o 分支1”显示一个 View 行，如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">//depot/main/... //depot/branch1/...</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后这个<code>git p4 clone</code>命令：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git p4 clone --detect-branches //depot@all</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>refs/remotes/p4/</code>为// depot / main 生成一个单独的分支<code>master</code>，并调用一个/ depot / branch1 <code>depot/branch1</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>但是，没有必要在 p4 中创建分支以便像分支一样使用它们。由于很难自动推断分支关系，<code>git-p4.branchList</code>因此可以使用 Git 配置设置来明确标识分支关系。它是一个 “source ：destination” 对的列表，就像一个简单的 p4 分支规范，其中 “source” 和 “destination” 是 p4 存储库中的路径元素。上面的例子依赖于 p4 分支的存在。没有 p4 分支，相同的结果将会发生：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git init depot
cd depot
git config git-p4.branchList main:branch1
git p4 clone --detect-branches //depot@all .</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>性能</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>快速导入机制<code>git p4</code>为每次调用创建一个包文件<code>git p4 sync</code>。通常，Git 垃圾压缩（ git-gc [1] ）会自动将这些压缩到更少的包文件，但显式调用<code>git repack -adf</code>可能会提高性能。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>配置变量</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>以下配置设置可用于修改<code>git p4</code>行为。他们都在该<code>git-p4</code>部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>一般变量</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.user</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用户指定为所有p4命令的选项，并带有<code>-u &lt;user&gt;</code>。该环境变量<code>P4USER</code>可以用来代替。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.password</p></div></div><div class="doc-postil"><div class="c-markdown"><p>作为所有 p4 命令的选项指定的密码<code>-P &lt;password&gt;</code>。该环境变量<code>P4PASS</code>可以用来代替。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.port</p></div></div><div class="doc-postil"><div class="c-markdown"><p>端口被指定为所有 p4 命令的选项<code>-p &lt;port&gt;</code>。该环境变量<code>P4PORT</code>可以用来代替。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.host</p></div></div><div class="doc-postil"><div class="c-markdown"><p>主机被指定为所有 p4 命令的选项，其中包含<code>-h &lt;host&gt;</code>。该环境变量<code>P4HOST</code>可以用来代替。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.client</p></div></div><div class="doc-postil"><div class="c-markdown"><p>客户端指定为所有 p4 命令的选项<code>-c &lt;client&gt;</code>，包括客户端规范。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.retries</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定在<code>p4 sync</code>网络超时的情况下重试 p4 命令（特别是）的次数。默认值为3.将该值设置为0以禁用重试，或者如果您的 p4版本不支持重试（2012年之前）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>克隆和同步变量</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.syncFromOrigin</p></div></div><div class="doc-postil"><div class="c-markdown"><p>因为从其他 Git 存储库导入提交比从 p4 导入提交要快得多，因此存在一种机制来首先在 Git 远程中查找 p4 更改。如果存在分支<code>refs/remote/origin/p4</code>，那么当从 p4 同步时，这些分支将被提取和使用。可以将此变量设置<code>false</code>为禁用此行为。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.branchUser</p></div></div><div class="doc-postil"><div class="c-markdown"><p>分支检测的一个阶段涉及查看 p4 分支以找到要导入的新分支。默认情况下，检查所有分支。此选项将搜索限制为仅由变量中指定的单个用户拥有的搜索。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.branchList</p></div></div><div class="doc-postil"><div class="c-markdown"><p>分支检测启用时要导入的分支列表。每个条目应该是一对由冒号（:)分隔的分支名称。这个例子声明 branchA 和 branchB 都是从 main 创建的：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git config       git-p4.branchList main:branchA
git config --add git-p4.branchList main:branchB</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.ignoredP4Labels</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要忽略的 p4 标签列表。这是在发现不可引用的标签时自动构建的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.importLabels</p></div></div><div class="doc-postil"><div class="c-markdown"><p>根据 --import-labels 将 p4 标签导入到 git 中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.labelImportRegexp</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只有与此正则表达式匹配的 p4 标签才会被导入。默认值是<code>[a-zA-Z0-9_\-.]+$</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.useClientSpec</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定应该使用 p4 客户端规范来识别感兴趣的 p4 仓库路径。这相当于指定选项<code>--use-client-spec</code>。请参阅上面的“客户端规格”部分。这个变量是一个布尔值，而不是 p4 客户端的名字。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.pathEncoding</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Perforce 保留原始操作系统给定的路径编码。Git 预计编码为 UTF-8 的路径。使用此配置来告诉 git-p4 Perforce 用于路径的编码。此编码用于将路径转码为 UTF-8 。例如，Windows 上的 Perforce 通常使用 “cp1252” 来编码路径名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.largeFileSystem</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定用于大型（二进制）文件的系统。请注意，大文件系统不支持该<code>git p4 submit</code>命令。只有 Git LFS 现在被实现（请参阅<a href="https://git-lfs.github.com/" target="_blank">https://git-lfs.github.com/</a>了解更多信息）。下载并安装 Git LFS 命令行扩展以使用此选项并像这样配置它：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git config       git-p4.largeFileSystem GitLFS</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.largeFileExtensions</p></div></div><div class="doc-postil"><div class="c-markdown"><p>所有与列表中文件扩展名匹配的文件都将由大文件系统处理。不要以扩展名为前缀<code>.</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.largeFileThreshold</p></div></div><div class="doc-postil"><div class="c-markdown"><p>所有未压缩大小超过阈值的文件都将由大文件系统处理。默认情况下，阈值以字节为单位定义。添加后缀 k ，m 或 g 以更改单位。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.largeFileCompressedThreshold</p></div></div><div class="doc-postil"><div class="c-markdown"><p>压缩大小超过阈值的所有文件都将由大文件系统处理。此选项可能会减慢您的克隆/同步过程。默认情况下，阈值以字节为单位定义。添加后缀 k ，m 或 g 以更改单位。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.largeFilePush</p></div></div><div class="doc-postil"><div class="c-markdown"><p>定义大文件是否自动推送到服务器的布尔变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.keepEmptyCommits</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果此布尔选项设置为 true ，则仅包含排除文件的更改列表将作为空提交导入。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.mapUser</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将 P4 用户映射到 Git 中的名称和电子邮件地址。使用以下格式的字符串来创建映射：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git config --add git-p4.mapUser "p4user = First Last &lt;mail@address.com&gt;"</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>映射将覆盖来自 P4 的任何用户信息。可以定义多个 P4 用户的映射。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>提交变量</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.detectRenames</p></div></div><div class="doc-postil"><div class="c-markdown"><p>检测重命名。参见 git-diff [1] 。这可能是真实的，错误的，或者如预期的那样<code>git diff -M</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.detectCopies</p></div></div><div class="doc-postil"><div class="c-markdown"><p>检测副本。参见 git-diff [1] 。这可能是真实的，错误的，或者如预期的那样<code>git diff -C</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.detectCopiesHarder</p></div></div><div class="doc-postil"><div class="c-markdown"><p>更难检测副本。参见 git-diff [1] 。一个布尔值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.preserveUser</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在提交时，无论谁调用，都要重新编写更改以反映 Git 作者<code>git p4 submit</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.allowMissingP4Users</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>preserveUser</code>属实，<code>git p4</code>通常会在 p4 用户映射中找不到作者的情况下死亡。无论如何，此设置都会提交更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.skipSubmitEdit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提交过程在提交每个 p4 更改之前调用编辑器。但是，如果此设置为 true ，则跳过编辑步骤。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.skipSubmitEditCheck</p></div></div><div class="doc-postil"><div class="c-markdown"><p>编辑 p4 更改消息后，<code>git p4</code>通过查看文件修改时间确保描述确实发生了变化。该选项禁用该测试。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.allowSubmit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，任何分支都可以用作<code>git p4 submit</code>操作的源。这个配置变量（如果设置的话）只允许指定的分支用作提交源。分支名称必须是短名称（不包括 “refs / heads /” ），并且应该用逗号（“，”）分隔，而不能有空格。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.skipUserNameCheck</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>git p4 submit</code>在 p4 用户映射中不存在正在运行的用户，则<code>git p4</code>退出。无论如何，此选项都可用于强制提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.attemptRCSCleanup</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果启用，<code>git p4 submit</code>将尝试清理 RCS 关键字（$ Header $等）。否则这些会导致合并冲突并阻止提交进行。目前这个选项应该被认为是实验性的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.exportLabels</p></div></div><div class="doc-postil"><div class="c-markdown"><p>根据 --export-labels 将 Git 标签导出到 p4 标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.labelExportRegexp</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只有与此正则表达式匹配的 p4 标签才会被导出。默认值是<code>[a-zA-Z0-9_\-.]+$</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git-p4.conflict</p></div></div><div class="doc-postil"><div class="c-markdown"><p>根据 --conflict 发现与 p4 发生冲突时的指定提交行为。默认行为是<code>ask</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>实施细节</h2></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>使用 Git 快速导入来导入 p4 中的更改集。</p></li><li><p>克隆或同步不需要 p4 客户端; 文件内容使用收集<code>p4 print</code>。</p></li><li><p>提交需要一个与 Git 存储库不在同一位置的 p4 客户端。修补程序一次一个地应用于此 p4 客户端并从那里提交。</p></li><li><p>导入的每个提交<code>git p4</code>在日志消息末尾都有一行指示 p4 仓库位置和更改编号。此行被以后的<code>git p4 sync</code>操作用于了解哪些 p4 更改是新的。</p></li></ul></div></div></div>