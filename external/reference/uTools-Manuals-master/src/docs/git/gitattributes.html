<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>gitattributes  - 定义每个路径的属性</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>$GIT_DIR/info/attributes, .gitattributes</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>一个<code>gitattributes</code>文件是一个给<code>attributes</code>路径名的简单文本文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>gitattributes</code>文件中的每一行都是以下格式：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">pattern        attr1 attr2 ...</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>也就是说，一个模式后跟一个属性列表，由空格分隔。前导空白和尾随空白被忽略。开头的行<code>#</code>被忽略。以双引号开头的模式以 C 风格引用。当模式与所讨论的路径相匹配时，行中列出的属性被赋予路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于给定路径，每个属性可以处于以下状态之一：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Set</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该路径具有特殊值“true”的属性; 这是通过仅列出属性列表中属性的名称来指定的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Unset</p></div></div><div class="doc-postil"><div class="c-markdown"><p>路径具有特殊值“false”的属性; 这是通过列出<code>-</code>在属性列表中以短划线为前缀的属性的名称来指定的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Set to a value</p></div></div><div class="doc-postil"><div class="c-markdown"><p>路径具有指定字符串值的属性; 这是通过<code>=</code>在属性列表中列出属性的名称，后跟等号和其值来指定的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Unspecified</p></div></div><div class="doc-postil"><div class="c-markdown"><p>没有模式匹配路径，并且没有任何说明路径是否具有该属性，路径的属性被称为未指定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当多于一个模式匹配路径时，稍后的一行覆盖较早的一行。这个重写是按属性完成的。模式如何匹配路径的规则与<code>.gitignore</code>文件中的相同；见 gitignore [5]。不像<code>.gitignore</code>，消极的模式是禁止的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当决定哪些属性被分配给一个路径时，Git 会咨询<code>$GIT_DIR/info/attributes</code>文件（其优先级最高），将<code>.gitattributes</code>文件放在与所讨论的路径相同的目录中，并将其父目录存储到工作树的顶级目录中包含<code>.gitattributes</code>来自有问题的路径，其优先级越低）。最后考虑全局和全系统文件（它们的优先级最低）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>.gitattributes</code>文件从工作树中丢失时，索引中的路径被用作回退。在结帐过程中，在索引中使用<code>.gitattributes</code>，然后使用工作树中的文件作为回退。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您希望仅影响单个存储库（即，将属性分配给特定于该存储库的一个用户工作流的<code>$GIT_DIR/info/attributes</code>文件），则属性应放置在该文件中。应该版本控制并分发到其他存储库（即所有用户感兴趣的属性）的属性应该放入<code>.gitattributes</code>文件中。应该影响单个用户的所有存储库的属性应放置在由<code>core.attributesFile</code>配置选项指定的文件中（请参阅 git-config [1]）。它的默认值是 $ XDG_CONFIG_HOME / git / attributes。如果 $ XDG_CONFIG_HOME 未设置或为空，则改为使用 $ HOME / .config / git / attributes。系统中所有用户的属性应放置在<code>$(prefix)/etc/gitattributes</code>文件中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有时您需要覆盖一个要指定<code>Unspecified</code>状态的路径的属性设置。这可以通过列出带有感叹号<code>!</code>前缀的属性名称来完成。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>效果</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>Git的某些操作可以通过将特定属性分配给路径来影响。目前，以下操作是可识别属性的。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>检出和检入</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>这些属性会影响存储在库中的内容复制到工作树中的文件时，命令，如<code>git checkout</code>和<code>git merge</code>运行。它们也会影响 Git 如何将存储在库中工作树中的内容存储在<code>git add</code>和<code>git commit</code>之上。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>text</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>该属性启用并控制行结束标准化。当一个文本文件被标准化时，它的行尾将在存储库中转换为 LF。要控制工作目录中使用的行结束风格，请使用单个文件的<code>eol</code>属性和所有文本文件的<code>core.eol</code>配置变量。请注意，<code>core.autocrlf</code>覆盖<code>core.eol</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>Set</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>text</code>在路径上设置属性可启用行结束标准化并将路径标记为文本文件。换行转换不需要猜测内容类型。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Unset</p></div></div><div class="doc-postil"><div class="c-markdown"><p>取消设置<code>text</code>路径上的属性会告诉 Git 在签入或结帐时不要尝试任何换行转换。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Set to string value "auto"</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>text</code>设置为“自动”时，该路径被标记为自动换行结束。如果 Git 确定内容是文本，则它的行尾在登记时会转换为 LF。用 CRLF 提交文件时，不进行转换。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Unspecified</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>text</code>属性未指定，Git 使用<code>core.autocrlf</code>配置变量来确定文件是否应该转换。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>任何其他值都会导致 Git 去扮演就像<code>text</code>未被指定一样。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>eol</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>该属性设置了要在工作目录中使用的特定行结束样式。它可以在没有任何内容检查的情况下实现行尾转换，从而有效地设置<code>text</code>属性。请注意，在具有 CRLF 行结尾的索引中的路径上设置此属性可能会使路径被认为是脏的。再次将路径添加到索引将标准化索引中的行尾。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Set to string value "crlf"</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此设置强制 Git 在签入时对该文件的行结束进行标准化，并在文件签出时将其转换为 CRLF。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Set to string value "lf"</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此设置强制 Git 在签入时将行尾标准化为 LF，并在签出文件时阻止转换为 CRLF。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>向后兼容<code>crlf</code>属性</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>为了向后兼容，该<code>crlf</code>属性被解释如下：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">crlf                text-crlf                -text
crlf=input        eol=lf</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h4>换行结束</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>虽然 Git 通常只保留文件内容，但可以将其配置为在存储库中将行尾标准化为 LF，并可选择将文件检出时转换为 CRLF。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您只是想在工作目录中拥有 CRLF 行结束符，而不考虑您正在使用的存储库，则可以在不使用任何属性的情况下设置配置变量“core.autocrlf”。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[core]
        autocrlf = true</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这不会强制对文本文件进行标准化，但会确保引入到存储库的文本文件的行结束符在添加时标准化为 LF，并且存储库中已经标准化的文件保持标准化。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您想确保任何贡献者向存储库引入的文本文件的行结束都已标准化，则可以将<code>all</code>文件的<code>text</code>属性设置为“自动” <code>all</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">*        text=auto</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这些属性允许进行细粒度的控制，如何转换行结束符。下面是一个例子，它将使Git规范化 .txt，.vcproj 和 .sh 文件，确保.vcproj 文件具有 CRLF，并且.sh 文件在工作目录中具有 LF，并防止.jpg 文件无论其内容如何标准化。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">*               text=auto*.txt                text*.vcproj        text eol=crlf*.sh                text eol=lf*.jpg                -text</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><div class="table-wrapper"><table><thead><tr class="firstRow"><th style="text-align: left;"><div class="table-header"><p>注意</p></div></th><th style="text-align: left;"><div class="table-header"><p>当使用推送到中央存储库的跨平台项目中启用 text = auto 转换时，应该对包含 CRLF 的文本文件进行规范化。</p></div></th></tr></thead><tbody></tbody></table></div></div></div><div class="doc-postil"><div class="c-markdown"><p>从一个干净的工作目录：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ echo "* text=auto" &gt;.gitattributes
$ git read-tree --empty   # Clean index, force re-scan of working directory
$ git add .$ git status        # Show files that will be normalized
$ git commit -m "Introduce end-of-line normalization"</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果有任何不应归一化的文件在<code>git status</code>出现，请在运行<code>git add -u</code>之前取消其<code>text</code>属性。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">manual.pdf        -text</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>相反，Git 未检测到的文本文件可以手动启用规范化。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">weirdchars.txt        text</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>core.safecrlf</code>设置为“true”或“warn”，Git 将验证转换对于当前<code>core.autocrlf</code>设置是否可逆。对于“真实”，Git 拒绝不可逆转的转换; 对于“警告”，Git 仅打印警告，但接受不可逆转的转换。安全触发器阻止对工作树中的文件执行这种转换，但有一些例外。即使...</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>git add</code> 本身不会触摸工作树中的文件，下一次检出会触发安全触发器;</p></li><li><p><code>git apply</code> 使用补丁更新文本文件确实会触摸工作树中的文件，但操作是关于文本文件和 CRLF 转换是关于修复行结束的不一致性，因此安全性不会触发；</p></li><li><p><code>git diff</code>本身不会触摸工作树中的文件，它通常会运行以检查您打算接下来的<code>git add</code>更改。为了及早发现潜在的问题，安全触发器。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>ident</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>ident</code>为路径设置属性时，Git 用blob对象中的<code>$Id:</code>替换<code>$Id$</code>，后面跟着40个字符的十六进制 blob 对象名称，后面跟着美元符号<code>$</code>。任何以worktree文件开头<code>$Id:</code>和结尾的字节序列<code>$</code>在登记时被<code>$Id$</code>替换。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>filter</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>一个<code>filter</code>属性可以设置为一个字符串值，用于命名配置中指定的过滤器驱动程序。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>过滤器驱动程序由一个<code>clean</code>命令和一个<code>smudge</code>命令组成，其中任何一个都可以不指定。结帐时，当<code>smudge</code>指定命令时，该命令从其标准输入中输入blob对象，其标准输出用于更新工作树文件。同样，该<code>clean</code>命令用于在签入时转换工作文件的内容。默认情况下，这些命令只处理一个blob并终止。例如<code>git add --all</code>，如果使用长时间运行的<code>process</code>过滤器来替代<code>clean</code>和/或<code>smudge</code>过滤器，则例如，Git 可以在单个Git 命令的整个生命周期内通过单个过滤器命令调用来处理所有  blob 。如果长时间运行<code>process</code>过滤器配置，那么它始终优先于配置的单个 blob 过滤器。有关用于与<code>process</code>过滤器通信的协议的说明，请参阅下面的部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>内容过滤的一个用途是将内容按摩成更适合平台，文件系统和用户使用的形状。对于这种操作模式，这里的关键词是“更方便”，而不是“把某些不可用的东西变成可用的”。换句话说，目的是如果某人取消了过滤器驱动程序的定义，或者没有合适的过滤器程序，该项目仍然可以使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>内容过滤的另一个用途是存储不能直接在存储库中使用的内容（例如，引用 Git 外部存储的真实内容的 UUID 或加密的内容），并在结帐时将其转换为可用的形式（例如下载外部内容或解密加密的内容）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这两个过滤器的行为不同，默认情况下，过滤器被视为前者，将内容按摩到更方便的形状。配置中缺少的过滤器驱动程序定义或以非零状态退出的过滤器驱动程序不是错误，而是使过滤器成为无操作中继。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以声明过滤器通过将过滤器&lt;driver&gt; .需要配置变量设置为<code>true</code>，将本身不可用的内容转换为可用内容。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，在.gitattributes 中，您可以为路径分配<code>filter</code>属性。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">*.c        filter=indent</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后，您可以在.git / config 中定义一个“filter.indent.clean”和“filter.indent.smudge”配置来指定一对命令，以在源文件签入时修改C程序的内容（“clean “运行）并检出（因为命令是”cat“，所以不做任何更改）。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[filter "indent"]
        clean = indent
        smudge = cat</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>为了获得最佳效果，<code>clean</code>如果运行两次（“清洁→清洁”应该相当于“清洁”），并且多个<code>smudge</code>命令不应该改变<code>clean</code>输出（“污迹→污迹→清洁”应当相当以“清洁”）。请参阅下面的合并部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>“indent”过滤器在这方面表现良好：它不会修改已经正确缩进的输入。在这种情况下，缺少污迹过滤器意味着干净的过滤器<code>must</code>接受自己的输出而不修改它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果过滤器<code>must</code>成功以使存储的内容可用，则可以在配置中声明过滤器是<code>required</code>：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[filter "crypt"]
        clean = openssl enc ...
        smudge = openssl enc -d ...
        required</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>过滤器命令行上的序列“％f”被替换为过滤器正在处理的文件的名称。过滤器可能会在关键字替换中使用它。例如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[filter "p4"]
        clean = git-p4-filter --clean %f
        smudge = git-p4-filter --smudge %f</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，“％f”是正在处理的路径的名称。根据正在过滤的版本，磁盘上的相应文件可能不存在，或者可能具有不同的内容。所以，smudge 和 clean 命令不应该尝试访问磁盘上的文件，而只能用作标准输入提供给他们的内容的过滤器。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>长时间运行过滤程序</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>如果过滤器命令（字符串值）是通过<code>filter.&lt;driver&gt;.process</code>定义的，那么 Git 可以在单个 Git 命令的整个生命周期内使用单个过滤器调用来处理所有 blob。这是通过使用基于标准输入和标准输出的数据包格式（pkt-line，参见technical / protocol-common.txt）来实现的，如下所示。除“* CONTENT”数据包和“0000”清除数据包之外的所有数据包都被视为文本，因此以LF结尾。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git在遇到需要清理或弄脏的第一个文件时启动过滤器。过滤器启动后，Git 发送一个欢迎消息（“git-filter-client”），一个支持的协议版本号列表和一个 flush 数据包。Git希望从先前发送的列表中读取一个欢迎响应消息（“git-filter-server”），一个协议版本号和一个 flush 数据包。所有进一步的沟通将基于选定的版本。下面的其余协议描述文档“version= 2”。请注意，以下示例中的“version = 42”不存在，仅用于说明协议在多个版本中的外观。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>版本协商之后，Git 发送它支持的所有功能和清除数据包的列表。Git 希望读取所需功能的列表，该列表必须是支持的功能列表的一个子集，以及作为响应的 flush 数据包：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">packet:          git&gt; git-filter-client
packet:          git&gt; version=2packet:          git&gt; version=42packet:          git&gt; 0000packet:          git&lt; git-filter-server
packet:          git&lt; version=2packet:          git&lt; 0000packet:          git&gt; capability=clean
packet:          git&gt; capability=smudge
packet:          git&gt; capability=not-yet-invented
packet:          git&gt; 0000packet:          git&lt; capability=clean
packet:          git&lt; capability=smudge
packet:          git&lt; 0000</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>版本2中支持的过滤器功能是“干净”，“污迹”和“延迟”（ "clean", "smudge", and "delay"）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>之后，Git 发送一个以 flush 数据包结尾的“key = value”对的列表。该列表将至少包含 filter 命令（基于支持的功能）以及要相对于存储库根目录过滤的文件的路径名。在冲洗数据包之后，Git 发送分割零或多个 pkt-line 数据包的内容和一个 flush 数据包来终止内容。请注意，过滤器在收到内容和最终清除数据包之前不得发送任何响应。另请注意，“key = value”对的“值”可以包含“=”字符，而该键不会包含该字符。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">packet:          git&gt; command=smudge
packet:          git&gt; pathname=path/testfile.dat
packet:          git&gt; 0000packet:          git&gt; CONTENT
packet:          git&gt; 0000</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>预计过滤器将以一个以“flush =”数据包结尾的“key = value”对列表作为响应。如果过滤器没有遇到问题，则列表必须包含“成功”状态。在这些数据包之后，过滤器应该在零或多个 pkt-line 数据包中发送内容，并在最后发送一个flush数据包。最后，预计会有一个以 flush 数据包结尾的“key = value”对的第二个列表。过滤器可以更改第二个列表中的状态或保持状态为空列表。请注意，空列表必须以 flush 数据包终止，无论如何。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">packet:          git&lt; status=success
packet:          git&lt; 0000packet:          git&lt; SMUDGED_CONTENT
packet:          git&lt; 0000packet:          git&lt; 0000  # empty list, keep "status=success" unchanged!</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果结果内容为空，则预计过滤器将以“成功”状态和清除数据包来响应空信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">packet:          git&lt; status=success
packet:          git&lt; 0000packet:          git&lt; 0000  # empty content!packet:          git&lt; 0000  # empty list, keep "status=success" unchanged!</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果过滤器不能或不想处理内容，则预期会以“错误”状态进行响应。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">packet:          git&lt; status=error
packet:          git&lt; 0000</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果过滤器在处理过程中遇到错误，则可以在内容（部分或完全）发送后发送状态“错误”。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">packet:          git&lt; status=success
packet:          git&lt; 0000packet:          git&lt; HALF_WRITTEN_ERRONEOUS_CONTENT
packet:          git&lt; 0000packet:          git&lt; status=error
packet:          git&lt; 0000</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果过滤器无法或不想处理内容以及 Git 进程生命周期内的任何未来内容，则预计会在协议中的任何时间以“中止”状态进行响应。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">packet:          git&lt; status=abort
packet:          git&lt; 0000</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果设置了“错误”/“中止”状态，Git 既不停止也不重新启动过滤器进程。但是，Git 根据<code>filter.&lt;driver&gt;.required</code>标志设置退出代码，模仿<code>filter.&lt;driver&gt;.clean</code>/ <code>filter.&lt;driver&gt;.smudge</code>机制的行为。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果过滤器在通信过程中死亡或者不遵守协议，则 Git 将停止过滤器过程，并使用下一个需要处理的文件重新启动它。根据<code>filter.&lt;driver&gt;.required</code>标志，Git会将其解释为错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>过滤器处理完一个命令后，需要等待包含下一个命令的“key = value”列表。Git 会在退出时关闭命令管道。预计过滤器会检测 EOF 并自行退出。Git 将等待，直到过滤器进程停止。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>延迟</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>如果过滤器支持“延迟”功能，则 Git 可以在过滤器命令和路径名后面发送“can-delay”标志。这个标志表示过滤器可以通过没有内容但响应状态“延迟”和清除数据包来延迟过滤当前 blob（例如以补偿网络等待时间）。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">packet:          git&gt; command=smudge
packet:          git&gt; pathname=path/testfile.dat
packet:          git&gt; can-delay=1packet:          git&gt; 0000packet:          git&gt; CONTENT
packet:          git&gt; 0000packet:          git&lt; status=delayed
packet:          git&lt; 0000</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果过滤器支持“延迟”功能，那么它必须支持“list_available_blobs”命令。如果Git发送这个命令，那么过滤器应该会返回一个路径名列表，这些路径名代表早先被延迟并且现在可用的斑点。该列表必须以 flush 数据包结尾，后跟“success”状态，该数据也以 flush 数据包终止。如果没有用于延迟路径的斑点可用，则过滤器预计将阻止该响应，直到至少有一个斑点可用。过滤器可以通过发送一个空列表来告诉 Git 它没有更多的延迟斑点。只要过滤器响应一个空的列表，Git 就会停止询问。此时 Git 尚未收到的所有斑点都将被视为丢失，并会导致错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">packet:          git&gt; command=list_available_blobs
packet:          git&gt; 0000packet:          git&lt; pathname=path/testfile.dat
packet:          git&lt; pathname=path/otherfile.dat
packet:          git&lt; 0000packet:          git&lt; status=success
packet:          git&lt; 0000</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>After Git received the pathnames, it will request the corresponding blobs again. These requests contain a pathname and an empty content section. The filter is expected to respond with the smudged content in the usual way as explained above.</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">packet:          git&gt; command=smudge
packet:          git&gt; pathname=path/testfile.dat
packet:          git&gt; 0000packet:          git&gt; 0000  # empty content!packet:          git&lt; status=success
packet:          git&lt; 0000packet:          git&lt; SMUDGED_CONTENT
packet:          git&lt; 0000packet:          git&lt; 0000  # empty list, keep "status=success" unchanged!</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h4>示例</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>长时间运行的过滤器演示实现可以在<code>contrib/long-running-filter/example.pl</code>位于 Git 核心存储库中找到。如果您开发自己的长时间运行的过滤器进程，那么<code>GIT_TRACE_PACKET</code>环境变量对调试非常有帮助（请参阅 git [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，由于前两者使用不同的进程间通信协议，因此不能使用现有<code>filter.&lt;driver&gt;.clean</code>或<code>filter.&lt;driver&gt;.smudge</code>命令<code>filter.&lt;driver&gt;.process</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>签入/签出属性之间的交互</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>在签入代码路径中，首先使用<code>filter</code>驱动程序（如果指定了相应的驱动程序并将其定义）转换为工作树文件，那么使用<code>ident</code>（如果已指定）处理结果，然后使用<code>text</code>（如果指定并适用，则再次）处理结果。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在签出代码路径中，blob 内容首先被<code>text</code>转换，然后被<code>ident</code>提交<code>filter</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>合并具有不同签入/签出属性的分支</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您已将属性添加到导致该文件的规范存储库格式发生更改的文件（如添加干净/污迹过滤器或 text / eol / ident 属性），那么合并属性不在位的任何东西通常会导致合并冲突。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为了防止这些不必要的合并冲突，可以通过设置<code>merge.renormalize</code>配置变量来解决三向合并问题时，可以让 Git 运行虚拟检出和检入文件的所有三个阶段。这样可以防止转换文件与未转换文件合并时由检入转换引起的更改导致虚假合并冲突。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只要“污迹→清理”与“干净”相同，即使对已经被污染的文件也会产生相同的输出，此策略将自动解决所有与过滤器有关的冲突。不以这种方式操作的过滤器可能会导致额外的合并冲突，必须手动解决。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>生成差异文本</h3></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>diff</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>该属性<code>diff</code>影响 Git 如何为特定文件生成差异。它可以告诉 Git 是为路径生成文本补丁还是将路径视为二进制文件。它也可以影响在 Hunk 标题<code>@@ -k,l +n,m @@</code>行上显示的行，告诉 Git 使用外部命令来生成 diff，或者在生成 diff 之前让 Git 将二进制文件转换为文本格式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Set</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将<code>diff</code>属性设置的路径视为文本，即使它们包含通常从不出现在文本文件中的字节值（例如 NUL）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Unset</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>diff</code>属性未设置的路径将生成<code>Binary files differ</code>（如果启用了二进制修补程序，则会生成二进制修补程序）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Unspecified</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>diff</code>首先未指定属性的路径将检查其内容，如果它看起来像文本且小于 core.bigFileThreshold，则将其视为文本。否则会产生<code>Binary files differ</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>String</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Diff 使用指定的 diff 驱动程序显示。每个驱动程序可以指定一个或多个选项，如以下部分所述。diff 驱动程序“foo”的选项由 Git 配置文件的“diff.foo”部分中的配置变量定义。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>定义一个外部差异驱动程序</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>差异驱动程序的定义是在<code>gitconfig</code>，而非<code>gitattributes</code>文件中完成的，所以严格来说，这个手册页是一个错误的地方来谈论它。然而...</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要定义一个外部差异驱动程序<code>jcdiff</code>，添加一个部分到你的<code>$GIT_DIR/config</code>文件（或<code>$HOME/.gitconfig</code>文件），像这样：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[diff "jcdiff"]
        command = j-c-diff</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>当 Git 需要向<code>diff</code>属性设置为<code>jcdiff</code>的路径显示 diff 时，它会调用您使用上述配置指定的命令，即<code>j-c-diff</code>使用7个参数，就像<code>GIT_EXTERNAL_DIFF</code>调用程序一样。有关详细信息，请参阅 git [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>定义一个自定义的 hunk-header</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>文本差异输出中的每组变化（称为“大块”）都以以下格式的行作为前缀：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">@@ -k,l +n,m @@ TEXT</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这被称为a <code>hunk header</code>。默认情况下，“TEXT”部分是以字母，下划线或美元符号开头的行; 这匹配了 GNU <code>diff -p</code>输出使用的内容。但是，此默认选择不适用于某些内容，您可以使用自定义模式进行选择。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>首先，在.gitattributes 中，您将为<code>diff</code>路径分配属性。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">*.tex        diff=tex</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后，您将定义一个“diff.tex.xfuncname”配置来指定一个正则表达式，该正则表达式与您希望显示为大块头“TEXT”的行匹配。添加一个部分到你的<code>$GIT_DIR/config</code>文件（或<code>$HOME/.gitconfig</code>文件），像这样：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[diff "tex"]
        xfuncname = "^(\\\\(sub)*section\\{.*)$"</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>注意。配置文件解析器会使用单级反斜杠，因此您需要将反斜杠加倍; 上面的模式选择一行以反斜杠开始的行，以及零个或多个出现的<code>sub</code>紧跟着<code>section</code>的开放大括号，直到行尾。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有一些内置模式可以使这更容易，并且<code>tex</code>是其中之一，所以您不必在配置文件中编写上述内容（您仍然需要使用属性机制来启用它，通过<code>.gitattributes</code>）。以下内置模式可用：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>ada</code> 适用于 Ada 语言的源代码。</p></li><li><p><code>bibtex</code> 适用于带有 BibTeX 编码参考的文件。</p></li><li><p><code>cpp</code> 适用于 C和C ++语言的源代码。</p></li><li><p><code>csharp</code> 适用于 C＃语言的源代码。</p></li><li><p><code>css</code> 适合级联样式表。</p></li><li><p><code>fortran</code> 适用于 Fortran 语言的源代码。</p></li><li><p><code>fountain</code> 适合喷泉文件。</p></li><li><p><code>html</code> 适用于 HTML / XHTML 文档。</p></li><li><p><code>java</code> 适用于 Java 语言的源代码。</p></li><li><p><code>matlab</code> 适用于 MATLAB 语言的源代码。</p></li><li><p><code>objc</code> 适用于 Objective-C 语言的源代码。</p></li><li><p><code>pascal</code> 适用于 Pascal / Delphi 语言的源代码。</p></li><li><p><code>perl</code> 适用于 Perl 语言的源代码。</p></li><li><p><code>php</code> 适用于 PHP 语言的源代码。</p></li><li><p><code>python</code> 适用于 Python 语言的源代码。</p></li><li><p><code>ruby</code> 适用于 Ruby 语言的源代码。</p></li><li><p><code>tex</code> 适用于 LaTeX 文档的源代码。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h4>自定义文字差异</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以<code>git diff --word-diff</code>通过在“diff。*。wordRegex”配置变量中指定适当的正则表达式来自定义用于在一行中拆分单词的规则。例如，在TeX中，反斜杠后面跟着一系列字母形成一个命令，但是几个这样的命令可以一起运行而不干预空白。要将它们分开，请在<code>$GIT_DIR/config</code>文件（或<code>$HOME/.gitconfig</code>文件）中使用正则表达式，如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[diff "tex"]
        wordRegex = "\\\\[a-zA-Z]+|[{}]|\\\\.|[^\\{}[:space:]]+"</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>为上一节中列出的所有语言提供了内置模式。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>执行二进制文件的文本差异</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>有时需要查看某些二进制文件的文本转换版本的差异。例如，文字处理器文档可以转换为 ASCII 文本表示，并显示文本的差异。即使这种转换丢失了一些信息，但由此产生的差异对于人类观看是有用的（但不能直接应用）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>textconv</code>配置选项被用来定义用于执行这种转换的程序。程序应该采用一个参数，即要转换的文件的名称，并在 stdout 上生成结果文本。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，要显示文件的exif信息的差异而不是二进制信息（假设已安装 exif 工具），请将以下部分添加到<code>$GIT_DIR/config</code>文件（或<code>$HOME/.gitconfig</code>文件）中：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[diff "jpg"]
        textconv = exif</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><div class="table-wrapper"><table><thead><tr class="firstRow"><th style="text-align: left;"><div class="table-header"><p>注意</p></div></th><th style="text-align: left;"><div class="table-header"><p>文本转换通常是单向转换; 在这个例子中，我们失去了实际的图像内容，只关注文本数据。这意味着由textconv生成的差异不适合应用。出于这个原因，只有 git diff 和 git log 命令系列（即 log，whatchanged，show）才会执行文本转换。git format-patch 永远不会生成这个输出。如果你想向某人发送一个二进制文件的文本转换差异（例如，因为它能够快速传达你所做的改变），你应该单独生成它并作为注释发送，除了你可能会使用的通常的二进制差异发送。</p></div></th></tr></thead><tbody></tbody></table></div></div></div><div class="doc-postil"><div class="c-markdown"><p>由于文本转换速度较慢，特别是在进行大量文本转换时<code>git log -p</code>，Git 提供了一种缓存输出并在未来差异中使用它的机制。要启用缓存，请在 diff 驱动程序的配置中设置“cachetextconv”变量。例如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[diff "jpg"]
        textconv = exif
        cachetextconv = true</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这将无限期地缓存每个 blob 上运行“exif”的结果。如果您更改 diff 驱动程序的 textconv 配置变量，Git 将自动使缓存项无效并重新运行 textconv 过滤器。如果您想手动使缓存失效（例如，因为您的“exif”版本已更新，现在可以产生更好的输出），您可以手动删除缓存<code>git update-ref -d refs/notes/textconv/jpg</code>（其中“jpg”是 diff 驱动程序的名称，如上面的例子）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>选择 textconv 与外部差异</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>如果要显示存储库中二进制或特殊格式的斑点之间的差异，可以选择使用外部 diff 命令，或使用 textconv 将它们转换为可区分的文本格式。您选择哪种方法取决于您的具体情况。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用外部 diff 命令的优点是灵活性。您不一定会发现面向行的更改，也不一定需要输出类似统一差异。您可以自由地以最适合您数据格式的方式查找和报告更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>相比之下，textconv 更受限制。您将数据转换为面向行的文本格式，Git 使用其常规差异工具生成输出。选择此方法有几个优点：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>使用方便。编写二进制文本转换通常要比执行自己的diff更简单。在很多情况下，现有的程序可以用作 textconv 过滤器（例如，exif，odt2txt）。</p></li><li><p>Git diff 功能。通过自己执行转换步骤，您仍然可以使用许多Git的差异功能，包括着色，文字差异和组合差异进行合并。</p></li><li><p>缓存。Textconv 缓存可以加速重复的差异，比如可能通过运行<code>git log -p</code>触发的差异。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><h4>将文件标记为二进制文件</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 通常会通过检查内容的开始来正确猜测 blob 是否包含文本或二进制数据。但是，有时您可能想要覆盖其决定，要么是因为 blob 稍后在文件中包含二进制数据，要么是因为在技术上由文本字符组成的内容对于人类读者而言是不透明的。例如，许多 postscript 文件只包含 ASCII 字符，但会产生嘈杂和无意义的差异。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将文件标记为二进制文件的最简单方法是在文件中取消设置 diff 属性<code>.gitattributes</code>：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">*.ps -diff</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这将导致 Git 生成<code>Binary files differ</code>（或二进制补丁，如果启用二进制补丁）而不是常规差异。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>但是，也可能需要指定其他diff驱动程序属性。例如，您可能希望使用<code>textconv</code>将 postscript 文件转换为 ASCII 表示以供人类查看，否则将它们视为二进制文件。您不能指定两者<code>-diff</code>和<code>diff=ps</code>属性。解决方案是使用<code>diff.*.binary</code>配置选项：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[diff "ps"]
  textconv = ps2ascii
  binary = true</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>执行三向合并</h3></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>merge</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>该属性<code>merge</code>影响如何在文件级合并过程<code>git merge</code>中合并文件的三个版本，以及其他命令（如<code>git revert</code>和<code>git cherry-pick</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Set</p></div></div><div class="doc-postil"><div class="c-markdown"><p>内置3路合并驱动程序用于以类似于套件<code>merge</code>命令的方式合并内容<code>RCS</code>。这适用于普通的文本文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Unset</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以当前分支的版本作为暂定合并结果，并声明合并有冲突。这适用于没有明确定义的合并语义的二进制文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Unspecified</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，它使用与<code>merge</code>设置属性时相同的内置3路合并驱动程序。但是，<code>merge.default</code>配置变量可以将不同的合并驱动程序命名为与未指定<code>merge</code>属性的路径一起使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>String （字符串）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用指定的自定义合并驱动程序执行3路合并。内置的3路合并驱动程序可以通过询问“文本”驱动程序来明确指定; 内置的“取当前分支”驱动程序可以用“二进制”来请求。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>内置合并驱动程序</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>有几个内置的低级合并驱动程序可以通过<code>merge</code>属性进行定义。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>text</p></div></div><div class="doc-postil"><div class="c-markdown"><p>文本文件的常用3路文件级别合并。冲突地区标有冲突标记<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>并且<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>。分支中的版本出现在<code>=======</code>标记之前，并且合并分支中的版本出现在<code>=======</code>标记之后。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>二进制</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将分支的版本保留在工作树中，但让路径处于冲突状态以供用户整理。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>联合</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对文本文件运行3路文件级别合并，但从两个版本中取出一行，而不是留下冲突标记。这往往会以随机顺序在结果文件中留下添加的行，并且用户应该验证结果。如果您不了解其含义，请不要使用它。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>定义一个自定义合并驱动程序</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>合并驱动程序的定义是在<code>.git/config</code>文件中完成的，而不是在<code>gitattributes</code>文件中完成的，所以严格来说，这个手册页是一个讨论它的错误地方。然而...</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要定义一个自定义合并驱动程序<code>filfre</code>，请向您的<code>$GIT_DIR/config</code>文件（或<code>$HOME/.gitconfig</code>文件）添加一个部分，如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[merge "filfre"]
        name = feel-free merge driver
        driver = filfre %O %A %B %L %P
        recursive = binary</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>该<code>merge.*.name</code>变量为驱动程序提供了一个人类可读的名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该<code>merge.*.driver</code>变量的值用于构造一个命令来运行以合并祖先的版本（<code>%O</code>），当前版本（<code>%A</code>）和其他分支的版本（<code>%B</code>）。当构建命令行时，这三个标记被替换为保存这些版本内容的临时文件的名称。此外，％L将替换为冲突标记大小（请参阅下文）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>合并驱动程序预计会通过覆盖文件而将合并结果留在名称为<code>%A</code>的文件中，如果设法将它们完全合并，则以零状态退出;如果存在冲突，则退出非零。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该<code>merge.*.recursive</code>变量指定在共有祖先之间进行内部合并时调用合并驱动程序时要使用的其他合并驱动程序（当存在多个合并驱动程序时）。如果未指定，则驱动程序本身用于内部合并和最终合并。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>合并驱动程序可以学习合并结果将通过<code>%P</code>占位符存储的路径名。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>conflict-marker-size</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>此属性控制冲突合并期间工作树文件中留下的冲突标记的长度。只有将值设置为正整数才会产生有意义的效果。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，<code>.gitattributes</code>在合并文件<code>Documentation/git-merge.txt</code>导致冲突时，此行可以用于告诉合并机制离开更长的时间（而不是通常的7个字符长）的冲突标记。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">Documentation/git-merge.txt        conflict-marker-size=32</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>检查空白错误</h3></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>whitespace</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>该<code>core.whitespace</code>配置变量允许您定义<code>diff</code>和<code>apply</code>应该考虑项目中的所有路径空白错误（请查看 git-配置[1]）。该属性为您提供了更好的每个路径控制。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Set</p></div></div><div class="doc-postil"><div class="c-markdown"><p>注意 Git 已知的所有类型的潜在空白错误。选项卡宽度取自<code>core.whitespace</code>配置变量的值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Unset</p></div></div><div class="doc-postil"><div class="c-markdown"><p>没有注意到任何错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Unspecified</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>core.whitespace</code>配置变量的值决定要注意的错误。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>String</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用与<code>core.whitespace</code>配置变量相同的格式指定逗号分隔的常见空白问题列表。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>创建一个档案</h3></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>export-ignore</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>具有该属性的文件和目录<code>export-ignore</code>不会被添加到存档文件中。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>export-subst</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>如果该属性<code>export-subst</code>是为一个文件设置的，那么 Git 将在将该文件添加到存档时展开多个占位符。扩展取决于提交 ID 的可用性，也就是说，如果 git-archive [1]被赋予树而不是提交或标签，则不会执行替换。占位符与用于git-log [1]的<code>--pretty=format:</code>git-log [1] 选项的占位符相同，只不过它们需要像这样包装：<code>$Format:PLACEHOLDERS$</code>在文件中。例如，字符串<code>$Format:%H$</code>将被提交散列替换。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>包装物品</h3></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>delta</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>对于属性<code>delta</code>设置为 false 的路径，不会尝试使用块压缩增量压缩。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>在 GUI 工具中查看文件</h3></div></div><div class="doc-postil"><div class="c-markdown"><h4><code>encoding</code></h4></div></div><div class="doc-postil"><div class="c-markdown"><p>这个属性的值指定了 GUI 工具应该使用的字符编码（例如 gitk [1]和 git-gui [1]）来显示相关文件的内容。请注意，由于性能方面的考虑，gitk [1]不使用此属性，除非在其选项中手动启用每个文件的编码。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果这个属性没有设置或者有一个无效值，那么<code>gui.encoding</code>会改用配置变量的值（参见 git-config [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>使用宏属性</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>您不希望对任何跟踪的二进制文件应用任何行尾转换，也不希望为其生成文本差异。你需要指定例如</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">*.jpg -text -diff</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>但是当你有很多属性时，这可能会变得很麻烦。使用宏属性，可以定义一个属性，该属性在设置时还可以同时设置或取消设置多个其他属性。系统知道一个内置的宏属性，<code>binary</code>：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">*.jpg binary</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>设置“binary”属性也会取消上面的“text”和“diff”属性。请注意，宏属性只能是“设置”，尽管设置一个属性可能会影响设置或取消设置其他属性，甚至将其他属性返回到“未指定”状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>定义宏属性</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>自定义宏属性只能定义在顶层 gitattributes 文件（<code>$GIT_DIR/info/attributes</code>，该<code>.gitattributes</code>文件在工作树的顶层，或者全球或全系统 gitattributes 文件），而不是<code>.gitattributes</code>在工作树子目录中的文件。内置宏属性“binary”相当于：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">[attr]binary -diff -merge -text</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>示例</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>如果你有这三个<code>gitattributes</code>文件：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">(in $GIT_DIR/info/attributes)
a*        foo !bar -baz
(in .gitattributes)
abc        foo bar baz
(in t/.gitattributes)
ab*        merge=filfre
abc        -foo -bar
*.c        frotz</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>给路径的属性<code>t/abc</code>计算如下：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>通过检查<code>t/.gitattributes</code>（与目标路径在同一目录中），Git 发现第一行匹配。<code>merge</code>属性设置。它还认为，第二行相匹配，和属性<code>foo</code>和<code>bar</code>都没有设置。</p></li><li><p>然后，它会检查<code>.gitattributes</code>（这是在父目录），并发现第一个行匹配，但<code>t/.gitattributes</code>文件已经决定如何<code>merge</code>，<code>foo</code>和<code>bar</code>属性应该给予这条道路，所以它的叶子<code>foo</code>和<code>bar</code>未设置。属性<code>baz</code>已设置。</p></li><li><p>最后它检查<code>$GIT_DIR/info/attributes</code>。该文件用于覆盖树中设置。第一行是匹配，并被<code>foo</code>设置，<code>bar</code>被还原为未指定状态，并且<code>baz</code>未设置。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>结果，分配的属性<code>t/abc</code>变为：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">foo        set to true
bar        unspecified
baz        set to false
merge        set to string value "filfre"
frotz        unspecified</code></pre></div></div></div>