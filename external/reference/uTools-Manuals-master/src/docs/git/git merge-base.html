<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-merge-base  - 为合并找到尽可能好的共同祖先</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git merge-base [-a|--all] &lt;commit&gt; &lt;commit&gt;…
git merge-base [-a|--all] --octopus &lt;commit&gt;…
git merge-base --is-ancestor &lt;commit&gt; &lt;commit&gt;git merge-base --independent &lt;commit&gt;…
git merge-base --fork-point &lt;ref&gt; [&lt;commit&gt;]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git merge-base</code>在两次提交之间找到最佳共同祖先以用于三向合并。<code>better</code>如果后者是前者的祖先，一个共同的祖先是另一个共同的祖先。一个没有任何更好的共同祖先的共同祖先是a <code>best common ancestor</code>，即a <code>merge base</code>。请注意，一对提交可能有多个合并基础。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>操作模式</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>作为最常见的特例，在命令行中只指定两个提交意味着计算给定两个提交之间的合并基础。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>更一般地说，在计算合并基数的两个提交中，有一个由命令行上的第一个提交参数指定; 另一个提交是一个（可能是假设的）提交，它是命令行上所有其余提交的合并。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>因此，<code>merge base</code>如果指定了两个以上的提交，则不一定包含在每个提交参数中。这与使用该<code>--merge-base</code>选项时不同于git-show-branch [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--octopus</p></div></div><div class="doc-postil"><div class="c-markdown"><p>计算所有提交的提交的最佳共同祖先，准备进行n路合并。这模仿的行为<code>git show-branch --merge-base</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--independent</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不是打印合并基础，而是使用相同的祖先打印提供的提交的最小子集。换句话说，在提交的提交中，列出那些无法从其他提供的提交。这模仿的行为<code>git show-branch --independent</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--is-ancestor</p></div></div><div class="doc-postil"><div class="c-markdown"><p>检查第一个&lt;commit&gt;是否是第二个&lt;commit&gt;的祖先，如果为true，则退出状态0，否则退出状态1。错误通过不为1的非零状态发出信号。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--fork-point</p></div></div><div class="doc-postil"><div class="c-markdown"><p>查找分支（或任何导致&lt;commit&gt;的历史记录）从另一个分支（或任何引用）&lt;ref&gt;分支的点。这不仅仅是寻找两个提交的共同祖先，而且还考虑了&lt;ref&gt;的引用日志，以查看引用&lt;commit&gt;的历史是否来自分支的早期化身&lt;ref&gt;（参见下面的这个模式）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-a   --all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>输出提交的所有合并基础，而不仅仅是一个。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>讨论</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>给定两个提交<code>A</code>和<code>B</code>，<code>git merge-base A B</code>将输出一个提交这从到达<code>A</code>和<code>B</code>通过父关系。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，对于这种拓扑结构：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">         o---o---o---B        /---o---1---o---o---o---A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>A</code>和<code>B</code>之间的合并基础是<code>1</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>鉴于三个提交<code>A</code>，<code>B</code>并且<code>C</code>，<code>git merge-base A B C</code>将计算之间的合并基础<code>A</code>和假设的承诺<code>M</code>，这是之间的合并<code>B</code>和<code>C</code>。例如，对于这种拓扑结构：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">       o---o---o---o---C      /     /   o---o---o---B    /   /---2---1---o---o---o---A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>结果<code>git merge-base A B C</code>是<code>1</code>。这是因为合并相当于拓扑承诺<code>M</code>之间<code>B</code>和<code>C</code>为：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">       o---o---o---o---o      /                 \     /   o---o---o---o---M    /   /---2---1---o---o---o---A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>结果<code>git merge-base A M</code>是<code>1</code>。提交<code>2</code>也是之间一个共同的祖先<code>A</code>和<code>M</code>，不过<code>1</code>是一个更好的共同的祖先，因为<code>2</code>是的祖先<code>1</code>。因此，<code>2</code>不是合并基础。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>结果<code>git merge-base --octopus A B C</code>是<code>2</code>，因为<code>2</code>是所有提交的最佳共同祖先。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当历史涉及纵横交错时<code>best</code>，两个提交可以有多个共同的祖先。例如，对于这种拓扑结构：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">---1---o---A
    \ /
     X    / \---2---o---o---B</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>两个<code>1</code>和<code>2</code>是A的合并底座和B.既不一个比另一个（均为更好<code>best</code>合并碱基）。如果<code>--all</code>没有给出选项，则没有指定哪一个输出最好。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>检查两个提交A和B之间的“快速前进”的常见方法是（或者至少用于）计算A和B之间的合并基础，并检查它是否与A相同，在这种情况下，A是B的祖先。你会在老的脚本中看到这种习惯用法。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">A=$(git rev-parse --verify A)if test "$A" = "$(git merge-base A B)"then        ... A is an ancestor of B ...fi</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在现代的git中，你可以用更直接的方式来说明这一点：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">if git merge-base --is-ancestor A B
then        ... A is an ancestor of B ...fi</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>代替。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>讨论叉点模式</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>在<code>topic</code>创建分支之后<code>git checkout -b topic origin/master</code>，远程跟踪分支的历史<code>origin/master</code>可能已经被重新卷绕和重建，导致这种形状的历史记录：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">                 o---B1                /---o---o---B2--o---o---o---B (origin/master)
        \
         B3
          \           Derived (topic)</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在那里<code>origin/master</code>用于指向提交B3，B2，B1，现在它指向B，并且当你在B3 <code>topic</code>时，你的分支在它的顶部被启动<code>origin/master</code>。此模式使用reflog <code>origin/master</code>来查找B3作为分叉点，以便<code>topic</code>可以在更新<code>origin/master</code>的基础上重新绑定：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ fork_point=$(git merge-base --fork-point origin/master topic)$ git rebase --onto origin/master $fork_point topic</code></pre></div></div></div>