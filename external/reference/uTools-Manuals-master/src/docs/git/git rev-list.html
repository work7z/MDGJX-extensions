<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>Name</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-rev-list  - 按反向时间顺序列出提交对象</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git rev-list [ --max-count=&lt;number&gt; ]             [ --skip=&lt;number&gt; ]             [ --max-age=&lt;timestamp&gt; ]             [ --min-age=&lt;timestamp&gt; ]             [ --sparse ]             [ --merges ]             [ --no-merges ]             [ --min-parents=&lt;number&gt; ]             [ --no-min-parents ]             [ --max-parents=&lt;number&gt; ]             [ --no-max-parents ]             [ --first-parent ]             [ --remove-empty ]             [ --full-history ]             [ --not ]             [ --all ]             [ --branches[=&lt;pattern&gt;] ]             [ --tags[=&lt;pattern&gt;] ]             [ --remotes[=&lt;pattern&gt;] ]             [ --glob=&lt;glob-pattern&gt; ]             [ --ignore-missing ]             [ --stdin ]             [ --quiet ]             [ --topo-order ]             [ --parents ]             [ --timestamp ]             [ --left-right ]             [ --left-only ]             [ --right-only ]             [ --cherry-mark ]             [ --cherry-pick ]             [ --encoding=&lt;encoding&gt; ]             [ --(author|committer|grep)=&lt;pattern&gt; ]             [ --regexp-ignore-case | -i ]             [ --extended-regexp | -E ]             [ --fixed-strings | -F ]             [ --date=&lt;format&gt;]             [ [ --objects | --objects-edge | --objects-edge-aggressive ]               [ --unpacked ] ]             [ --pretty | --header ]             [ --bisect ]             [ --bisect-vars ]             [ --bisect-all ]             [ --merge ]             [ --reverse ]             [ --walk-reflogs ]             [ --no-walk ] [ --do-walk ]             [ --count ]             [ --use-bitmap-index ]             &lt;commit&gt;… [ -- &lt;paths&gt;… ]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>通过跟踪<code>parent</code>来自给定提交的链接可以访问的列表提交，但排除可从其<code>^</code>前面提供的提交可访问的提交。默认情况下，输出按照时间倒序排列。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>你可以把它看作一个集合操作。在命令行中提交的提交形成了一组可从其中任何一个可访问的提交，然后<code>^</code>从该集合中减去前面给出的任何提交的提交。其余的提交是命令输出中的内容。可以使用各种其他选项和路径参数来进一步限制结果。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>因此，下面的命令：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        $ git rev-list foo bar ^baz</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>意思是“列出所有可从<code>foo</code>或可获取的提交<code>bar</code>，但不能从<code>baz</code>” 提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可以使用特殊的符号“ <code>&lt;commit1&gt;</code>.. <code>&lt;commit2&gt;</code>”作为“^'&lt;commit1&gt;' <code>&lt;commit2&gt;</code>”的缩写。例如，下列任何一种可以互换使用：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        $ git rev-list origin..HEAD
        $ git rev-list HEAD ^origin</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>另一种特殊的符号是“ <code>&lt;commit1&gt;</code>...... <code>&lt;commit2&gt;</code>”，这是合并有用。所得到的提交集合是两个操作数之间的对称差异。以下两个命令是等效的：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        $ git rev-list A B --not $(git merge-base --all A B)
        $ git rev-list A...B</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>rev-list</code>是一个非常重要的Git命令，因为它提供了构建和遍历提交血统图的功能。出于这个原因，它有很多不同的选项，使它可以被不同于<code>git bisect</code>和的命令使用<code>git repack</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><h3>提交限制</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>除了指定应使用描述中解释的特殊符号列出的提交范围之外，还可以应用其他提交限制。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除非另有说明，否则使用更多选项通常会进一步限制输出（例如<code>--since=&lt;date1&gt;</code>限制为提交更新<code>&lt;date1&gt;</code>，并将其与<code>--grep=&lt;pattern&gt;</code>对其日志消息具有匹配的提交的进一步限制进行使用<code>&lt;pattern&gt;</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，在提交排序和格式化选项之前应用这些选项，例如<code>--reverse</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-&lt;number&gt;   -n &lt;number&gt;   --max-count=&lt;number&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>限制提交输出的数量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--skip=&lt;number&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>number</code>在开始显示提交输出之前跳过提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--since=&lt;date&gt;   --after=&lt;date&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示比特定日期更近的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--until=&lt;date&gt;   --before=&lt;date&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示比特定日期更早的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--max-age=&lt;timestamp&gt;   --min-age=&lt;timestamp&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将提交输出限制在指定的时间范围内。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--author=&lt;pattern&gt;   --committer=&lt;pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将提交输出限制为与指定模式（正则表达式）匹配的作者/提交者标题行。使用多于一个<code>--author=&lt;pattern&gt;</code>，选择作者匹配任何给定模式的提交（类似地为多个<code>--committer=&lt;pattern&gt;</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--grep-reflog=&lt;pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将提交输出限制为具有与指定模式（正则表达式）匹配的reflog条目的提交输出。使用多于一个<code>--grep-reflog</code>，选择其reflog消息匹配任何给定模式的提交。除非<code>--walk-reflogs</code>正在使用，否则使用此选项是错误的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--grep=&lt;pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将提交输出限制为符合指定模式（正则表达式）的日志消息。使用多于一个<code>--grep=&lt;pattern&gt;</code>，提交的消息匹配任何给定模式的提交被选中（但请参阅<code>--all-match</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--all-match</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将提交输出限制为匹配所有给定的提交<code>--grep</code>，而不是至少匹配一个提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--invert-grep</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将提交输出限制为与日志消息不匹配的模式<code>--grep=&lt;pattern&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-i   --regexp-ignore-case</p></div></div><div class="doc-postil"><div class="c-markdown"><p>匹配正则表达式限制模式而不考虑字母大小写。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--basic-regexp</p></div></div><div class="doc-postil"><div class="c-markdown"><p>考虑限制模式是基本的正则表达式; 这是默认值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-E   --extended-regexp</p></div></div><div class="doc-postil"><div class="c-markdown"><p>考虑限制模式是扩展正则表达式而不是默认的基本正则表达式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-F   --fixed-strings</p></div></div><div class="doc-postil"><div class="c-markdown"><p>考虑限制模式为固定字符串（不要将模式解释为正则表达式）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-P   --perl-regexp</p></div></div><div class="doc-postil"><div class="c-markdown"><p>考虑限制模式是与Perl兼容的正则表达式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对这些类型的正则表达式的支持是可选的编译时间依赖性。如果Git没有编译支持它们，提供这个选项会导致它死亡。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--remove-empty</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当给定的路径从树上消失时停止。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--merges</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅打印合并提交。这完全一样<code>--min-parents=2</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-merges</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要打印与多个父代的提交。这完全一样<code>--max-parents=1</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--min-parents=&lt;number&gt;   --max-parents=&lt;number&gt;   --no-min-parents   --no-max-parents</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅显示至少（或至多）多次父级提交的提交。特别<code>--max-parents=1</code>是一样的<code>--no-merges</code>，<code>--min-parents=2</code>是一样的<code>--merges</code>。<code>--max-parents=0</code>给出所有的根提交和<code>--min-parents=3</code>所有子分支合并。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--no-min-parents</code>并<code>--no-max-parents</code>重新设置这些限制（无限制）。等价形式是<code>--min-parents=0</code>（任何承诺有0或更多父母）和<code>--max-parents=-1</code>（负数表示没有上限）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--first-parent</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在查看合并提交后，只跟踪第一个父提交。当查看特定主题分支的演变时，此选项可以提供更好的概述，因为合并到主题分支往往只是适应不断更新的上游时间，并且此选项允许您忽略单独提交到你的历史通过这样的合并。不能与--bisect结合使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--not</p></div></div><div class="doc-postil"><div class="c-markdown"><p>颠倒<code>^</code>所有后续修订说明符的前缀（或缺少）的含义，直到下一个<code>--not</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设所有的参考文件<code>refs/</code>，以及<code>HEAD</code>命令行都列为<code>&lt;commit&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--branches=&lt;pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设所有的参数<code>refs/heads</code>都在命令行中列为<code>&lt;commit&gt;</code>。如果<code>&lt;pattern&gt;</code>给出，则将分支限制为与给定shell glob匹配的分支。如果模式没有<code>?</code>，<code>*</code>或者<code>[</code>，<code>/*</code>在结束时暗示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--tags=&lt;pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设所有的参数<code>refs/tags</code>都在命令行中列为<code>&lt;commit&gt;</code>。如果<code>&lt;pattern&gt;</code>给出，则将标签限制为与给定 shell glob 匹配的标签。如果模式没有<code>?</code>，<code>*</code>或者<code>[</code>，<code>/*</code>在结束时暗示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--remotes=&lt;pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设所有的参数<code>refs/remotes</code>都在命令行中列为<code>&lt;commit&gt;</code>。如果<code>&lt;pattern&gt;</code>给出，则将远程跟踪分支限制为与给定shell glob匹配的分支。如果模式没有<code>?</code>，<code>*</code>或者<code>[</code>，<code>/*</code>在结束时暗示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--glob=&lt;glob-pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设所有与shell glob匹配的ref <code>&lt;glob-pattern&gt;</code>都在命令行中列出<code>&lt;commit&gt;</code>。领导<code>refs/</code>，如果失踪，会自动添加前缀。如果模式没有<code>?</code>，<code>*</code>或者<code>[</code>，<code>/*</code>在结束时暗示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--exclude=&lt;glob-pattern&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不包括裁判匹配<code>&lt;glob-pattern&gt;</code>，未来<code>--all</code>，<code>--branches</code>，<code>--tags</code>，<code>--remotes</code>，或<code>--glob</code>原本考虑。这个选项排除累积模式到下一个的重复<code>--all</code>，<code>--branches</code>，<code>--tags</code>，<code>--remotes</code>，或<code>--glob</code>选择（其他选项或参数不清除积累的模式）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>给予不应该开始的模式<code>refs/heads</code>，<code>refs/tags</code>或<code>refs/remotes</code>当应用到<code>--branches</code>，<code>--tags</code>或<code>--remotes</code>分别，他们必须开始<code>refs/</code>在应用于<code>--glob</code>或<code>--all</code>。如果尾随<code>/*</code>是有意的，则必须明确给出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--reflog</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设所有reflog提到的对象都在命令行中列为<code>&lt;commit&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ignore-missing</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在输入中看到一个无效的对象名称时，假装没有给出错误的输入。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--stdin</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除了<code>&lt;commit&gt;</code>在命令行上列出之外，还要从标准输入中读取它们。如果<code>--</code>看到分隔符，请停止读取提交并开始读取路径以限制结果。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--quiet</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要将任何内容打印到标准输出。这种形式主要是为了允许调用者测试退出状态以查看一系列对象是否完全连接（或不是）。<code>/dev/null</code>由于输出不需要格式化，因此比重定向 stdout 要快。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--cherry-mark</p></div></div><div class="doc-postil"><div class="c-markdown"><p>像<code>--cherry-pick</code>（见下文）但标记等价提交<code>=</code>而不是省略它们，以及不等价的提交<code>+</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--cherry-pick</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当提交集合受到对称差异限制时，省略任何提交引入与“另一侧”上的另一个提交相同的更改的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，如果您有两个分支，<code>A</code>并且<code>B</code>只列出所有提交的常用方法<code>--left-right</code>（请参阅下面的<code>--left-right</code>选项说明中的示例）。但是，它显示了从其他分支樱桃挑选的提交（例如，可能会从分支A挑选“b上的第3个分支”）。使用这个选项，这样的提交对将从输出中排除。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--left-only   --right-only</p></div></div><div class="doc-postil"><div class="c-markdown"><p>列表仅在对称差异的相应侧提交，即只有那些将被标记<code>&lt;</code>为resp的列表。<code>&gt;</code>通过<code>--left-right</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，<code>--cherry-pick --right-only A...B</code>省略了那些从提交<code>B</code>其在<code>A</code>或者补丁等同于提交<code>A</code>。换句话说，它列出了<code>+</code>来自提交<code>git cherry A B</code>。更准确地说，<code>--cherry-pick --right-only --no-merges</code>给出了确切的清单。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--cherry</p></div></div><div class="doc-postil"><div class="c-markdown"><p>的代名词<code>--right-only --cherry-mark --no-merges</code>; 有用的是将输出限制在我们这边的提交中，并且标记那些已经应用到分叉历史的另一边的那些<code>git log --cherry upstream...mybranch</code>，类似于<code>git cherry upstream mybranch</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-g   --walk-reflogs</p></div></div><div class="doc-postil"><div class="c-markdown"><p>而不是走提交祖先链，将 reflog 条目从最近的一条走到更旧的条目。当使用此选项，你不能指定提交排除（也就是<code>^commit</code>，<code>commit1..commit2</code>和<code>commit1...commit2</code>符号不能使用）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>凭借<code>--pretty</code>比其他格式<code>oneline</code>（原因很明显），这将导致输出有从引用日志信息采取两个额外的线路。输出中的reflog指示符可能会显示为<code>ref@{Nth}</code>（其中<code>Nth</code>是 reflog 中的反向按时间顺序的索引）或者<code>ref@{timestamp}</code>（具有该条目的时间戳），具体取决于以下几条规则：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>如果起始点被指定为<code>ref@{Nth}</code>，则显示索引格式。</p></li><li><p>如果起始点被指定为<code>ref@{now}</code>，则显示时间戳记格式。</p></li><li><p>如果两者都未使用，但<code>--date</code>已在命令行中提供，请按照要求的格式显示时间戳<code>--date</code>。</p></li><li><p>否则，显示索引格式。</p></li></ol><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>在此之下<code>--pretty=oneline</code>，提交消息在同一行上以此信息为前缀。该选项不能与<code>--reverse</code>。另请参阅 git-reflog [1]。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>--merge</p></div></div><div class="doc-postil"><div class="c-markdown"><p>合并失败后，显示引用文件有冲突并且不存在于所有合并头上。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--boundary</p></div></div><div class="doc-postil"><div class="c-markdown"><p>输出排除边界提交。边界提交以前缀<code>-</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--use-bitmap-index</p></div></div><div class="doc-postil"><div class="c-markdown"><p>尝试使用pack位图索引加速遍历（如果有可用的话）。请注意，遍历时<code>--objects</code>，树和斑点不会打印其相关路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--progress=&lt;header&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在考虑对象时显示stderr的进度报告。该<code>&lt;header&gt;</code>文本将印有各自的最新进展。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>历史简化</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>有时你只对历史的一部分感兴趣，例如修改特定&lt;path&gt;的提交。但是有两个部分<code>History Simplification</code>，一部分是选择提交，另一部分是如何执行，因为有各种策略可以简化历史记录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以下选项选择要显示的提交：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;paths&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提交修改给定的&lt;路径&gt;被选中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--simplify-by-decoration</p></div></div><div class="doc-postil"><div class="c-markdown"><p>由某个分支或标签引用的提交被选中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，可以显示额外的提交以提供有意义的历史记录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以下选项会影响简化的执行方式：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认模式</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将历史简化为解释树的最终状态的最简单历史记录。最简单的，因为如果最终结果是相同的（即合并具有相同内容的分支）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--full-history</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与默认模式相同，但不修剪某些历史记录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--dense</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只显示选定的提交，另外一些提供有意义的历史记录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--sparse</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示简化历史记录中的所有提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--simplify-merges</p></div></div><div class="doc-postil"><div class="c-markdown"><p>附加选项可<code>--full-history</code>从结果历史记录中删除一些不必要的合并，因为没有选定的提交对此合并作出贡献。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ancestry-path</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当给定一系列提交显示（例如<code>commit1..commit2</code>或<code>commit2 ^commit1</code>）时，仅显示直接存在于<code>commit1</code>和之间的祖先链上的<code>commit2</code>提交，即提交都是后代<code>commit1</code>，以及祖先<code>commit2</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>更详细的解释如下。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设你指定<code>foo</code>为&lt;路径&gt;。我们将调用修改的提交<code>foo</code>！TREESAME 和其余的 TREESAME。（在diff过滤后<code>foo</code>，它们分别看起来不同且相等。）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在下文中，我们将始终引用相同的示例历史记录来说明简化设置之间的差异。我们假设您正在筛选<code>foo</code>此提交图中的文件：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">          .-A---M---N---O---P---Q         /     /   /   /   /   /
        I     B   C   D   E   Y
         \   /   /   /   /   /
          `-------------'   X</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>历史A --- Q的水平线被认为是每个合并的第一个父代。提交是：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>I</code>是初始提交，其中<code>foo</code>存在内容“asdf”，文件<code>quux</code>存在内容“quux”。初始提交与空树比较，所以<code>I</code>是！TREESAME。</p></li><li><p>在中<code>A</code>，<code>foo</code>只包含“foo”。</p></li><li><p><code>B</code>包含与。相同的更改<code>A</code>。它的合并<code>M</code>是微不足道的，因此 TREESAME 给所有的父母。</p></li><li><p><code>C</code>不会更改<code>foo</code>，但其合并<code>N</code>会将其更改为“foobar”，因此对于任何父级，它不是 TREESAME。</p></li><li><p><code>D</code>设置<code>foo</code>为“baz”。它的合并<code>O</code>将来自<code>N</code>和<code>D</code>来自“foobarbaz” 的字符串结合起来; 即，它不是任何父母的 TREESAME。</p></li><li><p><code>E</code>更改<code>quux</code>为“xyzzy”，并将其合并<code>P</code>为“quux xyzzy”。<code>P</code>是TREESAME <code>O</code>，但不是<code>E</code>。</p></li><li><p><code>X</code>是一个独立的根提交，添加了一个新文件<code>side</code>并对其进行了<code>Y</code>修改。<code>Y</code>是TREESAME <code>X</code>。它的合并<code>Q</code>添加<code>side</code>到<code>P</code>，并且<code>Q</code>是TREESAME <code>P</code>，但不是<code>Y</code>。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p><code>rev-list</code>向后浏览历史记录，包括或不包括基于是否<code>--full-history</code>和/或父重写（通过<code>--parents</code>或<code>--children</code>）使用的提交。以下设置可用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认模式</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果对任何父项不是 TREESAME，则包含提交（尽管可以更改它，请参见<code>--sparse</code>下文）。如果提交是一个合并，并且它是一个父级的 TREESAME，则只跟随该父级。（即使有几个 TREESAME父母，请只遵循其中一个。）否则，请关注所有父母。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这导致：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">          .-A---N---O         /     /   /
        I---------D</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，只有遵循 TREESAME父级（如果有）的规则<code>B</code>完全从考虑中移除。<code>C</code>被认为是通过<code>N</code>，但是是
 TREESAME。根提交与空树比较，所以<code>I</code>是！TREESAME。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>父/子关系仅在可见时显示<code>--parents</code>，但不影响在默认模式下选择的提交，因此我们显示了父行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>- 没有父母重写的完整历史记录</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此模式与一点默认值不同：始终跟随合并的所有父项，即使它们中的一个为 TREESAME 也是如此。即使合并中有多个方面都包含提交，但这并不意味着合并本身就是！在这个例子中，我们得到了</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        I  A  B  N  D  O  P  Q</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>M</code>被排除在外，因为它对父母都是 TREESAME。<code>E</code>，<code>C</code>并且<code>B</code>都走了，但只能<code>B</code>是！TREESAME，所以别人不出现。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，如果没有父级重写，就不可能谈论提交之间的父/子关系，因此我们将它们显示为断开连接。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>- 父母重写的完整历史记录</p></div></div><div class="doc-postil"><div class="c-markdown"><p>普通提交只包含在！TREESAME（尽管可以改变，见<code>--sparse</code>下文）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>合并总是包括在内。但是，它们的父级列表会被重写：沿着每个父级删除未包含在其中的提交。这导致</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">          .-A---M---N---O---P---Q         /     /   /   /   /
        I     B   /   D   /
         \   /   /   /   /
          `-------------'</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>比较<code>--full-history</code>上面没有重写。请注意，<code>E</code>因为它是 TREESAME 而被删除，但P的父列表被重写为包含<code>E</code>父项<code>I</code>。同样的事情发生了<code>C</code>和<code>N</code>，和<code>X</code>，<code>Y</code>和<code>Q</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除上述设置外，您还可以更改 TREESAME 是否影响包含：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--dense</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果他们不是TREESAME给任何父母，那么被散步的提交将被包括在内。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--sparse</p></div></div><div class="doc-postil"><div class="c-markdown"><p>包括所有正在散步的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，如果没有<code>--full-history</code>，这仍然简化了合并：如果其中一位父母是 TREESAME，我们只遵循那一个，所以合并的其他方不会走。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--simplify-merges</p></div></div><div class="doc-postil"><div class="c-markdown"><p>首先，<code>--full-history</code>用父级重写的方式构建一个历史图（参见上文）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>然后根据以下规则简化每个提交<code>C</code>到<code>C'</code>最终历史记录中的替换：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>设置<code>C'</code>为<code>C</code>。</p></li><li><p>替换每个家长<code>P</code>的<code>C'</code>其简化<code>P'</code>。在这个过程中，放弃其他父母祖先或父母的父母将 TREESAME 提交给空树，并删除重复项，但请注意永不丢弃所有我们正在处理的父母。</p></li><li><p>如果在此父代重写之后，<code>C'</code>是根或合并提交（具有零或&gt; 1父项），边界提交或！TREESAME，它仍然存在。否则，它将被其唯一的父代替换。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>通过<code>--full-history</code>与父级重写进行比较，可以很好地显示此效果。这个例子变成：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">          .-A---M---N---O         /     /       /
        I     B       D
         \   /       /
          `---------'</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，在重大分歧<code>N</code>，<code>P</code>以及<code>Q</code>在<code>--full-history</code>：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>N</code>的父母名单已<code>I</code>被删除，因为它是另一父母的祖先<code>M</code>。仍然，<code>N</code>因为它是！ TREESAME。</p></li><li><p><code>P</code>的父母名单也被<code>I</code>删除。<code>P</code>然后被完全删除，因为它有一个父母，并且是 TREESAME。</p></li><li><p><code>Q</code>的父母名单已<code>Y</code>简化为<code>X</code>。<code>X</code>然后被删除，因为它是一个 TREESAME 根。<code>Q</code>然后被完全删除，因为它有一个父母，并且是TREESAME。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>最后，还有第五种可用的简化模式：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ancestry-path</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将显示的提交限制为在给定提交范围内“from”和“to”提交之间直接在祖先链上提交的提交。即只显示作为“to”提交祖先的提交和“提交”提交的后代。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>作为示例用例，请考虑以下提交历史记录：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">            D---E-------F           /     \       \
          B---C---G---H---I---J         /                     \
        A-------K---------------L--M</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>一个常规<code>D..M</code>计算的是一组祖先的提交<code>M</code>，但不包括那些祖先的提交<code>D</code>。这对于了解发生在历史上的事情是有用的，<code>M</code>因为<code>D</code>“有什么不<code>M</code>存在<code>D</code>”。在这个例子中的结果将是所有提交，除了<code>A</code>和<code>B</code>（与<code>D</code>本身，当然）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>但是，当我们想要查明哪些提交<code>M</code>受到引入<code>D</code>并需要修复的bug的影响时，我们可能只想查看其<code>D..M</code>实际后代的子集<code>D</code>，即排除<code>C</code>和<code>K</code>。这正是<code>--ancestry-path</code>选项所做的。适用<code>D..M</code>范围，它导致：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">                E-------F
                 \       \
                  G---H---I---J
                               \
                                L--M</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--simplify-by-decoration</code>通过省略标签未引用的提交，该选项允许您只查看历史拓扑的大图。如果（1）它们被标签引用，或者（2）它们改变了命令行给出的路径的内容，则提交被标记为！TREESAME（换句话说，保存在上述历史简化规则之后）。所有其他提交都标记为 TREESAME（可能会被简化）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>平分帮手</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>--bisect</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将输出限制为一个提交对象，该提交对象大致位于提交和排除提交之间的一半。请注意，坏的等分ref会<code>refs/bisect/bad</code>被添加到包含的提交（如果存在）并且好的等分ref <code>refs/bisect/good-*</code>被添加到排除的提交（如果存在）。因此，假设没有参考<code>refs/bisect/</code>，如果</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        $ git rev-list --bisect foo ^bar ^baz</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>输出<code>midpoint</code>，这两个命令的输出</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        $ git rev-list foo ^midpoint
        $ git rev-list midpoint ^bar ^baz</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>长度大致相同。找到引入回归的变化因此被简化为二分搜索：重复生成并测试新的中点，直到提交链的长度为1。不能与--first-parent结合使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--bisect-vars</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--bisect</code>除了<code>refs/bisect/</code>没有使用refs in之外，它的计算方法与之相同，除了输出的文本已准备好被shell评估。这些行将为变量指定中点修订的名称<code>bisect_rev</code>，并且测试之后<code>bisect_rev</code>要测试<code>bisect_nr</code>的提交的预期数量，如果<code>bisect_rev</code>结果为是，则要测试<code>bisect_good</code>的提交的预期数量，提交给被测试的<code>bisect_rev</code>结果是不好的<code>bisect_bad</code>，以及我们现在平分的提交数量<code>bisect_all</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--bisect-all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这将输出提交对象之间的所有提交对象包括和排除提交，按距离排序提交包含和排除。<code>refs/bisect/</code>没有使用参考。离他们最远的是最先显示的。（这是唯一显示的<code>--bisect</code>。）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这很有用，因为它可以很容易地选择一个好的提交来测试什么时候你想避免测试它们中的一些出于某种原因（它们可能不会编译）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--bisect-vars</code>在这种情况下，此选项可以与所有已排序的提交对象一起使用，并且会有与<code>--bisect-vars</code>单独使用相同的文本。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>提交订单</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，提交按反向时间顺序显示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--date-order</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在显示所有孩子之前不显示父母，但在提交时间戳顺序中显示提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--author-date-order</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在显示所有孩子之前不显示父母，但以作者时间戳顺序显示提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--topo-order</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在显示所有孩子之前不要显示父母，并且避免在多行历史记录中混合显示提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，在这样的提交历史记录中：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">    ---1----2----4----7
        \               \         3----5----6----8---</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>其中数字表示提交时间戳的顺序，<code>git rev-list</code>以及具有<code>--date-order</code>按时间戳顺序显示提交的朋友：8 7 6 5 4 3 2 1。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与<code>--topo-order</code>，他们会显示8 6 5 3 7 4 2 1（或8 7 4 2 6 5 3 1）; 一些较旧的提交显示在较新的提交之前，以避免将来自两条并行开发轨道的提交显示在一起。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--reverse</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以相反的顺序输出选择显示的提交（参见上面的提交限制部分）。不能与之结合<code>--walk-reflogs</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>对象遍历</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>这些选项主要针对包装Git存储库。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--objects</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打印列出的提交引用的任何对象的对象ID。<code>--objects foo ^bar</code>因此意味着“如果我有提交对象<code>bar</code>但不是我需要下载的所有对象ID <code>foo</code>”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--objects-edge</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--objects</code>与之类似，但也会打印以“ - ”字符为前缀的排除提交的ID。git-pack-objects [1]使用它来构建一个“精简”包，它基于这些排除的提交中包含的对象以分离形式记录对象，以减少网络流量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--objects-edge-aggressive</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--objects-edge</code>与之类似，但它试图以增加时间为代价寻找被排除的提交。这被用来代替<code>--objects-edge</code>浅存储库构建“瘦”包。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--indexed-objects</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设索引使用的所有树和斑点都列在命令行上。请注意，您可能也想使用<code>--objects</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--unpacked</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只用于<code>--objects</code>; 打印不在包装中的对象ID。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-walk=(sorted|unsorted)</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只显示给定的提交，但不要遍历其祖先。如果指定了范围，则这不起作用。如果提供了参数<code>unsorted</code>，则提交按照它们在命令行上的顺序显示。否则（如果<code>sorted</code>或没有给出参数），提交时间将按提交时间以反向时间顺序显示。不能与之结合<code>--graph</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--do-walk</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Overrides a previous <code>--no-walk</code>.</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>提交格式</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>使用这些选项，git-rev-list [1]的作用类似于更专门的提交日志工具系列：git-log [1]，git-show [1]和git-whatchanged [1]</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--pretty=&lt;format&gt;   --format=&lt;format&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在给定的格式漂亮地打印提交日志中的内容，在这里<code>&lt;format&gt;</code>可以是一个<code>oneline</code>，<code>short</code>，<code>medium</code>，<code>full</code>，<code>fuller</code>，<code>email</code>，<code>raw</code>，<code>format:&lt;string&gt;</code>和<code>tformat:&lt;string&gt;</code>。什么时候<code>&lt;format&gt;</code>没有上述情况，并且<code>%placeholder</code>在其中，它的行为就像<code>--pretty=tformat:&lt;format&gt;</code>是给予的一样。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关每种格式的其他详细信息，请参阅“PRETTY FORMATS”部分。当<code>=&lt;format&gt;</code>零件被省略时，它默认为<code>medium</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>注意：您可以在存储库配置中指定默认的漂亮格式（请参阅git-config [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--abbrev-commit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不显示完整的40字节十六进制提交对象名称，只显示部分前缀。非默认位数可以用“--abbrev = &lt;n&gt;”来指定（如果显示，它也会修改差异输出）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这应该使“--pretty = oneline”对于使用80列终端的人来说更加可读。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-abbrev-commit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示完整的40字节十六进制提交对象名称。这种否定<code>--abbrev-commit</code>和暗示它的选项如“--oneline”。它也覆盖<code>log.abbrevCommit</code>变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--oneline</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这是一起使用的“--pretty = oneline --abbrev-commit”的缩写。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--encoding=&lt;encoding&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提交对象在其编码头中记录用于日志消息的编码; 这个选项可以用来告诉命令在用户首选的编码中重新编写提交日志消息。对于非管道命令，默认为UTF-8。请注意，如果一个对象声称被编码<code>X</code>并且正在输出<code>X</code>，我们将逐字输出对象; 这意味着原始提交中的无效序列可能会被复制到输出中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--expand-tabs=&lt;n&gt;   --expand-tabs   --no-expand-tabs</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>&lt;n&gt;</code>在输出中显示日志消息之前，执行一个标签扩展（用足够的空格替换每个标签以填充下一个显示列的倍数）。<code>--expand-tabs</code>是一种短手<code>--expand-tabs=8</code>，并且<code>--no-expand-tabs</code>是一种短手<code>--expand-tabs=0</code>，即禁用选项卡扩展。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，突片在相当格式由4个空格（即缩进日志消息扩展<code>medium</code>，这是缺省值，<code>full</code>和<code>fuller</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--show-signature</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过签名传递<code>gpg --verify</code>并显示输出来检查签名提交对象的有效性。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--relative-date</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--date=relative</code>的同义词。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--date=&lt;format&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅对以人可读格式显示的日期生效，例如在使用时<code>--pretty</code>。<code>log.date</code>config变量为log命令的<code>--date</code>选项设置一个默认值。默认情况下，日期显示在原始时区（提交者或作者的）。如果<code>-local</code>附加到格式（例如，<code>iso-local</code>），则使用用户的本地时区。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--date=relative</code>显示相对于当前时间的日期，例如“2小时前”。该<code>-local</code>选项对于无效<code>--date=relative</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--date=local</code>是一个别名<code>--date=default-local</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--date=iso</code>（或<code>--date=iso8601</code>）以ISO 8601格式显示时间戳。与严格的ISO 8601格式的不同之处在于：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>一个空格而不是<code>T</code>日期/时间分隔符</p></li><li><p>时间和时区之间的空间</p></li><li><p>在时区的几小时和几分钟之间不会冒号</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p><code>--date=iso-strict</code>（或<code>--date=iso8601-strict</code>）以严格的ISO 8601格式显示时间戳。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>--date=rfc</code>（或<code>--date=rfc2822</code>）显示RFC 2822格式的时间戳，通常在电子邮件中找到。</p></li><li><p><code>--date=short</code>仅以<code>YYYY-MM-DD</code>格式显示日期，但不显示时间。</p></li><li><p><code>--date=raw</code>将时间显示为从时代（1970-01-01 00:00:00 UTC）开始的秒数，后跟一个空格，然后将时区作为UTC的偏移量（a <code>+</code>或<code>-</code>四位数;前两个是小时，并且第二个是分钟）。即，如果时间戳被格式化<code>strftime("%s %z")</code>）。请注意，该<code>-local</code>选项不会影响自始至终的秒数值（始终以UTC来衡量），但会切换随附的时区值。</p></li><li><p><code>--date=unix</code>将日期显示为Unix纪元时间戳（1970年以来的秒数）。与之相同<code>--raw</code>，这总是以UTC表示，因此<code>-local</code>不起作用。</p></li><li><p><code>--date=format:...</code>将格式输入<code>...</code>到系统中<code>strftime</code>，除了内部处理的％z和％Z之外。用于<code>--date=format:%c</code>以系统区域设置的首选格式显示日期。请参阅<code>strftime</code>手册以获取格式占位符的完整列表。使用时<code>-local</code>，正确的语法是<code>--date=format-local:...</code>。</p></li><li><p><code>--date=default</code>是默认格式，类似于<code>--date=rfc2822</code>，但有一些例外：</p></li><li><p>星期几之后没有逗号</p></li><li><p>使用本地时区时省略时区</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>--header</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以原始格式打印提交的内容; 每个记录都用NUL字符分隔。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--parents</p></div></div><div class="doc-postil"><div class="c-markdown"><p>也打印提交的父母（以“commit parent ...”的形式）。还允许父级重写，请参见<code>History Simplification</code>下文。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--children</p></div></div><div class="doc-postil"><div class="c-markdown"><p>也打印提交的子代（以“commit child ...”的形式）。还允许父级重写，请参见<code>History Simplification</code>下文。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--timestamp</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打印原始提交时间戳。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--left-right</p></div></div><div class="doc-postil"><div class="c-markdown"><p>标记可以从中提交提交的对称差异的哪一侧。来自左侧的提交将以前面的<code>&lt;</code>和前面的提交<code>&gt;</code>。如果合并<code>--boundary</code>，那些提交前缀为<code>-</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，如果你有这个拓扑：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">             y---b---b  branch B            / \ /           /   .          /   / \
         o---x---a---a  branch A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>你会得到这样的输出：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">        $ git rev-list --left-right --boundary --pretty=oneline A...B        &gt;bbbbbbb... 3rd on b        &gt;bbbbbbb... 2nd on b        &lt;aaaaaaa... 3rd on a        &lt;aaaaaaa... 2nd on a        -yyyyyyy... 1st on b        -xxxxxxx... 1st on a</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>--graph</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在输出的左侧绘制提交历史记录的基于文本的图形表示。这可能会导致在提交之间打印额外的行，以便正确绘制图表历史记录。不能与之结合<code>--no-walk</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这可以让父母重写，见<code>History Simplification</code>下文。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这意味着<code>--topo-order</code>默认情况下该选项，但<code>--date-order</code>也可以指定该选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--show-linear-break=&lt;barrier&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当不使用--graph时，所有历史分支都会变平，这使得很难看到两个连续的提交不属于线性分支。在这种情况下，这个选项在它们之间设置了一个障碍。如果<code>&lt;barrier&gt;</code>指定，则是将显示的字符串而不是默认的字符串。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--count</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打印一个数字，说明有多少提交将被列出，并禁止所有其他输出。与其一起使用时<code>--left-right</code>，将打印左侧和右侧提交的计数，并用制表符分隔。与<code>--cherry-mark</code>这些计数一起使用时，省略补丁等价提交，并打印由选项卡分隔的等价提交的计数。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>漂亮的格式</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>如果提交是合并，并且不是美观格式<code>oneline</code>，<code>email</code>或者<code>raw</code>在该<code>Author:</code>行之前插入额外的线条。该行以“Merge：”开始，并且祖先提交的sha1被打印出来，用空格分隔。请注意，如果您限制了对历史的查看，列出的提交可能不一定是<strong>直接</strong>父提交的列表：例如，如果您只对与某个目录或文件相关的更改感兴趣。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有几种内置格式，你可以通过设置一个漂亮的&lt;name&gt; config选项来定义其他格式<code>format:</code>，如下所述（参见git-config [1]）。以下是内置格式的详细信息：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>oneline</code>&lt;sha1&gt; &lt;title line&gt;</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>这被设计得尽可能紧凑。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>short</code>commit &lt;sha1&gt; Author: &lt;author&gt;</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;title line&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>medium</code>commit &lt;sha1&gt; Author: &lt;author&gt; Date:   &lt;author date&gt;</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;title line&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;full commit message&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>full</code>commit &lt;sha1&gt; Author: &lt;author&gt; Commit: &lt;committer&gt;</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;title line&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;full commit message&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>fuller</code>commit &lt;sha1&gt; Author:     &lt;author&gt; AuthorDate: &lt;author date&gt; Commit:     &lt;committer&gt; CommitDate: &lt;committer date&gt;</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;title line&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;full commit message&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>email</code>From &lt;sha1&gt; &lt;date&gt; From: &lt;author&gt; Date: &lt;author date&gt; Subject: PATCH &lt;title line&gt;</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;full commit message&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>raw</code> 的<code>raw</code>格式示出了整个提交完全一样存储在 commit 对象。值得注意的是，不管是否使用--abbrev 或 --no-abbrev，SHA-1 都会全部显示，并且<code>parents</code>信息显示的是真正的父提交，而不考虑移植或历史简化。请注意，这种格式会影响提交显示的方式，但不会影响比较显示的方式<code>git log --raw</code>。要以原始差异格式获取完整对象名称，请使用<code>--no-abbrev</code>。</p></li><li><p><code>format:&lt;string&gt;</code> 该<code>format:&lt;string&gt;</code>格式允许您指定要显示的信息。它的工作原理与 printf 格式有点相似，但有一个值得注意的例外，那就是用换行符<code>%n</code>代替<code>\n</code>。例如，<code>format:"The author of %h was %an, %ar%nThe title was &gt;&gt;%s&lt;&lt;%n"</code>会显示这样的内容：fe6e0ee 的作者是 Junio C Hamano，23小时前标题是&gt;&gt; t4119：测试 autocomputing -p &lt;n&gt;用于传统差异输入。&lt;&lt;</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>占位符是：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%H`: commit hash</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%h`: abbreviated commit hash</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%T`: tree hash</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%t`: abbreviated tree hash</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%P`: parent hashes</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%p`: abbreviated parent hashes</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%an`: author name</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%aN`: author name (respecting .mailmap, see [git-shortlog[1]](git-shortlog) or [git-blame[1]](git-blame))</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%ae`: author email</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%aE`: author email (respecting .mailmap, see [git-shortlog[1]](git-shortlog) or [git-blame[1]](git-blame))</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%ad`: author date (format respects --date= option)</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%aD`: author date, RFC2822 style</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%ar`: author date, relative</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%at`: author date, UNIX timestamp</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%ai`: author date, ISO 8601-like format</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%aI`: author date, strict ISO 8601 format</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%cn`: committer name</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%cN`: committer name (respecting .mailmap, see [git-shortlog[1]](git-shortlog) or [git-blame[1]](git-blame))</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%ce`: committer email</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%cE`: committer email (respecting .mailmap, see [git-shortlog[1]](git-shortlog) or [git-blame[1]](git-blame))</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%cd`: committer date (format respects --date= option)</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%cD`: committer date, RFC2822 style</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%cr`: committer date, relative</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%ct`: committer date, UNIX timestamp</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%ci`: committer date, ISO 8601-like format</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%cI`: committer date, strict ISO 8601 format</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%d`: ref names, like the --decorate option of [git-log[1]](git-log)</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%D`: ref names without the " (", ")" wrapping.</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%e`: encoding</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%s`: subject</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%f`: sanitized subject line, suitable for a filename</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%b`: body</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%B`: raw body (unwrapped subject and body)</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%GG`: raw verification message from GPG for a signed commit</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%G?`: show "G" for a good (valid) signature, "B" for a bad signature, "U" for a good signature with unknown validity, "X" for a good signature that has expired, "Y" for a good signature made by an expired key, "R" for a good signature made by a revoked key, "E" if the signature cannot be checked (e.g. missing key) and "N" for no signature</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%GS`: show the name of the signer for a signed commit</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%GK`: show the key used to sign a signed commit</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%gD`: reflog selector, e.g., `refs/stash@{1}` or `refs/stash@{2 minutes ago`}; the format follows the rules described for the `-g` option. The portion before the `@` is the refname as given on the command line (so `git log -g refs/heads/master` would yield `refs/heads/master@{0}`).</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%gd`: shortened reflog selector; same as `%gD`, but the refname portion is shortened for human readability (so `refs/heads/master` becomes just `master`).</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%gn`: reflog identity name</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%gN`: reflog identity name (respecting .mailmap, see [git-shortlog[1]](git-shortlog) or [git-blame[1]](git-blame))</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%ge`: reflog identity email</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%gE`: reflog identity email (respecting .mailmap, see [git-shortlog[1]](git-shortlog) or [git-blame[1]](git-blame))</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%gs`: reflog subject</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%Cred`: switch color to red</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%Cgreen`: switch color to green</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%Cblue`: switch color to blue</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%Creset`: reset color</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%C(…)`: color specification, as described under Values in the "CONFIGURATION FILE" section of [git-config[1]](git-config). By default, colors are shown only when enabled for log output (by `color.diff`, `color.ui`, or `--color`, and respecting the `auto` settings of the former if we are going to a terminal). `%C(auto,...)` is accepted as a historical synonym for the default (e.g., `%C(auto,red)`). Specifying `%C(always,...) will show the colors even when color is not otherwise enabled (though consider just using &amp;grave;--color=always` to enable color for the whole output, including this format and anything else git might color). `auto` alone (i.e. `%C(auto)`) will turn on auto coloring on the next placeholders until the color is switched again.</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%m`: left (`&lt;`), right (`&gt;`) or boundary (`-`) mark</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%n`: newline</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%%`: a raw `%`</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%x00`: print a byte from a hex code</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%w([&lt;w&gt;[,&lt;i1&gt;[,&lt;i2&gt;]]])`: switch line wrapping, like the -w option of [git-shortlog[1]](git-shortlog).</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%&lt;(&lt;N&gt;[,trunc|ltrunc|mtrunc])`: make the next placeholder take at least N columns, padding spaces on the right if necessary. Optionally truncate at the beginning (ltrunc), the middle (mtrunc) or the end (trunc) if the output is longer than N columns. Note that truncating only works correctly with N &gt;= 2.</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%&lt;|(&lt;N&gt;)`: make the next placeholder take at least until Nth columns, padding spaces on the right if necessary</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%&gt;(&lt;N&gt;)`, `%&gt;|(&lt;N&gt;)`: similar to `%&lt;(&lt;N&gt;)`, `%&lt;|(&lt;N&gt;)` respectively, but padding spaces on the left</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%&gt;&gt;(&lt;N&gt;)`, `%&gt;&gt;|(&lt;N&gt;)`: similar to `%&gt;(&lt;N&gt;)`, `%&gt;|(&lt;N&gt;)` respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  `%&gt;&lt;(&lt;N&gt;)`, `%&gt;&lt;|(&lt;N&gt;)`: similar to `% &lt;(&lt;N&gt;)`, `%&lt;|(&lt;N&gt;)` respectively, but padding both sides (i.e. the text is centered)</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js">-  %(trailers): display the trailers of the body as interpreted by [git-interpret-trailers[1]](git-interpret-trailers)</pre></div></div><div class="doc-postil"><div class="c-markdown"><div class="table-wrapper"><table><thead><tr class="firstRow"><th style="text-align: left;"><div class="table-header"><p>注意</p></div></th><th style="text-align: left;"><div class="table-header"><p>一些占位符可能取决于给修订遍历引擎的其他选项。例如，％g * reflog选项将插入一个空字符串，除非我们正在遍历reflog条目（例如，通过git log -g）。如果未在命令行中提供--decorate，则％d和％D占位符将使用“短”修饰格式。</p></div></th></tr></thead><tbody></tbody></table></div></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>+</code>在<code>%</code>占位符之后添加（加号），当且仅当占位符展开为非空字符串时，才在扩展之前插入换行符。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>-</code>在<code>%</code>占位符之后添加（减号），则当且仅当占位符展开为空字符串时，才会删除紧接扩展之前的所有连续换行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果在<code>%</code>占位符之后添加（空格），当且仅当占位符展开为非空字符串时，才在扩展之前插入空格。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p><code>tformat:</code> 该<code>tformat:</code>格式的操作完全相同<code>format:</code>，不同之处在于它提供了“终结者”的语义，而不是“分隔符”的语义。换句话说，每个提交都附加了消息结束符（通常是一个换行符），而不是放置在条目之间的分隔符。这意味着单行格式的最终条目将以新的行正确终止，就像“在线”格式一样。例如：$ git log -2 --pretty = format：％h 4da45bef \ | perl -pe'$ _。=“ -  NO NEWLINE \ n”除非/ \ n /'4da45be 7134973  - 否NEWLINE $ git log -2 --pretty = tformat：％h 4da45bef \ | perl -pe'$ _。=“ -  NO NEWLINE \ n”除非/ \ n /'4da45be 7134973</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>另外，任何含有<code>%</code>它的无法识别的字符串都会被解释为<code>tformat:</code>在它之前。例如，这两个是等价的：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git log -2 --pretty=tformat:%h 4da45bef $ git log -2 --pretty=%h 4da45bef</p></div></div></div>