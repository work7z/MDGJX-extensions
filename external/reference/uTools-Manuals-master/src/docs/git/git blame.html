<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-blame  - 显示修改和作者最后修改了文件的每一行</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git blame [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental]            [-L &lt;range&gt;] [-S &lt;revs-file&gt;] [-M] [-C] [-C] [-C] [--since=&lt;date&gt;]            [--progress] [--abbrev=&lt;n&gt;] [&lt;rev&gt; | --contents &lt;file&gt; | --reverse &lt;rev&gt;..&lt;rev&gt;]            [--] &lt;file&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>使用上次修改该行的修订版中的信息为给定文件中的每一行注释。或者，从给定修订开始注释。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定一次或多次时，<code>-L</code>将注释限制为所请求的行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>行的起源会自动沿着整个文件重命名（目前没有选项可以将重命名 - 关闭）。要追踪从一个文件移动到另一个文件的行，或者遵循从其他文件复制并粘贴的行等，请参阅<code>-C</code>和<code>-M</code>选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>报告没有告诉你任何有关已删除或替换的行; 您需要使用<code>git diff</code>以下段落中简要提及的工具或“pickaxe”接口。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除了支持文件注释之外，Git 还支持搜索开发历史记录，以了解更改中发生代码段的时间。这使得追踪代码片段何时被添加到文件，在文件之间移动或复制，并最终被删除或替换成为可能。它通过在 diff 中搜索文本字符串来工作。搜索<code>blame_usage</code>以下内容的镐接口的一个小例子：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git log --pretty=oneline -S'blame_usage'5040f17eba15504bad66b14a645bddd9b015ebb7 blame -S &lt;ancestry-file&gt;ea4c7f9bf69e781dd0cd88d2bccb2bf5cc15c9a7 git-blame: Make the output</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-b</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示边界提交的空白 SHA-1。这也可以通过<code>blame.blankboundary</code>配置选项来控制。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--root</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要将根提交视为边界。这也可以通过<code>blame.showRoot</code>配置选项来控制。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--show-stats</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在责备输出结尾包含更多统计数据。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-L &lt;start&gt;,&lt;end&gt;   -L :&lt;funcname&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅注释给定的线范围。可以多次指定。重叠范围是允许的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;开始&gt;和&lt;结束&gt;是可选的。“-L &lt;开始&gt;”或“-L &lt;开始&gt;”跨越从&lt;开始&gt;到文件结束。“-L，&lt;end&gt;”从文件开始到&lt;结束&gt;。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;开始&gt;和&lt;结束&gt;可以采取以下形式之一：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>数字                                                                                                         如果&lt;开始&gt;或&lt;结束&gt;是一个数字，它将指定一个绝对行号（行数从1开始）。</p></li><li><p>/ regex /                                                                                                  此表单将使用与给定的 POSIX 正则表达式匹配的第一行。如果&lt;start&gt;是一个正则表达式，它将从前一个<code>-L</code>范围的末尾（如果有的话）开始搜索，否则从文件起始处开始搜索。如果&lt;start&gt;是“^ / regex /”，它将从文件开头搜索。如果&lt;end&gt;是一个正则表达式，它将从&lt;start&gt;给出的行开始搜索。</p></li><li><p>+ offset 或 -offset                                                                                   
这仅对&lt;end&gt;有效，并将在&lt;start&gt;给出的行之前或之后指定行数。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>如果给出“：&lt;funcname&gt;”来代替&lt;start&gt;和&lt;end&gt;，它是一个正则表达式，表示从匹配&lt;funcname&gt;的第一个funcname行到下一个funcname行的范围。“：&lt;funcname&gt;”从上一个<code>-L</code>范围的末尾（如果有）搜索，否则从文件开头搜索。“^：&lt;funcname&gt;”从文件开头搜索。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-l</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示长时间（默认：关闭）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-t</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示原始时间戳（默认值：关闭）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-S &lt;revs-file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用 revs-file 中的修订版而不是调用 git-rev-list [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--reverse &lt;rev&gt;..&lt;rev&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>前进而不是后退。它不是显示一行出现的修订，而是显示一行存在的最后修订。这需要一系列的修订，如 START..END，在 START 中存在责任路径。<code>git blame --reverse START</code>是<code>git blame --reverse START..HEAD</code>为了方便。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-p   --porcelain</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以设计用于机器消耗的格式显示。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--line-porcelain</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示 porcelain瓷格式，但输出每行的提交信息，而不仅仅是第一次引用提交。意味着 - 瓷器。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--incremental</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以设计用于机器消耗的格式逐步显示结果。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--encoding=&lt;encoding&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定用于输出作者姓名和提交摘要的编码。将其设置为<code>none</code>使责备输出未转换的数据。有关更多信息，请参阅有关 git-log [1]手册页中编码的讨论。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--contents &lt;file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当未指定&lt;rev&gt;时，该命令注释从工作树副本向后开始的更改。该标志使命令假装工作树副本具有指定文件的内容（指定<code>-</code>使命令从标准输入中读取）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--date &lt;format&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定用于输出日期的格式。如果未提供--date，则使用 blame.date 配置变量的值。如果 blame.date 配置变量也未设置，则使用 iso 格式。有关支持的值，请参阅 git-log [1]上的--date 选项的讨论。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-progress</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当连接到终端时，默认情况下标准错误流会报告进度状态。即使没有附加到终端，该标志也可以进行进度报告。不能<code>--progress</code>与<code>--porcelain</code>或者 <code>--incrementa</code>一起使用<code>l</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-M&lt;num&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>检测文件中移动或复制的行。当提交移动或复制一行代码块时（例如，原始文件有A然后B提交将其更改为B然后A），传统<code>blame</code>算法只会注意到一半的移动，并且通常会将被移动的行（即B）交给父母，并将责任分配给向下移动（即A）到子女提交的行。有了这个选项，通过运行额外的检查通道，这两组线都被归咎于父母。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;num&gt;是可选的，但它是 Git 必须检测的字母数字字符数的下限，以便在文件中移动/复制，以便将这些行与父提交相关联。默认值是20。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-C&lt;num&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除了<code>-M</code>检测从同一提交中修改的其他文件移动或复制的行之外。当您重新组织您的程序并在各个文件之间移动代码时，这非常有用。当该选项被赋予两次时，该命令会另外在创建该文件的提交中查找来自其他文件的副本。当该选项被赋予三次时，该命令还会在任何提交中查找来自其他文件的副本。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;num&gt;是可选的，但它是 Git 必须检测的字母数字字符数的下限，作为文件之间的移动/复制，以便将这些行与父提交相关联。默认值是40.如果有多个<code>-C</code>选项，最后的&lt;num&gt;参数<code>-C</code>将生效。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-h</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示帮助信息。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-c</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用与 git-annotate [1]相同的输出模式（默认值：关闭）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--score-debug</p></div></div><div class="doc-postil"><div class="c-markdown"><p>包含与文件之间的行移动有关的调试信息（请参阅参考资料<code>-C</code>）和文件中移动的行（请参阅参考资料<code>-M</code>）。列出的第一个数字是分数。这是检测为在文件之间或文件内移动的字母数字字符的数量。这必须高于某个阈值<code>git blame</code>才能考虑这些代码行已被移动。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-f   --show-name</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在原始提交中显示文件名。默认情况下，如果由于重命名检测而出现来自具有不同名称的文件的任何行，则会显示文件名。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-n   --show-number</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在原始提交中显示行号（默认值：关闭）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-s</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从输出中抑制作者姓名和时间戳。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-e   --show-email</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示作者电子邮件而不是作者姓名（默认：关闭）。这也可以通过<code>blame.showEmail</code>配置选项来控制。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-w</p></div></div><div class="doc-postil"><div class="c-markdown"><p>比较父母的版本和孩子的时候，忽略空格以找到行的来源。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--abbrev=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用默认的 7 + 1 十六进制数字作为缩写对象名称，而不是使用&lt;n&gt; +1个数字。请注意，1列用于插入符号来标记边界提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--indent-heuristic   --no-indent-heuristic</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些是为了帮助调试和调整实验启发式（默认情况下是关闭的），这些启发式技术改变了差异边界以使修补程序更易于阅读。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>porcelain（瓷器）的格式</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>在这种格式下，每一行在一个标题后输出； 最低标题的第一行有：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>该行提交的40字节 SHA-1归因于;</p></li><li><p>原始文件中行的行号;</p></li><li><p>最终文件中行的行号;</p></li><li><p>在从一个不同于上一个提交的提交开始一组行的行中，该行中的行数。在随后的行中，该字段不存在。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>对于每个提交，此标题行后面至少有一次以下信息：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>作者姓名（“作者”），电子邮件（“作者邮件”），时间（“作者时间”）和时区（“author-tz”）; 提交者也是如此。</p></li><li><p>行被归于的提交中的文件名。</p></li><li><p>提交日志消息的第一行（“摘要”）。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>实际行的内容在上面的标题之后输出，以 TAB 为前缀。这是为了稍后允许添加更多的标题元素。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>porcelain（瓷器）格式通常会抑制已经看到的提交信息。例如，两条指向同一提交的行都会显示，但该提交的详细信息只会显示一次。这样更有效率，但可能需要读者保留更多的状态。该<code>--line-porcelain</code>选项可用于输出每行的完整提交信息，从而允许更简单（但效率较低）的用法，如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash"># count the number of lines attributed to each author
git blame --line-porcelain file |sed -n 's/^author //p' |sort | uniq -c | sort -rn</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>指定范围</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>不同于<code>git blame</code>与<code>git annotate</code>在旧版本的 git 的，注释的程度可以被限制到两个线范围和修订的范围。将<code>-L</code>注释限制为一系列行的选项可以多次指定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当你有兴趣为<code>foo</code>文件寻找40-60行的起源时，你可以使用<code>-L</code>像这样的选项（它们的意思是相同的 - 都要求从第40行开始的21行）：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git blame -L 40,60 foo
git blame -L 40,+21 foo</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>你也可以使用正则表达式来指定行范围：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git blame -L '/^sub hello {/,/^}$/' foo</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这将注释限制在<code>hello</code>子例程的主体中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您对版本v2.6.18以前的更改不感兴趣，或者更改时间超过3周，则可以使用类似于<code>git rev-list</code>以下内容的版本范围说明符：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git blame v2.6.18.. -- foo
git blame --since=3.weeks -- foo</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>使用修订范围说明符来限制注释时，自范围边界（上图中的提交v2.6.18或最近提交超过3周）以来未更改的行被指定为该范围边界承诺。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一种特别有用的方法是查看添加的文件是否具有通过从现有文件进行复制和粘贴创建的行。有时候这表明开发人员马虎，没有正确重构代码。您可以首先找到引入该文件的提交：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git log --diff-filter=A --pretty=short -- foo</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后使用<code>commit^!</code>符号注释提交与其父母之间的更改：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git blame -C -C -f $commit^! -- foo</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>增量输出</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>--incremental</code>选项调用时，该命令会在结果生成时输出结果。输出通常会首先讨论最近提交时触及的行（即行将被乱序注释），并被交互式查看者使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>输出格式与 Porcelain 格式类似，但不包含正在注释的文件中的实际行。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>每个blame条目总是以一行：&lt;40-byte hex sha1&gt; &lt;sourceline&gt; &lt;resultline&gt; &lt;num_lines&gt;</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>Line numbers count from 1.</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>当一次提交首次出现在流中时，它会在每行开始处描述额外提交信息（作者，电子邮件，提交者，日期，摘要等等）中打印出各种其他信息。 ）。</p></li><li><p>与 Porcelain 格式不同，文件名信息总是给出并终止条目：“filename”&lt;whitespace-quoted-filename-goes-here&gt;</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>因此解析某些面向行和面向字的解析器（对于大多数脚本语言而言这应该是很自然的）真的很容易。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-js"> Note</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>对于进行解析的人来说：为了使其更加健壮，只要忽略第一个和最后一个（“&lt;sha1&gt;”和“文件名”行）之间不识别标记词（或关心那个特定词）的任何行，在“扩展信息”的开头。这样，如果有任何增加的信息（如提交编码或扩展提交评论），责备观众不会在意。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>映射作者</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>如果文件<code>.mailmap</code>存在于存储库的顶层，或者位于 mailmap.file 或 mailmap.blob 配置选项所指向的位置，则它用于将作者和提交者名称以及电子邮件地址映射到规范的实名和电子邮件地址。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在简单的形式中，文件中的每一行由作者的标准真实姓名，空格以及在提交中使用的电子邮件地址（用<code>&lt;</code>and <code>&gt;</code>括起来）映射到名称。例如：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">Proper Name &lt;commit@email.xx&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>更复杂的形式是：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">&lt;proper@email.xx&gt; &lt;commit@email.xx&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>它允许 mailmap 只替换提交的电子邮件部分，并且：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">Proper Name &lt;proper@email.xx&gt; &lt;commit@email.xx&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>它允许 mailmap 替换与指定的提交电子邮件地址匹配的提交的名称和电子邮件，以及：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">Proper Name &lt;proper@email.xx&gt; Commit Name &lt;commit@email.xx&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>它允许 mailmap 替换与指定的提交名称和电子邮件地址相匹配的提交的名称和电子邮件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>示例1：您的历史记录包含两位作者 Jane 和 Joe 的提交，他们的名字以几种形式出现在存储库中：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">Joe Developer &lt;joe@example.com&gt;Joe R. Developer &lt;joe@example.com&gt;Jane Doe &lt;jane@example.com&gt;Jane Doe &lt;jane@laptop.(none)&gt;Jane D. &lt;jane@desktop.(none)&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>现在假设乔想让他的中间名得到最初的使用，而珍则更喜欢将她的姓氏完整地拼出来。一个合适的<code>.mailmap</code>文件应该是这样的：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">Jane Doe         &lt;jane@desktop.(none)&gt;Joe R. Developer &lt;joe@example.com&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>注意如何不需要输入<code>&lt;jane@laptop.(none)&gt;</code>，因为该作者的真实姓名已经是正确的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>示例2：您的存储库包含以下作者的提交：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">nick1 &lt;bugs@company.xx&gt;nick2 &lt;bugs@company.xx&gt;nick2 &lt;nick2@company.xx&gt;santa &lt;me@company.xx&gt;claus &lt;me@company.xx&gt;CTO &lt;cto@coompany.xx&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>那么你可能需要一个如下所示的<code>.mailmap</code>文件：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">&lt;cto@company.xx&gt;                       &lt;cto@coompany.xx&gt;Some Dude &lt;some@dude.xx&gt;         nick1 &lt;bugs@company.xx&gt;Other Author &lt;other@author.xx&gt;   nick2 &lt;bugs@company.xx&gt;Other Author &lt;other@author.xx&gt;         &lt;nick2@company.xx&gt;Santa Claus &lt;santa.claus@northpole.xx&gt; &lt;me@company.xx&gt;</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>将散列<code>#</code>用于自己的行中或电子邮件地址之后的注释。</p></div></div></div>