<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-cherry  - 查找尚未应用于上游的提交</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">git cherry [-v] [&lt;upstream&gt; [&lt;head&gt; [&lt;limit&gt;]]]</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>确定在<code>&lt;head&gt;..&lt;upstream&gt;</code>那里的提交是否有与<code>&lt;limit&gt;..&lt;head&gt;</code>范围内的提交相同。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>删除空格和行号后，基于 diff 等同性测试。因此，
 git-cherry 可以检测提交何时通过 git-cherry-pick [1]，git-am [1]或git-rebase [1] 被“复制”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在<code>&lt;limit&gt;..&lt;head&gt;</code>输出每个提交的 SHA1 ，前缀<code>-</code>为&lt;upstream&gt;（&lt;上游&gt;）中的等价提交，以及不提交<code>+</code>的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-v</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示 SHA1 旁边的提交主题。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;upstream&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>上游分支来搜索等效提交。默认为 HEAD 的上游分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;head&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>工作分部；默认为 HEAD。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;limit&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要报告提交到（包括）限制。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>示例</h2></div></div><div class="doc-postil"><div class="c-markdown"><h3>补丁工作流程</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>git-cherry 经常用于基于补丁的工作流程（请参阅gitworkflows [7]）以确定上游维护人员是否应用了一系列补丁。在这样的工作流程中，您可以创建并发送如下主题分支：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git checkout -b topic origin/master
# work and create some commits
$ git format-patch origin/master
$ git send-email ... 00*</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>稍后，您可以通过说（仍在<code>topic</code>）来查看您的更改是否已应用：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git fetch  # update your notion of origin/master
$ git cherry -v</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><h3>具体的例子</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>在主题由三个提交组成的情况下，维护者应用其中两个提交时，情况可能如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git log --graph --oneline --decorate --boundary origin/master...topic* 7654321 (origin/master) upstream tip commit[... snip some other commits ...]* cccc111 cherry-pick of C* aaaa111 cherry-pick of A[... snip a lot more that has happened ...]| * cccc000 (topic) commit C| * bbbb000 commit B| * aaaa000 commit A|/o 1234567 branch point</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在这种情况下，git-cherry 会显示一个尚未应用的简要摘要：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git cherry origin/master topic- cccc000... commit C+ bbbb000... commit B- aaaa000... commit A</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在这里，我们看到提交 A 和 C（标记为<code>-</code>）可以从您的<code>topic</code>分支中删除，当您重新绑定它<code>origin/master</code>时，提交 B（标记为<code>+</code>）仍然需要保留，以便它将被发送以应用到<code>origin/master</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>使用限制</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您的主题基于其他不在上游的工作，则可选&lt;limit&gt;非常有用。在前面的例子中展开，这可能看起来像：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git log --graph --oneline --decorate --boundary origin/master...topic* 7654321 (origin/master) upstream tip commit[... snip some other commits ...]* cccc111 cherry-pick of C* aaaa111 cherry-pick of A[... snip a lot more that has happened ...]| * cccc000 (topic) commit C| * bbbb000 commit B| * aaaa000 commit A| * 0000fff (base) unpublished stuff F[... snip ...]| * 0000aaa unpublished stuff A|/o 1234567 merge-base between upstream and topic</code></pre></div></div><div class="doc-postil"><div class="c-markdown"><p>通过指定<code>base</code>限制，您可以避免列出<code>base</code>和<code>topic</code>之间的提交：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre><code class="language-Bash">$ git cherry origin/master topic base- cccc000... commit C+ bbbb000... commit B- aaaa000... commit A</code></pre></div></div></div>