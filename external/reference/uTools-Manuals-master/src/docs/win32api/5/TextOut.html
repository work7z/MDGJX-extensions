<html>
<body>

<h3>函数功能</h3>该函数用当前选择字符、背景颜色和正文颜色将一个字符串写到指定位置。<br>
<h3>函数原型</h3>BOOL TextOut (HDC hdc, int nXStart, int nYStart, LPCTSTR lpString, int cbString)；<br>
<h3>参数</h3>
hdc：设备环境句柄。<br>
nXStart：指定用于字符串对齐的基准点的逻辑X坐标。<br>
nYStart：指定用于字符串对齐的基准点的逻辑Y坐标。<br>
lpString：指向将被绘制字符串的指针。此字符串不必为以\0结束的，因为cbString中指定了字符串的长度。<br>
cbString：字符串的字符数。<br>
<h3>返回值</h3>如果函数调用成功，返回值非零；如果函数调用失败，返回值是0。<br>
Windows NT：若想获得更多错误信息，请调用GetLastError函数。<br>
备注：对基准点的解释依赖于当前字符对齐模式，一个应用程序可以调用GetTextAlign来获得该模式，调用SetTextAlign来更改该模式。<br>
缺省地，此函数不能使用和修改当前位置，但一个应用程序可以在每次在指定设备环境中调用TextOut之前，通过将参数fMode设为TA_UPDATECP值来调用SetTextAlign，以允许系统在调用TextOut时修改当前位置，当上述标志设置时，系统会忽略随后调用TextOut中的nXStart和nYStart值。<br>
当把函数TextOut放入一个路径括号内时，系统为包含每一个字符并加上字符值的TrueType正文产生一个路径，产生的区域是字符框加上正文，而不是正文本身，可以在把TextOut放入路径括号之前设置背景模式为透明的，这样就能得到由TrueType正文的轮廓封闭而成的区域。下面是说明这个过程的例程代码：<br>
GetClientRect(hwnd, &r); BeginPath(hdc); TextOut(hdc, r.left, r.top, "Defenestration can be hazardous", 4); EndPath(hdc); SelectClipPath(hdc, RGN_AND); FillRect(hdc, &r, GetStockObject(GRAY_BRUSH))。<br>
<h3>速查</h3>Windows NT：3.1及以上版本；Windows：95及以上版本；Windows CE：不支持；头文件：wingdi.h；库文件：gdi32.lib；Unicode：在Windows NT环境下实现为Unicode和ANSI两种版本。<br>
</body>
</html>
