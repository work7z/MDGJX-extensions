<article class="" id="post-">
<header class="entry-header">
<h1 class="entry-title">jQuery.Deferred()</h1>
<div class="entry-meta">
						所属分类：<span class="category"><a href="/category/deferred-object/">延迟对象</a></span>
<span class="pull-right">英文文档：<a href="https://api.jquery123.com/jQuery.Deferred/" target="_blank">jQuery.Deferred()</a></span>
</div><!-- .entry-meta -->
</header><!-- .entry-header -->
<!-- .entry-header -->
<div class="entry-content">
<article class="entry method" id="jQuery-Deferred1"><h2 class="section-title">
<span class="name">jQuery.Deferred(  [beforeStart ] )</span><span class="returns">返回: <a href="/Types/#Deferred">Deferred</a></span>
</h2>
<div class="entry-wrapper">
<p class="desc"><strong>描述: </strong> 一个构造函数，返回一个链式实用对象方法来注册多个回调，回调队列，
			 调用回调队列，并转达任何同步或异步函数的成功或失败状态。</p>
<ul class="signatures"><li class="signature" id="jQuery-Deferred-beforeStart">
<h4 class="name">
<span class="version-details">添加的版本: <a href="/category/version/1.5/">1.5</a></span>jQuery.Deferred(  [beforeStart ] )</h4>
<ul><li>
<div><strong>beforeStart</strong></div>
<div>类型: <a href="/Types/#Function">Function</a>( <a href="/Types/#Deferred">Deferred</a> deferred )</div>
<div>一个构造函数返回之前调用的函数。
			      </div>
</li></ul>
</li></ul>
<div class="longdesc" id="entry-longdesc">
<p>
<code>jQuery.Deferred()</code>构造函数创建一个新的Deferred（延迟）对象。<code>new</code> 运算是可选的。</p>
<p>
<code>jQuery.Deferred</code>方法可以传递一个可选的函数，
			这个函数在构造函数返回之前调用，并且传递构建 <code>deferred</code>（延迟）对象作为 <code>this</code>对象作为第一个参数传递给函数。被调用的函数可以使用 <a href="/deferred.then"><code>deferred.then()</code></a>附加回调，例如。
			
			    	</p>
<p>
			    	一个Deferred（延迟）对象开始于<em>pending</em>状态。
			任何回调使用<a href="/deferred.then"><code>deferred.then()</code></a>, <a href="/deferred.always"><code>deferred.always()</code></a>, <a href="/deferred.done"><code>deferred.done()</code></a>, 或者 <a href="/deferred.fail"><code>deferred.fail()</code></a>添加到这个对象都是排队等待执行。调用<a href="/deferred.resolve"><code>deferred.resolve()</code></a> 或者 <a href="/deferred.resolveWith"><code>deferred.resolveWith()</code></a>转换Deferred（递延）到<em>resolved</em>（解决）的状态，并立即执行设置中任何的<code>doneCallbacks</code>。调用<a href="/deferred.reject"><code>deferred.reject()</code></a> 或者 <a href="/deferred.rejectWith"><code>deferred.rejectWith()</code></a>转换Deferred（递延）到<em>rejected</em>（拒绝）的状态，并立即执行设置中任何的<code>failCallbacks</code>。一旦对象已经进入了解决或拒绝状态，它处于该状态。回调仍然可以添加到解决或拒绝Deferred（递延） - 他们会立即执行。</p>
<h4>
			      Enhanced Callbacks with jQuery 
			    </h4>
<p>
			    	在JavaScript中很常见，有选择地在函数中接受被调用的回调函数。例如，
			到jQuery1.5之前的版本中，异步流程比如<code>jQuery.ajax()</code>，接受回调函数有时候在不久的将来调用Ajax请求成功时，错误，和完成。</p>
<p><code>jQuery.Deferred()</code> introduces several enhancements to the way callbacks are managed and invoked. In particular, <code>jQuery.Deferred()</code> provides flexible ways to provide multiple callbacks, and these callbacks can be invoked regardless of whether the original callback dispatch has already occurred. jQuery Deferred is based on the <a href="http://wiki.commonjs.org/wiki/Promises/A">CommonJS Promises/A</a> design.</p>
<p>One model for understanding Deferred is to think of it as a chain-aware function wrapper. The <a href="/deferred.then"><code>deferred.then()</code></a>, <a href="/deferred.always"><code>deferred.always()</code></a>, <a href="/deferred.done"><code>deferred.done()</code></a>, and <a href="/deferred.fail"><code>deferred.fail()</code></a> methods specify the functions to be called and the <a href="/deferred.resolve"><code>deferred.resolve(args)</code></a> or <a href="/deferred.reject"><code>deferred.reject(args)</code></a> methods "call" the functions with the arguments you supply. Once the Deferred has been resolved or rejected it stays in that state; a second call to <code>deferred.resolve()</code>, for example, is ignored. If more functions are added by <code>deferred.then()</code>, for example, after the Deferred is resolved, they are called immediately with the arguments previously provided.</p>
<p>In most cases where a jQuery API call returns a Deferred or Deferred-compatible object, such as <a href="/jQuery.ajax"><code>jQuery.ajax()</code></a> or <a href="/jQuery.when"><code>jQuery.when()</code></a>, you will only want to use the <a href="/deferred.then"><code>deferred.then()</code></a>, <a href="/deferred.done"><code>deferred.done()</code></a>, and <a href="/deferred.fail"><code>deferred.fail()</code></a> methods to add callbacks to the Deferred's queues. The internals of the API call or code that created the Deferred will invoke <a href="/deferred.resolve"><code>deferred.resolve()</code></a> or <a href="/deferred.reject"><code>deferred.reject()</code></a> on the deferred at some point, causing the appropriate callbacks to run.</p>
</div>
</div></article> </div>
</article>