<div class="body" role="main"><div class="section" id="module-tempfile"><h1><span class="yiyi-st" id="yiyi-10">11.6. <a class="reference internal" href="#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a>  - 生成临时文件和目录</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/tempfile.py">Lib / tempfile.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">此模块被用于创建临时文件和目录。</span><span class="yiyi-st" id="yiyi-13">它可以运行在所有python支持的操作系统上。</span><span class="yiyi-st" id="yiyi-14"><a class="reference internal" href="#tempfile.TemporaryFile" title="tempfile.TemporaryFile"><code class="xref py py-class docutils literal"><span class="pre">TemporaryFile</span></code></a>, <a class="reference internal" href="#tempfile.NamedTemporaryFile" title="tempfile.NamedTemporaryFile"><code class="xref py py-class docutils literal"><span class="pre">NamedTemporaryFile</span></code></a>, <a class="reference internal" href="#tempfile.TemporaryDirectory" title="tempfile.TemporaryDirectory"><code class="xref py py-class docutils literal"><span class="pre">TemporaryDirectory</span></code></a>, 和 <a class="reference internal" href="#tempfile.SpooledTemporaryFile" title="tempfile.SpooledTemporaryFile"><code class="xref py py-class docutils literal"><span class="pre">SpooledTemporaryFile</span></code></a> 是高级函数，提供自动清理和内容管理功能。</span><span class="yiyi-st" id="yiyi-15"><a class="reference internal" href="#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></code></a> 和 <a class="reference internal" href="#tempfile.mkdtemp" title="tempfile.mkdtemp"><code class="xref py py-func docutils literal"><span class="pre">mkdtemp()</span></code></a> 是底层函数，需要手动清理。</span></p><p><span class="yiyi-st" id="yiyi-16">所有用户可调用的函数和构造函数接受附加的参数，这些参数允许直接控制临时文件和目录的位置和名称。</span><span class="yiyi-st" id="yiyi-17">此模块使用的文件名包括一个随机字符串，允许这些文件在共享临时目录中安全地创建。</span><span class="yiyi-st" id="yiyi-18">为了保持向后兼容性，参数顺序有点奇怪；为了清楚起见，建议使用关键字参数。</span></p><p><span class="yiyi-st" id="yiyi-19">Tempfile模块定义了以下函数︰</span></p><dl class="function"><dt id="tempfile.TemporaryFile"><span class="yiyi-st" id="yiyi-20"><code class="descclassname">tempfile.</code><code class="descname">TemporaryFile</code><span class="sig-paren">(</span><em>mode='w+b'</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-21">返回一个<a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">类文件对象</span></a>以提供临时的数据存储空间。</span><span class="yiyi-st" id="yiyi-22">使用与<a class="reference internal" href="#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></code></a>相同的规则安全地创建文件。</span><span class="yiyi-st" id="yiyi-23">它将被关闭时立即被销毁（包括当对象被垃圾收集时的隐式关闭）。</span><span class="yiyi-st" id="yiyi-24">在Unix下，文件的目录条目根本不创建，或在文件创建后立即删除。</span><span class="yiyi-st" id="yiyi-25">其他平台不支持；您的代码不应该依赖于使用此函数创建的临时文件在文件系统中是否具有可见名称。</span></p><p><span class="yiyi-st" id="yiyi-26">生成的对象可以用作上下文管理器（参见<a class="reference internal" href="#tempfile-examples"><span>Examples</span></a>）。</span><span class="yiyi-st" id="yiyi-27">在完成上下文或销毁文件对象时，临时文件将从文件系统中删除。</span></p><p><span class="yiyi-st" id="yiyi-28"><em>模式</em>参数默认为<code class="docutils literal"><span class="pre">'w+b'</span></code>，以便创建的文件可以在不关闭的情况下读写。</span><span class="yiyi-st" id="yiyi-29">使用二进制模式，以便它在所有平台上一致地运行，而不考虑存储的数据。</span><span class="yiyi-st" id="yiyi-30"><em>缓冲</em>，<em>编码</em>和<em>换行</em>被解释为<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-31"><em>dir</em>，<em>前缀</em>和<em>后缀</em>参数的含义和默认值与<a class="reference internal" href="#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></code></a>相同。</span></p><p><span class="yiyi-st" id="yiyi-32">返回的对象是POSIX平台上的一个真正的文件对象。</span><span class="yiyi-st" id="yiyi-33">在其他平台上，它是一个类文件对象，其<code class="xref py py-attr docutils literal"><span class="pre">file</span></code>属性是基础的真实文件对象。</span></p><p><span class="yiyi-st" id="yiyi-34">如果可用且可行，则使用<a class="reference internal" href="os.html#os.O_TMPFILE" title="os.O_TMPFILE"><code class="xref py py-data docutils literal"><span class="pre">os.O_TMPFILE</span></code></a>标志（特定于Linux，需要Linux内核3.11或更高版本）。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-35"><span class="versionmodified">在3.5版本中已更改：</span>现在使用<a class="reference internal" href="os.html#os.O_TMPFILE" title="os.O_TMPFILE"><code class="xref py py-data docutils literal"><span class="pre">os.O_TMPFILE</span></code></a>标志（如果可用）。</span></p></div></dd></dl><dl class="function"><dt id="tempfile.NamedTemporaryFile"><span class="yiyi-st" id="yiyi-36"><code class="descclassname">tempfile.</code><code class="descname">NamedTemporaryFile</code><span class="sig-paren">(</span><em>mode='w+b'</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>delete=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-37">此函数与<a class="reference internal" href="#tempfile.TemporaryFile" title="tempfile.TemporaryFile"><code class="xref py py-func docutils literal"><span class="pre">TemporaryFile()</span></code></a>完全一样，除了文件保证在文件系统中有一个可见的名称（在Unix上，目录项没有取消链接）。</span><span class="yiyi-st" id="yiyi-38">该名称可以从返回的类文件对象的<code class="xref py py-attr docutils literal"><span class="pre">name</span></code>属性中检索。</span><span class="yiyi-st" id="yiyi-39">该名称是否可用于第二次打开该文件，而命名的临时文件仍然是打开的，在不同的平台（它可以这样在Unix上使用；它不能在Windows NT或更高版本）。</span><span class="yiyi-st" id="yiyi-40">如果<em>delete</em>为true（默认值），则文件一被关闭即被删除。</span><span class="yiyi-st" id="yiyi-41">返回的对象始终是类文件对象，其<code class="xref py py-attr docutils literal"><span class="pre">file</span></code>属性是基础的真实文件对象。</span><span class="yiyi-st" id="yiyi-42">这个类文件对象可以在<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句中使用，就像普通文件一样。</span></p></dd></dl><dl class="function"><dt id="tempfile.SpooledTemporaryFile"><span class="yiyi-st" id="yiyi-43"> <code class="descclassname">tempfile.</code><code class="descname">SpooledTemporaryFile</code><span class="sig-paren">(</span><em>max_size=0</em>, <em>mode='w+b'</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-44">This function operates exactly as <a class="reference internal" href="#tempfile.TemporaryFile" title="tempfile.TemporaryFile"><code class="xref py py-func docutils literal"><span class="pre">TemporaryFile()</span></code></a> does, except that data is spooled in memory until the file size exceeds <em>max_size</em>, or until the file’s <code class="xref py py-func docutils literal"><span class="pre">fileno()</span></code> method is called, at which point the contents are written to disk and operation proceeds as with <a class="reference internal" href="#tempfile.TemporaryFile" title="tempfile.TemporaryFile"><code class="xref py py-func docutils literal"><span class="pre">TemporaryFile()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-45">生成的文件还有一个附加方法，<code class="xref py py-func docutils literal"><span class="pre">rollover()</span></code>，这将导致文件滚动到磁盘文件，而不管其大小。</span></p><p><span class="yiyi-st" id="yiyi-46">返回的对象是类文件对象，其<code class="xref py py-attr docutils literal"><span class="pre">_file</span></code>属性是<a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a>或<a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a>对象文本<em>模式</em>）或真正的文件对象，具体取决于是否已调用<code class="xref py py-func docutils literal"><span class="pre">rollover()</span></code>。</span><span class="yiyi-st" id="yiyi-47">这个类文件对象可以在<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句中使用，就像普通文件一样。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-48"><span class="versionmodified">在版本3.3中更改：</span> truncate方法现在接受<code class="docutils literal"><span class="pre">size</span></code>参数。</span></p></div></dd></dl><dl class="function"><dt id="tempfile.TemporaryDirectory"><span class="yiyi-st" id="yiyi-49"> <code class="descclassname">tempfile.</code><code class="descname">TemporaryDirectory</code><span class="sig-paren">(</span><em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-50">此函数使用与<a class="reference internal" href="#tempfile.mkdtemp" title="tempfile.mkdtemp"><code class="xref py py-func docutils literal"><span class="pre">mkdtemp()</span></code></a>相同的规则安全地创建临时目录。</span><span class="yiyi-st" id="yiyi-51">生成的对象可以用作上下文管理器（参见<a class="reference internal" href="#tempfile-examples"><span>Examples</span></a>）。</span><span class="yiyi-st" id="yiyi-52">在完成上下文或销毁临时目录对象后，新创建的临时目录及其所有内容将从文件系统中删除。</span></p><p><span class="yiyi-st" id="yiyi-53">可以从返回的对象的<code class="xref py py-attr docutils literal"><span class="pre">name</span></code>属性检索目录名称。</span><span class="yiyi-st" id="yiyi-54">当返回的对象用作上下文管理器时，<code class="xref py py-attr docutils literal"><span class="pre">name</span></code>将分配给<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句中<a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a>子句的目标，if有一个。</span></p><p><span class="yiyi-st" id="yiyi-55">可以通过调用<code class="xref py py-func docutils literal"><span class="pre">cleanup()</span></code>方法显式清除目录。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-56"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="tempfile.mkstemp"><span class="yiyi-st" id="yiyi-57"> <code class="descclassname">tempfile.</code><code class="descname">mkstemp</code><span class="sig-paren">(</span><em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>text=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-58">以最安全的方式创建临时文件。</span><span class="yiyi-st" id="yiyi-59">假设平台正确地实现了<a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>的<a class="reference internal" href="os.html#os.O_EXCL" title="os.O_EXCL"><code class="xref py py-const docutils literal"><span class="pre">os.O_EXCL</span></code></a>标志，则文件创建中没有竞争条件。</span><span class="yiyi-st" id="yiyi-60">该文件只能由创建用户标识读写。</span><span class="yiyi-st" id="yiyi-61">如果平台使用权限位来指示文件是否可执行，则该文件不可由任何人执行。</span><span class="yiyi-st" id="yiyi-62">文件描述器不会被子进程继承。</span></p><p><span class="yiyi-st" id="yiyi-63">与<a class="reference internal" href="#tempfile.TemporaryFile" title="tempfile.TemporaryFile"><code class="xref py py-func docutils literal"><span class="pre">TemporaryFile()</span></code></a>不同，<a class="reference internal" href="#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></code></a>的用户负责在完成后删除临时文件。</span></p><p><span class="yiyi-st" id="yiyi-64">如果<em>后缀</em>不是<code class="docutils literal"><span class="pre">None</span></code>，则文件名将以该后缀结尾，否则将没有后缀。</span><span class="yiyi-st" id="yiyi-65"><a class="reference internal" href="#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></code></a>不会在文件名和后缀之间加一个点；如果需要，将其放在<em>后缀</em>的开头。</span></p><p><span class="yiyi-st" id="yiyi-66">如果<em>前缀</em>不是<code class="docutils literal"><span class="pre">None</span></code>，文件名将以该前缀开头；否则，使用默认前缀。</span><span class="yiyi-st" id="yiyi-67">默认值为<a class="reference internal" href="#tempfile.gettempprefix" title="tempfile.gettempprefix"><code class="xref py py-func docutils literal"><span class="pre">gettempprefix()</span></code></a>或<a class="reference internal" href="#tempfile.gettempprefixb" title="tempfile.gettempprefixb"><code class="xref py py-func docutils literal"><span class="pre">gettempprefixb()</span></code></a>的返回值。</span></p><p><span class="yiyi-st" id="yiyi-68">如果<em>dir</em>不是<code class="docutils literal"><span class="pre">None</span></code>，则将在该目录中创建文件；否则，将使用默认目录。</span><span class="yiyi-st" id="yiyi-69">默认目录从平台相关列表中选择，但应用程序的用户可以通过设置<em>TMPDIR</em>，<em>TEMP</em>或<em>TMP  t&gt; t2&gt;环境变量。</em></span><span class="yiyi-st" id="yiyi-70">因此，不能保证生成的文件名将具有任何不错的属性，例如当通过<code class="docutils literal"><span class="pre">os.popen()</span></code>传递到外部命令时不需要引用。</span></p><p><span class="yiyi-st" id="yiyi-71">如果<em>后缀</em>，<em>前缀</em>和<em>dir</em>中的任何一个不是<code class="docutils literal"><span class="pre">None</span></code>，则它们必须是相同类型。</span><span class="yiyi-st" id="yiyi-72">如果它们是字节，返回的名称将是字节而不是str。</span><span class="yiyi-st" id="yiyi-73">如果要强制字节返回值，否则默认行为，传递<code class="docutils literal"><span class="pre">suffix=b''</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-74">如果指定<em>文本</em>，则指示是以二进制模式（默认）还是文本模式打开文件。</span><span class="yiyi-st" id="yiyi-75">在某些平台上，这没有什么区别。</span></p><p><span class="yiyi-st" id="yiyi-76"><a class="reference internal" href="#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></code></a>返回一个包含打开文件的操作系统级句柄的元组（由<a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>返回）和该文件的绝对路径名， 。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-77"><span class="versionmodified">Changed in version 3.5: </span><em>suffix</em>, <em>prefix</em>, and <em>dir</em> may now be supplied in bytes in order to obtain a bytes return value. </span><span class="yiyi-st" id="yiyi-78">在此之前，只允许str。</span><span class="yiyi-st" id="yiyi-79"><em>后缀</em>和<em>前缀</em>现在接受并默认为<code class="docutils literal"><span class="pre">None</span></code>，以使用适当的默认值。</span></p></div></dd></dl><dl class="function"><dt id="tempfile.mkdtemp"><span class="yiyi-st" id="yiyi-80"> <code class="descclassname">tempfile.</code><code class="descname">mkdtemp</code><span class="sig-paren">(</span><em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">以最安全的方式创建临时目录。</span><span class="yiyi-st" id="yiyi-82">目录的创建没有竞争条件。</span><span class="yiyi-st" id="yiyi-83">该目录只有创建用户ID才可读，可写和可搜索。</span></p><p><span class="yiyi-st" id="yiyi-84"><a class="reference internal" href="#tempfile.mkdtemp" title="tempfile.mkdtemp"><code class="xref py py-func docutils literal"><span class="pre">mkdtemp()</span></code></a>的用户负责在完成操作后删除临时目录及其内容。</span></p><p><span class="yiyi-st" id="yiyi-85"><em>前缀</em>，<em>后缀</em>和<em>dir</em>参数与<a class="reference internal" href="#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></code></a>相同。</span></p><p><span class="yiyi-st" id="yiyi-86"><a class="reference internal" href="#tempfile.mkdtemp" title="tempfile.mkdtemp"><code class="xref py py-func docutils literal"><span class="pre">mkdtemp()</span></code></a>返回新目录的绝对路径名。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-87"><span class="versionmodified">Changed in version 3.5: </span><em>suffix</em>, <em>prefix</em>, and <em>dir</em> may now be supplied in bytes in order to obtain a bytes return value. </span><span class="yiyi-st" id="yiyi-88">在此之前，只允许str。</span><span class="yiyi-st" id="yiyi-89"><em>后缀</em>和<em>前缀</em>现在接受并默认为<code class="docutils literal"><span class="pre">None</span></code>，以使用适当的默认值。</span></p></div></dd></dl><dl class="function"><dt id="tempfile.gettempdir"><span class="yiyi-st" id="yiyi-90"> <code class="descclassname">tempfile.</code><code class="descname">gettempdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-91">返回用于临时文件的目录的名称。</span><span class="yiyi-st" id="yiyi-92">这定义了此模块中所有函数的<em>dir</em>参数的默认值。</span></p><p><span class="yiyi-st" id="yiyi-93">Python搜索标准目录列表以找到调用用户可以在其中创建文件的目录。</span><span class="yiyi-st" id="yiyi-94">列表是：</span></p><ol class="arabic simple"><li><span class="yiyi-st" id="yiyi-95">由<span class="target" id="index-1"></span> <code class="xref std std-envvar docutils literal"><span class="pre">TMPDIR</span></code></span></li><li><span class="yiyi-st" id="yiyi-96">由<span class="target" id="index-2"></span> <code class="xref std std-envvar docutils literal"><span class="pre">TEMP</span></code></span></li><li><span class="yiyi-st" id="yiyi-97">由<span class="target" id="index-3"></span> <code class="xref std std-envvar docutils literal"><span class="pre">TMP</span></code></span></li><li><span class="yiyi-st" id="yiyi-100">平台特定位置：</span><ul><li><span class="yiyi-st" id="yiyi-98">在Windows上，目录<code class="file docutils literal"><span class="pre">C:\TEMP</span></code>，<code class="file docutils literal"><span class="pre">C:\TMP</span></code>，<code class="file docutils literal"><span class="pre">\TEMP</span></code>和<code class="file docutils literal"><span class="pre">\TMP</span></code> 。</span></li><li><span class="yiyi-st" id="yiyi-99">在所有其他平台上，依次按照目录<code class="file docutils literal"><span class="pre">/tmp</span></code>，<code class="file docutils literal"><span class="pre">/var/tmp</span></code>和<code class="file docutils literal"><span class="pre">/usr/tmp</span></code></span></li></ul></li><li><span class="yiyi-st" id="yiyi-101">作为最后的手段，当前工作目录。</span></li></ol><p><span class="yiyi-st" id="yiyi-102">此搜索的结果已缓存，请参见下面的<a class="reference internal" href="#tempfile.tempdir" title="tempfile.tempdir"><code class="xref py py-data docutils literal"><span class="pre">tempdir</span></code></a>的描述。</span></p></dd></dl><dl class="function"><dt id="tempfile.gettempdirb"><span class="yiyi-st" id="yiyi-103"> <code class="descclassname">tempfile.</code><code class="descname">gettempdirb</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">与<a class="reference internal" href="#tempfile.gettempdir" title="tempfile.gettempdir"><code class="xref py py-func docutils literal"><span class="pre">gettempdir()</span></code></a>相同，但返回值以字节为单位。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-105"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="tempfile.gettempprefix"><span class="yiyi-st" id="yiyi-106"> <code class="descclassname">tempfile.</code><code class="descname">gettempprefix</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">返回用于创建临时文件的文件名前缀。</span><span class="yiyi-st" id="yiyi-108">这不包含目录组件。</span></p></dd></dl><dl class="function"><dt id="tempfile.gettempprefixb"><span class="yiyi-st" id="yiyi-109"> <code class="descclassname">tempfile.</code><code class="descname">gettempprefixb</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-110">与<a class="reference internal" href="#tempfile.gettempprefix" title="tempfile.gettempprefix"><code class="xref py py-func docutils literal"><span class="pre">gettempprefix()</span></code></a>相同，但返回值以字节为单位。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-111"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-112">模块使用全局变量来存储用于由<a class="reference internal" href="#tempfile.gettempdir" title="tempfile.gettempdir"><code class="xref py py-func docutils literal"><span class="pre">gettempdir()</span></code></a>返回的临时文件的目录的名称。</span><span class="yiyi-st" id="yiyi-113">它可以直接设置为覆盖选择过程，但不建议这样做。</span><span class="yiyi-st" id="yiyi-114">此模块中的所有函数都使用<em>dir</em>参数，可用于指定目录，这是建议的方法。</span></p><dl class="data"><dt id="tempfile.tempdir"><span class="yiyi-st" id="yiyi-115"> <code class="descclassname">tempfile.</code><code class="descname">tempdir</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-116">当设置为除<code class="docutils literal"><span class="pre">None</span></code>之外的值时，此变量为此模块中定义的所有函数定义<em>dir</em>参数的默认值。</span></p><p><span class="yiyi-st" id="yiyi-117">如果在对<a class="reference internal" href="#tempfile.gettempprefix" title="tempfile.gettempprefix"><code class="xref py py-func docutils literal"><span class="pre">gettempprefix()</span></code></a>之外的任何函数的任何调用上，<code class="docutils literal"><span class="pre">tempdir</span></code>未设置或<code class="docutils literal"><span class="pre">None</span></code>，则按照<a class="reference internal" href="#tempfile.gettempdir" title="tempfile.gettempdir"><code class="xref py py-func docutils literal"><span class="pre">gettempdir()</span></code></a>。</span></p></dd></dl><div class="section" id="examples"><h2><span class="yiyi-st" id="yiyi-118">11.6.1.</span><span class="yiyi-st" id="yiyi-119">示例</span></h2><p><span class="yiyi-st" id="yiyi-120">以下是<a class="reference internal" href="#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a>模块的典型用法示例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tempfile</span>

<span class="go"># create a temporary file and write some data to it</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryFile</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s1">'Hello world!'</span><span class="p">)</span>
<span class="go"># read data from file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">b'Hello world!'</span>
<span class="go"># close the file, it will be removed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="go"># create a temporary file using a context manager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s1">'Hello world!'</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">b'Hello world!'</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go"># file is now closed and removed</span>

<span class="go"># create a temporary directory using the context manager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmpdirname</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'created temporary directory'</span><span class="p">,</span> <span class="n">tmpdirname</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go"># directory and contents have been removed</span>
</code></pre></div><div class="section" id="deprecated-functions-and-variables"><h2><span class="yiyi-st" id="yiyi-121">11.6.2.</span><span class="yiyi-st" id="yiyi-122">已弃用的函数和变量</span></h2><p><span class="yiyi-st" id="yiyi-123">创建临时文件的历史方法是首先使用<a class="reference internal" href="#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal"><span class="pre">mktemp()</span></code></a>函数生成文件名，然后使用此名称创建文件。</span><span class="yiyi-st" id="yiyi-124">不幸的是，这不安全，因为不同的进程可能会在调用<a class="reference internal" href="#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal"><span class="pre">mktemp()</span></code></a>和随后尝试通过第一个进程创建文件之间的时间创建一个具有此名称的文件。</span><span class="yiyi-st" id="yiyi-125">解决方案是结合这两个步骤并立即创建文件。</span><span class="yiyi-st" id="yiyi-126">此方法由<a class="reference internal" href="#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></code></a>和上述其他函数使用。</span></p><dl class="function"><dt id="tempfile.mktemp"><span class="yiyi-st" id="yiyi-127"> <code class="descclassname">tempfile.</code><code class="descname">mktemp</code><span class="sig-paren">(</span><em>suffix=''</em>, <em>prefix='tmp'</em>, <em>dir=None</em><span class="sig-paren">)</span></span></dt><dd><div class="deprecated"><p><span class="yiyi-st" id="yiyi-128"><span class="versionmodified">从版本2.3开始弃用：</span>改为使用<a class="reference internal" href="#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></code></a>。</span></p></div><p><span class="yiyi-st" id="yiyi-129">返回在调用时不存在的文件的绝对路径名。</span><span class="yiyi-st" id="yiyi-130">The <em>prefix</em>, <em>suffix</em>, and <em>dir</em> arguments are similar to those of <a class="reference internal" href="#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">mkstemp()</span></code></a>, except that bytes file names, <code class="docutils literal"><span class="pre">suffix=None</span></code> and <code class="docutils literal"><span class="pre">prefix=None</span></code> are not supported.</span></p><div class="admonition warning"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-131">警告</span></p><p><span class="yiyi-st" id="yiyi-132">使用此功能可能会在程序中引入安全漏洞。</span><span class="yiyi-st" id="yiyi-133">当你回来做任何事情与文件名，它返回，其他人可能会打败你打。</span><span class="yiyi-st" id="yiyi-134"><a class="reference internal" href="#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal"><span class="pre">mktemp()</span></code></a>使用可以很容易地替换为<a class="reference internal" href="#tempfile.NamedTemporaryFile" title="tempfile.NamedTemporaryFile"><code class="xref py py-func docutils literal"><span class="pre">NamedTemporaryFile()</span></code></a>，传递<code class="docutils literal"><span class="pre">delete=False</span></code></span></p><div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">name</span>
<span class="go">'/tmp/tmptjujjt'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s2">"Hello World!</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="go">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="go">False</span>
</pre></div></div></div></dd></dl></div></div></div>