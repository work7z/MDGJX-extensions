<div class="body" role="main"><div class="section" id="module-_thread"><h1><span class="yiyi-st" id="yiyi-10">17.9. </span><span class="yiyi-st" id="yiyi-11"><a class="reference internal" href="#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal"><span class="pre">_thread</span></code></a> — Low-level threading API</span></h1><p><span class="yiyi-st" id="yiyi-12">此模块提供用于处理多线程（也称为<em class="dfn">轻量级进程</em>或<em class="dfn">任务</em>）的低级原语 - 多个控制线程共享其全局数据空间。</span><span class="yiyi-st" id="yiyi-13">对于同步，提供简单锁（也称为<em class="dfn">互斥体</em>或<em class="dfn">二进制信号量</em>）。</span><span class="yiyi-st" id="yiyi-14"><a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a>模块提供了一个更易于使用和更高级别的线程API构建在此模块之上。</span></p><p id="index-1"><span class="yiyi-st" id="yiyi-15">模块是可选的。</span><span class="yiyi-st" id="yiyi-16">它在Windows，Linux，SGI IRIX，Solaris 2.x以及具有POSIX线程（也称为POSIX线程）的系统上受支持。</span><span class="yiyi-st" id="yiyi-17">“pthread”）实现。</span><span class="yiyi-st" id="yiyi-18">对于缺少<a class="reference internal" href="#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal"><span class="pre">_thread</span></code></a>模块的系统，<a class="reference internal" href="_dummy_thread.html#module-_dummy_thread" title="_dummy_thread: Drop-in replacement for the _thread module."><code class="xref py py-mod docutils literal"><span class="pre">_dummy_thread</span></code></a>模块可用。</span><span class="yiyi-st" id="yiyi-19">它复制此模块的接口，并可用作插件替换。</span></p><p><span class="yiyi-st" id="yiyi-20">它定义了以下常量和函数：</span></p><dl class="exception"><dt id="_thread.error"><span class="yiyi-st" id="yiyi-21"> <em class="property">exception </em><code class="descclassname">_thread.</code><code class="descname">error</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-22">引发线程特定的错误。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-23"><span class="versionmodified">在版本3.3中更改：</span>这现在是内建<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a>的同义词。</span></p></div></dd></dl><dl class="data"><dt id="_thread.LockType"><span class="yiyi-st" id="yiyi-24"> <code class="descclassname">_thread.</code><code class="descname">LockType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-25">这是锁对象的类型。</span></p></dd></dl><dl class="function"><dt id="_thread.start_new_thread"><span class="yiyi-st" id="yiyi-26"> <code class="descclassname">_thread.</code><code class="descname">start_new_thread</code><span class="sig-paren">(</span><em>function</em>, <em>args</em><span class="optional">[</span>, <em>kwargs</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-27">启动一个新线程并返回其标识符。</span><span class="yiyi-st" id="yiyi-28">线程使用参数列表<em>args</em>（必须是元组）执行函数<em>function</em>。</span><span class="yiyi-st" id="yiyi-29">可选的<em>kwargs</em>参数指定关键字参数的字典。</span><span class="yiyi-st" id="yiyi-30">当函数返回时，线程静默退出。</span><span class="yiyi-st" id="yiyi-31">当函数以未处理的异常终止时，将打印堆栈跟踪，然后线程退出（但其他线程继续运行）。</span></p></dd></dl><dl class="function"><dt id="_thread.interrupt_main"><span class="yiyi-st" id="yiyi-32"> <code class="descclassname">_thread.</code><code class="descname">interrupt_main</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-33">引发主线程中的<a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-34">一个子线程可以使用这个函数来中断主线程。</span></p></dd></dl><dl class="function"><dt id="_thread.exit"><span class="yiyi-st" id="yiyi-35"> <code class="descclassname">_thread.</code><code class="descname">exit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-36">引发<a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal"><span class="pre">SystemExit</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-37">当不被捕获时，这将导致线程静默地退出。</span></p></dd></dl><dl class="function"><dt id="_thread.allocate_lock"><span class="yiyi-st" id="yiyi-38"> <code class="descclassname">_thread.</code><code class="descname">allocate_lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-39">返回一个新的锁对象。</span><span class="yiyi-st" id="yiyi-40">锁的方法如下所述。</span><span class="yiyi-st" id="yiyi-41">锁首先解锁。</span></p></dd></dl><dl class="function"><dt id="_thread.get_ident"><span class="yiyi-st" id="yiyi-42"> <code class="descclassname">_thread.</code><code class="descname">get_ident</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-43">返回当前线程的'线程标识符'。</span><span class="yiyi-st" id="yiyi-44">这是一个非零整数。</span><span class="yiyi-st" id="yiyi-45">它的价值没有直接的意义；它旨在作为要使用的魔术cookie。</span><span class="yiyi-st" id="yiyi-46">索引线程特定数据的字典。</span><span class="yiyi-st" id="yiyi-47">线程标识符可以在线程退出并创建另一个线程时被回收。</span></p></dd></dl><dl class="function"><dt id="_thread.stack_size"><span class="yiyi-st" id="yiyi-48"> <code class="descclassname">_thread.</code><code class="descname">stack_size</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-49">返回创建新线程时使用的线程堆栈大小。</span><span class="yiyi-st" id="yiyi-50">可选的<em>size</em>参数指定用于随后创建的线程的堆栈大小，并且必须为0（使用平台或已配置的默认值）或至少为32,768（32 KiB）的正整数值。</span><span class="yiyi-st" id="yiyi-51">如果未指定<em>size</em>，则使用0。</span><span class="yiyi-st" id="yiyi-52">如果不支持更改线程堆栈大小，则会引发<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-53">如果指定的堆栈大小无效，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>并且堆栈大小未修改。</span><span class="yiyi-st" id="yiyi-54">32 KiB是当前支持的最小堆栈大小值，以保证解释器本身有足够的堆栈空间。</span><span class="yiyi-st" id="yiyi-55">请注意，一些平台可能对堆栈大小的值有特殊限制，例如要求最小堆栈大小&gt; 32 KiB或需要分配系统内存页大小的倍数 - 有关更多信息，请参阅平台文档（4 KiB页是常见的；使用4096的倍数作为堆栈大小是在没有更具体信息的情况下的建议方法）。</span><span class="yiyi-st" id="yiyi-56">可用性：Windows，具有POSIX线程的系统。</span></p></dd></dl><dl class="data"><dt id="_thread.TIMEOUT_MAX"><span class="yiyi-st" id="yiyi-57"> <code class="descclassname">_thread.</code><code class="descname">TIMEOUT_MAX</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-58"><code class="xref py py-meth docutils literal"><span class="pre">Lock.acquire()</span></code>的<em>timeout</em>参数允许的最大值。</span><span class="yiyi-st" id="yiyi-59">指定超过此值的超时将引发<a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-60"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-61">锁定对象有以下方法：</span></p><dl class="method"><dt id="_thread.lock.acquire"><span class="yiyi-st" id="yiyi-62"> <code class="descclassname">lock.</code><code class="descname">acquire</code><span class="sig-paren">(</span><em>waitflag=1</em>, <em>timeout=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-63">没有任何可选参数，此方法无条件地获取锁，如果必要等待，直到它被另一个线程释放（一次只有一个线程可以获取锁 - 这是他们的存在的原因）。</span></p><p><span class="yiyi-st" id="yiyi-64">如果存在整数<em>waitflag</em>参数，则操作取决于其值：如果它为零，则仅在无需等待即可立即获取锁时才获取锁，而如果非零，则锁是无条件获得。</span></p><p><span class="yiyi-st" id="yiyi-65">如果浮点<em>超时</em>参数存在且为正，则它指定返回前的最大等待时间（以秒为单位）。</span><span class="yiyi-st" id="yiyi-66">负数<em>超时</em>参数指定无界等待。</span><span class="yiyi-st" id="yiyi-67">如果<em>waitflag</em>为零，则不能指定<em>超时</em>。</span></p><p><span class="yiyi-st" id="yiyi-68">如果成功获取锁，则返回值为<code class="docutils literal"><span class="pre">True</span></code>，如果未成功，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-69"><span class="versionmodified">在版本3.2中更改：</span> <em>超时</em>参数是新的。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-70"><span class="versionmodified">在版本3.2中更改：</span>锁获取现在可以被POSIX上的信号中断。</span></p></div></dd></dl><dl class="method"><dt id="_thread.lock.release"><span class="yiyi-st" id="yiyi-71"> <code class="descclassname">lock.</code><code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-72">释放锁。</span><span class="yiyi-st" id="yiyi-73">锁必须早已获得，但不一定由同一线程获取。</span></p></dd></dl><dl class="method"><dt id="_thread.lock.locked"><span class="yiyi-st" id="yiyi-74"> <code class="descclassname">lock.</code><code class="descname">locked</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-75">返回锁的状态：<code class="docutils literal"><span class="pre">True</span></code>如果它已被某个线程获取，<code class="docutils literal"><span class="pre">False</span></code>如果没有。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-76">除了这些方法，锁定对象也可以通过<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句使用，例如。</span><span class="yiyi-st" id="yiyi-77">：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">_thread</span>

<span class="n">a_lock</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">allocate_lock</span><span class="p">()</span>

<span class="k">with</span> <span class="n">a_lock</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"a_lock is locked while this executes"</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-78"><strong>注意事项：</strong></span></p><ul class="simple" id="index-2"><li><span class="yiyi-st" id="yiyi-79">线程与中断奇怪地交互：<a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a>异常将被任意线程接收。</span><span class="yiyi-st" id="yiyi-80">（当<a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal"><span class="pre">signal</span></code></a>模块可用时，中断总是进入主线程。）</span></li><li><span class="yiyi-st" id="yiyi-81">调用<a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></code></a>或提高<a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal"><span class="pre">SystemExit</span></code></a>异常等效于调用<a class="reference internal" href="#_thread.exit" title="_thread.exit"><code class="xref py py-func docutils literal"><span class="pre">_thread.exit()</span></code></a>。</span></li><li><span class="yiyi-st" id="yiyi-82">不能中断锁的<code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code>方法 - 获取锁后，将发生<a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a>异常。</span></li><li><span class="yiyi-st" id="yiyi-83">当主线程退出时，系统定义其他线程是否存活。</span><span class="yiyi-st" id="yiyi-84">在大多数系统上，它们会在不执行<a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> ... <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a>子句或执行对象析构器的情况下被杀死。</span></li><li><span class="yiyi-st" id="yiyi-85">当主线程退出时，它不执行任何常规的清理（除了<a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> ... <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a>子句被遵守），标准I / O文件不冲洗。</span></li></ul></div></div>