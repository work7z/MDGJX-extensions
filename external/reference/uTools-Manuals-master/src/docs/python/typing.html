<div class="body" role="main"><div class="section" id="module-typing"><h1><span class="yiyi-st" id="yiyi-10">26.1. <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see PEP 484)."><code class="xref py py-mod docutils literal"><span class="pre">typing</span></code></a> —— 支持类型提示</span></h1><div class="versionadded"><p><span class="yiyi-st" id="yiyi-11"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div><p><span class="yiyi-st" id="yiyi-12"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/typing.py">Lib/typing.py</a></span></p><p><span class="yiyi-st" id="yiyi-13">此模块支持由<span class="target" id="index-0"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>指定的类型提示。</span><span class="yiyi-st" id="yiyi-14">The most fundamental support consists of the type <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#typing.Union" title="typing.Union"><code class="xref py py-class docutils literal"><span class="pre">Union</span></code></a>, <a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-class docutils literal"><span class="pre">Tuple</span></code></a>, <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-class docutils literal"><span class="pre">Callable</span></code></a>, <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal"><span class="pre">TypeVar</span></code></a>, and <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal"><span class="pre">Generic</span></code></a>. </span><span class="yiyi-st" id="yiyi-15">有关完整规格，请参阅<span class="target" id="index-1"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>。</span><span class="yiyi-st" id="yiyi-16">有关类型提示的简化介绍，请参见<span class="target" id="index-2"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a>。</span></p><p><span class="yiyi-st" id="yiyi-17">下面的函数接受和返回一个字符串，并注释如下：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">'Hello '</span> <span class="o">+</span> <span class="n">name</span>
</code></pre><p><span class="yiyi-st" id="yiyi-18">在函数<code class="docutils literal"><span class="pre">greeting</span></code>中，参数<code class="docutils literal"><span class="pre">name</span></code>应为<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>类型，返回类型<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>。</span><span class="yiyi-st" id="yiyi-19">子类型被接受为参数。</span></p><div class="section" id="type-aliases"><h2><span class="yiyi-st" id="yiyi-20">26.1.1.</span><span class="yiyi-st" id="yiyi-21">类型别名</span></h2><p><span class="yiyi-st" id="yiyi-22">通过将类型分配给别名来定义类型别名。</span><span class="yiyi-st" id="yiyi-23">在此示例中，<code class="docutils literal"><span class="pre">Vector</span></code>和<code class="docutils literal"><span class="pre">List[float]</span></code>将被视为可互换的同义词：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span>
<span class="n">Vector</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># typechecks; a list of floats qualifies as a Vector.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</code></pre><p><span class="yiyi-st" id="yiyi-24">类型别名可用于简化复杂类型签名。</span><span class="yiyi-st" id="yiyi-25">例如：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>

<span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">Address</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">Server</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># The static type checker will treat the previous type signature as</span>
<span class="c1"># being exactly equivalent to this one.</span>
<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">servers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</code></pre></div><div class="section" id="newtype"><h2><span class="yiyi-st" id="yiyi-26">26.1.2.</span><span class="yiyi-st" id="yiyi-27">NewType </span></h2><p><span class="yiyi-st" id="yiyi-28">使用<code class="docutils literal"><span class="pre">NewType</span></code>帮助函数创建不同类型：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">'UserId'</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-29">静态类型检查器将把新类型视为原始类型的子类。</span><span class="yiyi-st" id="yiyi-30">这有助于捕获逻辑错误：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># typechecks</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># does not typecheck; an int is not a UserId</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-31">您仍然可以对<code class="docutils literal"><span class="pre">UserId</span></code>类型的变量执行所有<code class="docutils literal"><span class="pre">int</span></code>操作，但结果始终为<code class="docutils literal"><span class="pre">int</span></code>类型。</span><span class="yiyi-st" id="yiyi-32">这样，您可以在<code class="docutils literal"><span class="pre">int</span></code>中传递<code class="docutils literal"><span class="pre">UserId</span></code>，但会阻止您以无效方式意外创建<code class="docutils literal"><span class="pre">UserId</span></code>：</span></p><pre><code class="language-python"><span></span><span class="c1"># 'output' is of type 'int', not 'UserId'</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-33">注意，这些检查仅由静态类型检查器强制执行。</span><span class="yiyi-st" id="yiyi-34">在运行时，语句<code class="docutils literal"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code>使<code class="docutils literal"><span class="pre">Derived</span></code>成为一个函数，该函数立即返回传递给它的任何参数。</span><span class="yiyi-st" id="yiyi-35">这意味着表达式<code class="docutils literal"><span class="pre">Derived(some_value)</span></code>不会创建新类或引入超出常规函数调用的任何开销。</span></p><p><span class="yiyi-st" id="yiyi-36">更准确地说，在运行时刻，表达式<code class="docutils literal"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code>永远为真。</span></p><p><span class="yiyi-st" id="yiyi-37">这也意味着不可能创建<code class="docutils literal"><span class="pre">Derived</span></code>的子类型，因为它是运行时的标识函数，而不是实际类型。</span><span class="yiyi-st" id="yiyi-38">类似地，不可能基于<code class="docutils literal"><span class="pre">Derived</span></code>类型创建另一个<code class="docutils literal"><span class="pre">NewType</span></code>：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">'UserId'</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># Fails at runtime and does not typecheck</span>
<span class="k">class</span> <span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>

<span class="c1"># Also does not typecheck</span>
<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">'ProUserId'</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-39">有关详细信息，请参阅<span class="target" id="index-3"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-40">注意</span></p><p><span class="yiyi-st" id="yiyi-41">回想一下，类型别名的使用声明两种类型彼此<em>等效</em>。</span><span class="yiyi-st" id="yiyi-42">执行<code class="docutils literal"><span class="pre">别名</span> <span class="pre">=</span> <span class="pre">原始</span>会使静态类型检查器将<code class="docutils literal"><span class="pre">Alias</span></code>视为<em></em>到<code class="docutils literal"><span class="pre">Original</span></code></code></span><span class="yiyi-st" id="yiyi-43">当您想要简化复杂类型签名时，这是非常有用的。</span></p><p class="last"><span class="yiyi-st" id="yiyi-44">相比之下，<code class="docutils literal"><span class="pre">NewType</span></code>声明一种类型为另一个类型的<em>子类型</em>。</span><span class="yiyi-st" id="yiyi-45">执行<code class="docutils literal"><span class="pre">导出</span> <span class="pre">=</span> <span class="pre">NewType（'Derived'，NewType（'Derived'，</span> <span class="pre">Original）</span>静态类型检查器将<code class="docutils literal"><span class="pre">Derived</span></code>视为<code class="docutils literal"><span class="pre">Original</span></code>的<em>子类</em>，这意味着不能使用类型<code class="docutils literal"><span class="pre">Original</span></code>的值在期望类型为<code class="docutils literal"><span class="pre">Derived</span></code>的地方。</code></span><span class="yiyi-st" id="yiyi-46">当您希望以最小的运行时成本防止逻辑错误时，这是​​有用的。</span></p></div></div><div class="section" id="callable"><h2><span class="yiyi-st" id="yiyi-47">26.1.3.</span><span class="yiyi-st" id="yiyi-48">可调用</span></h2><p><span class="yiyi-st" id="yiyi-49">期望特定签名的回调函数的框架可以使用<code class="docutils literal"><span class="pre">Callable [[Arg1Type，</span> <span class="pre">Arg2Type]，Arg2Type]，</span> <span class="pre">ReturnType]</span></code></span></p><p><span class="yiyi-st" id="yiyi-50">例如：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>

<span class="k">def</span> <span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>
</code></pre><p><span class="yiyi-st" id="yiyi-51">可以通过用类型hint中的参数列表替换字面值省略来声明可调用的返回类型，而不指定调用声明：hint：<code class="docutils literal"><span class="pre">Callable [...，</span> <span class="pre">ReturnType]</span></code></span><span class="yiyi-st" id="yiyi-52"><code class="docutils literal"><span class="pre">None</span></code>作为类型提示是一种特殊情况，并替换为<code class="docutils literal"><span class="pre">type(None)</span></code>。</span></p></div><div class="section" id="generics"><h2><span class="yiyi-st" id="yiyi-53">26.1.4.</span><span class="yiyi-st" id="yiyi-54">泛型</span></h2><p><span class="yiyi-st" id="yiyi-55">由于不能以通用方式静态推断容器中保存的对象的类型信息，因此已经扩展了抽象基类以支持预订来表示容器元素的预期类型。</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">def</span> <span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-56">可以通过使用在名为<a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal"><span class="pre">TypeVar</span></code></a>的类型中可用的新工厂来对泛型进行参数化。</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'T'</span><span class="p">)</span>      <span class="c1"># Declare type variable</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>   <span class="c1"># Generic function</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div><div class="section" id="user-defined-generic-types"><h2><span class="yiyi-st" id="yiyi-57">26.1.5.</span><span class="yiyi-st" id="yiyi-58">用户定义的泛型类型</span></h2><p><span class="yiyi-st" id="yiyi-59">用户类可以定义为通用类。</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="k">import</span> <span class="n">Logger</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'T'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">'Set '</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">'Get '</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">'</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</code></pre><p><span class="yiyi-st" id="yiyi-60"><code class="docutils literal"><span class="pre">Generic[T]</span></code>定义类<code class="docutils literal"><span class="pre">LoggedVar</span></code>采用单个类型参数<code class="docutils literal"><span class="pre">T</span></code></span><span class="yiyi-st" id="yiyi-61">这也使<code class="docutils literal"><span class="pre">T</span></code>有效作为类体中的类型。</span></p><p><span class="yiyi-st" id="yiyi-62"><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal"><span class="pre">Generic</span></code></a>基类使用定义<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>的元类，使得<code class="docutils literal"><span class="pre">LoggedVar[t]</span></code>有效作为类型：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-63">泛型类型可以有任意数量的类型变量，类型变量可以被约束：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'T'</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'S'</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StrangePair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">]):</span>
    <span class="o">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-64"><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal"><span class="pre">Generic</span></code></a>的每个类型变量参数必须是不同的。</span><span class="yiyi-st" id="yiyi-65">因此无效：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'T'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># INVALID</span>
    <span class="o">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-66">您可以使用多个继承与<a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal"><span class="pre">Generic</span></code></a>：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sized</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'T'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-67">当继承泛型类时，一些类型变量可以修复：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'T'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyDict</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-68">在这种情况下，<code class="docutils literal"><span class="pre">MyDict</span></code>具有单个参数<code class="docutils literal"><span class="pre">T</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-69">将不指定类型参数的泛型类子类化为每个位置假设<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>。</span><span class="yiyi-st" id="yiyi-70">在下面的示例中，<code class="docutils literal"><span class="pre">MyIterable</span></code>不是通用的，而是隐含地继承自<code class="docutils literal"><span class="pre">Iterable[Any]</span></code>：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Same as Iterable[Any]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-71"><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal"><span class="pre">Generic</span></code></a>使用的元类是<a class="reference internal" href="abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal"><span class="pre">abc.ABCMeta</span></code></a></span><span class="yiyi-st" id="yiyi-72">通用类可以是通过包括抽象方法或属性的ABC，并且通用类也可以具有ABC作为基类而没有元类冲突。</span><span class="yiyi-st" id="yiyi-73">不支持通用元类。</span></p></div><div class="section" id="the-any-type"><h2><span class="yiyi-st" id="yiyi-74">26.1.6.</span><span class="yiyi-st" id="yiyi-75"><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>类型</span></h2><p><span class="yiyi-st" id="yiyi-76">一种特殊类型的类型是<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>。</span><span class="yiyi-st" id="yiyi-77">静态类型检查器会将每种类型视为与<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>和<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>兼容，与每种类型兼容。</span></p><p><span class="yiyi-st" id="yiyi-78">这意味着可以对<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>上的类型的值执行任何操作或方法调用，并将其分配给任何变量：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span>

<span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># type: Any</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>       <span class="c1"># OK</span>

<span class="n">s</span> <span class="o">=</span> <span class="s1">''</span>      <span class="c1"># type: str</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>       <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Typechecks; 'item' could be any type,</span>
    <span class="c1"># and that type might have a 'bar' method</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-79">请注意，在将类型<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>的值指定为更精确的类型时，不会执行类型检查。</span><span class="yiyi-st" id="yiyi-80">For example, the static type checker did not report an error when assigning <code class="docutils literal"><span class="pre">a</span></code> to <code class="docutils literal"><span class="pre">s</span></code> even though <code class="docutils literal"><span class="pre">s</span></code> was declared to be of type <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> and receives an <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> value at runtime!</span></p><p><span class="yiyi-st" id="yiyi-81">此外，没有返回类型或参数类型的所有函数将默认使用<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># A static type checker will treat the above</span>
<span class="c1"># as having the same signature as:</span>
<span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</code></pre><p><span class="yiyi-st" id="yiyi-82">当您需要混合动态和静态类型代码时，此行为允许<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>用作<em>escape hatch</em>。</span></p><p><span class="yiyi-st" id="yiyi-83">对比<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>与<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>行为的行为。</span><span class="yiyi-st" id="yiyi-84">与<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>类似，每个类型都是<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>的子类型。</span><span class="yiyi-st" id="yiyi-85">但是，与<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>不同，反之亦然：<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>是<em>而不是</em>每个其他类型的子类型。</span></p><p><span class="yiyi-st" id="yiyi-86">这意味着当值的类型是<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>时，类型检查器将拒绝几乎所有的操作，并将其分配给更专门类型的变量（或使用它作为返回值）类型错误。</span><span class="yiyi-st" id="yiyi-87">例如：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Fails; an object does not have a 'magic' method.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Typechecks</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># Typechecks, since ints and strs are subclasses of object</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span>

<span class="c1"># Typechecks, since Any is compatible with all types</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-88">使用<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>表示值可以是类型安全方式的任何类型。</span><span class="yiyi-st" id="yiyi-89">使用<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>表示值是动态类型。</span></p></div><div class="section" id="classes-functions-and-decorators"><h2><span class="yiyi-st" id="yiyi-90">26.1.7.</span><span class="yiyi-st" id="yiyi-91">类，函数和装饰器</span></h2><p><span class="yiyi-st" id="yiyi-92">模块定义了以下类，函数和装饰器：</span></p><dl class="class"><dt id="typing.Any"><span class="yiyi-st" id="yiyi-93"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Any</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">表示无约束类型的特殊类型。</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-95">任何对象都是<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>的实例。</span></li><li><span class="yiyi-st" id="yiyi-96">任何类都是<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>的子类。</span></li><li><span class="yiyi-st" id="yiyi-97">作为特殊情况，<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>和<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>是彼此的子类。</span></li></ul></dd></dl><dl class="class"><dt id="typing.TypeVar"><span class="yiyi-st" id="yiyi-98"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">TypeVar</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-99">类型变量。</span></p><p><span class="yiyi-st" id="yiyi-100">用法：</span></p><pre><code class="language-python"><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'T'</span><span class="p">)</span>  <span class="c1"># Can be anything</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Must be str or bytes</span>
</code></pre><p><span class="yiyi-st" id="yiyi-101">类型变量主要用于静态类型检查器的好处。</span><span class="yiyi-st" id="yiyi-102">它们用作泛型类型以及通用函数定义的参数。</span><span class="yiyi-st" id="yiyi-103">有关泛型类型的更多信息，请参阅类Generic。</span><span class="yiyi-st" id="yiyi-104">通用函数的工作方式如下：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="sd">"""Return a list containing n references to x."""</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

<span class="k">def</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
    <span class="sd">"""Return the longest of two strings."""</span>
    <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span>
</code></pre><p><span class="yiyi-st" id="yiyi-105">后面的示例的声明本质上是<code class="docutils literal"><span class="pre">（str，</span> <span class="pre">str）</span> <span class="pre"> - &gt;</span> <span class="pre">str</span> <code class="docutils literal"><span class="pre">（字节，</span> <span class="pre">字节）</span> <span class="pre"> - &gt;</span> <span class="pre">字节</span></code></code></span><span class="yiyi-st" id="yiyi-106">还要注意，如果参数是<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>的某个子类的实例，则返回类型仍然是平常的<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-107">在运行时，运行时，<code class="docutils literal"><span class="pre">isinstance（x，</span> <span class="pre">T）</span>将引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</code></span><span class="yiyi-st" id="yiyi-108">一般来说，<a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a>和<a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a>不应与类型一起使用。</span></p><p><span class="yiyi-st" id="yiyi-109">类型变量可以通过传递<code class="docutils literal"><span class="pre">covariant=True</span></code>或<code class="docutils literal"><span class="pre">contravariant=True</span></code>标记为协变或逆变。</span><span class="yiyi-st" id="yiyi-110">有关详细信息，请参阅<span class="target" id="index-4"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>。</span><span class="yiyi-st" id="yiyi-111">默认类型变量是不变的。</span><span class="yiyi-st" id="yiyi-112">或者，类型变量可以使用<code class="docutils literal"><span class="pre">bound=&lt;type&gt;</span></code>来指定上界。</span><span class="yiyi-st" id="yiyi-113">这意味着对类型变量替换（显式或隐式）的实际类型必须是边界类型的子类型，请参见<span class="target" id="index-5"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>。</span></p></dd></dl><dl class="class"><dt id="typing.Union"><span class="yiyi-st" id="yiyi-114"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Union</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-115">共用体类型； <code class="docutils literal"><span class="pre">联合[X，</span> <span class="pre">Y]</span>表示X或Y.</code></span></p><p><span class="yiyi-st" id="yiyi-116">要定义共用体，请使用e。</span><span class="yiyi-st" id="yiyi-117"><code class="docutils literal"><span class="pre">Union [int，</span> <span class="pre">str]</span></code></span><span class="yiyi-st" id="yiyi-118">细节：</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-119">参数必须是类型，并且必须至少有一个。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-120">工会联合会是扁平的，</span><span class="yiyi-st" id="yiyi-121"></span></p><pre><code class="language-python"><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-122">单一参数的联合消失，e。</span><span class="yiyi-st" id="yiyi-123"></span></p><pre><code class="language-python"><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># The constructor actually returns int</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-124">跳过冗余参数，e。</span><span class="yiyi-st" id="yiyi-125"></span></p><pre><code class="language-python"><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-126">当比较联合时，参数顺序被忽略，e。</span><span class="yiyi-st" id="yiyi-127"></span></p><pre><code class="language-python"><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-128">如果<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal"><span class="pre">Any</span></code></a>存在，它是唯一的幸存者，</span><span class="yiyi-st" id="yiyi-129"></span></p><pre><code class="language-python"><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">==</span> <span class="n">Any</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-130">你不能子类化或实例化一个共用体。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-131">您不能写<code class="docutils literal"><span class="pre">Union[X][Y]</span></code>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-132">您可以使用<code class="docutils literal"><span class="pre">Optional[X]</span></code>作为<code class="docutils literal"><span class="pre">联合的缩写[X，</span> <span class="pre">无]</span></code></span></p></li></ul></dd></dl><dl class="class"><dt id="typing.Optional"><span class="yiyi-st" id="yiyi-133"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Optional</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-134">可选类型。</span></p><p><span class="yiyi-st" id="yiyi-135"><code class="docutils literal"><span class="pre">Optional[X]</span></code>等效于<code class="docutils literal"><span class="pre">Union [X，</span> <span class="pre">type（None）]</span></code></span></p><p><span class="yiyi-st" id="yiyi-136">请注意，这不是一个可选参数的概念，它是一个具有默认值的参数。</span><span class="yiyi-st" id="yiyi-137">具有默认值的可选参数不需要在其类型注解上使用<code class="docutils literal"><span class="pre">Optional</span></code>限定符（虽然如果默认值为<code class="docutils literal"><span class="pre">None</span></code></span><span class="yiyi-st" id="yiyi-138">如果允许显式值<code class="docutils literal"><span class="pre">None</span></code>，则强制参数可能仍然具有<code class="docutils literal"><span class="pre">Optional</span></code>类型。</span></p></dd></dl><dl class="class"><dt id="typing.Tuple"><span class="yiyi-st" id="yiyi-139"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Tuple</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-140">元组类型； <code class="docutils literal"><span class="pre">元组[X，</span> <span class="pre">Y]</span>是两个项目的元组的类型，第一个项目类型为X，第二个项目类型为Y.</code></span></p><p><span class="yiyi-st" id="yiyi-141">示例：示例：<code class="docutils literal"><span class="pre">元组[T1，</span> <span class="pre">T2]</span>是对应于类型变量T1和T2的两个元素的元组。</code></span><span class="yiyi-st" id="yiyi-142"><code class="docutils literal"><span class="pre">Tuple [int，</span> <span class="pre">float，float，</span> <span class="pre">str]</span>是一个int，int，float和string.string 。</code></span></p><p><span class="yiyi-st" id="yiyi-143">要指定同构类型的变量元组，请使用字面值省略号，</span><span class="yiyi-st" id="yiyi-144"><code class="docutils literal"><span class="pre">Tuple [int，</span> <span class="pre">...]</span></code></span></p></dd></dl><dl class="class"><dt id="typing.Callable"><span class="yiyi-st" id="yiyi-145"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Callable</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-146">可叫类型； <code class="docutils literal"><span class="pre">Callable [[int]，</span> <span class="pre">str]</span>是（int） - &gt; str.str的函数。</code></span></p><p><span class="yiyi-st" id="yiyi-147">订阅语法必须始终使用两个值：参数列表和返回类型。</span><span class="yiyi-st" id="yiyi-148">参数列表必须是一个类型列表；返回类型必须是单个类型。</span></p><p><span class="yiyi-st" id="yiyi-149">没有用于指示可选或关键字参数的语法，这种函数类型很少用作回调类型。</span><span class="yiyi-st" id="yiyi-150"><code class="docutils literal"><span class="pre">Callable [...，</span> <span class="pre">ReturnType]</span>可用于输入hint一个可调用的任何数量的参数并返回<code class="docutils literal"><span class="pre">ReturnType</span></code>。</code></span><span class="yiyi-st" id="yiyi-151">平常<a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-class docutils literal"><span class="pre">Callable</span></code></a>等效于<code class="docutils literal"><span class="pre">Callable [...，</span> <span class="pre">Any]</span></code></span></p></dd></dl><dl class="class"><dt id="typing.Generic"><span class="yiyi-st" id="yiyi-152"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Generic</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-153">泛型类型的抽象基类。</span></p><p><span class="yiyi-st" id="yiyi-154">通常类型通常通过从具有一个或多个类型变量的该类的实例化继承来声明。</span><span class="yiyi-st" id="yiyi-155">例如，通用映射类型可以定义为：</span></p><pre><code class="language-python"><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</code></pre><p><span class="yiyi-st" id="yiyi-156">然后可以使用此类，如下所示：</span></p><pre><code class="language-python"><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'X'</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'Y'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lookup_name</span><span class="p">(</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</code></pre></dd></dl><dl class="class"><dt id="typing.Iterable"><span class="yiyi-st" id="yiyi-157"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Iterable</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-158"><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Iterable</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.Iterator"><span class="yiyi-st" id="yiyi-159"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Iterator</code><span class="sig-paren">(</span><em>Iterable[T_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-160"><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Iterator</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.SupportsInt"><span class="yiyi-st" id="yiyi-161"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsInt</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-162">具有一个抽象方法的ABC <code class="docutils literal"><span class="pre">__int__</span></code>。</span></p></dd></dl><dl class="class"><dt id="typing.SupportsFloat"><span class="yiyi-st" id="yiyi-163"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsFloat</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-164">具有一个抽象方法的ABC：<code class="docutils literal"><span class="pre">__float__</span></code>。</span></p></dd></dl><dl class="class"><dt id="typing.SupportsAbs"><span class="yiyi-st" id="yiyi-165"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsAbs</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-166">具有在其返回类型中是协变的一个抽象方法<code class="docutils literal"><span class="pre">__abs__</span></code>的ABC。</span></p></dd></dl><dl class="class"><dt id="typing.SupportsRound"><span class="yiyi-st" id="yiyi-167"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsRound</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-168">具有一个抽象方法的ABC，它具有在其返回类型中协变的一个抽象方法<code class="docutils literal"><span class="pre">__round__</span></code>。</span></p></dd></dl><dl class="class"><dt id="typing.Reversible"><span class="yiyi-st" id="yiyi-169"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Reversible</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-170">具有一个抽象方法的ABC <code class="docutils literal"><span class="pre">__reversed__</span></code>返回<code class="docutils literal"><span class="pre">Iterator[T_co]</span></code>。</span></p></dd></dl><dl class="class"><dt id="typing.Container"><span class="yiyi-st" id="yiyi-171"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Container</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-172"><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Container</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.AbstractSet"><span class="yiyi-st" id="yiyi-173"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AbstractSet</code><span class="sig-paren">(</span><em>Sized, Iterable[T_co], Container[T_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-174"><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Set</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.MutableSet"><span class="yiyi-st" id="yiyi-175"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableSet</code><span class="sig-paren">(</span><em>AbstractSet[T]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-176"><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MutableSet</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.Mapping"><span class="yiyi-st" id="yiyi-177"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Mapping</code><span class="sig-paren">(</span><em>Sized, Iterable[KT], Container[KT], Generic[VT_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-178"><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Mapping</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.MutableMapping"><span class="yiyi-st" id="yiyi-179"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableMapping</code><span class="sig-paren">(</span><em>Mapping[KT, VT]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-180"><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MutableMapping</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.Sequence"><span class="yiyi-st" id="yiyi-181"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Sequence</code><span class="sig-paren">(</span><em>Sized, Iterable[T_co], Container[T_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-182"><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.MutableSequence"><span class="yiyi-st" id="yiyi-183"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableSequence</code><span class="sig-paren">(</span><em>Sequence[T]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-184"><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MutableSequence</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.ByteString"><span class="yiyi-st" id="yiyi-185"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ByteString</code><span class="sig-paren">(</span><em>Sequence[int]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-186"><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.ByteString</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-187">此类型表示类型<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>，<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>和<a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-188">作为此类型的缩写，<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>可用于注释上述任何类型的参数。</span></p></dd></dl><dl class="class"><dt id="typing.List"><span class="yiyi-st" id="yiyi-189"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">List</code><span class="sig-paren">(</span><em>list, MutableSequence[T]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-190"><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>的通用版本。</span><span class="yiyi-st" id="yiyi-191">用于注释返回类型。</span><span class="yiyi-st" id="yiyi-192">要注释参数，最好使用抽象容器类型，例如<a class="reference internal" href="#typing.Mapping" title="typing.Mapping"><code class="xref py py-class docutils literal"><span class="pre">Mapping</span></code></a>，<a class="reference internal" href="#typing.Sequence" title="typing.Sequence"><code class="xref py py-class docutils literal"><span class="pre">Sequence</span></code></a>或<a class="reference internal" href="#typing.AbstractSet" title="typing.AbstractSet"><code class="xref py py-class docutils literal"><span class="pre">AbstractSet</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-193">这种类型可以如下使用：</span></p><pre><code class="language-python"><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">'T'</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">keep_positives</span><span class="p">(</span><span class="n">vector</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></dd></dl><dl class="class"><dt id="typing.Set"><span class="yiyi-st" id="yiyi-194"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Set</code><span class="sig-paren">(</span><em>set, MutableSet[T]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-195"><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">builtins.set</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.MappingView"><span class="yiyi-st" id="yiyi-196"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MappingView</code><span class="sig-paren">(</span><em>Sized, Iterable[T_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-197"><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MappingView</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.KeysView"><span class="yiyi-st" id="yiyi-198"> <em class="property">class </em><code class="descclassname">typing.</code><code class="descname">KeysView</code><span class="sig-paren">(</span><em>MappingView[KT_co], AbstractSet[KT_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-199"><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.KeysView</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.ItemsView"><span class="yiyi-st" id="yiyi-200"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ItemsView</code><span class="sig-paren">(</span><em>MappingView, Generic[KT_co, VT_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-201"><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.ItemsView</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.ValuesView"><span class="yiyi-st" id="yiyi-202"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ValuesView</code><span class="sig-paren">(</span><em>MappingView[VT_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-203"><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.ValuesView</span></code></a></span></p></dd></dl><dl class="class"><dt id="typing.Dict"><span class="yiyi-st" id="yiyi-204"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Dict</code><span class="sig-paren">(</span><em>dict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-205"><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>的通用版本。</span><span class="yiyi-st" id="yiyi-206">此类型的用法如下：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">get_position_in_index</span><span class="p">(</span><span class="n">word_list</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">word_list</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</code></pre></dd></dl><dl class="class"><dt id="typing.Generator"><span class="yiyi-st" id="yiyi-207"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Generator</code><span class="sig-paren">(</span><em>Iterator[T_co], Generic[T_co, T_contra, V_co]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-208">生成器可以通过通用类型<code class="docutils literal"><span class="pre">注释生成器[YieldType，</span> <span class="pre">SendType，SendType，</span> <span class="pre">ReturnType]</span></code></span><span class="yiyi-st" id="yiyi-209">例如：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">'Done'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-210">注意，与打字模块中的许多其他泛型不同，<a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal"><span class="pre">Generator</span></code></a>的<code class="docutils literal"><span class="pre">SendType</span></code>反向变化，而不是协变或不变。</span></p><p><span class="yiyi-st" id="yiyi-211">如果您的生成器只会产生值，请将<code class="docutils literal"><span class="pre">SendType</span></code>和<code class="docutils literal"><span class="pre">ReturnType</span></code>设置为<code class="docutils literal"><span class="pre">None</span></code>：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre><p><span class="yiyi-st" id="yiyi-212">或者，将生成器注释为返回类型<code class="docutils literal"><span class="pre">Iterator[YieldType]</span></code>：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></dd></dl><dl class="class"><dt id="typing.io"><span class="yiyi-st" id="yiyi-213"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">io</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-214">I / O流类型的包装器命名空间。</span></p><p><span class="yiyi-st" id="yiyi-215">This defines the generic type <code class="docutils literal"><span class="pre">IO[AnyStr]</span></code> and aliases <code class="docutils literal"><span class="pre">TextIO</span></code> and <code class="docutils literal"><span class="pre">BinaryIO</span></code> for respectively <code class="docutils literal"><span class="pre">IO[str]</span></code> and <code class="docutils literal"><span class="pre">IO[bytes]</span></code>. </span><span class="yiyi-st" id="yiyi-216">这些表示由<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>返回的I / O流的类型。</span></p></dd></dl><dl class="class"><dt id="typing.re"><span class="yiyi-st" id="yiyi-217"><em class="property">class </em><code class="descclassname">typing.</code><code class="descname">re</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-218">正则表达式匹配类型的Wrapper命名空间。</span></p><p><span class="yiyi-st" id="yiyi-219">这定义了类型别名<code class="docutils literal"><span class="pre">Pattern</span></code>和<code class="docutils literal"><span class="pre">Match</span></code>，它们对应于来自<a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal"><span class="pre">re.compile()</span></code></a>和<a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal"><span class="pre">re.match()</span></code></a>。</span><span class="yiyi-st" id="yiyi-220">These types (and the corresponding functions) are generic in <code class="docutils literal"><span class="pre">AnyStr</span></code> and can be made specific by writing <code class="docutils literal"><span class="pre">Pattern[str]</span></code>, <code class="docutils literal"><span class="pre">Pattern[bytes]</span></code>, <code class="docutils literal"><span class="pre">Match[str]</span></code>, or <code class="docutils literal"><span class="pre">Match[bytes]</span></code>.</span></p></dd></dl><dl class="function"><dt id="typing.NamedTuple"><span class="yiyi-st" id="yiyi-221"><code class="descclassname">typing.</code><code class="descname">NamedTuple</code><span class="sig-paren">(</span><em>typename</em>, <em>fields</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-222">namedtuple的类型化版本。</span></p><p><span class="yiyi-st" id="yiyi-223">用法：</span></p><pre><code class="language-python"><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">(</span><span class="s1">'Employee'</span><span class="p">,</span> <span class="p">[(</span><span class="s1">'name'</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">'id'</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</code></pre><p><span class="yiyi-st" id="yiyi-224">这相当于：</span></p><pre><code class="language-python"><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">'Employee'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'name'</span><span class="p">,</span> <span class="s1">'id'</span><span class="p">])</span>
</code></pre><p><span class="yiyi-st" id="yiyi-225">生成的类有一个额外的属性：_field_types，给出一个dict将字段名称映射到类型。</span><span class="yiyi-st" id="yiyi-226">（字段名称在_fields属性中，它是namedtuple API的一部分。</span></p></dd></dl><dl class="function"><dt id="typing.cast"><span class="yiyi-st" id="yiyi-227"><code class="descclassname">typing.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>typ</em>, <em>val</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-228">将值转换为类型。</span></p><p><span class="yiyi-st" id="yiyi-229">这将返回不变的值。</span><span class="yiyi-st" id="yiyi-230">对于类型检查器，这表示返回值具有指定的类型，但是在运行时我们有意地不检查任何东西（我们希望这是尽可能快的）。</span></p></dd></dl><dl class="function"><dt id="typing.get_type_hints"><span class="yiyi-st" id="yiyi-231"><code class="descclassname">typing.</code><code class="descname">get_type_hints</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-232">返回函数或方法对象的类型提示。</span></p><p><span class="yiyi-st" id="yiyi-233">这通常与<code class="docutils literal"><span class="pre">obj.__annotations__</span></code>相同，但它处理编码为字符串字面值的正向引用，字面值，如果必要，添加<code class="docutils literal"><span class="pre">Optional[t]</span></code>设置为None。</span></p></dd></dl><dl class="function"><dt id="typing.no_type_check"><span class="yiyi-st" id="yiyi-234"> <code class="descclassname">@</code><code class="descclassname">typing.</code><code class="descname">no_type_check</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-235">装饰器来指示注解不是类型提示。</span></p><p><span class="yiyi-st" id="yiyi-236">参数必须是类或函数；如果它是一个类，它将递归应用于该类中定义的所有方法（但不适用于其超类或子类中定义的方法）。</span></p><p><span class="yiyi-st" id="yiyi-237">这会改变函数的位置。</span></p></dd></dl><dl class="function"><dt id="typing.no_type_check_decorator"><span class="yiyi-st" id="yiyi-238"> <code class="descclassname">@</code><code class="descclassname">typing.</code><code class="descname">no_type_check_decorator</code><span class="sig-paren">(</span><em>decorator</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-239">装饰器给另一个装饰器<a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal"><span class="pre">no_type_check()</span></code></a>效果。</span></p><p><span class="yiyi-st" id="yiyi-240">这将装饰器包装在<a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal"><span class="pre">no_type_check()</span></code></a>中的装饰函数。</span></p></dd></dl></div></div></div>