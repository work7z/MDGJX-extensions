<div class="body" role="main"><div class="section" id="module-bdb"><h1><span class="yiyi-st" id="yiyi-10">27.1. <a class="reference internal" href="#module-bdb" title="bdb: Debugger framework."><code class="xref py py-mod docutils literal"><span class="pre">bdb</span></code></a>  - 调试器框架</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/bdb.py">Lib / bdb.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-bdb" title="bdb: Debugger framework."><code class="xref py py-mod docutils literal"><span class="pre">bdb</span></code></a>模块处理基本调试器函数，如设置断点或通过调试器管理执行。</span></p><p><span class="yiyi-st" id="yiyi-13">定义了以下异常：</span></p><dl class="exception"><dt id="bdb.BdbQuit"><span class="yiyi-st" id="yiyi-14"> <em class="property">exception </em><code class="descclassname">bdb.</code><code class="descname">BdbQuit</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-15">用于退出调试器的<a class="reference internal" href="#bdb.Bdb" title="bdb.Bdb"><code class="xref py py-class docutils literal"><span class="pre">Bdb</span></code></a>类引发的异常。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-16"><a class="reference internal" href="#module-bdb" title="bdb: Debugger framework."><code class="xref py py-mod docutils literal"><span class="pre">bdb</span></code></a>模块还定义了两个类：</span></p><dl class="class"><dt id="bdb.Breakpoint"><span class="yiyi-st" id="yiyi-17"> <em class="property">class </em><code class="descclassname">bdb.</code><code class="descname">Breakpoint</code><span class="sig-paren">(</span><em>self</em>, <em>file</em>, <em>line</em>, <em>temporary=0</em>, <em>cond=None</em>, <em>funcname=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-18">此类实现临时断点，忽略计数，禁用和（重新）启用和条件。</span></p><p><span class="yiyi-st" id="yiyi-19">断点通过<code class="xref py py-attr docutils literal"><span class="pre">bpbynumber</span></code>和<code class="docutils literal"><span class="pre">（文件，</span> <span class="pre">行）</span></code>的列表通过<code class="xref py py-attr docutils literal"><span class="pre">bplist</span></code>。</span><span class="yiyi-st" id="yiyi-20">前者指向<a class="reference internal" href="#bdb.Breakpoint" title="bdb.Breakpoint"><code class="xref py py-class docutils literal"><span class="pre">Breakpoint</span></code></a>类的单个实例。</span><span class="yiyi-st" id="yiyi-21">后者指向此类实例的列表，因为每行可能有多个断点。</span></p><p><span class="yiyi-st" id="yiyi-22">创建断点时，其关联的文件名应为规范形式。</span><span class="yiyi-st" id="yiyi-23">如果定义了<em>funcname</em>，则当执行该函数的第一行时，将计算断点命中。</span><span class="yiyi-st" id="yiyi-24">条件断点总是计算命中。</span></p><p><span class="yiyi-st" id="yiyi-25"><a class="reference internal" href="#bdb.Breakpoint" title="bdb.Breakpoint"><code class="xref py py-class docutils literal"><span class="pre">Breakpoint</span></code></a>实例具有以下方法：</span></p><dl class="method"><dt id="bdb.Breakpoint.deleteMe"><span class="yiyi-st" id="yiyi-26"> <code class="descname">deleteMe</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-27">从与文件/行关联的列表中删除断点。</span><span class="yiyi-st" id="yiyi-28">如果它是该位置中的最后一个断点，它还会删除文件/行的条目。</span></p></dd></dl><dl class="method"><dt id="bdb.Breakpoint.enable"><span class="yiyi-st" id="yiyi-29"> <code class="descname">enable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-30">将断点标记为已启用。</span></p></dd></dl><dl class="method"><dt id="bdb.Breakpoint.disable"><span class="yiyi-st" id="yiyi-31"> <code class="descname">disable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-32">将断点标记为禁用。</span></p></dd></dl><dl class="method"><dt id="bdb.Breakpoint.bpformat"><span class="yiyi-st" id="yiyi-33"> <code class="descname">bpformat</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-34">返回一个包含断点的所有信息的字符串，格式很好：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-35">断点号。</span></li><li><span class="yiyi-st" id="yiyi-36">如果是临时的或不是。</span></li><li><span class="yiyi-st" id="yiyi-37">其文件，行位置。</span></li><li><span class="yiyi-st" id="yiyi-38">导致中断的条件。</span></li><li><span class="yiyi-st" id="yiyi-39">如果必须忽略下一个N次。</span></li><li><span class="yiyi-st" id="yiyi-40">断点命中计数。</span></li></ul><div class="versionadded"><p><span class="yiyi-st" id="yiyi-41"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="bdb.Breakpoint.bpprint"><span class="yiyi-st" id="yiyi-42"> <code class="descname">bpprint</code><span class="sig-paren">(</span><em>out=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-43">将<a class="reference internal" href="#bdb.Breakpoint.bpformat" title="bdb.Breakpoint.bpformat"><code class="xref py py-meth docutils literal"><span class="pre">bpformat()</span></code></a>的输出打印到文件<em>输出</em>或如果<code class="docutils literal"><span class="pre">None</span></code>输出到标准输出。</span></p></dd></dl></dd></dl><dl class="class"><dt id="bdb.Bdb"><span class="yiyi-st" id="yiyi-44"> <em class="property">class </em><code class="descclassname">bdb.</code><code class="descname">Bdb</code><span class="sig-paren">(</span><em>skip=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-45"><a class="reference internal" href="#bdb.Bdb" title="bdb.Bdb"><code class="xref py py-class docutils literal"><span class="pre">Bdb</span></code></a>类充当通用的Python调试器基类。</span></p><p><span class="yiyi-st" id="yiyi-46">这个类负责跟踪设施的细节；派生类应该实现用户交互。</span><span class="yiyi-st" id="yiyi-47">标准调试器类（<a class="reference internal" href="pdb.html#pdb.Pdb" title="pdb.Pdb"><code class="xref py py-class docutils literal"><span class="pre">pdb.Pdb</span></code></a>）是一个示例。</span></p><p><span class="yiyi-st" id="yiyi-48">如果给定了<em>skip</em>参数，则必须是可重复的glob样式模块名称模式。</span><span class="yiyi-st" id="yiyi-49">调试器不会步入到源于与这些模式之一匹配的模块中的帧。</span><span class="yiyi-st" id="yiyi-50">帧是否被认为源于某个模块由帧全局中的<code class="docutils literal"><span class="pre">__name__</span></code>确定。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-51"><span class="versionmodified">版本3.1中的新功能：</span> <em>跳过</em>参数。</span></p></div><p><span class="yiyi-st" id="yiyi-52">以下方法<a class="reference internal" href="#bdb.Bdb" title="bdb.Bdb"><code class="xref py py-class docutils literal"><span class="pre">Bdb</span></code></a>通常不需要重写。</span></p><dl class="method"><dt id="bdb.Bdb.canonic"><span class="yiyi-st" id="yiyi-53"> <code class="descname">canonic</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-54">用于以规范形式获取文件名的辅助方法，即作为案例规范化（在不区分大小写的文件系统上）绝对路径，剥离了周围的尖括号。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.reset"><span class="yiyi-st" id="yiyi-55"> <code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-56">将<code class="xref py py-attr docutils literal"><span class="pre">botframe</span></code>，<code class="xref py py-attr docutils literal"><span class="pre">stopframe</span></code>，<code class="xref py py-attr docutils literal"><span class="pre">returnframe</span></code>和<code class="xref py py-attr docutils literal"><span class="pre">quitting</span></code>属性设置为准备开始调试。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.trace_dispatch"><span class="yiyi-st" id="yiyi-57"> <code class="descname">trace_dispatch</code><span class="sig-paren">(</span><em>frame</em>, <em>event</em>, <em>arg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-58">此功能作为调试帧的跟踪功能安装。</span><span class="yiyi-st" id="yiyi-59">它的返回值是新的跟踪函数（在大多数情况下，也就是说，它自己）。</span></p><p><span class="yiyi-st" id="yiyi-60">默认实现决定如何分派帧，具体取决于将要执行的事件类型（作为字符串传递）。</span><span class="yiyi-st" id="yiyi-61"><em>事件</em>可以是以下之一：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-62"><code class="docutils literal"><span class="pre">"line"</span></code>：将执行一行新代码。</span></li><li><span class="yiyi-st" id="yiyi-63"><code class="docutils literal"><span class="pre">"call"</span></code>：一个函数即将被调用，或者输入另一个代码块。</span></li><li><span class="yiyi-st" id="yiyi-64"><code class="docutils literal"><span class="pre">"return"</span></code>：函数或其他代码块即将返回。</span></li><li><span class="yiyi-st" id="yiyi-65"><code class="docutils literal"><span class="pre">"exception"</span></code>：发生异常。</span></li><li><span class="yiyi-st" id="yiyi-66"><code class="docutils literal"><span class="pre">"c_call"</span></code>：即将调用C函数。</span></li><li><span class="yiyi-st" id="yiyi-67"><code class="docutils literal"><span class="pre">"c_return"</span></code>：返回C函数。</span></li><li><span class="yiyi-st" id="yiyi-68"><code class="docutils literal"><span class="pre">"c_exception"</span></code>：C函数引发了异常。</span></li></ul><p><span class="yiyi-st" id="yiyi-69">对于Python事件，调用专门的函数（见下文）。</span><span class="yiyi-st" id="yiyi-70">对于C事件，不采取任何操作。</span></p><p><span class="yiyi-st" id="yiyi-71"><em>arg</em>参数取决于上一个事件。</span></p><p><span class="yiyi-st" id="yiyi-72">有关跟踪功能的更多信息，请参阅<a class="reference internal" href="sys.html#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal"><span class="pre">sys.settrace()</span></code></a>的文档。</span><span class="yiyi-st" id="yiyi-73">有关代码和框架对象的详细信息，请参阅<a class="reference internal" href="../reference/datamodel.html#types"><span>The standard type hierarchy</span></a>。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.dispatch_line"><span class="yiyi-st" id="yiyi-74"> <code class="descname">dispatch_line</code><span class="sig-paren">(</span><em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-75">如果调试器应在当前行上停止，请调用<a class="reference internal" href="#bdb.Bdb.user_line" title="bdb.Bdb.user_line"><code class="xref py py-meth docutils literal"><span class="pre">user_line()</span></code></a>方法（应在子类中重写）。</span><span class="yiyi-st" id="yiyi-76">如果设置了<code class="xref py py-attr docutils literal"><span class="pre">Bdb.quitting</span></code>标志（可以从<a class="reference internal" href="#bdb.Bdb.user_line" title="bdb.Bdb.user_line"><code class="xref py py-meth docutils literal"><span class="pre">user_line()</span></code></a>设置），则引发<a class="reference internal" href="#bdb.BdbQuit" title="bdb.BdbQuit"><code class="xref py py-exc docutils literal"><span class="pre">BdbQuit</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-77">返回对<a class="reference internal" href="#bdb.Bdb.trace_dispatch" title="bdb.Bdb.trace_dispatch"><code class="xref py py-meth docutils literal"><span class="pre">trace_dispatch()</span></code></a>方法的引用，以便在该范围中进行进一步跟踪。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.dispatch_call"><span class="yiyi-st" id="yiyi-78"> <code class="descname">dispatch_call</code><span class="sig-paren">(</span><em>frame</em>, <em>arg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-79">如果调试器应该在此函数调用上停止，请调用<a class="reference internal" href="#bdb.Bdb.user_call" title="bdb.Bdb.user_call"><code class="xref py py-meth docutils literal"><span class="pre">user_call()</span></code></a>方法（应在子类中重写）。</span><span class="yiyi-st" id="yiyi-80">如果设置了<code class="xref py py-attr docutils literal"><span class="pre">Bdb.quitting</span></code>标志（可以从<a class="reference internal" href="#bdb.Bdb.user_call" title="bdb.Bdb.user_call"><code class="xref py py-meth docutils literal"><span class="pre">user_call()</span></code></a>设置），则引发<a class="reference internal" href="#bdb.BdbQuit" title="bdb.BdbQuit"><code class="xref py py-exc docutils literal"><span class="pre">BdbQuit</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-81">返回对<a class="reference internal" href="#bdb.Bdb.trace_dispatch" title="bdb.Bdb.trace_dispatch"><code class="xref py py-meth docutils literal"><span class="pre">trace_dispatch()</span></code></a>方法的引用，以便在该范围中进行进一步跟踪。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.dispatch_return"><span class="yiyi-st" id="yiyi-82"> <code class="descname">dispatch_return</code><span class="sig-paren">(</span><em>frame</em>, <em>arg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">如果调试器应该在此函数return上停止，调用<a class="reference internal" href="#bdb.Bdb.user_return" title="bdb.Bdb.user_return"><code class="xref py py-meth docutils literal"><span class="pre">user_return()</span></code></a>方法（应在子类中重写）。</span><span class="yiyi-st" id="yiyi-84">如果设置了<code class="xref py py-attr docutils literal"><span class="pre">Bdb.quitting</span></code>标志（可以从<a class="reference internal" href="#bdb.Bdb.user_return" title="bdb.Bdb.user_return"><code class="xref py py-meth docutils literal"><span class="pre">user_return()</span></code></a>设置），则引发<a class="reference internal" href="#bdb.BdbQuit" title="bdb.BdbQuit"><code class="xref py py-exc docutils literal"><span class="pre">BdbQuit</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-85">返回对<a class="reference internal" href="#bdb.Bdb.trace_dispatch" title="bdb.Bdb.trace_dispatch"><code class="xref py py-meth docutils literal"><span class="pre">trace_dispatch()</span></code></a>方法的引用，以便在该范围中进行进一步跟踪。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.dispatch_exception"><span class="yiyi-st" id="yiyi-86"> <code class="descname">dispatch_exception</code><span class="sig-paren">(</span><em>frame</em>, <em>arg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-87">如果调试器应该在此异常停止，调用<a class="reference internal" href="#bdb.Bdb.user_exception" title="bdb.Bdb.user_exception"><code class="xref py py-meth docutils literal"><span class="pre">user_exception()</span></code></a>方法（应在子类中重写）。</span><span class="yiyi-st" id="yiyi-88">如果设置了<code class="xref py py-attr docutils literal"><span class="pre">Bdb.quitting</span></code>标志（可以从<a class="reference internal" href="#bdb.Bdb.user_exception" title="bdb.Bdb.user_exception"><code class="xref py py-meth docutils literal"><span class="pre">user_exception()</span></code></a>设置），则引发<a class="reference internal" href="#bdb.BdbQuit" title="bdb.BdbQuit"><code class="xref py py-exc docutils literal"><span class="pre">BdbQuit</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-89">返回对<a class="reference internal" href="#bdb.Bdb.trace_dispatch" title="bdb.Bdb.trace_dispatch"><code class="xref py py-meth docutils literal"><span class="pre">trace_dispatch()</span></code></a>方法的引用，以在该范围中进行进一步跟踪。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-90">通常派生类不会覆盖以下方法，但如果他们想重新定义停止和断点的定义，它们可能会被覆盖。</span></p><dl class="method"><dt id="bdb.Bdb.stop_here"><span class="yiyi-st" id="yiyi-91"> <code class="descname">stop_here</code><span class="sig-paren">(</span><em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-92">此方法检查<em>帧</em>是否在调用堆栈中<code class="xref py py-attr docutils literal"><span class="pre">botframe</span></code>之下。</span><span class="yiyi-st" id="yiyi-93"><code class="xref py py-attr docutils literal"><span class="pre">botframe</span></code>是调试开始的帧。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.break_here"><span class="yiyi-st" id="yiyi-94"> <code class="descname">break_here</code><span class="sig-paren">(</span><em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-95">此方法检查在文件名和行中属于<em>frame</em>的断点，或者至少在当前函数中。</span><span class="yiyi-st" id="yiyi-96">如果断点是临时断点，则此方法将删除它。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.break_anywhere"><span class="yiyi-st" id="yiyi-97"> <code class="descname">break_anywhere</code><span class="sig-paren">(</span><em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-98">此方法检查当前帧的文件名中是否有断点。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-99">派生类应该覆盖这些方法以获得对调试器操作的控制。</span></p><dl class="method"><dt id="bdb.Bdb.user_call"><span class="yiyi-st" id="yiyi-100"> <code class="descname">user_call</code><span class="sig-paren">(</span><em>frame</em>, <em>argument_list</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-101">当有可能在被调用函数中的任何位置可能需要中断的可能性时，从<a class="reference internal" href="#bdb.Bdb.dispatch_call" title="bdb.Bdb.dispatch_call"><code class="xref py py-meth docutils literal"><span class="pre">dispatch_call()</span></code></a>调用此方法。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.user_line"><span class="yiyi-st" id="yiyi-102"> <code class="descname">user_line</code><span class="sig-paren">(</span><em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-103">当<a class="reference internal" href="#bdb.Bdb.stop_here" title="bdb.Bdb.stop_here"><code class="xref py py-meth docutils literal"><span class="pre">stop_here()</span></code></a>或<a class="reference internal" href="#bdb.Bdb.break_here" title="bdb.Bdb.break_here"><code class="xref py py-meth docutils literal"><span class="pre">break_here()</span></code></a>产生<code class="docutils literal"><span class="pre">True</span></code>时，从<a class="reference internal" href="#bdb.Bdb.dispatch_line" title="bdb.Bdb.dispatch_line"><code class="xref py py-meth docutils literal"><span class="pre">dispatch_line()</span></code></a>调用此方法。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.user_return"><span class="yiyi-st" id="yiyi-104"> <code class="descname">user_return</code><span class="sig-paren">(</span><em>frame</em>, <em>return_value</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-105">当<a class="reference internal" href="#bdb.Bdb.stop_here" title="bdb.Bdb.stop_here"><code class="xref py py-meth docutils literal"><span class="pre">stop_here()</span></code></a>产生<code class="docutils literal"><span class="pre">True</span></code>时，从<a class="reference internal" href="#bdb.Bdb.dispatch_return" title="bdb.Bdb.dispatch_return"><code class="xref py py-meth docutils literal"><span class="pre">dispatch_return()</span></code></a>调用此方法。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.user_exception"><span class="yiyi-st" id="yiyi-106"> <code class="descname">user_exception</code><span class="sig-paren">(</span><em>frame</em>, <em>exc_info</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">当<a class="reference internal" href="#bdb.Bdb.stop_here" title="bdb.Bdb.stop_here"><code class="xref py py-meth docutils literal"><span class="pre">stop_here()</span></code></a>产生<code class="docutils literal"><span class="pre">True</span></code>时，从<a class="reference internal" href="#bdb.Bdb.dispatch_exception" title="bdb.Bdb.dispatch_exception"><code class="xref py py-meth docutils literal"><span class="pre">dispatch_exception()</span></code></a>调用此方法。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.do_clear"><span class="yiyi-st" id="yiyi-108"> <code class="descname">do_clear</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-109">处理断点如果是临时断点必须删除。</span></p><p><span class="yiyi-st" id="yiyi-110">此方法必须由派生类实现。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-111">派生类和客户端可以调用以下方法来影响步进状态。</span></p><dl class="method"><dt id="bdb.Bdb.set_step"><span class="yiyi-st" id="yiyi-112"> <code class="descname">set_step</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-113">在一行代码后停止。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.set_next"><span class="yiyi-st" id="yiyi-114"> <code class="descname">set_next</code><span class="sig-paren">(</span><em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-115">停止在给定帧中或下面的下一行。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.set_return"><span class="yiyi-st" id="yiyi-116"> <code class="descname">set_return</code><span class="sig-paren">(</span><em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-117">从给定框架返回时停止。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.set_until"><span class="yiyi-st" id="yiyi-118"> <code class="descname">set_until</code><span class="sig-paren">(</span><em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-119">当线路不大于当前线路的线路或从当前帧返回时停止。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.set_trace"><span class="yiyi-st" id="yiyi-120"> <code class="descname">set_trace</code><span class="sig-paren">(</span><span class="optional">[</span><em>frame</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-121">从<em>帧</em>开始调试。</span><span class="yiyi-st" id="yiyi-122">如果未指定<em>帧</em>，则从调用者的帧开始调试。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.set_continue"><span class="yiyi-st" id="yiyi-123"> <code class="descname">set_continue</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-124">仅在断点处或完成后停止。</span><span class="yiyi-st" id="yiyi-125">如果没有断点，请将系统跟踪功能设置为无。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.set_quit"><span class="yiyi-st" id="yiyi-126"> <code class="descname">set_quit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-127">将<code class="xref py py-attr docutils literal"><span class="pre">quitting</span></code>属性设置为<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-128">在下一次调用<code class="xref py py-meth docutils literal"><span class="pre">dispatch_*()</span></code>方法之一时引入<a class="reference internal" href="#bdb.BdbQuit" title="bdb.BdbQuit"><code class="xref py py-exc docutils literal"><span class="pre">BdbQuit</span></code></a>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-129">派生类和客户端可以调用以下方法来操作断点。</span><span class="yiyi-st" id="yiyi-130">如果出现错误，这些方法将返回包含错误消息的字符串，如果一切正常，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><dl class="method"><dt id="bdb.Bdb.set_break"><span class="yiyi-st" id="yiyi-131"> <code class="descname">set_break</code><span class="sig-paren">(</span><em>filename</em>, <em>lineno</em>, <em>temporary=0</em>, <em>cond</em>, <em>funcname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-132">设置新的断点。</span><span class="yiyi-st" id="yiyi-133">如果对于作为参数传递的<em>filename</em>，<em>lineno</em>行不存在，则返回错误消息。</span><span class="yiyi-st" id="yiyi-134"><em>filename</em>应为正则形式，如<a class="reference internal" href="#bdb.Bdb.canonic" title="bdb.Bdb.canonic"><code class="xref py py-meth docutils literal"><span class="pre">canonic()</span></code></a>方法中所述。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.clear_break"><span class="yiyi-st" id="yiyi-135"> <code class="descname">clear_break</code><span class="sig-paren">(</span><em>filename</em>, <em>lineno</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-136">删除<em>文件名</em>和<em>lineno</em>中的断点。</span><span class="yiyi-st" id="yiyi-137">如果没有设置，则返回错误消息。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.clear_bpbynumber"><span class="yiyi-st" id="yiyi-138"> <code class="descname">clear_bpbynumber</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-139">删除<code class="xref py py-attr docutils literal"><span class="pre">Breakpoint.bpbynumber</span></code>中索引为<em>arg</em>的断点。</span><span class="yiyi-st" id="yiyi-140">如果<em>arg</em>不是数字或超出范围，则返回错误消息。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.clear_all_file_breaks"><span class="yiyi-st" id="yiyi-141"> <code class="descname">clear_all_file_breaks</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-142">删除<em>文件名</em>中的所有断点。</span><span class="yiyi-st" id="yiyi-143">如果没有设置，则返回错误消息。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.clear_all_breaks"><span class="yiyi-st" id="yiyi-144"> <code class="descname">clear_all_breaks</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-145">删除所有现有断点。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.get_bpbynumber"><span class="yiyi-st" id="yiyi-146"> <code class="descname">get_bpbynumber</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-147">返回由给定数字指定的断点。</span><span class="yiyi-st" id="yiyi-148">如果<em>arg</em>是字符串，它将被转换为数字。</span><span class="yiyi-st" id="yiyi-149">如果<em>arg</em>是非数字字符串，如果给定的断点从未存在或已被删除，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-150"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="bdb.Bdb.get_break"><span class="yiyi-st" id="yiyi-151"> <code class="descname">get_break</code><span class="sig-paren">(</span><em>filename</em>, <em>lineno</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-152">检查<em>文件名</em>的<em>lineno</em>是否有断点。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.get_breaks"><span class="yiyi-st" id="yiyi-153"> <code class="descname">get_breaks</code><span class="sig-paren">(</span><em>filename</em>, <em>lineno</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-154">返回<em>filename</em>中<em>lineno</em>的所有断点，如果没有设置则返回空列表。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.get_file_breaks"><span class="yiyi-st" id="yiyi-155"> <code class="descname">get_file_breaks</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156">返回<em>filename</em>中的所有断点，如果没有设置，则返回一个空列表。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.get_all_breaks"><span class="yiyi-st" id="yiyi-157"> <code class="descname">get_all_breaks</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-158">返回设置的所有断点。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-159">派生类和客户端可以调用以下方法来获取表示堆栈跟踪的数据结构。</span></p><dl class="method"><dt id="bdb.Bdb.get_stack"><span class="yiyi-st" id="yiyi-160"> <code class="descname">get_stack</code><span class="sig-paren">(</span><em>f</em>, <em>t</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-161">获取帧和所有较高（调用）和较低帧的记录列表，以及较高部分的大小。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.format_stack_entry"><span class="yiyi-st" id="yiyi-162"> <code class="descname">format_stack_entry</code><span class="sig-paren">(</span><em>frame_lineno</em>, <em>lprefix=': '</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-163">返回包含由<code class="docutils literal"><span class="pre">（frame，</span> <span class="pre">lineno）</span></code>元组标识的堆栈条目的信息的字符串：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-164">包含框架的文件名的规范形式。</span></li><li><span class="yiyi-st" id="yiyi-165">函数名称或<code class="docutils literal"><span class="pre">"&lt;lambda&gt;"</span></code>。</span></li><li><span class="yiyi-st" id="yiyi-166">输入参数。</span></li><li><span class="yiyi-st" id="yiyi-167">返回值。</span></li><li><span class="yiyi-st" id="yiyi-168">代码行（如果存在）。</span></li></ul></dd></dl><p><span class="yiyi-st" id="yiyi-169">客户端可以调用以下两种方法来使用调试器调试以字符串形式给出的<a class="reference internal" href="../glossary.html#term-statement"><span class="xref std std-term">statement</span></a>。</span></p><dl class="method"><dt id="bdb.Bdb.run"><span class="yiyi-st" id="yiyi-170"> <code class="descname">run</code><span class="sig-paren">(</span><em>cmd</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-171">调试通过<a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>函数执行的语句。</span><span class="yiyi-st" id="yiyi-172"><em>全局</em>默认为<code class="xref py py-attr docutils literal"><span class="pre">__main__.__dict__</span></code>，<em>本地</em>默认为<em>全局</em>。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.runeval"><span class="yiyi-st" id="yiyi-173"> <code class="descname">runeval</code><span class="sig-paren">(</span><em>expr</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-174">调试通过<a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>函数执行的表达式。</span><span class="yiyi-st" id="yiyi-175"><em>全局</em>和<em>本地</em>的含义与<a class="reference internal" href="#bdb.Bdb.run" title="bdb.Bdb.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a>中的含义相同。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.runctx"><span class="yiyi-st" id="yiyi-176"> <code class="descname">runctx</code><span class="sig-paren">(</span><em>cmd</em>, <em>globals</em>, <em>locals</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-177">用于向后兼容。</span><span class="yiyi-st" id="yiyi-178">调用<a class="reference internal" href="#bdb.Bdb.run" title="bdb.Bdb.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a>方法。</span></p></dd></dl><dl class="method"><dt id="bdb.Bdb.runcall"><span class="yiyi-st" id="yiyi-179"> <code class="descname">runcall</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-180">调试单个函数调用，并返回其结果。</span></p></dd></dl></dd></dl><p><span class="yiyi-st" id="yiyi-181">最后，该模块定义了以下功能：</span></p><dl class="function"><dt id="bdb.checkfuncname"><span class="yiyi-st" id="yiyi-182"> <code class="descclassname">bdb.</code><code class="descname">checkfuncname</code><span class="sig-paren">(</span><em>b</em>, <em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-183">检查我们是否应该在这里断开，这取决于断点<em>b</em>设置的方式。</span></p><p><span class="yiyi-st" id="yiyi-184">如果它通过行号设置，它检查<code class="docutils literal"><span class="pre">b.line</span></code>是否与框架中也作为参数传递的相同。</span><span class="yiyi-st" id="yiyi-185">如果断点是通过函数名设置的，我们必须检查我们是否在正确的框架（正确的函数），如果我们在其第一个可执行行。</span></p></dd></dl><dl class="function"><dt id="bdb.effective"><span class="yiyi-st" id="yiyi-186"> <code class="descclassname">bdb.</code><code class="descname">effective</code><span class="sig-paren">(</span><em>file</em>, <em>line</em>, <em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-187">确定此行代码是否存在有效（活动）断点。</span><span class="yiyi-st" id="yiyi-188">返回一个断点的元组和一个布尔值，指示是否可以删除临时断点。</span><span class="yiyi-st" id="yiyi-189">如果没有匹配的断点，返回<code class="docutils literal"><span class="pre">（无，</span> <span class="pre">无）</span> </code></span></p></dd></dl><dl class="function"><dt id="bdb.set_trace"><span class="yiyi-st" id="yiyi-190"> <code class="descclassname">bdb.</code><code class="descname">set_trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-191">使用调用者框架中的<a class="reference internal" href="#bdb.Bdb" title="bdb.Bdb"><code class="xref py py-class docutils literal"><span class="pre">Bdb</span></code></a>实例开始调试。</span></p></dd></dl></div></div>