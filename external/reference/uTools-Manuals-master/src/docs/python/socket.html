<div class="body" role="main"><div class="section" id="module-socket"><h1><span class="yiyi-st" id="yiyi-10">18.1. <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> — 底层网络接口</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>S源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/socket.py">Lib/socket.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">这个模块提供访问BSD <em>套接字(socket)</em> 的接口。</span><span class="yiyi-st" id="yiyi-13">它适用于所有现代Unix系统，Windows，MacOs及其他可能的平台。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-14">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-15">由于某些调用使用了操作系统的socket APIs，一些特性是依赖于特定平台的。</span></p></div><p id="index-0"><span class="yiyi-st" id="yiyi-16">这个Python接口直接将套接字的Unix系统调用和库接口翻译成Python的面向对象风格：<a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> 函数返回一个 <em class="dfn">socket 对象</em>，这个对象的方法实现了不同的套接字系统调用。</span><span class="yiyi-st" id="yiyi-17">其中，一些参数类型比对应的C接口更高级：如对Python文件对象的 <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> 和 <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> 操作，接收操作中缓冲区分配是自动的， 发送操作中缓冲区长度是隐含的。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-18">另请参阅</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-19"><a class="reference internal" href="socketserver.html#module-socketserver" title="socketserver: A framework for network servers."><code class="xref py py-mod docutils literal"><span class="pre">socketserver</span></code></a>模块</span></dt><dd><span class="yiyi-st" id="yiyi-20">简化写作网络服务器的类。</span></dd><dt><span class="yiyi-st" id="yiyi-21"><a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a>模块</span></dt><dd><span class="yiyi-st" id="yiyi-22">套接字对象的 TLS/SSL 封装。</span></dd></dl></div><div class="section" id="socket-families"><h2><span class="yiyi-st" id="yiyi-23">18.1.1. </span><span class="yiyi-st" id="yiyi-24">Socket 协议族</span></h2><p><span class="yiyi-st" id="yiyi-25">该模块支持何种socket协议族取决于系统与编译选项。</span></p><p><span class="yiyi-st" id="yiyi-26">当一个socket对象被创建时，该socket对象所需的地址格式会根据特定的地址族被自动选择。</span><span class="yiyi-st" id="yiyi-27">Socket 地址被表示为：</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-28">一个绑定到文件系统节点的 <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a> 套接字的地址被表示为一个字符串，这个字符串使用文件系统编码与 <code class="docutils literal"><span class="pre">'surrogateescape'</span></code> 错误处理器 (see <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>).</span><span class="yiyi-st" id="yiyi-29">一个Linux抽象命名空间中的地址被作为一个被初始化为空字节的<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 返回；注意命名空间中的这些地址可以与常规文件系统套接字通讯，因此打算运行在Linux上的程序需要能同时处理两种类型的地址。</span><span class="yiyi-st" id="yiyi-30">当作为个一参数传递时，一个字符串或类字节对象可以被用做任意类型的地址。</span></p><span class="yiyi-st" id="yiyi-31"><blockquote><div><div class="versionchanged"><p><span class="versionmodified">3.3 版本中的更改︰</span> <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a> 套接字路径先前均假定使用 utf-8 编码。</p></div><div class="versionchanged"><p><span class="versionmodified">3.5 版本中的更改︰</span> 现在接受可写入的 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</p></div></div></blockquote></span></li><li><p class="first"><span class="yiyi-st" id="yiyi-32">一对参数 <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code>用于 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> 地址族, 其中<em>host</em>是一个字符串，表示在internet中像  <code class="docutils literal"><span class="pre">'daring.cwi.nl'</span></code>这样的域名 或 像<code class="docutils literal"><span class="pre">'100.50.200.5'</span></code>这样的IPv4地址, <em>port</em>（端口）参数是一个整数.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-33">对于 <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal"><span class="pre">AF_INET6</span></code></a> 地址族, 一个地址被表示为一个四维元组 <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port,</span> <span class="pre">flowinfo,</span> <span class="pre">scopeid)</span></code> ， 其中， <em>flowinfo</em> 和 <em>scopeid</em> 分别代表C中<code class="xref py py-const docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr_in6</span></code>结构体中的成员 <code class="docutils literal"><span class="pre">sin6_flowinfo</span></code> 与 <code class="docutils literal"><span class="pre">sin6_scope_id</span></code> 。 为了向后兼容，在 <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> 模块的方法中， <em>flowinfo</em> 与 <em>scopeid</em> 参数可以被省略。</span><span class="yiyi-st" id="yiyi-34">但是请注意，忽略 <em>scopeid</em> 参数会导致操作IPv6地址时出现问题。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-35"><code class="xref py py-const docutils literal"><span class="pre">AF_NETLINK</span></code> 套接字被表示为一个二维元组 <code class="docutils literal"><span class="pre">(pid,</span> <span class="pre">groups)</span></code>.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-36">只有 Linux 支持的 TIPC 需要使用 <code class="xref py py-const docutils literal"><span class="pre">AF_TIPC</span></code> 地址族。</span><span class="yiyi-st" id="yiyi-37">TIPC 是一个开放的、基于非 IP 的、为 在集群计算机环境中使用而设计的网络协议。</span><span class="yiyi-st" id="yiyi-38">地址由表示成一个元组，元祖字段取决于地址类型。</span><span class="yiyi-st" id="yiyi-39">一般的元组形式是 <code class="docutils literal"><span class="pre">(addr_type，</span> <span class="pre">v1、</span> <span class="pre">v2、</span> <span class="pre">v3</span> <span class="pre">[，</span> <span class="pre">scope])</span></code>，其中︰</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-40"><em>addr_type</em> 是 <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_NAMESEQ</span></code>，<code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_NAME</span></code> 或 <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_ID</span></code>中的一个。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-41"><em>scope</em> 是 <code class="xref py py-const docutils literal"><span class="pre">TIPC_ZONE_SCOPE</span></code>、 <code class="xref py py-const docutils literal"><span class="pre">TIPC_CLUSTER_SCOPE</span></code> 和 <code class="xref py py-const docutils literal"><span class="pre">TIPC_NODE_SCOPE</span></code> 中的一个。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-42">如果 <em>addr_type</em> 是 <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_NAME</span></code>，那么 <em>v1</em> 是服务器类型、 <em>v2</em> 是端口标识符，<em>v3</em> 应为 0。</span></p><p><span class="yiyi-st" id="yiyi-43">如果 <em>addr_type</em> 是 <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_NAMESEQ</span></code>，那么 <em>v1</em> 是服务器类型、 <em>v2</em> 是下级端口号， <em>v3</em> 是上级端口号。</span></p><p><span class="yiyi-st" id="yiyi-44">如果 <em>addr_type</em> 是 <code class="xref py py-const docutils literal"><span class="pre">TIPC_ADDR_ID</span></code>，那么<em>v1</em> 是节点，<em>v2</em> 是引用，<em>v3</em> 应该设置为 0。</span></p></li></ul></li><li><p class="first"><span class="yiyi-st" id="yiyi-45">一个元组 <code class="docutils literal"><span class="pre">(interface，</span> <span class="pre">)</span></code> 用于 <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal"><span class="pre">AF_CAN</span></code></a> 地址族， <em>interface</em> 是一个表示成像 <code class="docutils literal"><span class="pre">'can0'</span></code> 的网络接口名称的字符串。</span><span class="yiyi-st" id="yiyi-46">网络接口名称 <code class="docutils literal"><span class="pre">‘’</span></code> 可以用来接收这个地址族的所有网络接口的数据包。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-47">一个字符串或一个元组 <code class="docutils literal"><span class="pre">(id，</span> <span class="pre">unit)</span></code> 用于 <code class="xref py py-const docutils literal"><span class="pre">PF_SYSTEM</span></code> 族的 <code class="xref py py-const docutils literal"><span class="pre">SYSPROTO_CONTROL</span></code> 协议。</span><span class="yiyi-st" id="yiyi-48">内核管理的字符串名称是动态分配的ID。</span><span class="yiyi-st" id="yiyi-49">如果内核管理的ID和unit号已知或者使用已注册ID，那么元祖可以被使用。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-50"><span class="versionmodified">3.3 版本中新加入。</span></span></p></div></li><li><p class="first"><span class="yiyi-st" id="yiyi-51"><code class="xref py py-const docutils literal"><span class="pre">AF_BLUETOOTH</span></code> 支持下列协议和地址格式︰</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-52"><code class="xref py py-const docutils literal"><span class="pre">BTPROTO_L2CAP</span></code> accepts <code class="docutils literal"><span class="pre">(bdaddr,</span> <span class="pre">psm)</span></code> where <code class="docutils literal"><span class="pre">bdaddr</span></code> is the Bluetooth address as a string and <code class="docutils literal"><span class="pre">psm</span></code> is an integer.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-53"><code class="xref py py-const docutils literal"><span class="pre">BTPROTO_RFCOMM</span></code> accepts <code class="docutils literal"><span class="pre">(bdaddr,</span> <span class="pre">channel)</span></code> where <code class="docutils literal"><span class="pre">bdaddr</span></code> is the Bluetooth address as a string and <code class="docutils literal"><span class="pre">channel</span></code> is an integer.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-54"><code class="xref py py-const docutils literal"><span class="pre">BTPROTO_HCI</span></code> accepts <code class="docutils literal"><span class="pre">(device_id,)</span></code> where <code class="docutils literal"><span class="pre">device_id</span></code> is either an integer or a string with the Bluetooth address of the interface. </span><span class="yiyi-st" id="yiyi-55">(This depends on your OS; NetBSD and DragonFlyBSD expect a Bluetooth address while everything else expects an integer.)</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-56"><span class="versionmodified">Changed in version 3.2: </span>NetBSD and DragonFlyBSD support added.</span></p></div></li><li><p class="first"><span class="yiyi-st" id="yiyi-57"><code class="xref py py-const docutils literal"><span class="pre">BTPROTO_SCO</span></code> accepts <code class="docutils literal"><span class="pre">bdaddr</span></code> where <code class="docutils literal"><span class="pre">bdaddr</span></code> is a <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> object containing the Bluetooth address in a string format. </span><span class="yiyi-st" id="yiyi-58">(ex. </span><span class="yiyi-st" id="yiyi-59"><code class="docutils literal"><span class="pre">b'12:23:34:45:56:67'</span></code>) This protocol is not supported under FreeBSD.</span></p></li></ul></li><li><p class="first"><span class="yiyi-st" id="yiyi-60">Certain other address families (<code class="xref py py-const docutils literal"><span class="pre">AF_PACKET</span></code>, <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal"><span class="pre">AF_CAN</span></code></a>) support specific representations.</span></p></li></ul><p><span class="yiyi-st" id="yiyi-61">在表示IPv4地址时，可以采用两种特殊的字符串形式来表示特定的主机地址：用空字符串表示<code class="xref py py-const docutils literal"><span class="pre">INADDR_ANY</span></code>；用字符串<code class="docutils literal"><span class="pre">'&lt;broadcast&gt;'</span></code>来表示<code class="xref py py-const docutils literal"><span class="pre">INADDR_BROADCAST</span></code>。</span><span class="yiyi-st" id="yiyi-62">This behavior is not compatible with IPv6, therefore, you may want to avoid these if you intend to support IPv6 with your Python programs.</span></p><p><span class="yiyi-st" id="yiyi-63">If you use a hostname in the <em>host</em> portion of IPv4/v6 socket address, the program may show a nondeterministic behavior, as Python uses the first address returned from the DNS resolution. </span><span class="yiyi-st" id="yiyi-64">The socket address will be resolved differently into an actual IPv4/v6 address, depending on the results from DNS resolution and/or the host configuration. </span><span class="yiyi-st" id="yiyi-65">For deterministic behavior use a numeric address in <em>host</em> portion.</span></p><p><span class="yiyi-st" id="yiyi-66">All errors raise exceptions. </span><span class="yiyi-st" id="yiyi-67">The normal exceptions for invalid argument types and out-of-memory conditions can be raised; starting from Python 3.3, errors related to socket or address semantics raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> or one of its subclasses (they used to raise <a class="reference internal" href="#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a>).</span></p><p><span class="yiyi-st" id="yiyi-68">通过<a class="reference internal" href="#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">setblocking()</span></code></a>支持非阻塞模式。</span><span class="yiyi-st" id="yiyi-69">A generalization of this based on timeouts is supported through <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a>.</span></p></div><div class="section" id="module-contents"><h2><span class="yiyi-st" id="yiyi-70">18.1.2. </span><span class="yiyi-st" id="yiyi-71">模块内容</span></h2><p><span class="yiyi-st" id="yiyi-72">模块<a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a>导出以下元素。</span></p><div class="section" id="exceptions"><h3><span class="yiyi-st" id="yiyi-73">18.1.2.1. </span><span class="yiyi-st" id="yiyi-74">异常</span></h3><dl class="exception"><dt id="socket.error"><span class="yiyi-st" id="yiyi-75"> <em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">error</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-76">已弃用的<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>别名。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-77"><span class="versionmodified">Changed in version 3.3: </span>Following <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3151"><strong>PEP 3151</strong></a>, this class was made an alias of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>.</span></p></div></dd></dl><dl class="exception"><dt id="socket.herror"><span class="yiyi-st" id="yiyi-78"> <em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">herror</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-79">A subclass of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>, this exception is raised for address-related errors, i.e. </span><span class="yiyi-st" id="yiyi-80">for functions that use <em>h_errno</em> in the POSIX C API, including <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal"><span class="pre">gethostbyname_ex()</span></code></a> and <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal"><span class="pre">gethostbyaddr()</span></code></a>. </span><span class="yiyi-st" id="yiyi-81">The accompanying value is a pair <code class="docutils literal"><span class="pre">(h_errno,</span> <span class="pre">string)</span></code> representing an error returned by a library call. </span><span class="yiyi-st" id="yiyi-82"><em>h_errno</em> is a numeric value, while <em>string</em> represents the description of <em>h_errno</em>, as returned by the <code class="xref c c-func docutils literal"><span class="pre">hstrerror()</span></code> C function.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-83"><span class="versionmodified">在版本3.3中已更改：</span>此类已成为<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>的子类。</span></p></div></dd></dl><dl class="exception"><dt id="socket.gaierror"><span class="yiyi-st" id="yiyi-84"> <em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">gaierror</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-85">A subclass of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>, this exception is raised for address-related errors by <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal"><span class="pre">getaddrinfo()</span></code></a> and <a class="reference internal" href="#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-func docutils literal"><span class="pre">getnameinfo()</span></code></a>. </span><span class="yiyi-st" id="yiyi-86">The accompanying value is a pair <code class="docutils literal"><span class="pre">(error,</span> <span class="pre">string)</span></code> representing an error returned by a library call. </span><span class="yiyi-st" id="yiyi-87"><em>string</em> represents the description of <em>error</em>, as returned by the <code class="xref c c-func docutils literal"><span class="pre">gai_strerror()</span></code> C function. </span><span class="yiyi-st" id="yiyi-88">The numeric <em>error</em> value will match one of the <code class="xref py py-const docutils literal"><span class="pre">EAI_*</span></code> constants defined in this module.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-89"><span class="versionmodified">在版本3.3中已更改：</span>此类已成为<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>的子类。</span></p></div></dd></dl><dl class="exception"><dt id="socket.timeout"><span class="yiyi-st" id="yiyi-90"> <em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">timeout</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-91">A subclass of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>, this exception is raised when a timeout occurs on a socket which has had timeouts enabled via a prior call to <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a> (or implicitly through <a class="reference internal" href="#socket.setdefaulttimeout" title="socket.setdefaulttimeout"><code class="xref py py-func docutils literal"><span class="pre">setdefaulttimeout()</span></code></a>). </span><span class="yiyi-st" id="yiyi-92">The accompanying value is a string whose value is currently always “timed out”.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-93"><span class="versionmodified">在版本3.3中已更改：</span>此类已成为<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>的子类。</span></p></div></dd></dl></div><div class="section" id="constants"><h3><span class="yiyi-st" id="yiyi-94">18.1.2.2. </span><span class="yiyi-st" id="yiyi-95">常量</span></h3><span class="yiyi-st" id="yiyi-183"> <blockquote><div><p>AF_* 和 SOCK_* 常量现在是 <code class="xref py py-class docutils literal"><span class="pre">AddressFamily</span></code> 和 <code class="xref py py-class docutils literal"><span class="pre">SocketKind</span></code> <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal"><span class="pre">IntEnum</span></code></a> collections。</p> <div class="versionadded"><p><span class="versionmodified">版本 3.4 中新增。</span></p></div></div></blockquote></span><dl class="data"><dt id="socket.AF_UNIX"><span class="yiyi-st" id="yiyi-96"> <code class="descclassname">socket.</code><code class="descname">AF_UNIX</code></span></dt><dt id="socket.AF_INET"><span class="yiyi-st" id="yiyi-97"> <code class="descclassname">socket.</code><code class="descname">AF_INET</code></span></dt><dt id="socket.AF_INET6"><span class="yiyi-st" id="yiyi-98"> <code class="descclassname">socket.</code><code class="descname">AF_INET6</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-99">这些常量表示地址（和协议）族，用于 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> 的第一个参数。</span><span class="yiyi-st" id="yiyi-100">如果未定义 <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a> 常量，则不支持此协议。</span><span class="yiyi-st" id="yiyi-101">根据系统的不同，可能会有更多常量。</span></p></dd></dl><dl class="data"><dt id="socket.SOCK_STREAM"><span class="yiyi-st" id="yiyi-102"> <code class="descclassname">socket.</code><code class="descname">SOCK_STREAM</code></span></dt><dt id="socket.SOCK_DGRAM"><span class="yiyi-st" id="yiyi-103"> <code class="descclassname">socket.</code><code class="descname">SOCK_DGRAM</code></span></dt><dt id="socket.SOCK_RAW"><span class="yiyi-st" id="yiyi-104"> <code class="descclassname">socket.</code><code class="descname">SOCK_RAW</code></span></dt><dt id="socket.SOCK_RDM"><span class="yiyi-st" id="yiyi-105"> <code class="descclassname">socket.</code><code class="descname">SOCK_RDM</code></span></dt><dt id="socket.SOCK_SEQPACKET"><span class="yiyi-st" id="yiyi-106"> <code class="descclassname">socket.</code><code class="descname">SOCK_SEQPACKET</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">这些常量表示套接字类型，用于 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> 的第二个参数。</span><span class="yiyi-st" id="yiyi-108">根据系统的不同，可能会有更多常量。</span><span class="yiyi-st" id="yiyi-109">（似乎只有 <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_STREAM</span></code></a> 和 <a class="reference internal" href="#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_DGRAM</span></code></a> 广泛使用。）</span></p></dd></dl><dl class="data"><dt id="socket.SOCK_CLOEXEC"><span class="yiyi-st" id="yiyi-110"> <code class="descclassname">socket.</code><code class="descname">SOCK_CLOEXEC</code></span></dt><dt id="socket.SOCK_NONBLOCK"><span class="yiyi-st" id="yiyi-111"> <code class="descclassname">socket.</code><code class="descname">SOCK_NONBLOCK</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-112">这两个常量（如果已定义）可以与套接字类型结合使用，并允许你以原子方式设置一些标志（从而避免可能的竞争条件和需要单独调用）。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-113">另请参见</span></p><p class="last"><span class="yiyi-st" id="yiyi-114"><a class="reference external" href="http://udrepper.livejournal.com/20407.html">安全文件描述符处理</a>以获得更全面的解释。</span></p></div><p><span class="yiyi-st" id="yiyi-115">可用于：Linux &gt;= 2.6.27.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-116"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-117"> <code class="descname">SO_*</code></span></dt><dt id="socket.SOMAXCONN"><span class="yiyi-st" id="yiyi-118"> <code class="descclassname">socket.</code><code class="descname">SOMAXCONN</code></span></dt><dt><span class="yiyi-st" id="yiyi-119"> <code class="descname">MSG_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-120"> <code class="descname">SOL_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-121"> <code class="descname">SCM_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-122"> <code class="descname">IPPROTO_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-123"> <code class="descname">IPPORT_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-124"> <code class="descname">INADDR_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-125"> <code class="descname">IP_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-126"> <code class="descname">IPV6_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-127"> <code class="descname">EAI_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-128"> <code class="descname">AI_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-129"> <code class="descname">NI_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-130"> <code class="descname">TCP_*</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-131">Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module. </span><span class="yiyi-st" id="yiyi-132">They are generally used in arguments to the <code class="xref py py-meth docutils literal"><span class="pre">setsockopt()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">getsockopt()</span></code> methods of socket objects. </span><span class="yiyi-st" id="yiyi-133">In most cases, only those symbols that are defined in the Unix header files are defined; for a few symbols, default values are provided.</span></p></dd></dl><dl class="data"><dt id="socket.AF_CAN"><span class="yiyi-st" id="yiyi-134"> <code class="descclassname">socket.</code><code class="descname">AF_CAN</code></span></dt><dt id="socket.PF_CAN"><span class="yiyi-st" id="yiyi-135"> <code class="descclassname">socket.</code><code class="descname">PF_CAN</code></span></dt><dt><span class="yiyi-st" id="yiyi-136"> <code class="descname">SOL_CAN_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-137"> <code class="descname">CAN_*</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-138">Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.</span></p><p><span class="yiyi-st" id="yiyi-139">Availability: Linux &gt;= 2.6.25.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-140"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="data"><dt id="socket.CAN_BCM"><span class="yiyi-st" id="yiyi-141"> <code class="descclassname">socket.</code><code class="descname">CAN_BCM</code></span></dt><dt><span class="yiyi-st" id="yiyi-142"> <code class="descname">CAN_BCM_*</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-143">CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) protocol. </span><span class="yiyi-st" id="yiyi-144">Broadcast manager constants, documented in the Linux documentation, are also defined in the socket module.</span></p><p><span class="yiyi-st" id="yiyi-145">Availability: Linux &gt;= 2.6.25.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-146"><span class="versionmodified">New in version 3.4.</span></span></p></div></dd></dl><dl class="data"><dt id="socket.CAN_RAW_FD_FRAMES"><span class="yiyi-st" id="yiyi-147"> <code class="descclassname">socket.</code><code class="descname">CAN_RAW_FD_FRAMES</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-148">Enables CAN FD support in a CAN_RAW socket. </span><span class="yiyi-st" id="yiyi-149">This is disabled by default. </span><span class="yiyi-st" id="yiyi-150">This allows your application to send both CAN and CAN FD frames; however, you one must accept both CAN and CAN FD frames when reading from the socket.</span></p><p><span class="yiyi-st" id="yiyi-151">This constant is documented in the Linux documentation.</span></p><p><span class="yiyi-st" id="yiyi-152">Availability: Linux &gt;= 3.6.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-153"><span class="versionmodified">New in version 3.5.</span></span></p></div></dd></dl><dl class="data"><dt id="socket.AF_RDS"><span class="yiyi-st" id="yiyi-154"> <code class="descclassname">socket.</code><code class="descname">AF_RDS</code></span></dt><dt id="socket.PF_RDS"><span class="yiyi-st" id="yiyi-155"> <code class="descclassname">socket.</code><code class="descname">PF_RDS</code></span></dt><dt id="socket.SOL_RDS"><span class="yiyi-st" id="yiyi-156"> <code class="descclassname">socket.</code><code class="descname">SOL_RDS</code></span></dt><dt><span class="yiyi-st" id="yiyi-157"> <code class="descname">RDS_*</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-158">Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.</span></p><p><span class="yiyi-st" id="yiyi-159">Availability: Linux &gt;= 2.6.30.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-160"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-161"> <code class="descname">SIO_*</code></span></dt><dt><span class="yiyi-st" id="yiyi-162"> <code class="descname">RCVALL_*</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-163">Constants for Windows’ WSAIoctl(). </span><span class="yiyi-st" id="yiyi-164">The constants are used as arguments to the <a class="reference internal" href="#socket.socket.ioctl" title="socket.socket.ioctl"><code class="xref py py-meth docutils literal"><span class="pre">ioctl()</span></code></a> method of socket objects.</span></p></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-165"> <code class="descname">TIPC_*</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-166">TIPC related constants, matching the ones exported by the C socket API. </span><span class="yiyi-st" id="yiyi-167">See the TIPC documentation for more information.</span></p></dd></dl><dl class="data"><dt id="socket.AF_LINK"><span class="yiyi-st" id="yiyi-168"> <code class="descclassname">socket.</code><code class="descname">AF_LINK</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-169">Availability: BSD, OSX.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-170"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="socket.has_ipv6"><span class="yiyi-st" id="yiyi-171"> <code class="descclassname">socket.</code><code class="descname">has_ipv6</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-172">This constant contains a boolean value which indicates if IPv6 is supported on this platform.</span></p></dd></dl><dl class="data"><dt id="socket.BDADDR_ANY"><span class="yiyi-st" id="yiyi-173"> <code class="descclassname">socket.</code><code class="descname">BDADDR_ANY</code></span></dt><dt id="socket.BDADDR_LOCAL"><span class="yiyi-st" id="yiyi-174"> <code class="descclassname">socket.</code><code class="descname">BDADDR_LOCAL</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-175">These are string constants containing Bluetooth addresses with special meanings. </span><span class="yiyi-st" id="yiyi-176">For example, <a class="reference internal" href="#socket.BDADDR_ANY" title="socket.BDADDR_ANY"><code class="xref py py-const docutils literal"><span class="pre">BDADDR_ANY</span></code></a> can be used to indicate any address when specifying the binding socket with <code class="xref py py-const docutils literal"><span class="pre">BTPROTO_RFCOMM</span></code>.</span></p></dd></dl><dl class="data"><dt id="socket.HCI_FILTER"><span class="yiyi-st" id="yiyi-177"> <code class="descclassname">socket.</code><code class="descname">HCI_FILTER</code></span></dt><dt id="socket.HCI_TIME_STAMP"><span class="yiyi-st" id="yiyi-178"> <code class="descclassname">socket.</code><code class="descname">HCI_TIME_STAMP</code></span></dt><dt id="socket.HCI_DATA_DIR"><span class="yiyi-st" id="yiyi-179"> <code class="descclassname">socket.</code><code class="descname">HCI_DATA_DIR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-180">For use with <code class="xref py py-const docutils literal"><span class="pre">BTPROTO_HCI</span></code>. </span><span class="yiyi-st" id="yiyi-181"><a class="reference internal" href="#socket.HCI_FILTER" title="socket.HCI_FILTER"><code class="xref py py-const docutils literal"><span class="pre">HCI_FILTER</span></code></a> is not available for NetBSD or DragonFlyBSD. </span><span class="yiyi-st" id="yiyi-182"><a class="reference internal" href="#socket.HCI_TIME_STAMP" title="socket.HCI_TIME_STAMP"><code class="xref py py-const docutils literal"><span class="pre">HCI_TIME_STAMP</span></code></a> and <a class="reference internal" href="#socket.HCI_DATA_DIR" title="socket.HCI_DATA_DIR"><code class="xref py py-const docutils literal"><span class="pre">HCI_DATA_DIR</span></code></a> are not available for FreeBSD, NetBSD, or DragonFlyBSD.</span></p></dd></dl></div><div class="section" id="functions"><h3><span class="yiyi-st" id="yiyi-184">18.1.2.3. </span><span class="yiyi-st" id="yiyi-185">功能函数</span></h3><div class="section" id="creating-sockets"><h4><span class="yiyi-st" id="yiyi-186">18.1.2.3.1. </span><span class="yiyi-st" id="yiyi-187">创建 sockets</span></h4><p><span class="yiyi-st" id="yiyi-188">以下函数都可以创建<a class="reference internal" href="#socket-objects"><span>socket 对象</span></a>.</span></p><dl class="function"><dt id="socket.socket"><span class="yiyi-st" id="yiyi-189"> <code class="descclassname">socket.</code><code class="descname">socket</code><span class="sig-paren">(</span><em>family=AF_INET</em>, <em>type=SOCK_STREAM</em>, <em>proto=0</em>, <em>fileno=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-190">使用给定的地址族、套接字类型和协议号创建一个新的套接字。</span><span class="yiyi-st" id="yiyi-191">地址族应当为 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a>（默认）、 <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal"><span class="pre">AF_INET6</span></code></a>、<a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a>、<a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal"><span class="pre">AF_CAN</span></code></a> 或 <a class="reference internal" href="#socket.AF_RDS" title="socket.AF_RDS"><code class="xref py py-const docutils literal"><span class="pre">AF_RDS</span></code></a>。</span><span class="yiyi-st" id="yiyi-192">套接字类型应该为 <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_STREAM</span></code></a>（默认）、<a class="reference internal" href="#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_DGRAM</span></code></a>、<a class="reference internal" href="#socket.SOCK_RAW" title="socket.SOCK_RAW"><code class="xref py py-const docutils literal"><span class="pre">SOCK_RAW</span></code></a> 或者其它某一个<code class="docutils literal"><span class="pre">SOCK_</span></code> 常量。</span><span class="yiyi-st" id="yiyi-193">协议号通常为零并可以省略，在地址族为 <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal"><span class="pre">AF_CAN</span></code></a> 的情况下，协议号应该是 <code class="xref py py-const docutils literal"><span class="pre">CAN_RAW</span></code> 或 <a class="reference internal" href="#socket.CAN_BCM" title="socket.CAN_BCM"><code class="xref py py-const docutils literal"><span class="pre">CAN_BCM</span></code></a> 之一。</span><span class="yiyi-st" id="yiyi-194">如果指定了 <em>fileno</em>，则忽略其它参数，从而返回具有指定文件描述符的套接字。</span><span class="yiyi-st" id="yiyi-195">与 <a class="reference internal" href="#socket.fromfd" title="socket.fromfd"><code class="xref py py-func docutils literal"><span class="pre">socket.fromfd()</span></code></a> 不同，<em>fileno</em> 将返回相同的套接字而不是复制一个。</span><span class="yiyi-st" id="yiyi-196">这可能有助于使用 <a class="reference internal" href="#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">socket.close()</span></code></a> 关闭分离的套接字。</span></p><p><span class="yiyi-st" id="yiyi-197">新创建的套接字是<a class="reference internal" href="os.html#fd-inheritance"><span>不可继承的</span></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-198"><span class="versionmodified">在版本3.3中更改：</span>添加了 AF_CAN 地址族。</span><span class="yiyi-st" id="yiyi-199">添加 AF_RDS 地址族。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-200"><span class="versionmodified">版本3.4中更改：</span>添加了 CAN_BCM 协议。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-201"><span class="versionmodified">在版本3.4中更改：</span>返回的套接字现在是不可继承的。</span></p></div></dd></dl><dl class="function"><dt id="socket.socketpair"><span class="yiyi-st" id="yiyi-202"> <code class="descclassname">socket.</code><code class="descname">socketpair</code><span class="sig-paren">(</span><span class="optional">[</span><em>family</em><span class="optional">[</span>, <em>type</em><span class="optional">[</span>, <em>proto</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-203">使用所给的地址族，套接字类型和协议号创建一对已连接的socket 对象.</span><span class="yiyi-st" id="yiyi-204">Address family, socket type, and protocol number are as for the <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> function above. </span><span class="yiyi-st" id="yiyi-205">The default family is <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a> if defined on the platform; otherwise, the default is <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-206">The newly created sockets are <a class="reference internal" href="os.html#fd-inheritance"><span>non-inheritable</span></a>.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-207"><span class="versionmodified">Changed in version 3.2: </span>The returned socket objects now support the whole socket API, rather than a subset.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-208"><span class="versionmodified">Changed in version 3.4: </span>The returned sockets are now non-inheritable.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-209"><span class="versionmodified">Changed in version 3.5: </span>Windows support added.</span></p></div></dd></dl><dl class="function"><dt id="socket.create_connection"><span class="yiyi-st" id="yiyi-210"> <code class="descclassname">socket.</code><code class="descname">create_connection</code><span class="sig-paren">(</span><em>address</em><span class="optional">[</span>, <em>timeout</em><span class="optional">[</span>, <em>source_address</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-211">连接到监听网络地址(一个2-tuple(host,port)),然后返回`socket`对象。这是比`socket.connect（）`更高级的函数：如果`host`是非数字主机名，它将尝试为`AF_INET`和`AF_INET6`解析它，然后尝试依次连接到所有可能的地址，直到连接成功。 这使得编写兼容`IPv4`和`IPv6`的客户端变得容易。
  <em></em><code class="docutils literal"><span class="pre"></span><span class="pre"></span></code></span><span class="yiyi-st" id="yiyi-212">连接到监听网络地址(一个2-tuple(host,port)),然后返回`socket`对象。这是比`socket.connect（）`更高级的函数：如果`host`是非数字主机名，它将尝试为`AF_INET`和`AF_INET6`解析它，然后尝试依次连接到所有可能的地址，直到连接成功。  <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre"></span></code></a><em></em><a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal"><span class="pre"></span></code></a><a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal"><span class="pre"></span></code></a></span><span class="yiyi-st" id="yiyi-213">这使得编写兼容`IPv4`和`IPv6`的客户端变得容易。</span></p><p><span class="yiyi-st" id="yiyi-214">尝试连接之前，传递可选的`timeout`参数将在`socket`实例上设置超时。 <em></em></span><span class="yiyi-st" id="yiyi-215"> 如果未提供超时，则使用由`getdefaulttimeout（）`返回的全局默认超时设置。 <em></em><a class="reference internal" href="#socket.getdefaulttimeout" title="socket.getdefaulttimeout"><code class="xref py py-func docutils literal"><span class="pre"></span></code></a></span></p><p><span class="yiyi-st" id="yiyi-216">如果提供，则在连接之前，`source_address`必须是`socket`绑定到的源地址的`2元组（主机，端口）`。  <em></em><code class="docutils literal"><span class="pre"></span><span class="pre"></span></code></span><span class="yiyi-st" id="yiyi-217"> 如果主机或端口分别为“”或0，则将使用操作系统默认行为。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-218"><span class="versionmodified">Changed in version 3.2: </span><em>source_address</em> was added.</span></p></div></dd></dl><dl class="function"><dt id="socket.fromfd"><span class="yiyi-st" id="yiyi-219"> <code class="descclassname">socket.</code><code class="descname">fromfd</code><span class="sig-paren">(</span><em>fd</em>, <em>family</em>, <em>type</em>, <em>proto=0</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-220">复制文件描述符fd（由文件对象的fileno（）方法返回的整数），并根据结果构建一个套接字对象。  <em></em><code class="xref py py-meth docutils literal"><span class="pre"></span></code></span><span class="yiyi-st" id="yiyi-221">地址族，套接字类型和协议号与上面的socket（）函数一样。  <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre"></span></code></a></span><span class="yiyi-st" id="yiyi-222">文件描述符应该引用一个socket，但这不会被检查 - 如果文件描述符无效，对象的后续操作可能会失败。</span><span class="yiyi-st" id="yiyi-223"> 这个函数很少用，但可以用来在传递给程序的套接字上获取或设置套接字选项作为标准输入或输出（例如由Unix inet守护进程启动的服务器）。</span><span class="yiyi-st" id="yiyi-224"> 假设socket处于阻塞模式。</span></p><p><span class="yiyi-st" id="yiyi-225">The newly created socket is <a class="reference internal" href="os.html#fd-inheritance"><span>non-inheritable</span></a>.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-226"><span class="versionmodified">Changed in version 3.4: </span>The returned socket is now non-inheritable.</span></p></div></dd></dl><dl class="function"><dt id="socket.fromshare"><span class="yiyi-st" id="yiyi-227"> <code class="descclassname">socket.</code><code class="descname">fromshare</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-228">使用从`socket.share（）`方法获得的数据实例化一个socket.<a class="reference internal" href="#socket.socket.share" title="socket.socket.share"><code class="xref py py-meth docutils literal"><span class="pre"></span></code></a></span><span class="yiyi-st" id="yiyi-229"> 假设socket处于阻塞模式</span></p><p><span class="yiyi-st" id="yiyi-230">Availability: Windows.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-231"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="data"><dt id="socket.SocketType"><span class="yiyi-st" id="yiyi-232"> <code class="descclassname">socket.</code><code class="descname">SocketType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-233">这是一个代表socket对象类型的Python类型对象。</span><span class="yiyi-st" id="yiyi-234">它与`type(socket(...))`相同。
 <code class="docutils literal"><span class="pre"></span></code></span></p></dd></dl></div><div class="section" id="other-functions"><h4><span class="yiyi-st" id="yiyi-235">18.1.2.3.2. </span><span class="yiyi-st" id="yiyi-236">其它函数</span></h4><p><span class="yiyi-st" id="yiyi-237"><a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> 模块中同样也提供多种其他网络相关的服务：</span></p><dl class="function"><dt id="socket.getaddrinfo"><span class="yiyi-st" id="yiyi-238"> <code class="descclassname">socket.</code><code class="descname">getaddrinfo</code><span class="sig-paren">(</span><em>host</em>, <em>port</em>, <em>family=0</em>, <em>type=0</em>, <em>proto=0</em>, <em>flags=0</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-239">将 <em>host</em>/<em>port</em> 参数转换为一个5元组序列，其中包含创建连接到该服务的套接字的所有必要参数。</span><span class="yiyi-st" id="yiyi-240"><em>host</em> 是一个域名，一个表示 IPv4/v6 地址的字符串或者为 <code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-241"><em>port</em> 是一个表示服务名称的字符串例如<code class="docutils literal"><span class="pre">'http'</span></code>、一个表示端口号的数字或者为 <code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-242">通过传递 <code class="docutils literal"><span class="pre">None</span></code> 作为 <em>host</em> 和 <em>port</em> 的值，可以将 <code class="docutils literal"><span class="pre">NULL</span></code> 传递给底层 C API。</span></p><p><span class="yiyi-st" id="yiyi-243">可以选择指定 <em>family</em>、<em>type</em> 和 <em>proto</em> 参数，以缩小返回的地址列表。</span><span class="yiyi-st" id="yiyi-244">将零作为每个参数的值传递将选择全部结果。</span><span class="yiyi-st" id="yiyi-245"><em>flags</em>参数可以是 <code class="docutils literal"><span class="pre">AI_*</span></code> 常量中的一个或几个，并将影响如何计算和返回结果。</span><span class="yiyi-st" id="yiyi-246">例如，<code class="xref py py-const docutils literal"><span class="pre">AI_NUMERICHOST</span></code>将禁用域名解析，如果<em>host</em>是域名，则会引发错误。</span></p><p><span class="yiyi-st" id="yiyi-247">该函数返回具有以下结构的5元组列表：</span></p><p><span class="yiyi-st" id="yiyi-248"><code class="docutils literal"><span class="pre">(family,</span> <span class="pre">type,</span> <span class="pre">proto,</span> <span class="pre">canonname,</span> <span class="pre">sockaddr)</span></code></span></p><p><span class="yiyi-st" id="yiyi-249">在这些元组中，<em>family</em>、<em>type</em>、<em>proto</em> 都是整数，用于传递给 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> 函数。</span><span class="yiyi-st" id="yiyi-250">如果<code class="xref py py-const docutils literal"><span class="pre">AI_CANONNAME</span></code>是<em>flags</em>参数的一部分，<em>canonname</em>将是一个表示<em>host</em>的规范名称的字符串；否则<em>canonname</em>将为空。</span><span class="yiyi-st" id="yiyi-251"><em>sockaddr</em> 是一个描述套接字地址的元组，格式依赖于返回的 <em>family</em>（<a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> 为 <code class="docutils literal"><span class="pre">(address,</span> <span class="pre">port)</span></code> 2元组，<a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal"><span class="pre">AF_INET6</span></code></a> 为 <code class="docutils literal"><span class="pre">(address,</span> <span class="pre">port,</span> <span class="pre">flow</span> <span class="pre">info,</span> <span class="pre">scope</span> <span class="pre">id)</span></code> 4元组），用于传递给<a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">socket.connect()</span></code></a> 方法。</span></p><p><span class="yiyi-st" id="yiyi-252">以下示例在端口80上获取与<code class="docutils literal"><span class="pre">example.org</span></code>的假设TCP连接的地址信息（如果未启用IPv6，则系统上的结果可能不同）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="s2">"example.org"</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="n">proto</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_TCP</span><span class="p">)</span>
<span class="go">[(&lt;AddressFamily.AF_INET6: 10&gt;, &lt;SocketType.SOCK_STREAM: 1&gt;,</span>
<span class="go"> 6, '', ('2606:2800:220:1:248:1893:25c8:1946', 80, 0, 0)),</span>
<span class="go"> (&lt;AddressFamily.AF_INET: 2&gt;, &lt;SocketType.SOCK_STREAM: 1&gt;,</span>
<span class="go"> 6, '', ('93.184.216.34', 80))]</span>
</code></pre><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-253"><span class="versionmodified">版本3.2中已更改：</span>现在可以使用关键字参数传递参数。</span></p></div></dd></dl><dl class="function"><dt id="socket.getfqdn"><span class="yiyi-st" id="yiyi-254"> <code class="descclassname">socket.</code><code class="descname">getfqdn</code><span class="sig-paren">(</span><span class="optional">[</span><em>name</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-255">Return a fully qualified domain name for <em>name</em>. </span><span class="yiyi-st" id="yiyi-256">If <em>name</em> is omitted or empty, it is interpreted as the local host. </span><span class="yiyi-st" id="yiyi-257">To find the fully qualified name, the hostname returned by <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal"><span class="pre">gethostbyaddr()</span></code></a> is checked, followed by aliases for the host, if available. </span><span class="yiyi-st" id="yiyi-258">The first name which includes a period is selected. </span><span class="yiyi-st" id="yiyi-259">In case no fully qualified domain name is available, the hostname as returned by <a class="reference internal" href="#socket.gethostname" title="socket.gethostname"><code class="xref py py-func docutils literal"><span class="pre">gethostname()</span></code></a> is returned.</span></p></dd></dl><dl class="function"><dt id="socket.gethostbyname"><span class="yiyi-st" id="yiyi-260"> <code class="descclassname">socket.</code><code class="descname">gethostbyname</code><span class="sig-paren">(</span><em>hostname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-261">将主机名转换为IPv4地址格式。</span><span class="yiyi-st" id="yiyi-262">IPv4地址以字符串形式返回，例如<code class="docutils literal"><span class="pre">'100.50.200.5'</span></code>。</span><span class="yiyi-st" id="yiyi-263">如果主机名是IPv4地址本身，则返回不变。</span><span class="yiyi-st" id="yiyi-264">See <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal"><span class="pre">gethostbyname_ex()</span></code></a> for a more complete interface. </span><span class="yiyi-st" id="yiyi-265"><a class="reference internal" href="#socket.gethostbyname" title="socket.gethostbyname"><code class="xref py py-func docutils literal"><span class="pre">gethostbyname()</span></code></a> does not support IPv6 name resolution, and <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal"><span class="pre">getaddrinfo()</span></code></a> should be used instead for IPv4/v6 dual stack support.</span></p></dd></dl><dl class="function"><dt id="socket.gethostbyname_ex"><span class="yiyi-st" id="yiyi-266"> <code class="descclassname">socket.</code><code class="descname">gethostbyname_ex</code><span class="sig-paren">(</span><em>hostname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-267">Translate a host name to IPv4 address format, extended interface. </span><span class="yiyi-st" id="yiyi-268">Return a triple <code class="docutils literal"><span class="pre">(hostname,</span> <span class="pre">aliaslist,</span> <span class="pre">ipaddrlist)</span></code> where <em>hostname</em> is the primary host name responding to the given <em>ip_address</em>, <em>aliaslist</em> is a (possibly empty) list of alternative host names for the same address, and <em>ipaddrlist</em> is a list of IPv4 addresses for the same interface on the same host (often but not always a single address). </span><span class="yiyi-st" id="yiyi-269"><a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal"><span class="pre">gethostbyname_ex()</span></code></a> does not support IPv6 name resolution, and <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal"><span class="pre">getaddrinfo()</span></code></a> should be used instead for IPv4/v6 dual stack support.</span></p></dd></dl><dl class="function"><dt id="socket.gethostname"><span class="yiyi-st" id="yiyi-270"> <code class="descclassname">socket.</code><code class="descname">gethostname</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-271">Return a string containing the hostname of the machine where the Python interpreter is currently executing.</span></p><p><span class="yiyi-st" id="yiyi-272">Note: <a class="reference internal" href="#socket.gethostname" title="socket.gethostname"><code class="xref py py-func docutils literal"><span class="pre">gethostname()</span></code></a> doesn’t always return the fully qualified domain name; use <a class="reference internal" href="#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal"><span class="pre">getfqdn()</span></code></a> for that.</span></p></dd></dl><dl class="function"><dt id="socket.gethostbyaddr"><span class="yiyi-st" id="yiyi-273"> <code class="descclassname">socket.</code><code class="descname">gethostbyaddr</code><span class="sig-paren">(</span><em>ip_address</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-274">Return a triple <code class="docutils literal"><span class="pre">(hostname,</span> <span class="pre">aliaslist,</span> <span class="pre">ipaddrlist)</span></code> where <em>hostname</em> is the primary host name responding to the given <em>ip_address</em>, <em>aliaslist</em> is a (possibly empty) list of alternative host names for the same address, and <em>ipaddrlist</em> is a list of IPv4/v6 addresses for the same interface on the same host (most likely containing only a single address). </span><span class="yiyi-st" id="yiyi-275">To find the fully qualified domain name, use the function <a class="reference internal" href="#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal"><span class="pre">getfqdn()</span></code></a>. </span><span class="yiyi-st" id="yiyi-276"><a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal"><span class="pre">gethostbyaddr()</span></code></a> supports both IPv4 and IPv6.</span></p></dd></dl><dl class="function"><dt id="socket.getnameinfo"><span class="yiyi-st" id="yiyi-277"> <code class="descclassname">socket.</code><code class="descname">getnameinfo</code><span class="sig-paren">(</span><em>sockaddr</em>, <em>flags</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-278">Translate a socket address <em>sockaddr</em> into a 2-tuple <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code>. </span><span class="yiyi-st" id="yiyi-279">Depending on the settings of <em>flags</em>, the result can contain a fully-qualified domain name or numeric address representation in <em>host</em>. </span><span class="yiyi-st" id="yiyi-280">Similarly, <em>port</em> can contain a string port name or a numeric port number.</span></p></dd></dl><dl class="function"><dt id="socket.getprotobyname"><span class="yiyi-st" id="yiyi-281"> <code class="descclassname">socket.</code><code class="descname">getprotobyname</code><span class="sig-paren">(</span><em>protocolname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-282">Translate an Internet protocol name (for example, <code class="docutils literal"><span class="pre">'icmp'</span></code>) to a constant suitable for passing as the (optional) third argument to the <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a> function. </span><span class="yiyi-st" id="yiyi-283">This is usually only needed for sockets opened in “raw” mode (<a class="reference internal" href="#socket.SOCK_RAW" title="socket.SOCK_RAW"><code class="xref py py-const docutils literal"><span class="pre">SOCK_RAW</span></code></a>); for the normal socket modes, the correct protocol is chosen automatically if the protocol is omitted or zero.</span></p></dd></dl><dl class="function"><dt id="socket.getservbyname"><span class="yiyi-st" id="yiyi-284"> <code class="descclassname">socket.</code><code class="descname">getservbyname</code><span class="sig-paren">(</span><em>servicename</em><span class="optional">[</span>, <em>protocolname</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-285">Translate an Internet service name and protocol name to a port number for that service. </span><span class="yiyi-st" id="yiyi-286">The optional protocol name, if given, should be <code class="docutils literal"><span class="pre">'tcp'</span></code> or <code class="docutils literal"><span class="pre">'udp'</span></code>, otherwise any protocol will match.</span></p></dd></dl><dl class="function"><dt id="socket.getservbyport"><span class="yiyi-st" id="yiyi-287"> <code class="descclassname">socket.</code><code class="descname">getservbyport</code><span class="sig-paren">(</span><em>port</em><span class="optional">[</span>, <em>protocolname</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-288">Translate an Internet port number and protocol name to a service name for that service. </span><span class="yiyi-st" id="yiyi-289">The optional protocol name, if given, should be <code class="docutils literal"><span class="pre">'tcp'</span></code> or <code class="docutils literal"><span class="pre">'udp'</span></code>, otherwise any protocol will match.</span></p></dd></dl><dl class="function"><dt id="socket.ntohl"><span class="yiyi-st" id="yiyi-290"> <code class="descclassname">socket.</code><code class="descname">ntohl</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-291">将32位正整数从网络字节顺序转换为主机字节顺序。</span><span class="yiyi-st" id="yiyi-292">On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.</span></p></dd></dl><dl class="function"><dt id="socket.ntohs"><span class="yiyi-st" id="yiyi-293"> <code class="descclassname">socket.</code><code class="descname">ntohs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-294">Convert 16-bit positive integers from network to host byte order. </span><span class="yiyi-st" id="yiyi-295">On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.</span></p></dd></dl><dl class="function"><dt id="socket.htonl"><span class="yiyi-st" id="yiyi-296"> <code class="descclassname">socket.</code><code class="descname">htonl</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-297">Convert 32-bit positive integers from host to network byte order. </span><span class="yiyi-st" id="yiyi-298">On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.</span></p></dd></dl><dl class="function"><dt id="socket.htons"><span class="yiyi-st" id="yiyi-299"> <code class="descclassname">socket.</code><code class="descname">htons</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-300">Convert 16-bit positive integers from host to network byte order. </span><span class="yiyi-st" id="yiyi-301">On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.</span></p></dd></dl><dl class="function"><dt id="socket.inet_aton"><span class="yiyi-st" id="yiyi-302"> <code class="descclassname">socket.</code><code class="descname">inet_aton</code><span class="sig-paren">(</span><em>ip_string</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-303">Convert an IPv4 address from dotted-quad string format (for example, ‘123.45.67.89’) to 32-bit packed binary format, as a bytes object four characters in length. </span><span class="yiyi-st" id="yiyi-304">This is useful when conversing with a program that uses the standard C library and needs objects of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in_addr</span></code>, which is the C type for the 32-bit packed binary this function returns.</span></p><p><span class="yiyi-st" id="yiyi-305"><a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal"><span class="pre">inet_aton()</span></code></a> also accepts strings with less than three dots; see the Unix manual page <em class="manpage">inet(3)</em> for details.</span></p><p><span class="yiyi-st" id="yiyi-306">If the IPv4 address string passed to this function is invalid, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> will be raised. </span><span class="yiyi-st" id="yiyi-307">Note that exactly what is valid depends on the underlying C implementation of <code class="xref c c-func docutils literal"><span class="pre">inet_aton()</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-308"><a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal"><span class="pre">inet_aton()</span></code></a> does not support IPv6, and <a class="reference internal" href="#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal"><span class="pre">inet_pton()</span></code></a> should be used instead for IPv4/v6 dual stack support.</span></p></dd></dl><dl class="function"><dt id="socket.inet_ntoa"><span class="yiyi-st" id="yiyi-309"> <code class="descclassname">socket.</code><code class="descname">inet_ntoa</code><span class="sig-paren">(</span><em>packed_ip</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-310">Convert a 32-bit packed IPv4 address (a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> four bytes in length) to its standard dotted-quad string representation (for example, ‘123.45.67.89’). </span><span class="yiyi-st" id="yiyi-311">This is useful when conversing with a program that uses the standard C library and needs objects of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in_addr</span></code>, which is the C type for the 32-bit packed binary data this function takes as an argument.</span></p><p><span class="yiyi-st" id="yiyi-312">If the byte sequence passed to this function is not exactly 4 bytes in length, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> will be raised. </span><span class="yiyi-st" id="yiyi-313"><a class="reference internal" href="#socket.inet_ntoa" title="socket.inet_ntoa"><code class="xref py py-func docutils literal"><span class="pre">inet_ntoa()</span></code></a> does not support IPv6, and <a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal"><span class="pre">inet_ntop()</span></code></a> should be used instead for IPv4/v6 dual stack support.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-314"><span class="versionmodified">Changed in version 3.5: </span>Writable <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> is now accepted.</span></p></div></dd></dl><dl class="function"><dt id="socket.inet_pton"><span class="yiyi-st" id="yiyi-315"> <code class="descclassname">socket.</code><code class="descname">inet_pton</code><span class="sig-paren">(</span><em>address_family</em>, <em>ip_string</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-316">将IP地址从其特定类型的字符串格式转换为压缩的二进制格式。</span><span class="yiyi-st" id="yiyi-317"><a class="reference internal" href="#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal"><span class="pre">inet_pton()</span></code></a> is useful when a library or network protocol calls for an object of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in_addr</span></code> (similar to <a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal"><span class="pre">inet_aton()</span></code></a>) or <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in6_addr</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-318">Supported values for <em>address_family</em> are currently <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> and <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal"><span class="pre">AF_INET6</span></code></a>. </span><span class="yiyi-st" id="yiyi-319">If the IP address string <em>ip_string</em> is invalid, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> will be raised. </span><span class="yiyi-st" id="yiyi-320">Note that exactly what is valid depends on both the value of <em>address_family</em> and the underlying implementation of <code class="xref c c-func docutils literal"><span class="pre">inet_pton()</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-321">Availability: Unix (maybe not all platforms), Windows.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-322"><span class="versionmodified">Changed in version 3.4: </span>Windows support added</span></p></div></dd></dl><dl class="function"><dt id="socket.inet_ntop"><span class="yiyi-st" id="yiyi-323"> <code class="descclassname">socket.</code><code class="descname">inet_ntop</code><span class="sig-paren">(</span><em>address_family</em>, <em>packed_ip</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-324">Convert a packed IP address (a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> of some number of bytes) to its standard, family-specific string representation (for example, <code class="docutils literal"><span class="pre">'7.10.0.5'</span></code> or <code class="docutils literal"><span class="pre">'5aef:2b::8'</span></code>). </span><span class="yiyi-st" id="yiyi-325"><a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal"><span class="pre">inet_ntop()</span></code></a> is useful when a library or network protocol returns an object of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in_addr</span></code> (similar to <a class="reference internal" href="#socket.inet_ntoa" title="socket.inet_ntoa"><code class="xref py py-func docutils literal"><span class="pre">inet_ntoa()</span></code></a>) or <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">in6_addr</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-326">Supported values for <em>address_family</em> are currently <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a> and <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal"><span class="pre">AF_INET6</span></code></a>. </span><span class="yiyi-st" id="yiyi-327">If the bytes object <em>packed_ip</em> is not the correct length for the specified address family, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> will be raised. </span><span class="yiyi-st" id="yiyi-328"><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> is raised for errors from the call to <a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal"><span class="pre">inet_ntop()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-329">Availability: Unix (maybe not all platforms), Windows.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-330"><span class="versionmodified">Changed in version 3.4: </span>Windows support added</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-331"><span class="versionmodified">Changed in version 3.5: </span>Writable <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> is now accepted.</span></p></div></dd></dl><dl class="function"><dt id="socket.CMSG_LEN"><span class="yiyi-st" id="yiyi-332"> <code class="descclassname">socket.</code><code class="descname">CMSG_LEN</code><span class="sig-paren">(</span><em>length</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-333">Return the total length, without trailing padding, of an ancillary data item with associated data of the given <em>length</em>. </span><span class="yiyi-st" id="yiyi-334">This value can often be used as the buffer size for <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal"><span class="pre">recvmsg()</span></code></a> to receive a single item of ancillary data, but <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3542.html"><strong>RFC 3542</strong></a> requires portable applications to use <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal"><span class="pre">CMSG_SPACE()</span></code></a> and thus include space for padding, even when the item will be the last in the buffer. </span><span class="yiyi-st" id="yiyi-335">Raises <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> if <em>length</em> is outside the permissible range of values.</span></p><p><span class="yiyi-st" id="yiyi-336">Availability: most Unix platforms, possibly others.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-337"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="function"><dt id="socket.CMSG_SPACE"><span class="yiyi-st" id="yiyi-338"> <code class="descclassname">socket.</code><code class="descname">CMSG_SPACE</code><span class="sig-paren">(</span><em>length</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-339">Return the buffer size needed for <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal"><span class="pre">recvmsg()</span></code></a> to receive an ancillary data item with associated data of the given <em>length</em>, along with any trailing padding. </span><span class="yiyi-st" id="yiyi-340">The buffer space needed to receive multiple items is the sum of the <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal"><span class="pre">CMSG_SPACE()</span></code></a> values for their associated data lengths. </span><span class="yiyi-st" id="yiyi-341">Raises <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> if <em>length</em> is outside the permissible range of values.</span></p><p><span class="yiyi-st" id="yiyi-342">Note that some systems might support ancillary data without providing this function. </span><span class="yiyi-st" id="yiyi-343">Also note that setting the buffer size using the results of this function may not precisely limit the amount of ancillary data that can be received, since additional data may be able to fit into the padding area.</span></p><p><span class="yiyi-st" id="yiyi-344">Availability: most Unix platforms, possibly others.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-345"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="function"><dt id="socket.getdefaulttimeout"><span class="yiyi-st" id="yiyi-346"> <code class="descclassname">socket.</code><code class="descname">getdefaulttimeout</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-347">返回新套接字对象的默认超时值（以秒为单位）（浮点数）。</span><span class="yiyi-st" id="yiyi-348">A value of <code class="docutils literal"><span class="pre">None</span></code> indicates that new socket objects have no timeout. </span><span class="yiyi-st" id="yiyi-349">When the socket module is first imported, the default is <code class="docutils literal"><span class="pre">None</span></code>.</span></p></dd></dl><dl class="function"><dt id="socket.setdefaulttimeout"><span class="yiyi-st" id="yiyi-350"> <code class="descclassname">socket.</code><code class="descname">setdefaulttimeout</code><span class="sig-paren">(</span><em>timeout</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-351">为新的套接字对象设置默认超时（以秒为单位）（float）。</span><span class="yiyi-st" id="yiyi-352">首次导入插槽模块时，默认值为<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-353">有关可能的值及其各自含义，请参见<a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="socket.sethostname"><span class="yiyi-st" id="yiyi-354"> <code class="descclassname">socket.</code><code class="descname">sethostname</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-355">将计算机的主机名设置为<em>名称</em>。</span><span class="yiyi-st" id="yiyi-356">如果您没有足够的权限，则会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>异常。</span></p><p><span class="yiyi-st" id="yiyi-357">Availability: Unix.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-358"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="function"><dt id="socket.if_nameindex"><span class="yiyi-st" id="yiyi-359"> <code class="descclassname">socket.</code><code class="descname">if_nameindex</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-360">Return a list of network interface information (index int, name string) tuples. </span><span class="yiyi-st" id="yiyi-361"><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> if the system call fails.</span></p><p><span class="yiyi-st" id="yiyi-362">Availability: Unix.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-363"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="function"><dt id="socket.if_nametoindex"><span class="yiyi-st" id="yiyi-364"> <code class="descclassname">socket.</code><code class="descname">if_nametoindex</code><span class="sig-paren">(</span><em>if_name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-365">Return a network interface index number corresponding to an interface name. </span><span class="yiyi-st" id="yiyi-366"><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> if no interface with the given name exists.</span></p><p><span class="yiyi-st" id="yiyi-367">Availability: Unix.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-368"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="function"><dt id="socket.if_indextoname"><span class="yiyi-st" id="yiyi-369"> <code class="descclassname">socket.</code><code class="descname">if_indextoname</code><span class="sig-paren">(</span><em>if_index</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-370">Return a network interface name corresponding to an interface index number. </span><span class="yiyi-st" id="yiyi-371"><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> if no interface with the given index exists.</span></p><p><span class="yiyi-st" id="yiyi-372">Availability: Unix.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-373"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl></div></div></div><div class="section" id="socket-objects"><h2><span class="yiyi-st" id="yiyi-374">18.1.3. </span><span class="yiyi-st" id="yiyi-375">Socket 对象</span></h2><p><span class="yiyi-st" id="yiyi-376">Socket 对象有以下方法.</span><span class="yiyi-st" id="yiyi-377">Except for <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code></a>, these correspond to Unix system calls applicable to sockets.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-378"><span class="versionmodified">Changed in version 3.2: </span>Support for the <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> protocol was added. </span><span class="yiyi-st" id="yiyi-379">Exiting the context manager is equivalent to calling <a class="reference internal" href="#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a>.</span></p></div><dl class="method"><dt id="socket.socket.accept"><span class="yiyi-st" id="yiyi-380"> <code class="descclassname">socket.</code><code class="descname">accept</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-381">接收一个连接.</span><span class="yiyi-st" id="yiyi-382">该socket 必须要绑定一个地址和监听连接.</span><span class="yiyi-st" id="yiyi-383">The return value is a pair <code class="docutils literal"><span class="pre">(conn,</span> <span class="pre">address)</span></code> where <em>conn</em> is a <em>new</em> socket object usable to send and receive data on the connection, and <em>address</em> is the address bound to the socket on the other end of the connection.</span></p><p><span class="yiyi-st" id="yiyi-384">The newly created socket is <a class="reference internal" href="os.html#fd-inheritance"><span>non-inheritable</span></a>.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-385"><span class="versionmodified">Changed in version 3.4: </span>The socket is now non-inheritable.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-386"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.bind"><span class="yiyi-st" id="yiyi-387"> <code class="descclassname">socket.</code><code class="descname">bind</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-388">Bind the socket to <em>address</em>. </span><span class="yiyi-st" id="yiyi-389">套接字必须尚未绑定。</span><span class="yiyi-st" id="yiyi-390">(The format of <em>address</em> depends on the address family — see above.)</span></p></dd></dl><dl class="method"><dt id="socket.socket.close"><span class="yiyi-st" id="yiyi-391"> <code class="descclassname">socket.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-392">Mark the socket closed. </span><span class="yiyi-st" id="yiyi-393">The underlying system resource (e.g. </span><span class="yiyi-st" id="yiyi-394">a file descriptor) is also closed when all file objects from <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code></a> are closed. </span><span class="yiyi-st" id="yiyi-395">Once that happens, all future operations on the socket object will fail. </span><span class="yiyi-st" id="yiyi-396">The remote end will receive no more data (after queued data is flushed).</span></p><p><span class="yiyi-st" id="yiyi-397">套接字在被垃圾回收时自动关闭，但建议显式地<a class="reference internal" href="#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a>，或者在打开套接字时使用<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-398">Note</span></p><p class="last"><span class="yiyi-st" id="yiyi-399"><a class="reference internal" href="#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> releases the resource associated with a connection but does not necessarily close the connection immediately. </span><span class="yiyi-st" id="yiyi-400">If you want to close the connection in a timely fashion, call <a class="reference internal" href="#socket.socket.shutdown" title="socket.socket.shutdown"><code class="xref py py-meth docutils literal"><span class="pre">shutdown()</span></code></a> before <a class="reference internal" href="#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a>.</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.connect"><span class="yiyi-st" id="yiyi-401"> <code class="descclassname">socket.</code><code class="descname">connect</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-402">Connect to a remote socket at <em>address</em>. </span><span class="yiyi-st" id="yiyi-403">(The format of <em>address</em> depends on the address family — see above.)</span></p><p><span class="yiyi-st" id="yiyi-404">If the connection is interrupted by a signal, the method waits until the connection completes, or raise a <a class="reference internal" href="#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal"><span class="pre">socket.timeout</span></code></a> on timeout, if the signal handler doesn’t raise an exception and the socket is blocking or has a timeout. </span><span class="yiyi-st" id="yiyi-405">For non-blocking sockets, the method raises an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception if the connection is interrupted by a signal (or the exception raised by the signal handler).</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-406"><span class="versionmodified">Changed in version 3.5: </span>The method now waits until the connection completes instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception if the connection is interrupted by a signal, the signal handler doesn’t raise an exception and the socket is blocking or has a timeout (see the <span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.connect_ex"><span class="yiyi-st" id="yiyi-407"> <code class="descclassname">socket.</code><code class="descname">connect_ex</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-408">Like <code class="docutils literal"><span class="pre">connect(address)</span></code>, but return an error indicator instead of raising an exception for errors returned by the C-level <code class="xref c c-func docutils literal"><span class="pre">connect()</span></code> call (other problems, such as “host not found,” can still raise exceptions). </span><span class="yiyi-st" id="yiyi-409">The error indicator is <code class="docutils literal"><span class="pre">0</span></code> if the operation succeeded, otherwise the value of the <code class="xref c c-data docutils literal"><span class="pre">errno</span></code> variable. </span><span class="yiyi-st" id="yiyi-410">This is useful to support, for example, asynchronous connects.</span></p></dd></dl><dl class="method"><dt id="socket.socket.detach"><span class="yiyi-st" id="yiyi-411"> <code class="descclassname">socket.</code><code class="descname">detach</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-412">Put the socket object into closed state without actually closing the underlying file descriptor. </span><span class="yiyi-st" id="yiyi-413">The file descriptor is returned, and can be reused for other purposes.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-414"><span class="versionmodified">New in version 3.2.</span></span></p></div></dd></dl><dl class="method"><dt id="socket.socket.dup"><span class="yiyi-st" id="yiyi-415"> <code class="descclassname">socket.</code><code class="descname">dup</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-416">Duplicate the socket.</span></p><p><span class="yiyi-st" id="yiyi-417">The newly created socket is <a class="reference internal" href="os.html#fd-inheritance"><span>non-inheritable</span></a>.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-418"><span class="versionmodified">Changed in version 3.4: </span>The socket is now non-inheritable.</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.fileno"><span class="yiyi-st" id="yiyi-419"> <code class="descclassname">socket.</code><code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-420">Return the socket’s file descriptor (a small integer), or -1 on failure. </span><span class="yiyi-st" id="yiyi-421">This is useful with <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select.select()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-422">Under Windows the small integer returned by this method cannot be used where a file descriptor can be used (such as <a class="reference internal" href="os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">os.fdopen()</span></code></a>). </span><span class="yiyi-st" id="yiyi-423">Unix does not have this limitation.</span></p></dd></dl><dl class="method"><dt id="socket.socket.get_inheritable"><span class="yiyi-st" id="yiyi-424"> <code class="descclassname">socket.</code><code class="descname">get_inheritable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-425">Get the <a class="reference internal" href="os.html#fd-inheritance"><span>inheritable flag</span></a> of the socket’s file descriptor or socket’s handle: <code class="docutils literal"><span class="pre">True</span></code> if the socket can be inherited in child processes, <code class="docutils literal"><span class="pre">False</span></code> if it cannot.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-426"><span class="versionmodified">New in version 3.4.</span></span></p></div></dd></dl><dl class="method"><dt id="socket.socket.getpeername"><span class="yiyi-st" id="yiyi-427"> <code class="descclassname">socket.</code><code class="descname">getpeername</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-428">Return the remote address to which the socket is connected. </span><span class="yiyi-st" id="yiyi-429">This is useful to find out the port number of a remote IPv4/v6 socket, for instance. </span><span class="yiyi-st" id="yiyi-430">(The format of the address returned depends on the address family — see above.) </span><span class="yiyi-st" id="yiyi-431">On some systems this function is not supported.</span></p></dd></dl><dl class="method"><dt id="socket.socket.getsockname"><span class="yiyi-st" id="yiyi-432"> <code class="descclassname">socket.</code><code class="descname">getsockname</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-433">Return the socket’s own address. </span><span class="yiyi-st" id="yiyi-434">This is useful to find out the port number of an IPv4/v6 socket, for instance. </span><span class="yiyi-st" id="yiyi-435">(The format of the address returned depends on the address family — see above.)</span></p></dd></dl><dl class="method"><dt id="socket.socket.getsockopt"><span class="yiyi-st" id="yiyi-436"> <code class="descclassname">socket.</code><code class="descname">getsockopt</code><span class="sig-paren">(</span><em>level</em>, <em>optname</em><span class="optional">[</span>, <em>buflen</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-437">Return the value of the given socket option (see the Unix man page <em class="manpage">getsockopt(2)</em>). </span><span class="yiyi-st" id="yiyi-438">The needed symbolic constants (<code class="xref py py-const docutils literal"><span class="pre">SO_*</span></code> etc.) </span><span class="yiyi-st" id="yiyi-439">are defined in this module. </span><span class="yiyi-st" id="yiyi-440">If <em>buflen</em> is absent, an integer option is assumed and its integer value is returned by the function. </span><span class="yiyi-st" id="yiyi-441">If <em>buflen</em> is present, it specifies the maximum length of the buffer used to receive the option in, and this buffer is returned as a bytes object. </span><span class="yiyi-st" id="yiyi-442">It is up to the caller to decode the contents of the buffer (see the optional built-in module <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> for a way to decode C structures encoded as byte strings).</span></p></dd></dl><dl class="method"><dt id="socket.socket.gettimeout"><span class="yiyi-st" id="yiyi-443"> <code class="descclassname">socket.</code><code class="descname">gettimeout</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-444">Return the timeout in seconds (float) associated with socket operations, or <code class="docutils literal"><span class="pre">None</span></code> if no timeout is set. </span><span class="yiyi-st" id="yiyi-445">This reflects the last call to <a class="reference internal" href="#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">setblocking()</span></code></a> or <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a>.</span></p></dd></dl><dl class="method"><dt id="socket.socket.ioctl"><span class="yiyi-st" id="yiyi-446"> <code class="descclassname">socket.</code><code class="descname">ioctl</code><span class="sig-paren">(</span><em>control</em>, <em>option</em><span class="sig-paren">)</span></span></dt><dd><table class="docutils field-list" frame="void" rules="none"><tbody valign="top"><tr class="field-odd field"><th class="field-name"><span class="yiyi-st" id="yiyi-447">Platform:</span></th><td class="field-body"><span class="yiyi-st" id="yiyi-448">Windows</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-449">The <a class="reference internal" href="#socket.socket.ioctl" title="socket.socket.ioctl"><code class="xref py py-meth docutils literal"><span class="pre">ioctl()</span></code></a> method is a limited interface to the WSAIoctl system interface. </span><span class="yiyi-st" id="yiyi-450">Please refer to the <a class="reference external" href="https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx">Win32 documentation</a> for more information.</span></p><p><span class="yiyi-st" id="yiyi-451">On other platforms, the generic <a class="reference internal" href="fcntl.html#fcntl.fcntl" title="fcntl.fcntl"><code class="xref py py-func docutils literal"><span class="pre">fcntl.fcntl()</span></code></a> and <a class="reference internal" href="fcntl.html#fcntl.ioctl" title="fcntl.ioctl"><code class="xref py py-func docutils literal"><span class="pre">fcntl.ioctl()</span></code></a> functions may be used; they accept a socket object as their first argument.</span></p></dd></dl><dl class="method"><dt id="socket.socket.listen"><span class="yiyi-st" id="yiyi-452"> <code class="descclassname">socket.</code><code class="descname">listen</code><span class="sig-paren">(</span><span class="optional">[</span><em>backlog</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-453">Enable a server to accept connections. </span><span class="yiyi-st" id="yiyi-454">If <em>backlog</em> is specified, it must be at least 0 (if it is lower, it is set to 0); it specifies the number of unaccepted connections that the system will allow before refusing new connections. </span><span class="yiyi-st" id="yiyi-455">If not specified, a default reasonable value is chosen.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-456"><span class="versionmodified">Changed in version 3.5: </span>The <em>backlog</em> parameter is now optional.</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.makefile"><span class="yiyi-st" id="yiyi-457"> <code class="descclassname">socket.</code><code class="descname">makefile</code><span class="sig-paren">(</span><em>mode='r'</em>, <em>buffering=None</em>, <em>*</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em><span class="sig-paren">)</span></span></dt><dd><p id="index-6"><span class="yiyi-st" id="yiyi-458">Return a <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> associated with the socket. </span><span class="yiyi-st" id="yiyi-459">The exact returned type depends on the arguments given to <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code></a>. </span><span class="yiyi-st" id="yiyi-460">These arguments are interpreted the same way as by the built-in <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> function, except the only supported <em>mode</em> values are <code class="docutils literal"><span class="pre">'r'</span></code> (default), <code class="docutils literal"><span class="pre">'w'</span></code> and <code class="docutils literal"><span class="pre">'b'</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-461">The socket must be in blocking mode; it can have a timeout, but the file object’s internal buffer may end up in an inconsistent state if a timeout occurs.</span></p><p><span class="yiyi-st" id="yiyi-462">Closing the file object returned by <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code></a> won’t close the original socket unless all other file objects have been closed and <a class="reference internal" href="#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">socket.close()</span></code></a> has been called on the socket object.</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-463">Note</span></p><p class="last"><span class="yiyi-st" id="yiyi-464">On Windows, the file-like object created by <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code></a> cannot be used where a file object with a file descriptor is expected, such as the stream arguments of <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-meth docutils literal"><span class="pre">subprocess.Popen()</span></code></a>.</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.recv"><span class="yiyi-st" id="yiyi-465"> <code class="descclassname">socket.</code><code class="descname">recv</code><span class="sig-paren">(</span><em>bufsize</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-466">从套接字接收数据。</span><span class="yiyi-st" id="yiyi-467">返回值是一个代表所收到的数据的字节对象。</span><span class="yiyi-st" id="yiyi-468">The maximum amount of data to be received at once is specified by <em>bufsize</em>. </span><span class="yiyi-st" id="yiyi-469">See the Unix manual page <em class="manpage">recv(2)</em> for the meaning of the optional argument <em>flags</em>; it defaults to zero.</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-470">Note</span></p><p class="last"><span class="yiyi-st" id="yiyi-471">For best match with hardware and network realities, the value of <em>bufsize</em> should be a relatively small power of 2, for example, 4096.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-472"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.recvfrom"><span class="yiyi-st" id="yiyi-473"> <code class="descclassname">socket.</code><code class="descname">recvfrom</code><span class="sig-paren">(</span><em>bufsize</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-474">Receive data from the socket. </span><span class="yiyi-st" id="yiyi-475">The return value is a pair <code class="docutils literal"><span class="pre">(bytes,</span> <span class="pre">address)</span></code> where <em>bytes</em> is a bytes object representing the data received and <em>address</em> is the address of the socket sending the data. </span><span class="yiyi-st" id="yiyi-476">See the Unix manual page <em class="manpage">recv(2)</em> for the meaning of the optional argument <em>flags</em>; it defaults to zero. </span><span class="yiyi-st" id="yiyi-477">(The format of <em>address</em> depends on the address family — see above.)</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-478"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.recvmsg"><span class="yiyi-st" id="yiyi-479"> <code class="descclassname">socket.</code><code class="descname">recvmsg</code><span class="sig-paren">(</span><em>bufsize</em><span class="optional">[</span>, <em>ancbufsize</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-480">Receive normal data (up to <em>bufsize</em> bytes) and ancillary data from the socket. </span><span class="yiyi-st" id="yiyi-481">The <em>ancbufsize</em> argument sets the size in bytes of the internal buffer used to receive the ancillary data; it defaults to 0, meaning that no ancillary data will be received. </span><span class="yiyi-st" id="yiyi-482">Appropriate buffer sizes for ancillary data can be calculated using <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal"><span class="pre">CMSG_SPACE()</span></code></a> or <a class="reference internal" href="#socket.CMSG_LEN" title="socket.CMSG_LEN"><code class="xref py py-func docutils literal"><span class="pre">CMSG_LEN()</span></code></a>, and items which do not fit into the buffer might be truncated or discarded. </span><span class="yiyi-st" id="yiyi-483">The <em>flags</em> argument defaults to 0 and has the same meaning as for <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-484">The return value is a 4-tuple: <code class="docutils literal"><span class="pre">(data,</span> <span class="pre">ancdata,</span> <span class="pre">msg_flags,</span> <span class="pre">address)</span></code>. </span><span class="yiyi-st" id="yiyi-485">The <em>data</em> item is a <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> object holding the non-ancillary data received. </span><span class="yiyi-st" id="yiyi-486">The <em>ancdata</em> item is a list of zero or more tuples <code class="docutils literal"><span class="pre">(cmsg_level,</span> <span class="pre">cmsg_type,</span> <span class="pre">cmsg_data)</span></code> representing the ancillary data (control messages) received: <em>cmsg_level</em> and <em>cmsg_type</em> are integers specifying the protocol level and protocol-specific type respectively, and <em>cmsg_data</em> is a <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> object holding the associated data. </span><span class="yiyi-st" id="yiyi-487">The <em>msg_flags</em> item is the bitwise OR of various flags indicating conditions on the received message; see your system documentation for details. </span><span class="yiyi-st" id="yiyi-488">If the receiving socket is unconnected, <em>address</em> is the address of the sending socket, if available; otherwise, its value is unspecified.</span></p><p><span class="yiyi-st" id="yiyi-489">On some systems, <a class="reference internal" href="#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal"><span class="pre">sendmsg()</span></code></a> and <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal"><span class="pre">recvmsg()</span></code></a> can be used to pass file descriptors between processes over an <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a> socket. </span><span class="yiyi-st" id="yiyi-490">When this facility is used (it is often restricted to <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_STREAM</span></code></a> sockets), <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal"><span class="pre">recvmsg()</span></code></a> will return, in its ancillary data, items of the form <code class="docutils literal"><span class="pre">(socket.SOL_SOCKET,</span> <span class="pre">socket.SCM_RIGHTS,</span> <span class="pre">fds)</span></code>, where <em>fds</em> is a <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> object representing the new file descriptors as a binary array of the native C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> type. </span><span class="yiyi-st" id="yiyi-491">If <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal"><span class="pre">recvmsg()</span></code></a> raises an exception after the system call returns, it will first attempt to close any file descriptors received via this mechanism.</span></p><p><span class="yiyi-st" id="yiyi-492">Some systems do not indicate the truncated length of ancillary data items which have been only partially received. </span><span class="yiyi-st" id="yiyi-493">If an item appears to extend beyond the end of the buffer, <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal"><span class="pre">recvmsg()</span></code></a> will issue a <a class="reference internal" href="exceptions.html#RuntimeWarning" title="RuntimeWarning"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeWarning</span></code></a>, and will return the part of it which is inside the buffer provided it has not been truncated before the start of its associated data.</span></p><p><span class="yiyi-st" id="yiyi-494">On systems which support the <code class="xref py py-const docutils literal"><span class="pre">SCM_RIGHTS</span></code> mechanism, the following function will receive up to <em>maxfds</em> file descriptors, returning the message data and a list containing the descriptors (while ignoring unexpected conditions such as unrelated control messages being received). </span><span class="yiyi-st" id="yiyi-495">See also <a class="reference internal" href="#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal"><span class="pre">sendmsg()</span></code></a>.</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">array</span>

<span class="k">def</span> <span class="nf">recv_fds</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msglen</span><span class="p">,</span> <span class="n">maxfds</span><span class="p">):</span>
    <span class="n">fds</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">"i"</span><span class="p">)</span>   <span class="c1"># Array of ints</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">ancdata</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvmsg</span><span class="p">(</span><span class="n">msglen</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">CMSG_LEN</span><span class="p">(</span><span class="n">maxfds</span> <span class="o">*</span> <span class="n">fds</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">cmsg_level</span><span class="p">,</span> <span class="n">cmsg_type</span><span class="p">,</span> <span class="n">cmsg_data</span> <span class="ow">in</span> <span class="n">ancdata</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cmsg_level</span> <span class="o">==</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span> <span class="ow">and</span> <span class="n">cmsg_type</span> <span class="o">==</span> <span class="n">socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span><span class="p">):</span>
            <span class="c1"># Append data, ignoring any truncated integers at the end.</span>
            <span class="n">fds</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">)</span> <span class="o">%</span> <span class="n">fds</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">msg</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-496">Availability: most Unix platforms, possibly others.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-497"><span class="versionmodified">New in version 3.3.</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-498"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.recvmsg_into"><span class="yiyi-st" id="yiyi-499"> <code class="descclassname">socket.</code><code class="descname">recvmsg_into</code><span class="sig-paren">(</span><em>buffers</em><span class="optional">[</span>, <em>ancbufsize</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-500">Receive normal data and ancillary data from the socket, behaving as <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal"><span class="pre">recvmsg()</span></code></a> would, but scatter the non-ancillary data into a series of buffers instead of returning a new bytes object. </span><span class="yiyi-st" id="yiyi-501">The <em>buffers</em> argument must be an iterable of objects that export writable buffers (e.g. </span><span class="yiyi-st" id="yiyi-502"><a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> objects); these will be filled with successive chunks of the non-ancillary data until it has all been written or there are no more buffers. </span><span class="yiyi-st" id="yiyi-503">The operating system may set a limit (<a class="reference internal" href="os.html#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal"><span class="pre">sysconf()</span></code></a> value <code class="docutils literal"><span class="pre">SC_IOV_MAX</span></code>) on the number of buffers that can be used. </span><span class="yiyi-st" id="yiyi-504">The <em>ancbufsize</em> and <em>flags</em> arguments have the same meaning as for <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal"><span class="pre">recvmsg()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-505">The return value is a 4-tuple: <code class="docutils literal"><span class="pre">(nbytes,</span> <span class="pre">ancdata,</span> <span class="pre">msg_flags,</span> <span class="pre">address)</span></code>, where <em>nbytes</em> is the total number of bytes of non-ancillary data written into the buffers, and <em>ancdata</em>, <em>msg_flags</em> and <em>address</em> are the same as for <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal"><span class="pre">recvmsg()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-506">Example:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">socket</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socketpair</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s1">'----'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s1">'0123456789'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b3</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s1">'--------------'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">b</span><span class="s1">'Mary had a little lamb'</span><span class="p">)</span>
<span class="go">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="o">.</span><span class="n">recvmsg_into</span><span class="p">([</span><span class="n">b1</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b2</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">9</span><span class="p">],</span> <span class="n">b3</span><span class="p">])</span>
<span class="go">(22, [], 0, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">]</span>
<span class="go">[bytearray(b'Mary'), bytearray(b'01 had a 9'), bytearray(b'little lamb---')]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-507">Availability: most Unix platforms, possibly others.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-508"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="method"><dt id="socket.socket.recvfrom_into"><span class="yiyi-st" id="yiyi-509"> <code class="descclassname">socket.</code><code class="descname">recvfrom_into</code><span class="sig-paren">(</span><em>buffer</em><span class="optional">[</span>, <em>nbytes</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-510">Receive data from the socket, writing it into <em>buffer</em> instead of creating a new bytestring. </span><span class="yiyi-st" id="yiyi-511">The return value is a pair <code class="docutils literal"><span class="pre">(nbytes,</span> <span class="pre">address)</span></code> where <em>nbytes</em> is the number of bytes received and <em>address</em> is the address of the socket sending the data. </span><span class="yiyi-st" id="yiyi-512">See the Unix manual page <em class="manpage">recv(2)</em> for the meaning of the optional argument <em>flags</em>; it defaults to zero. </span><span class="yiyi-st" id="yiyi-513">(The format of <em>address</em> depends on the address family — see above.)</span></p></dd></dl><dl class="method"><dt id="socket.socket.recv_into"><span class="yiyi-st" id="yiyi-514"> <code class="descclassname">socket.</code><code class="descname">recv_into</code><span class="sig-paren">(</span><em>buffer</em><span class="optional">[</span>, <em>nbytes</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-515">Receive up to <em>nbytes</em> bytes from the socket, storing the data into a buffer rather than creating a new bytestring. </span><span class="yiyi-st" id="yiyi-516">If <em>nbytes</em> is not specified (or 0), receive up to the size available in the given buffer. </span><span class="yiyi-st" id="yiyi-517">Returns the number of bytes received. </span><span class="yiyi-st" id="yiyi-518">See the Unix manual page <em class="manpage">recv(2)</em> for the meaning of the optional argument <em>flags</em>; it defaults to zero.</span></p></dd></dl><dl class="method"><dt id="socket.socket.send"><span class="yiyi-st" id="yiyi-519"> <code class="descclassname">socket.</code><code class="descname">send</code><span class="sig-paren">(</span><em>bytes</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-520">socket</span><span class="yiyi-st" id="yiyi-521">插座必须连接到远程插座。</span><span class="yiyi-st" id="yiyi-522">The optional <em>flags</em> argument has the same meaning as for <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> above. </span><span class="yiyi-st" id="yiyi-523">Returns the number of bytes sent. </span><span class="yiyi-st" id="yiyi-524">Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. </span><span class="yiyi-st" id="yiyi-525">For further information on this topic, consult the <a class="reference internal" href="../howto/sockets.html#socket-howto"><span>Socket Programming HOWTO</span></a>.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-526"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.sendall"><span class="yiyi-st" id="yiyi-527"> <code class="descclassname">socket.</code><code class="descname">sendall</code><span class="sig-paren">(</span><em>bytes</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-528">Send data to the socket. </span><span class="yiyi-st" id="yiyi-529">The socket must be connected to a remote socket. </span><span class="yiyi-st" id="yiyi-530">The optional <em>flags</em> argument has the same meaning as for <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> above. </span><span class="yiyi-st" id="yiyi-531">Unlike <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a>, this method continues to send data from <em>bytes</em> until either all data has been sent or an error occurs. </span><span class="yiyi-st" id="yiyi-532"><code class="docutils literal"><span class="pre">None</span></code> is returned on success. </span><span class="yiyi-st" id="yiyi-533">On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-534"><span class="versionmodified">Changed in version 3.5: </span>The socket timeout is no more reset each time data is sent successfully. </span><span class="yiyi-st" id="yiyi-535">The socket timeout is now the maximum total duration to send all data.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-536"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.sendto"><span class="yiyi-st" id="yiyi-537"> <code class="descclassname">socket.</code><code class="descname">sendto</code><span class="sig-paren">(</span><em>bytes</em>, <em>address</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-538"> <code class="descclassname">socket.</code><code class="descname">sendto</code><span class="sig-paren">(</span><em>bytes</em>, <em>flags</em>, <em>address</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-539">Send data to the socket. </span><span class="yiyi-st" id="yiyi-540">The socket should not be connected to a remote socket, since the destination socket is specified by <em>address</em>. </span><span class="yiyi-st" id="yiyi-541">The optional <em>flags</em> argument has the same meaning as for <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> above. </span><span class="yiyi-st" id="yiyi-542">Return the number of bytes sent. </span><span class="yiyi-st" id="yiyi-543">(The format of <em>address</em> depends on the address family — see above.)</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-544"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.sendmsg"><span class="yiyi-st" id="yiyi-545"> <code class="descclassname">socket.</code><code class="descname">sendmsg</code><span class="sig-paren">(</span><em>buffers</em><span class="optional">[</span>, <em>ancdata</em><span class="optional">[</span>, <em>flags</em><span class="optional">[</span>, <em>address</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-546">Send normal and ancillary data to the socket, gathering the non-ancillary data from a series of buffers and concatenating it into a single message. </span><span class="yiyi-st" id="yiyi-547">The <em>buffers</em> argument specifies the non-ancillary data as an iterable of <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a> (e.g. </span><span class="yiyi-st" id="yiyi-548"><a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> objects); the operating system may set a limit (<a class="reference internal" href="os.html#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal"><span class="pre">sysconf()</span></code></a> value <code class="docutils literal"><span class="pre">SC_IOV_MAX</span></code>) on the number of buffers that can be used. </span><span class="yiyi-st" id="yiyi-549">The <em>ancdata</em> argument specifies the ancillary data (control messages) as an iterable of zero or more tuples <code class="docutils literal"><span class="pre">(cmsg_level,</span> <span class="pre">cmsg_type,</span> <span class="pre">cmsg_data)</span></code>, where <em>cmsg_level</em> and <em>cmsg_type</em> are integers specifying the protocol level and protocol-specific type respectively, and <em>cmsg_data</em> is a bytes-like object holding the associated data. </span><span class="yiyi-st" id="yiyi-550">Note that some systems (in particular, systems without <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal"><span class="pre">CMSG_SPACE()</span></code></a>) might support sending only one control message per call. </span><span class="yiyi-st" id="yiyi-551">The <em>flags</em> argument defaults to 0 and has the same meaning as for <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a>. </span><span class="yiyi-st" id="yiyi-552">If <em>address</em> is supplied and not <code class="docutils literal"><span class="pre">None</span></code>, it sets a destination address for the message. </span><span class="yiyi-st" id="yiyi-553">The return value is the number of bytes of non-ancillary data sent.</span></p><p><span class="yiyi-st" id="yiyi-554">The following function sends the list of file descriptors <em>fds</em> over an <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal"><span class="pre">AF_UNIX</span></code></a> socket, on systems which support the <code class="xref py py-const docutils literal"><span class="pre">SCM_RIGHTS</span></code> mechanism. </span><span class="yiyi-st" id="yiyi-555">See also <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal"><span class="pre">recvmsg()</span></code></a>.</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">array</span>

<span class="k">def</span> <span class="nf">send_fds</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">fds</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sock</span><span class="o">.</span><span class="n">sendmsg</span><span class="p">([</span><span class="n">msg</span><span class="p">],</span> <span class="p">[(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">"i"</span><span class="p">,</span> <span class="n">fds</span><span class="p">))])</span>
</code></pre><p><span class="yiyi-st" id="yiyi-556">Availability: most Unix platforms, possibly others.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-557"><span class="versionmodified">New in version 3.3.</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-558"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.sendfile"><span class="yiyi-st" id="yiyi-559"> <code class="descclassname">socket.</code><code class="descname">sendfile</code><span class="sig-paren">(</span><em>file</em>, <em>offset=0</em>, <em>count=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-560">Send a file until EOF is reached by using high-performance <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal"><span class="pre">os.sendfile</span></code></a> and return the total number of bytes which were sent. </span><span class="yiyi-st" id="yiyi-561"><em>file</em> must be a regular file object opened in binary mode. </span><span class="yiyi-st" id="yiyi-562">If <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal"><span class="pre">os.sendfile</span></code></a> is not available (e.g. </span><span class="yiyi-st" id="yiyi-563">Windows) or <em>file</em> is not a regular file <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> will be used instead. </span><span class="yiyi-st" id="yiyi-564"><em>offset</em> tells from where to start reading the file. </span><span class="yiyi-st" id="yiyi-565">If specified, <em>count</em> is the total number of bytes to transmit as opposed to sending the file until EOF is reached. </span><span class="yiyi-st" id="yiyi-566">File position is updated on return or also in case of error in which case <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal"><span class="pre">file.tell()</span></code></a> can be used to figure out the number of bytes which were sent. </span><span class="yiyi-st" id="yiyi-567">The socket must be of <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_STREAM</span></code></a> type. </span><span class="yiyi-st" id="yiyi-568">Non- blocking sockets are not supported.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-569"><span class="versionmodified">New in version 3.5.</span></span></p></div></dd></dl><dl class="method"><dt id="socket.socket.set_inheritable"><span class="yiyi-st" id="yiyi-570"> <code class="descclassname">socket.</code><code class="descname">set_inheritable</code><span class="sig-paren">(</span><em>inheritable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-571">Set the <a class="reference internal" href="os.html#fd-inheritance"><span>inheritable flag</span></a> of the socket’s file descriptor or socket’s handle.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-572"><span class="versionmodified">New in version 3.4.</span></span></p></div></dd></dl><dl class="method"><dt id="socket.socket.setblocking"><span class="yiyi-st" id="yiyi-573"> <code class="descclassname">socket.</code><code class="descname">setblocking</code><span class="sig-paren">(</span><em>flag</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-574">设置阻塞或非阻塞套接字模式t: 如果 <em>flag</em> 为假, 该套接字设置为无阻塞，否则成阻塞模式.：</span></p><p><span class="yiyi-st" id="yiyi-575">此方法确切来说是 <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a> 调用函数的简写形式:</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-576"><code class="docutils literal"><span class="pre">sock.setblocking(True)</span></code> 相当于 <code class="docutils literal"><span class="pre">sock.settimeout(None)</span></code></span></li><li><span class="yiyi-st" id="yiyi-577"><code class="docutils literal"><span class="pre">sock.setblocking(False)</span></code> 相当于 <code class="docutils literal"><span class="pre">sock.settimeout(0.0)</span></code></span></li></ul></dd></dl><dl class="method"><dt id="socket.socket.settimeout"><span class="yiyi-st" id="yiyi-578"> <code class="descclassname">socket.</code><code class="descname">settimeout</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-579">Set a timeout on blocking socket operations. </span><span class="yiyi-st" id="yiyi-580">The <em>value</em> argument can be a nonnegative floating point number expressing seconds, or <code class="docutils literal"><span class="pre">None</span></code>. </span><span class="yiyi-st" id="yiyi-581">If a non-zero value is given, subsequent socket operations will raise a <a class="reference internal" href="#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal"><span class="pre">timeout</span></code></a> exception if the timeout period <em>value</em> has elapsed before the operation has completed. </span><span class="yiyi-st" id="yiyi-582">If zero is given, the socket is put in non-blocking mode. </span><span class="yiyi-st" id="yiyi-583">If <code class="docutils literal"><span class="pre">None</span></code> is given, the socket is put in blocking mode.</span></p><p><span class="yiyi-st" id="yiyi-584">For further information, please consult the <a class="reference internal" href="#socket-timeouts"><span>notes on socket timeouts</span></a>.</span></p></dd></dl><dl class="method"><dt id="socket.socket.setsockopt"><span class="yiyi-st" id="yiyi-585"> <code class="descclassname">socket.</code><code class="descname">setsockopt</code><span class="sig-paren">(</span><em>level</em>, <em>optname</em>, <em>value</em><span class="sig-paren">)</span></span></dt><dd><p id="index-14"><span class="yiyi-st" id="yiyi-586">Set the value of the given socket option (see the Unix manual page <em class="manpage">setsockopt(2)</em>). </span><span class="yiyi-st" id="yiyi-587">The needed symbolic constants are defined in the <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> module (<code class="xref py py-const docutils literal"><span class="pre">SO_*</span></code> etc.). </span><span class="yiyi-st" id="yiyi-588">The value can be an integer or a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> representing a buffer. </span><span class="yiyi-st" id="yiyi-589">In the latter case it is up to the caller to ensure that the bytestring contains the proper bits (see the optional built-in module <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> for a way to encode C structures as bytestrings).</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-590"><span class="versionmodified">Changed in version 3.5: </span>Writable <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> is now accepted.</span></p></div></dd></dl><dl class="method"><dt id="socket.socket.shutdown"><span class="yiyi-st" id="yiyi-591"> <code class="descclassname">socket.</code><code class="descname">shutdown</code><span class="sig-paren">(</span><em>how</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-592">Shut down one or both halves of the connection. </span><span class="yiyi-st" id="yiyi-593">如果<em>how</em>是<code class="xref py py-const docutils literal"><span class="pre">SHUT_RD</span></code>，则不允许进一步接收。</span><span class="yiyi-st" id="yiyi-594">如果<em>how</em>是<code class="xref py py-const docutils literal"><span class="pre">SHUT_WR</span></code>，则不允许进一步发送。</span><span class="yiyi-st" id="yiyi-595">If <em>how</em> is <code class="xref py py-const docutils literal"><span class="pre">SHUT_RDWR</span></code>, further sends and receives are disallowed.</span></p></dd></dl><dl class="method"><dt id="socket.socket.share"><span class="yiyi-st" id="yiyi-596"> <code class="descclassname">socket.</code><code class="descname">share</code><span class="sig-paren">(</span><em>process_id</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-597">Duplicate a socket and prepare it for sharing with a target process. </span><span class="yiyi-st" id="yiyi-598">The target process must be provided with <em>process_id</em>. </span><span class="yiyi-st" id="yiyi-599">The resulting bytes object can then be passed to the target process using some form of interprocess communication and the socket can be recreated there using <a class="reference internal" href="#socket.fromshare" title="socket.fromshare"><code class="xref py py-func docutils literal"><span class="pre">fromshare()</span></code></a>. </span><span class="yiyi-st" id="yiyi-600">Once this method has been called, it is safe to close the socket since the operating system has already duplicated it for the target process.</span></p><p><span class="yiyi-st" id="yiyi-601">Availability: Windows.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-602"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-603">Note that there are no methods <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code>; use <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> and <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> without <em>flags</em> argument instead.</span></p><p><span class="yiyi-st" id="yiyi-604">Socket objects also have these (read-only) attributes that correspond to the values given to the <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-class docutils literal"><span class="pre">socket</span></code></a> constructor.</span></p><dl class="attribute"><dt id="socket.socket.family"><span class="yiyi-st" id="yiyi-605"> <code class="descclassname">socket.</code><code class="descname">family</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-606">The socket family.</span></p></dd></dl><dl class="attribute"><dt id="socket.socket.type"><span class="yiyi-st" id="yiyi-607"> <code class="descclassname">socket.</code><code class="descname">type</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-608">The socket type.</span></p></dd></dl><dl class="attribute"><dt id="socket.socket.proto"><span class="yiyi-st" id="yiyi-609"> <code class="descclassname">socket.</code><code class="descname">proto</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-610">The socket protocol.</span></p></dd></dl></div><div class="section" id="notes-on-socket-timeouts"><h2><span class="yiyi-st" id="yiyi-611">18.1.4. </span><span class="yiyi-st" id="yiyi-612">Notes on socket timeouts</span></h2><p><span class="yiyi-st" id="yiyi-613">A socket object can be in one of three modes: blocking, non-blocking, or timeout. </span><span class="yiyi-st" id="yiyi-614">Sockets are by default always created in blocking mode, but this can be changed by calling <a class="reference internal" href="#socket.setdefaulttimeout" title="socket.setdefaulttimeout"><code class="xref py py-func docutils literal"><span class="pre">setdefaulttimeout()</span></code></a>.</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-615">In <em>blocking mode</em>, operations block until complete or the system returns an error (such as connection timed out).</span></li><li><span class="yiyi-st" id="yiyi-616">In <em>non-blocking mode</em>, operations fail (with an error that is unfortunately system-dependent) if they cannot be completed immediately: functions from the <a class="reference internal" href="select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal"><span class="pre">select</span></code></a> can be used to know when and whether a socket is available for reading or writing.</span></li><li><span class="yiyi-st" id="yiyi-617">In <em>timeout mode</em>, operations fail if they cannot be completed within the timeout specified for the socket (they raise a <a class="reference internal" href="#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal"><span class="pre">timeout</span></code></a> exception) or if the system returns an error.</span></li></ul><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-618">Note</span></p><p class="last"><span class="yiyi-st" id="yiyi-619">At the operating system level, sockets in <em>timeout mode</em> are internally set in non-blocking mode. </span><span class="yiyi-st" id="yiyi-620">Also, the blocking and timeout modes are shared between file descriptors and socket objects that refer to the same network endpoint. </span><span class="yiyi-st" id="yiyi-621">This implementation detail can have visible consequences if e.g. </span><span class="yiyi-st" id="yiyi-622">you decide to use the <a class="reference internal" href="#socket.socket.fileno" title="socket.socket.fileno"><code class="xref py py-meth docutils literal"><span class="pre">fileno()</span></code></a> of a socket.</span></p></div><div class="section" id="timeouts-and-the-connect-method"><h3><span class="yiyi-st" id="yiyi-623">18.1.4.1. </span><span class="yiyi-st" id="yiyi-624">Timeouts and the <code class="docutils literal"><span class="pre">connect</span></code> method</span></h3><p><span class="yiyi-st" id="yiyi-625">The <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a> operation is also subject to the timeout setting, and in general it is recommended to call <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a> before calling <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a> or pass a timeout parameter to <a class="reference internal" href="#socket.create_connection" title="socket.create_connection"><code class="xref py py-meth docutils literal"><span class="pre">create_connection()</span></code></a>. </span><span class="yiyi-st" id="yiyi-626">However, the system network stack may also return a connection timeout error of its own regardless of any Python socket timeout setting.</span></p></div><div class="section" id="timeouts-and-the-accept-method"><h3><span class="yiyi-st" id="yiyi-627">18.1.4.2. </span><span class="yiyi-st" id="yiyi-628">Timeouts and the <code class="docutils literal"><span class="pre">accept</span></code> method</span></h3><p><span class="yiyi-st" id="yiyi-629">If <a class="reference internal" href="#socket.getdefaulttimeout" title="socket.getdefaulttimeout"><code class="xref py py-func docutils literal"><span class="pre">getdefaulttimeout()</span></code></a> is not <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>, sockets returned by the <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a> method inherit that timeout. </span><span class="yiyi-st" id="yiyi-630">Otherwise, the behaviour depends on settings of the listening socket:</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-631">if the listening socket is in <em>blocking mode</em> or in <em>timeout mode</em>, the socket returned by <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a> is in <em>blocking mode</em>;</span></li><li><span class="yiyi-st" id="yiyi-632">if the listening socket is in <em>non-blocking mode</em>, whether the socket returned by <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a> is in blocking or non-blocking mode is operating system-dependent. </span><span class="yiyi-st" id="yiyi-633">If you want to ensure cross-platform behaviour, it is recommended you manually override this setting.</span></li></ul></div></div><div class="section" id="example"><h2><span class="yiyi-st" id="yiyi-634">18.1.5. </span><span class="yiyi-st" id="yiyi-635">示例</span></h2><p><span class="yiyi-st" id="yiyi-636">以下是使用TCP/IP协议的四个最小示例程序：一个回显收到的所有数据的服务器（仅为一个客户端提供服务），以及一个使用它的客户端。</span><span class="yiyi-st" id="yiyi-637">请注意，服务器必须顺序执行 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a>、<a class="reference internal" href="#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal"><span class="pre">bind()</span></code></a>、<a class="reference internal" href="#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code></a>、<a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a>（可能重复执行 <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a> 以服务多个客户端），而客户端只需要顺序执行<a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a>、<a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a>。</span><span class="yiyi-st" id="yiyi-638">另请注意，服务器在它正在侦听的套接字上没有<a class="reference internal" href="#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal"><span class="pre">sendall()</span></code></a>/<a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a>，而是在<a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a>返回的新套接字上。</span></p><p><span class="yiyi-st" id="yiyi-639">前两个示例仅支持IPv4。</span></p><pre><code class="language-python"><span></span><span class="c1"># Echo server program</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">''</span>                 <span class="c1"># Symbolic name meaning all available interfaces</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># Arbitrary non-privileged port</span>
<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">conn</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Connected by'</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span> <span class="k">break</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre><pre><code class="language-python"><span></span><span class="c1"># Echo client program</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">'daring.cwi.nl'</span>    <span class="c1"># The remote host</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># The same port as used by the server</span>
<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">b</span><span class="s1">'Hello, world'</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Received'</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</code></pre><p><span class="yiyi-st" id="yiyi-640">接下来的两个示例与上面两个示例相同，但同时支持IPv4和IPv6。</span><span class="yiyi-st" id="yiyi-641">服务器端将监听可用的第一个地址族（其实它应该两者都监听）。</span><span class="yiyi-st" id="yiyi-642">在大多数支持IPv6的系统中，IPv6优先而且服务器可能不接受IPv4流量。</span><span class="yiyi-st" id="yiyi-643">客户端将尝试连接由于名称解析而返回的所有地址，并将流量发送到成功连接的第一个地址。</span></p><pre><code class="language-python"><span></span><span class="c1"># Echo server program</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="kc">None</span>               <span class="c1"># Symbolic name meaning all available interfaces</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># Arbitrary non-privileged port</span>
<span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNSPEC</span><span class="p">,</span>
                              <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AI_PASSIVE</span><span class="p">):</span>
    <span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">canonname</span><span class="p">,</span> <span class="n">sa</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">break</span>
<span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'could not open socket'</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
<span class="k">with</span> <span class="n">conn</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Connected by'</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre><pre><code class="language-python"><span></span><span class="c1"># Echo client program</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">'daring.cwi.nl'</span>    <span class="c1"># The remote host</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># The same port as used by the server</span>
<span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">):</span>
    <span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">canonname</span><span class="p">,</span> <span class="n">sa</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">break</span>
<span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'could not open socket'</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">with</span> <span class="n">s</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">b</span><span class="s1">'Hello, world'</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Received'</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</code></pre><p><span class="yiyi-st" id="yiyi-644">下一个示例演示如何在Windows上使用原始套接字编写非常简单的网络嗅探器。</span><span class="yiyi-st" id="yiyi-645">该示例需要管理员权限才能修改接口：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">socket</span>

<span class="c1"># the public network interface</span>
<span class="n">HOST</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostbyname</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">())</span>

<span class="c1"># create a raw socket and bind it to the public interface</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_IP</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Include IP headers</span>
<span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_IP</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">IP_HDRINCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># receive all packages</span>
<span class="n">s</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SIO_RCVALL</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">RCVALL_ON</span><span class="p">)</span>

<span class="c1"># receive a package</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">65565</span><span class="p">))</span>

<span class="c1"># disabled promiscuous mode</span>
<span class="n">s</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SIO_RCVALL</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">RCVALL_OFF</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-646">The last example shows how to use the socket interface to communicate to a CAN network using the raw socket protocol. </span><span class="yiyi-st" id="yiyi-647">To use CAN with the broadcast manager protocol instead, open a socket with:</span></p><pre><code class="language-python"><span></span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_CAN</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">CAN_BCM</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-648">After binding (<code class="xref py py-const docutils literal"><span class="pre">CAN_RAW</span></code>) or connecting (<a class="reference internal" href="#socket.CAN_BCM" title="socket.CAN_BCM"><code class="xref py py-const docutils literal"><span class="pre">CAN_BCM</span></code></a>) the socket, you can use the <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal"><span class="pre">socket.send()</span></code></a>, and the <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">socket.recv()</span></code></a> operations (and their counterparts) on the socket object as usual.</span></p><p><span class="yiyi-st" id="yiyi-649">This example might require special privileges:</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>


<span class="c1"># CAN frame packing/unpacking (see 'struct can_frame' in &lt;linux/can.h&gt;)</span>

<span class="n">can_frame_fmt</span> <span class="o">=</span> <span class="s2">"=IB3x8s"</span>
<span class="n">can_frame_size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">can_frame_fmt</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">build_can_frame</span><span class="p">(</span><span class="n">can_id</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">can_dlc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">b</span><span class="s1">'</span><span class="se">\x00</span><span class="s1">'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">can_frame_fmt</span><span class="p">,</span> <span class="n">can_id</span><span class="p">,</span> <span class="n">can_dlc</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dissect_can_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="n">can_id</span><span class="p">,</span> <span class="n">can_dlc</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">can_frame_fmt</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">can_id</span><span class="p">,</span> <span class="n">can_dlc</span><span class="p">,</span> <span class="n">data</span><span class="p">[:</span><span class="n">can_dlc</span><span class="p">])</span>


<span class="c1"># create a raw socket and bind it to the 'vcan0' interface</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_CAN</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">CAN_RAW</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">'vcan0'</span><span class="p">,))</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">cf</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="n">can_frame_size</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">'Received: can_id=</span><span class="si">%x</span><span class="s1">, can_dlc=</span><span class="si">%x</span><span class="s1">, data=</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">dissect_can_frame</span><span class="p">(</span><span class="n">cf</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Error sending CAN frame'</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">build_can_frame</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">b</span><span class="s1">'</span><span class="se">\x01\x02\x03</span><span class="s1">'</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Error sending CAN frame'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-650">Running an example several times with too small delay between executions, could lead to this error:</span></p><pre><code class="language-python"><span></span><span class="ne">OSError</span><span class="p">:</span> <span class="p">[</span><span class="n">Errno</span> <span class="mi">98</span><span class="p">]</span> <span class="n">Address</span> <span class="n">already</span> <span class="ow">in</span> <span class="n">use</span>
</code></pre><p><span class="yiyi-st" id="yiyi-651">This is because the previous execution has left the socket in a <code class="docutils literal"><span class="pre">TIME_WAIT</span></code> state, and can’t be immediately reused.</span></p><p><span class="yiyi-st" id="yiyi-652">There is a <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> flag to set, in order to prevent this, <code class="xref py py-data docutils literal"><span class="pre">socket.SO_REUSEADDR</span></code>:</span></p><pre><code class="language-python"><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
</code></pre><p><span class="yiyi-st" id="yiyi-653">the <code class="xref py py-data docutils literal"><span class="pre">SO_REUSEADDR</span></code> flag tells the kernel to reuse a local socket in <code class="docutils literal"><span class="pre">TIME_WAIT</span></code> state, without waiting for its natural timeout to expire.</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-654">See also</span></p><p><span class="yiyi-st" id="yiyi-655">For an introduction to socket programming (in C), see the following papers:</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-656"><em>An Introductory 4.3BSD Interprocess Communication Tutorial</em>, by Stuart Sechrest</span></li><li><span class="yiyi-st" id="yiyi-657"><em>An Advanced 4.3BSD Interprocess Communication Tutorial</em>, by Samuel J. Leffler et al,</span></li></ul><p class="last"><span class="yiyi-st" id="yiyi-658">both in the UNIX Programmer’s Manual, Supplementary Documents 1 (sections PS1:7 and PS1:8). </span><span class="yiyi-st" id="yiyi-659">The platform-specific reference material for the various socket-related system calls are also a valuable source of information on the details of socket semantics. </span><span class="yiyi-st" id="yiyi-660">For Unix, refer to the manual pages; for Windows, see the WinSock (or Winsock 2) specification. </span><span class="yiyi-st" id="yiyi-661">For IPv6-ready APIs, readers may want to refer to <span class="target" id="index-15"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3493.html"><strong>RFC 3493</strong></a> titled Basic Socket Interface Extensions for IPv6.</span></p></div></div></div></div>