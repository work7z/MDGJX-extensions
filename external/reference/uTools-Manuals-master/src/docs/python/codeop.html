<div class="body" role="main"><div class="section" id="module-codeop"><h1><span class="yiyi-st" id="yiyi-10">30.2. <a class="reference internal" href="#module-codeop" title="codeop: Compile (possibly incomplete) Python code."><code class="xref py py-mod docutils literal"><span class="pre">codeop</span></code></a>  - 编译Python代码</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/codeop.py">Lib / codeop.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-codeop" title="codeop: Compile (possibly incomplete) Python code."><code class="xref py py-mod docutils literal"><span class="pre">codeop</span></code></a>模块提供了可以模拟Python read-eval-print循环的实用程序，如在<a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal"><span class="pre">code</span></code></a>模块中所做的那样。</span><span class="yiyi-st" id="yiyi-13">结果，你可能不想直接使用模块；如果你想在你的程序中包含这样一个循环，你可能想使用<a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal"><span class="pre">code</span></code></a>模块。</span></p><p><span class="yiyi-st" id="yiyi-14">这个工作有两个部分：</span></p><ol class="arabic simple"><li><span class="yiyi-st" id="yiyi-15">判断一行Python语句输入是否完成了：简而言之，在后面打印‘<code class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></code>‘或者 ‘<code class="docutils literal"><span class="pre">...</span></code>‘ 。</span></li><li><span class="yiyi-st" id="yiyi-16">记住用户已经输入了哪些未来语句，因此后续输入可以用这些生效编译。</span></li></ol><p><span class="yiyi-st" id="yiyi-17"><a class="reference internal" href="#module-codeop" title="codeop: Compile (possibly incomplete) Python code."><code class="xref py py-mod docutils literal"><span class="pre">codeop</span></code></a>模块提供了一种执行这些操作的方法，以及一种执行这两种操作的方法。</span></p><p><span class="yiyi-st" id="yiyi-18">做只是前者：</span></p><dl class="function"><dt id="codeop.compile_command"><span class="yiyi-st" id="yiyi-19"> <code class="descclassname">codeop.</code><code class="descname">compile_command</code><span class="sig-paren">(</span><em>source</em>, <em>filename="&lt;input&gt;"</em>, <em>symbol="single"</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-20">尝试编译<em>源</em>，它应是一个Python代码字符串，并且如果<em>source</em>是有效的Python代码，则返回一个代码对象。</span><span class="yiyi-st" id="yiyi-21">在这种情况下，代码对象的filename属性将为<em>filename</em>，默认为<code class="docutils literal"><span class="pre">'&lt;input&gt;'</span></code>。</span><span class="yiyi-st" id="yiyi-22">如果<em>source</em>是<em>不是</em>有效的Python代码，但是是有效Python代码的前缀，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-23">如果<em>源</em>有问题，则会引发异常。</span><span class="yiyi-st" id="yiyi-24">如果有无效的Python语法，则会引发<a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code></a>，如果存在无效的字面值，则会引发<a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a>或<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-25">The <em>symbol</em> argument determines whether <em>source</em> is compiled as a statement (<code class="docutils literal"><span class="pre">'single'</span></code>, the default) or as an <a class="reference internal" href="../glossary.html#term-expression"><span class="xref std std-term">expression</span></a> (<code class="docutils literal"><span class="pre">'eval'</span></code>). </span><span class="yiyi-st" id="yiyi-26">任何其他值都会引起<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-27">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-28">可能（但不太可能）解析器在到达源结尾之前停止以成功结果进行语法分析；在这种情况下，可以忽略尾随符号，而不是引起错误。</span><span class="yiyi-st" id="yiyi-29">例如，反斜杠后跟两个换行符后面可能跟随任意的垃圾。</span><span class="yiyi-st" id="yiyi-30">一旦解析器的API更好，这将是固定的。</span></p></div></dd></dl><dl class="class"><dt id="codeop.Compile"><span class="yiyi-st" id="yiyi-31"> <em class="property">class </em><code class="descclassname">codeop.</code><code class="descname">Compile</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-32">这个类的实例具有在声明中与内建函数<a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a>相同的<a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a>方法，但区别在于如果实例编译包含<a class="reference internal" href="__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a>语句，实例“记住”并用所有生效的语句编译所有后续程序文本。</span></p></dd></dl><dl class="class"><dt id="codeop.CommandCompiler"><span class="yiyi-st" id="yiyi-33"> <em class="property">class </em><code class="descclassname">codeop.</code><code class="descname">CommandCompiler</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-34">此类的实例具有与声明中相同的<a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a>方法<a class="reference internal" href="#codeop.compile_command" title="codeop.compile_command"><code class="xref py py-func docutils literal"><span class="pre">compile_command()</span></code></a>；区别在于，如果实例编译包含<code class="docutils literal"><span class="pre">__future__</span></code>语句的程序文本，则实例“记住”并用有效语句编译所有后续程序文本。</span></p></dd></dl></div></div>