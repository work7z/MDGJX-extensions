<div class="body" role="main"><div class="section" id="module-json"><h1><span class="yiyi-st" id="yiyi-10">19.2. <a class="reference internal" href="#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal"><span class="pre">json</span></code></a> - JSON编码器和解码器</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/json/__init__.py">Lib / json / __ init __.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference external" href="http://json.org">JSON (JavaScript Object Notation)</a>, specified by <span class="target" id="index-0"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7159.html"><strong>RFC 7159</strong></a> (which obsoletes <span class="target" id="index-1"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4627.html"><strong>RFC 4627</strong></a>) and by <a class="reference external" href="http://www.ecma-international.org/publications/standards/Ecma-404.htm">ECMA-404</a>, is a lightweight data interchange format inspired by <a class="reference external" href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a> object literal syntax (although it is not a strict subset of JavaScript <a class="footnote-reference" href="#rfc-errata" id="id1">[1]</a> ).</span></p><p><span class="yiyi-st" id="yiyi-13"><a class="reference internal" href="#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal"><span class="pre">json</span></code></a>显示标准库<a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal"><span class="pre">marshal</span></code></a>和<a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>模块的用户熟悉的API。</span></p><p><span class="yiyi-st" id="yiyi-14">对基本Python对象层次结构进行编码：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="s1">'foo'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'bar'</span><span class="p">:</span> <span class="p">(</span><span class="s1">'baz'</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}])</span>
<span class="go">'["foo", {"bar": ["baz", null, 1.0, 2]}]'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="s2">"</span><span class="se">\"</span><span class="s2">foo</span><span class="se">\b</span><span class="s2">ar"</span><span class="p">))</span>
<span class="go">"\"foo\bar"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="s1">'</span><span class="se">\u1234</span><span class="s1">'</span><span class="p">))</span>
<span class="go">"\u1234"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="s1">'</span><span class="se">\\</span><span class="s1">'</span><span class="p">))</span>
<span class="go">"\\"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">"c"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">{"a": 0, "b": 0, "c": 0}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">([</span><span class="s1">'streaming API'</span><span class="p">],</span> <span class="n">io</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">'["streaming API"]'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-15">紧凑编码：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,{</span><span class="s1">'4'</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">'6'</span><span class="p">:</span> <span class="mi">7</span><span class="p">}],</span> <span class="n">separators</span><span class="o">=</span><span class="p">(</span><span class="s1">','</span><span class="p">,</span> <span class="s1">':'</span><span class="p">))</span>
<span class="go">'[1,2,3,{"4":5,"6":7}]'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-16">漂亮的输出：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s1">'4'</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">'6'</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="go">{</span>
<span class="go">    "4": 5,</span>
<span class="go">    "6": 7</span>
<span class="go">}</span>
</code></pre><p><span class="yiyi-st" id="yiyi-17">解码JSON：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="s1">'["foo", {"bar":["baz", null, 1.0, 2]}]'</span><span class="p">)</span>
<span class="go">['foo', {'bar': ['baz', None, 1.0, 2]}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="s1">'"</span><span class="se">\\</span><span class="s1">"foo</span><span class="se">\\</span><span class="s1">bar"'</span><span class="p">)</span>
<span class="go">'"foo\x08ar'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s1">'["streaming API"]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>
<span class="go">['streaming API']</span>
</code></pre><p><span class="yiyi-st" id="yiyi-18">专用JSON对象解码：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">as_complex</span><span class="p">(</span><span class="n">dct</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="s1">'__complex__'</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s1">'real'</span><span class="p">],</span> <span class="n">dct</span><span class="p">[</span><span class="s1">'imag'</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">dct</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="s1">'{"__complex__": true, "real": 1, "imag": 2}'</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">object_hook</span><span class="o">=</span><span class="n">as_complex</span><span class="p">)</span>
<span class="go">(1+2j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="s1">'1.1'</span><span class="p">,</span> <span class="n">parse_float</span><span class="o">=</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">)</span>
<span class="go">Decimal('1.1')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-19">扩展<a class="reference internal" href="#json.JSONEncoder" title="json.JSONEncoder"><code class="xref py py-class docutils literal"><span class="pre">JSONEncoder</span></code></a>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ComplexEncoder</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">JSONEncoder</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">imag</span><span class="p">]</span>
<span class="gp">... </span>        <span class="c1"># Let the base class default method raise the TypeError</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">JSONEncoder</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">ComplexEncoder</span><span class="p">)</span>
<span class="go">'[2.0, 1.0]'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ComplexEncoder</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">'[2.0, 1.0]'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">ComplexEncoder</span><span class="p">()</span><span class="o">.</span><span class="n">iterencode</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">))</span>
<span class="go">['[2.0', ', 1.0', ']']</span>
</code></pre><p><span class="yiyi-st" id="yiyi-20">使用<a class="reference internal" href="#module-json.tool" title="json.tool: A command line to validate and pretty-print JSON."><code class="xref py py-mod docutils literal"><span class="pre">json.tool</span></code></a>从shell验证和pretty-print：</span></p><div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="nb">echo</span> <span class="s1">'{"json":"obj"}'</span> <span class="p">|</span> python -m json.tool
<span class="o">{</span>
    <span class="s2">"json"</span>: <span class="s2">"obj"</span>
<span class="o">}</span>
$ <span class="nb">echo</span> <span class="s1">'{1.2:3.4}'</span> <span class="p">|</span> python -m json.tool
Expecting property name enclosed in double quotes: line <span class="m">1</span> column <span class="m">2</span> <span class="o">(</span>char 1<span class="o">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-21">有关详细文档，请参见<a class="reference internal" href="#json-commandline"><span>Command Line Interface</span></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-22">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-23">JSON是<a class="reference external" href="http://yaml.org/">YAML</a> 1.2的子集。</span><span class="yiyi-st" id="yiyi-24">由此模块的默认设置（特别是默认的<em>分隔符</em>值）生成的JSON也是YAML 1.0和1.1的子集。</span><span class="yiyi-st" id="yiyi-25">因此，该模块也可以用作YAML串行器。</span></p></div><div class="section" id="basic-usage"><h2><span class="yiyi-st" id="yiyi-26">19.2.1. </span><span class="yiyi-st" id="yiyi-27">基本用法</span></h2><dl class="function"><dt id="json.dump"><span class="yiyi-st" id="yiyi-28"> <code class="descclassname">json.</code><code class="descname">dump</code><span class="sig-paren">(</span><em>obj</em>, <em>fp</em>, <em>skipkeys=False</em>, <em>ensure_ascii=True</em>, <em>check_circular=True</em>, <em>allow_nan=True</em>, <em>cls=None</em>, <em>indent=None</em>, <em>separators=None</em>, <em>default=None</em>, <em>sort_keys=False</em>, <em>**kw</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-29">将<em>obj</em>序列化为<em>fp</em>（a <code class="docutils literal"><span class="pre">.write()</span></code>  - 支持<a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">file-like object</span></a>使用此<a class="reference internal" href="#py-to-json-table"><span>conversion table</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-30">如果 <em>skipkeys</em> 的值为 true (默认为: <code class="docutils literal"><span class="pre">False</span></code>), 那么不是基本类型 (<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a>, <code class="docutils literal"><span class="pre">None</span></code>)的字典键将会被跳过, 而不是引发一个 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 异常.</span></p><p><span class="yiyi-st" id="yiyi-31"><a class="reference internal" href="#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal"><span class="pre">json</span></code></a>模块总是产生<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>对象，而不是<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-32">因此，<code class="docutils literal"><span class="pre">fp.write()</span></code>必须支持<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>输入。</span></p><p><span class="yiyi-st" id="yiyi-33">如果<em>ensure_ascii</em>为true（这是默认值），则输出将保证所有传入的非ASCII字符都转义。</span><span class="yiyi-st" id="yiyi-34">如果<em>ensure_ascii</em>为false，则这些字符将按原样输出。</span></p><p><span class="yiyi-st" id="yiyi-35">如果<em>check_circular</em>为false（默认值：<code class="docutils literal"><span class="pre">True</span></code>），则将跳过容器类型的循环引用检查，循环引用将导致<a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-36">如果<em>allow_nan</em>为false（默认值：<code class="docutils literal"><span class="pre">True</span></code>），则将是<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>序列化超出范围<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>值（<code class="docutils literal"><span class="pre">nan</span></code>，<code class="docutils literal"><span class="pre">inf</span></code>，<code class="docutils literal"><span class="pre">-inf</span></code>），严格遵守JSON规范。</span><span class="yiyi-st" id="yiyi-37">如果<em>allow_nan</em>为true，则将使用与其等效的JavaScript代码（<code class="docutils literal"><span class="pre">NaN</span></code>，<code class="docutils literal"><span class="pre">Infinity</span></code>，<code class="docutils literal"><span class="pre">-Infinity</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-38">如果<em>indent</em>是非负整数或字符串，那么JSON数组元素和对象成员将以该缩进级别打印。</span><span class="yiyi-st" id="yiyi-39">缩进级别0，负数或<code class="docutils literal"><span class="pre">""</span></code>将只插入换行符。</span><span class="yiyi-st" id="yiyi-40"><code class="docutils literal"><span class="pre">None</span></code>（默认值）选择最紧凑的表示。</span><span class="yiyi-st" id="yiyi-41">使用正整数缩进缩进，每个级别有许多空格。</span><span class="yiyi-st" id="yiyi-42">如果<em>缩进</em>是字符串（例如<code class="docutils literal"><span class="pre">"\t"</span></code>），则该字符串用于缩进每个级别。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-43"><span class="versionmodified">在版本3.2中更改：</span>允许<em>缩进</em>的字符串以及整数。</span></p></div><p><span class="yiyi-st" id="yiyi-44">如果指定，<em>分隔符</em>应为<code class="docutils literal"><span class="pre">（item_separator，</span> <span class="pre">key_separator）</span></code>元组。</span><span class="yiyi-st" id="yiyi-45">The default is <code class="docutils literal"><span class="pre">(',</span> <span class="pre">',</span> <span class="pre">':</span> <span class="pre">')</span></code> if <em>indent</em> is <code class="docutils literal"><span class="pre">None</span></code> and <code class="docutils literal"><span class="pre">(',',</span> <span class="pre">':</span> <span class="pre">')</span></code> otherwise. </span><span class="yiyi-st" id="yiyi-46">要获得最紧凑的JSON表示，应指定<code class="docutils literal"><span class="pre">（'，'，</span> <span class="pre">'：'）</span></code></span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-47"><span class="versionmodified">在版本3.4中更改：</span>使用<code class="docutils literal"><span class="pre">（'，'，</span> <span class="pre">'：</span> <span class="pre">'）作为默认值，如果<em>缩进</em>不是<code class="docutils literal"><span class="pre">None</span></code>。</span></code></span></p></div><p><span class="yiyi-st" id="yiyi-48">如果指定，<em>默认</em>应该是一个函数，为不能被序列化的对象调用。</span><span class="yiyi-st" id="yiyi-49">它应该返回对象的JSON可编码版本或引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-50">如果未指定，则会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-51">如果<em>sort_keys</em>为真（默认值：<code class="docutils literal"><span class="pre">False</span></code>），则字典的输出将按键排序。</span></p><p><span class="yiyi-st" id="yiyi-52">要使用自定义<a class="reference internal" href="#json.JSONEncoder" title="json.JSONEncoder"><code class="xref py py-class docutils literal"><span class="pre">JSONEncoder</span></code></a>子类（例如</span><span class="yiyi-st" id="yiyi-53">覆盖<code class="xref py py-meth docutils literal"><span class="pre">default()</span></code>方法以序列化其他类型），使用<em>cls</em> kwarg指定它；否则使用<a class="reference internal" href="#json.JSONEncoder" title="json.JSONEncoder"><code class="xref py py-class docutils literal"><span class="pre">JSONEncoder</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="json.dumps"><span class="yiyi-st" id="yiyi-54"> <code class="descclassname">json.</code><code class="descname">dumps</code><span class="sig-paren">(</span><em>obj</em>, <em>skipkeys=False</em>, <em>ensure_ascii=True</em>, <em>check_circular=True</em>, <em>allow_nan=True</em>, <em>cls=None</em>, <em>indent=None</em>, <em>separators=None</em>, <em>default=None</em>, <em>sort_keys=False</em>, <em>**kw</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-55">使用此<a class="reference internal" href="#py-to-json-table"><span>conversion table</span></a>将<em>obj</em>序列化为JSON格式的<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>。</span><span class="yiyi-st" id="yiyi-56">参数具有与<a class="reference internal" href="#json.dump" title="json.dump"><code class="xref py py-func docutils literal"><span class="pre">dump()</span></code></a>中相同的含义。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-57">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-58">Unlike <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a> and <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal"><span class="pre">marshal</span></code></a>, JSON is not a framed protocol, so trying to serialize multiple objects with repeated calls to <a class="reference internal" href="#json.dump" title="json.dump"><code class="xref py py-func docutils literal"><span class="pre">dump()</span></code></a> using the same <em>fp</em> will result in an invalid JSON file.</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-59">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-60">JSON的键/值对中的键始终为<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>类型。</span><span class="yiyi-st" id="yiyi-61">当字典转换为JSON时，字典的所有键都会强制转换为字符串。</span><span class="yiyi-st" id="yiyi-62">因此，如果字典转换为JSON然后回到字典，字典可能不等于原始字典。</span><span class="yiyi-st" id="yiyi-63">也就是说，如果x具有非字符串键，则<code class="docutils literal"><span class="pre">载入（dumps（x））</span> <span class="pre">！=</span> <span class="pre">x</span> </code></span></p></div></dd></dl><dl class="function"><dt id="json.load"><span class="yiyi-st" id="yiyi-64"> <code class="descclassname">json.</code><code class="descname">load</code><span class="sig-paren">(</span><em>fp</em>, <em>cls=None</em>, <em>object_hook=None</em>, <em>parse_float=None</em>, <em>parse_int=None</em>, <em>parse_constant=None</em>, <em>object_pairs_hook=None</em>, <em>**kw</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-65">使用 <a class="reference internal" href="#json-to-py-table"><span>这个转换表</span></a> 将 <em>fp</em> (一个包含 JSON 文档并支持 <code class="docutils literal"><span class="pre">.read()</span></code>方法的 <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">file-like object</span></a> ) 反序列化为一个python对象。</span></p><p><span class="yiyi-st" id="yiyi-66"><em>object_hook</em>是一个可选的函数，它将被任何对象字面值解码（<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>）的结果调用。</span><span class="yiyi-st" id="yiyi-67">将使用<em>object_hook</em>的返回值而不是<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>。</span><span class="yiyi-st" id="yiyi-68">这个功能可以用于实现自定义的解码器（例如，</span><span class="yiyi-st" id="yiyi-69"><a class="reference external" href="http://www.jsonrpc.org">JSON-RPC</a>类提示）。</span></p><p><span class="yiyi-st" id="yiyi-70"><em>object_pairs_hook</em>是一个可选的函数，它将使用任何对象字面值的结果进行调用，并使用对的有序列表进行解码。</span><span class="yiyi-st" id="yiyi-71">将使用<em>object_pairs_hook</em>的返回值，而不是<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>。</span><span class="yiyi-st" id="yiyi-72">该特征可以用于实现依赖于键和值对被解码的顺序的自定义解码器（例如，<a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-func docutils literal"><span class="pre">collections.OrderedDict()</span></code></a>将记住插入的顺序）。</span><span class="yiyi-st" id="yiyi-73">如果还定义了<em>object_hook</em>，则<em>object_pairs_hook</em>优先。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-74"><span class="versionmodified">在版本3.1中已更改：</span>添加对<em>object_pairs_hook</em>的支持。</span></p></div><p><span class="yiyi-st" id="yiyi-75"><em>parse_float</em>（如果指定）将使用要解码的每个JSON浮点的字符串进行调用。</span><span class="yiyi-st" id="yiyi-76">默认情况下，这相当于<code class="docutils literal"><span class="pre">float(num_str)</span></code>。</span><span class="yiyi-st" id="yiyi-77">这可以用于使用另一个数据类型或解析器为JSON浮动（例如。</span><span class="yiyi-st" id="yiyi-78"><a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a>）。</span></p><p><span class="yiyi-st" id="yiyi-79"><em>parse_int</em>（如果指定）将使用要解码的每个JSON int的字符串进行调用。</span><span class="yiyi-st" id="yiyi-80">默认情况下，这相当于<code class="docutils literal"><span class="pre">int(num_str)</span></code>。</span><span class="yiyi-st" id="yiyi-81">这可以用于使用另一个数据类型或解析器为JSON整数（例如。</span><span class="yiyi-st" id="yiyi-82"><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>）。</span></p><p><span class="yiyi-st" id="yiyi-83"><em>parse_constant</em>如果指定，将使用以下字符串之一调用：<code class="docutils literal"><span class="pre">'-Infinity'</span></code>，<code class="docutils literal"><span class="pre">'Infinity'</span></code>，<code class="docutils literal"><span class="pre">'NaN'</span></code>。</span><span class="yiyi-st" id="yiyi-84">这可以用于引发异常，如果遇到无效的JSON数字。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-85"><span class="versionmodified">在版本3.1中更改：</span> <em>parse_constant</em>不会在“null”，“true”和“false”上调用。</span></p></div><p><span class="yiyi-st" id="yiyi-86">要使用自定义<a class="reference internal" href="#json.JSONDecoder" title="json.JSONDecoder"><code class="xref py py-class docutils literal"><span class="pre">JSONDecoder</span></code></a>子类，请使用<code class="docutils literal"><span class="pre">cls</span></code> kwarg；否则使用<a class="reference internal" href="#json.JSONDecoder" title="json.JSONDecoder"><code class="xref py py-class docutils literal"><span class="pre">JSONDecoder</span></code></a>。</span><span class="yiyi-st" id="yiyi-87">额外的关键字参数将被传递给类的构造函数。</span></p><p><span class="yiyi-st" id="yiyi-88">如果反序列化的数据不是有效的JSON文档，则会引发<a class="reference internal" href="#json.JSONDecodeError" title="json.JSONDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">JSONDecodeError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="json.loads"><span class="yiyi-st" id="yiyi-89"> <code class="descclassname">json.</code><code class="descname">loads</code><span class="sig-paren">(</span><em>s</em>, <em>encoding=None</em>, <em>cls=None</em>, <em>object_hook=None</em>, <em>parse_float=None</em>, <em>parse_int=None</em>, <em>parse_constant=None</em>, <em>object_pairs_hook=None</em>, <em>**kw</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">使用此<a class="reference internal" href="#json-to-py-table"><span>conversion table</span></a>将包含JSON文档的<em>s</em>（a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>实例）解压缩为Python对象。</span></p><p><span class="yiyi-st" id="yiyi-91">其他参数与<a class="reference internal" href="#json.load" title="json.load"><code class="xref py py-func docutils literal"><span class="pre">load()</span></code></a>中含义相同，除了<em>编码</em>，它被忽略和弃用。</span></p><p><span class="yiyi-st" id="yiyi-92">如果反序列化的数据不是有效的JSON文档，则会引发<a class="reference internal" href="#json.JSONDecodeError" title="json.JSONDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">JSONDecodeError</span></code></a>。</span></p></dd></dl></div><div class="section" id="encoders-and-decoders"><h2><span class="yiyi-st" id="yiyi-93">19.2.2. </span><span class="yiyi-st" id="yiyi-94">Encoders and Decoders</span></h2><dl class="class"><dt id="json.JSONDecoder"><span class="yiyi-st" id="yiyi-95"> <em class="property">class </em><code class="descclassname">json.</code><code class="descname">JSONDecoder</code><span class="sig-paren">(</span><em>object_hook=None</em>, <em>parse_float=None</em>, <em>parse_int=None</em>, <em>parse_constant=None</em>, <em>strict=True</em>, <em>object_pairs_hook=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-96">简单的JSON解码器。</span></p><p><span class="yiyi-st" id="yiyi-97">默认情况下，在解码时执行以下翻译：</span></p><table border="1" class="docutils" id="json-to-py-table"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-98">JSON</span></th><th class="head"><span class="yiyi-st" id="yiyi-99">Python</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-100">object</span></td><td><span class="yiyi-st" id="yiyi-101">dict</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-102">数组</span></td><td><span class="yiyi-st" id="yiyi-103">列表</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-104">串</span></td><td><span class="yiyi-st" id="yiyi-105">str</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-106">number（int）</span></td><td><span class="yiyi-st" id="yiyi-107">int</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-108">数字（实数）</span></td><td><span class="yiyi-st" id="yiyi-109">浮动</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-110">真正</span></td><td><span class="yiyi-st" id="yiyi-111">真正</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-112">假</span></td><td><span class="yiyi-st" id="yiyi-113">假</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-114">空值</span></td><td><span class="yiyi-st" id="yiyi-115">没有</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-116">它还将<code class="docutils literal"><span class="pre">NaN</span></code>，<code class="docutils literal"><span class="pre">Infinity</span></code>和<code class="docutils literal"><span class="pre">-Infinity</span></code>理解为它们对应的<code class="docutils literal"><span class="pre">float</span></code>值， 。</span></p><p><span class="yiyi-st" id="yiyi-117"><em>object_hook</em>（如果指定）将使用每个解析的JSON对象的结果进行调用，其返回值将用于替换给定的<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>。</span><span class="yiyi-st" id="yiyi-118">这可以用于提供定制反序列化（例如，</span><span class="yiyi-st" id="yiyi-119">以支持JSON-RPC类提示）。</span></p><p><span class="yiyi-st" id="yiyi-120"><em>object_pairs_hook</em>（如果指定）将使用对的有序列表解码的每个JSON对象的结果进行调用。</span><span class="yiyi-st" id="yiyi-121">将使用<em>object_pairs_hook</em>的返回值，而不是<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>。</span><span class="yiyi-st" id="yiyi-122">该特征可以用于实现依赖于键和值对被解码的顺序的自定义解码器（例如，<a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-func docutils literal"><span class="pre">collections.OrderedDict()</span></code></a>将记住插入的顺序）。</span><span class="yiyi-st" id="yiyi-123">如果还定义了<em>object_hook</em>，则<em>object_pairs_hook</em>优先。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-124"><span class="versionmodified">在版本3.1中已更改：</span>添加对<em>object_pairs_hook</em>的支持。</span></p></div><p><span class="yiyi-st" id="yiyi-125"><em>parse_float</em>（如果指定）将使用要解码的每个JSON浮点的字符串进行调用。</span><span class="yiyi-st" id="yiyi-126">默认情况下，这相当于<code class="docutils literal"><span class="pre">float(num_str)</span></code>。</span><span class="yiyi-st" id="yiyi-127">这可以用于使用另一个数据类型或解析器为JSON浮动（例如。</span><span class="yiyi-st" id="yiyi-128"><a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a>）。</span></p><p><span class="yiyi-st" id="yiyi-129"><em>parse_int</em>（如果指定）将使用要解码的每个JSON int的字符串进行调用。</span><span class="yiyi-st" id="yiyi-130">默认情况下，这相当于<code class="docutils literal"><span class="pre">int(num_str)</span></code>。</span><span class="yiyi-st" id="yiyi-131">这可以用于使用另一个数据类型或解析器为JSON整数（例如。</span><span class="yiyi-st" id="yiyi-132"><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>）。</span></p><p><span class="yiyi-st" id="yiyi-133"><em>parse_constant</em>如果指定，将使用以下字符串之一调用：<code class="docutils literal"><span class="pre">'-Infinity'</span></code>，<code class="docutils literal"><span class="pre">'Infinity'</span></code>，<code class="docutils literal"><span class="pre">'NaN'</span></code>，<code class="docutils literal"><span class="pre">'null'</span></code>，<code class="docutils literal"><span class="pre">'true'</span></code>，<code class="docutils literal"><span class="pre">'false'</span></code>。</span><span class="yiyi-st" id="yiyi-134">这可以用于引发异常，如果遇到无效的JSON数字。</span></p><p><span class="yiyi-st" id="yiyi-135">如果<em>strict</em>为false（<code class="docutils literal"><span class="pre">True</span></code>是默认值），则在字符串中将允许控制字符。</span><span class="yiyi-st" id="yiyi-136">在此上下文中的控制字符是具有在0-31范围内的字符代码的字符，包括<code class="docutils literal"><span class="pre">'\t'</span></code>（tab），<code class="docutils literal"><span class="pre">'\n'</span></code>，<code class="docutils literal"><span class="pre">'\r'</span></code>和<code class="docutils literal"><span class="pre">'\0'</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-137">如果反序列化的数据不是有效的JSON文档，则会引发<a class="reference internal" href="#json.JSONDecodeError" title="json.JSONDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">JSONDecodeError</span></code></a>。</span></p><dl class="method"><dt id="json.JSONDecoder.decode"><span class="yiyi-st" id="yiyi-138"> <code class="descname">decode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-139">返回<em>s</em>（包含JSON文档的<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>实例）的Python表示形式。</span></p><p><span class="yiyi-st" id="yiyi-140">如果给定的JSON文档无效，则会引发<a class="reference internal" href="#json.JSONDecodeError" title="json.JSONDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">JSONDecodeError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="json.JSONDecoder.raw_decode"><span class="yiyi-st" id="yiyi-141"> <code class="descname">raw_decode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-142">从<em>s</em>（以JSON文档开头的<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>）解码JSON文档，并返回一个2元组的Python表示形式和<em>s  t4 &gt;文档结束。</em></span></p><p><span class="yiyi-st" id="yiyi-143">这可以用于从可能在末尾有无关数据的字符串解码JSON文档。</span></p></dd></dl></dd></dl><dl class="class"><dt id="json.JSONEncoder"><span class="yiyi-st" id="yiyi-144"> <em class="property">class </em><code class="descclassname">json.</code><code class="descname">JSONEncoder</code><span class="sig-paren">(</span><em>skipkeys=False</em>, <em>ensure_ascii=True</em>, <em>check_circular=True</em>, <em>allow_nan=True</em>, <em>sort_keys=False</em>, <em>indent=None</em>, <em>separators=None</em>, <em>default=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-145">用于Python数据结构的可扩展JSON编码器。</span></p><p><span class="yiyi-st" id="yiyi-146">默认情况下支持以下对象和类型：</span></p><table border="1" class="docutils" id="py-to-json-table"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-147">Python</span></th><th class="head"><span class="yiyi-st" id="yiyi-148">JSON</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-149">命令</span></td><td><span class="yiyi-st" id="yiyi-150">目的</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-151">列表，元组</span></td><td><span class="yiyi-st" id="yiyi-152">数组</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-153">str</span></td><td><span class="yiyi-st" id="yiyi-154">串</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-155">int，float，int-＆float-derived枚举</span></td><td><span class="yiyi-st" id="yiyi-156">数</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-157">真正</span></td><td><span class="yiyi-st" id="yiyi-158">真正</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-159">假</span></td><td><span class="yiyi-st" id="yiyi-160">假</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-161">没有</span></td><td><span class="yiyi-st" id="yiyi-162">空值</span></td></tr></tbody></table><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-163"><span class="versionmodified">在版本3.4中更改：</span>添加了对int和float派生的Enum类的支持。</span></p></div><p><span class="yiyi-st" id="yiyi-164">要扩展它以识别其他对象，使用另一个返回<code class="docutils literal"><span class="pre">o</span></code>可序列化对象的方法，子类化并实现<a class="reference internal" href="#json.JSONEncoder.default" title="json.JSONEncoder.default"><code class="xref py py-meth docutils literal"><span class="pre">default()</span></code></a>方法，否则应调用超类实现（to引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>）。</span></p><p><span class="yiyi-st" id="yiyi-165">如果<em>skipkeys</em>为false（默认值），则会尝试对非str，int，float或None的键进行编码的<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-166">如果<em>skipkeys</em>为true，则此类项目将被直接跳过。</span></p><p><span class="yiyi-st" id="yiyi-167">如果<em>ensure_ascii</em>为true（默认值），则输出将保证所有传入的非ASCII字符都转义。</span><span class="yiyi-st" id="yiyi-168">如果<em>ensure_ascii</em>为false，则这些字符将按原样输出。</span></p><p><span class="yiyi-st" id="yiyi-169">如果<em>check_circular</em>为true（默认值），则在编码期间将检查列表，diction和自定义编码对象的循环引用，以防止无限递归（这将导致<a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a></span><span class="yiyi-st" id="yiyi-170">否则，不进行这样的检查。</span></p><p><span class="yiyi-st" id="yiyi-171">If <em>allow_nan</em> is true (the default), then <code class="docutils literal"><span class="pre">NaN</span></code>, <code class="docutils literal"><span class="pre">Infinity</span></code>, and <code class="docutils literal"><span class="pre">-Infinity</span></code> will be encoded as such. </span><span class="yiyi-st" id="yiyi-172">此行为不符合JSON规范，但与大多数基于JavaScript的编码器和解码器一致。</span><span class="yiyi-st" id="yiyi-173">否则，将对此类浮点进行编码为<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-174">如果<em>sort_keys</em>为真（默认值：<code class="docutils literal"><span class="pre">False</span></code>），那么字典的输出将按键排序；这对于回归测试非常有用，以确保JSON序列化可以在每天的基础上进行比较。</span></p><p><span class="yiyi-st" id="yiyi-175">如果<em>缩进</em>是非负整数或字符串，那么JSON数组元素和对象成员将以该缩进级别打印。</span><span class="yiyi-st" id="yiyi-176">缩进级别为0，负数或<code class="docutils literal"><span class="pre">""</span></code>将只插入换行符。</span><span class="yiyi-st" id="yiyi-177"><code class="docutils literal"><span class="pre">None</span></code>（默认值）选择最紧凑的表示。</span><span class="yiyi-st" id="yiyi-178">使用正整数缩进缩进，每个级别有许多空格。</span><span class="yiyi-st" id="yiyi-179">如果<em>缩进</em>是字符串（例如<code class="docutils literal"><span class="pre">"\t"</span></code>），则该字符串用于缩进每个级别。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-180"><span class="versionmodified">在版本3.2中更改：</span>允许<em>缩进</em>的字符串以及整数。</span></p></div><p><span class="yiyi-st" id="yiyi-181">如果指定，<em>分隔符</em>应为<code class="docutils literal"><span class="pre">（item_separator，</span> <span class="pre">key_separator）</span></code>元组。</span><span class="yiyi-st" id="yiyi-182">The default is <code class="docutils literal"><span class="pre">(',</span> <span class="pre">',</span> <span class="pre">':</span> <span class="pre">')</span></code> if <em>indent</em> is <code class="docutils literal"><span class="pre">None</span></code> and <code class="docutils literal"><span class="pre">(',',</span> <span class="pre">':</span> <span class="pre">')</span></code> otherwise. </span><span class="yiyi-st" id="yiyi-183">要获得最紧凑的JSON表示，应指定<code class="docutils literal"><span class="pre">（'，'，</span> <span class="pre">'：'）</span></code></span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-184"><span class="versionmodified">在版本3.4中更改：</span>使用<code class="docutils literal"><span class="pre">（'，'，</span> <span class="pre">'：</span> <span class="pre">'）作为默认值，如果<em>缩进</em>不是<code class="docutils literal"><span class="pre">None</span></code>。</span></code></span></p></div><p><span class="yiyi-st" id="yiyi-185">如果指定，<em>默认</em>应该是一个函数，为不能被序列化的对象调用。</span><span class="yiyi-st" id="yiyi-186">它应该返回对象的JSON可编码版本或引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-187">如果未指定，则会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p><dl class="method"><dt id="json.JSONEncoder.default"><span class="yiyi-st" id="yiyi-188"> <code class="descname">default</code><span class="sig-paren">(</span><em>o</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-189">在子类中实现此方法，以便为<em>o</em>返回可序列化对象，或调用基本实现（引入<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>）。</span></p><p><span class="yiyi-st" id="yiyi-190">例如，要支持任意迭代器，您可以实现默认像这样：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
   <span class="k">try</span><span class="p">:</span>
       <span class="n">iterable</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
   <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
       <span class="k">pass</span>
   <span class="k">else</span><span class="p">:</span>
       <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
   <span class="c1"># Let the base class default method raise the TypeError</span>
   <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">JSONEncoder</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
</code></pre></dd></dl><dl class="method"><dt id="json.JSONEncoder.encode"><span class="yiyi-st" id="yiyi-191"> <code class="descname">encode</code><span class="sig-paren">(</span><em>o</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-192">返回Python数据结构（<em>o</em>）的JSON字符串表示形式。</span><span class="yiyi-st" id="yiyi-193">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">JSONEncoder</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">({</span><span class="s2">"foo"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"bar"</span><span class="p">,</span> <span class="s2">"baz"</span><span class="p">]})</span>
<span class="go">'{"foo": ["bar", "baz"]}'</span>
</code></pre></dd></dl><dl class="method"><dt id="json.JSONEncoder.iterencode"><span class="yiyi-st" id="yiyi-194"> <code class="descname">iterencode</code><span class="sig-paren">(</span><em>o</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-195">编码给定对象<em>o</em>，并将每个字符串表示形式设置为可用。</span><span class="yiyi-st" id="yiyi-196">例如：</span></p><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">json</span><span class="o">.</span><span class="n">JSONEncoder</span><span class="p">()</span><span class="o">.</span><span class="n">iterencode</span><span class="p">(</span><span class="n">bigobject</span><span class="p">):</span>
    <span class="n">mysocket</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</code></pre></dd></dl></dd></dl></div><div class="section" id="exceptions"><h2><span class="yiyi-st" id="yiyi-197">19.2.3. </span><span class="yiyi-st" id="yiyi-198">Exceptions</span></h2><dl class="exception"><dt id="json.JSONDecodeError"><span class="yiyi-st" id="yiyi-199"> <em class="property">exception </em><code class="descclassname">json.</code><code class="descname">JSONDecodeError</code><span class="sig-paren">(</span><em>msg</em>, <em>doc</em>, <em>pos</em>, <em>end=None</em><span class="sig-paren">)</span></span></dt><dd><span class="yiyi-st" id="yiyi-201"><blockquote> <div><p>Subclass of <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> with the following additional attributes:</p> <dl class="attribute"> <dt id="json.JSONDecodeError.msg"> <code class="descname">msg</code></dt> <dd><p>The unformatted error message.</p> </dd></dl> <dl class="attribute"> <dt id="json.JSONDecodeError.doc"> <code class="descname">doc</code></dt> <dd><p>The JSON document being parsed.</p> </dd></dl> <dl class="attribute"> <dt id="json.JSONDecodeError.pos"> <code class="descname">pos</code></dt> <dd><p>The start index of <em>doc</em> where parsing failed.</p> </dd></dl> <dl class="attribute"> <dt id="json.JSONDecodeError.lineno"> <code class="descname">lineno</code></dt> <dd><p>The line corresponding to <em>pos</em>.</p> </dd></dl> <dl class="attribute"> <dt id="json.JSONDecodeError.colno"> <code class="descname">colno</code></dt> <dd><p>The column corresponding to <em>pos</em>.</p> </dd></dl> </div></blockquote></span><div class="versionadded"><p><span class="yiyi-st" id="yiyi-200"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="standard-compliance-and-interoperability"><h2><span class="yiyi-st" id="yiyi-202">19.2.4. </span><span class="yiyi-st" id="yiyi-203">Standard Compliance and Interoperability</span></h2><p><span class="yiyi-st" id="yiyi-204">JSON格式由<span class="target" id="index-2"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc7159.html"><strong>RFC 7159</strong></a>和<a class="reference external" href="http://www.ecma-international.org/publications/standards/Ecma-404.htm">ECMA-404</a>指定。</span><span class="yiyi-st" id="yiyi-205">本节详细说明此模块符合RFC的级别。</span><span class="yiyi-st" id="yiyi-206">为了简单起见，不考虑<a class="reference internal" href="#json.JSONEncoder" title="json.JSONEncoder"><code class="xref py py-class docutils literal"><span class="pre">JSONEncoder</span></code></a>和<a class="reference internal" href="#json.JSONDecoder" title="json.JSONDecoder"><code class="xref py py-class docutils literal"><span class="pre">JSONDecoder</span></code></a>子类以及除明确提及的参数之外的参数。</span></p><p><span class="yiyi-st" id="yiyi-207">此模块以严格的方式不符合RFC，实现一些有效的JavaScript但不是有效的JSON的扩展。</span><span class="yiyi-st" id="yiyi-208">尤其是：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-209">接受和输出无限和NaN数值；</span></li><li><span class="yiyi-st" id="yiyi-210">接受对象内的重复名称，并且仅使用最后名称/值对的值。</span></li></ul><p><span class="yiyi-st" id="yiyi-211">由于RFC允许RFC兼容的解析器接受不符合RFC的输入文本，所以该模块的解串器在默认设置下技术上符合RFC。</span></p><div class="section" id="character-encodings"><h3><span class="yiyi-st" id="yiyi-212">19.2.4.1. </span><span class="yiyi-st" id="yiyi-213">Character Encodings</span></h3><p><span class="yiyi-st" id="yiyi-214">RFC要求使用UTF-8，UTF-16或UTF-32来表示JSON，为了实现最大的互操作性，推荐使用UTF-8。</span></p><p><span class="yiyi-st" id="yiyi-215">RFC允许（尽管不是必需的），此模块的序列化器默认设置为<em>ensure_ascii = True</em>，从而转义输出，以使结果字符串只包含ASCII字符。</span></p><p><span class="yiyi-st" id="yiyi-216">除了<em>ensure_ascii</em>参数之外，此模块严格按照Python对象和<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">Unicode</span> <span class="pre">strings</span></code></a>并且因此不另外直接解决字符编码的问题。</span></p><p><span class="yiyi-st" id="yiyi-217">RFC禁止在JSON文本的开头添加字节顺序标记（BOM），并且此模块的序列化程序不会向其输出添加BOM。</span><span class="yiyi-st" id="yiyi-218">RFC允许（但不要求）JSON解串器在其输入中忽略初始BOM。</span><span class="yiyi-st" id="yiyi-219">当存在初始BOM时，此模块的解串器引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-220">RFC没有明确禁止包含不对应于有效Unicode字符的字节序列的JSON字符串。</span><span class="yiyi-st" id="yiyi-221">不成对的UTF-16代理），但它确实注意到，它们可能导致互操作性问题。</span><span class="yiyi-st" id="yiyi-222">默认情况下，此模块接受和输出（当存在于原始<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>）这样的序列的代码点。</span></p></div><div class="section" id="infinite-and-nan-number-values"><h3><span class="yiyi-st" id="yiyi-223">19.2.4.2. </span><span class="yiyi-st" id="yiyi-224">Infinite and NaN Number Values</span></h3><p><span class="yiyi-st" id="yiyi-225">RFC不允许表示无限或NaN数值。</span><span class="yiyi-st" id="yiyi-226">尽管如此，默认情况下，此模块接受并输出<code class="docutils literal"><span class="pre">Infinity</span></code>，<code class="docutils literal"><span class="pre">-Infinity</span></code>和<code class="docutils literal"><span class="pre">NaN</span></code>，如同它们是有效的JSON数字面值值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Neither of these calls raises an exception, but the results are not valid JSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">'-inf'</span><span class="p">))</span>
<span class="go">'-Infinity'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">'nan'</span><span class="p">))</span>
<span class="go">'NaN'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same when deserializing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="s1">'-Infinity'</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="s1">'NaN'</span><span class="p">)</span>
<span class="go">nan</span>
</code></pre><p><span class="yiyi-st" id="yiyi-227">在序列化程序中，可以使用<em>allow_nan</em>参数来更改此行为。</span><span class="yiyi-st" id="yiyi-228">在解串器中，<em>parse_constant</em>参数可用于更改此行为。</span></p></div><div class="section" id="repeated-names-within-an-object"><h3><span class="yiyi-st" id="yiyi-229">19.2.4.3. </span><span class="yiyi-st" id="yiyi-230">Repeated Names Within an Object</span></h3><p><span class="yiyi-st" id="yiyi-231">RFC指定JSON对象中的名称应该是唯一的，但不要求如何处理JSON对象中的重复名称。</span><span class="yiyi-st" id="yiyi-232">默认情况下，此模块不引发异常；相反，它忽略除了给定名称的最后一个名称/值对之外的所有值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weird_json</span> <span class="o">=</span> <span class="s1">'{"x": 1, "x": 2, "x": 3}'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">weird_json</span><span class="p">)</span>
<span class="go">{'x': 3}</span>
</code></pre><p><span class="yiyi-st" id="yiyi-233">可以使用<em>object_pairs_hook</em>参数更改此行为。</span></p></div><div class="section" id="top-level-non-object-non-array-values"><h3><span class="yiyi-st" id="yiyi-234">19.2.4.4. </span><span class="yiyi-st" id="yiyi-235">Top-level Non-Object, Non-Array Values</span></h3><p><span class="yiyi-st" id="yiyi-236">由过时的<span class="target" id="index-3"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc4627.html"><strong>RFC 4627</strong></a>指定的旧版本JSON要求JSON文本的顶级值必须是JSON对象或数组（Python <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>或<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>），并且不能是JSON空值，布尔值，数字或字符串值。</span><span class="yiyi-st" id="yiyi-237"><span class="target" id="index-4"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc7159.html"><strong>RFC 7159</strong></a>删除了该限制，此模块不会，也从未在其序列化器或其解串器中实现此限制。</span></p><p><span class="yiyi-st" id="yiyi-238">无论如何，为了实现最大的互操作性，您可能希望自愿遵守该限制。</span></p></div><div class="section" id="implementation-limitations"><h3><span class="yiyi-st" id="yiyi-239">19.2.4.5. </span><span class="yiyi-st" id="yiyi-240">Implementation Limitations</span></h3><p><span class="yiyi-st" id="yiyi-241">一些JSON解串器实现可能设置以下限制：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-242">接受的JSON文本的大小</span></li><li><span class="yiyi-st" id="yiyi-243">JSON对象和数组的最大嵌套级别</span></li><li><span class="yiyi-st" id="yiyi-244">JSON数字的范围和精度</span></li><li><span class="yiyi-st" id="yiyi-245">JSON字符串的内容和最大长度</span></li></ul><p><span class="yiyi-st" id="yiyi-246">除了相关的Python数据类型本身或Python解释器本身之外，此模块不强加任何此类限制。</span></p><p><span class="yiyi-st" id="yiyi-247">当序列化为JSON时，请注意可能会消耗您的JSON的应用程序中的任何此类限制。</span><span class="yiyi-st" id="yiyi-248">特别地，通常将JSON数字反序列化为IEEE 754双精度数字，并且因此服从于该表示的范围和精度限制。</span><span class="yiyi-st" id="yiyi-249">当序列化非常大的Python <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>值或者序列化“异常”数值类型的实例（例如<a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a>）时，这一点尤其重要。</span></p></div></div><div class="section" id="module-json.tool"><h2><span class="yiyi-st" id="yiyi-250">19.2.5. </span><span class="yiyi-st" id="yiyi-251">Command Line Interface</span></h2><p><span class="yiyi-st" id="yiyi-252"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/json/tool.py">Lib / json / tool.py</a></span></p><p><span class="yiyi-st" id="yiyi-253"><a class="reference internal" href="#module-json.tool" title="json.tool: A command line to validate and pretty-print JSON."><code class="xref py py-mod docutils literal"><span class="pre">json.tool</span></code></a>模块提供了一个简单的命令行界面来验证和美观打印JSON对象。</span></p><p><span class="yiyi-st" id="yiyi-254">如果未指定可选的<code class="docutils literal"><span class="pre">infile</span></code>和<code class="docutils literal"><span class="pre">outfile</span></code>参数，将分别使用<a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-attr docutils literal"><span class="pre">sys.stdin</span></code></a>和<a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-attr docutils literal"><span class="pre">sys.stdout</span></code></a> ：</span></p><div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="nb">echo</span> <span class="s1">'{"json": "obj"}'</span> <span class="p">|</span> python -m json.tool
<span class="o">{</span>
    <span class="s2">"json"</span>: <span class="s2">"obj"</span>
<span class="o">}</span>
$ <span class="nb">echo</span> <span class="s1">'{1.2:3.4}'</span> <span class="p">|</span> python -m json.tool
Expecting property name enclosed in double quotes: line <span class="m">1</span> column <span class="m">2</span> <span class="o">(</span>char 1<span class="o">)</span>
</pre></div></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-255"><span class="versionmodified">在版本3.5中更改：</span>输出现在与输入处于相同的顺序。</span><span class="yiyi-st" id="yiyi-256">使用<a class="reference internal" href="#cmdoption--sort-keys"><code class="xref std std-option docutils literal"><span class="pre">--sort-keys</span></code></a>选项按字母顺序对字典的输出进行排序。</span></p></div><div class="section" id="command-line-options"><h3><span class="yiyi-st" id="yiyi-257">19.2.5.1. </span><span class="yiyi-st" id="yiyi-258">Command line options</span></h3><dl class="cmdoption"><dt id="cmdoption-arg-infile"><span class="yiyi-st" id="yiyi-259"> <code class="descname">infile</code><code class="descclassname"></code></span></dt><dd><p><span class="yiyi-st" id="yiyi-260">要验证或打印的JSON文件：</span></p><div class="highlight-bash"><div class="highlight"><pre><span></span>$ python -m json.tool mp_films.json
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"title"</span>: <span class="s2">"And Now for Something Completely Different"</span>,
        <span class="s2">"year"</span>: 1971
    <span class="o">}</span>,
    <span class="o">{</span>
        <span class="s2">"title"</span>: <span class="s2">"Monty Python and the Holy Grail"</span>,
        <span class="s2">"year"</span>: 1975
    <span class="o">}</span>
<span class="o">]</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-261">如果未指定<em>infile</em>，请从<a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-attr docutils literal"><span class="pre">sys.stdin</span></code></a>中读取。</span></p></dd></dl><dl class="cmdoption"><dt id="cmdoption-arg-outfile"><span class="yiyi-st" id="yiyi-262"> <code class="descname">outfile</code><code class="descclassname"></code></span></dt><dd><p><span class="yiyi-st" id="yiyi-263">将<em>infile</em>的输出写入给定的<em>outfile</em>。</span><span class="yiyi-st" id="yiyi-264">否则，将其写入<a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-attr docutils literal"><span class="pre">sys.stdout</span></code></a>。</span></p></dd></dl><dl class="cmdoption"><dt id="cmdoption--sort-keys"><span class="yiyi-st" id="yiyi-265"> <code class="descname">--sort-keys</code><code class="descclassname"></code></span></dt><dd><p><span class="yiyi-st" id="yiyi-266">按字母顺序按字母顺序排序字典的输出。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-267"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="cmdoption"><dt id="cmdoption-h"><span class="yiyi-st" id="yiyi-268"> <span id="cmdoption--help"></span><code class="descname">-h</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--help</code><code class="descclassname"></code></span></dt><dd><p><span class="yiyi-st" id="yiyi-269">显示帮助消息。</span></p></dd></dl><p class="rubric"><span class="yiyi-st" id="yiyi-270">脚注</span></p><table class="docutils footnote" frame="void" id="rfc-errata" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-271"><a class="fn-backref" href="#id1">[1]</a></span></td><td><span class="yiyi-st" id="yiyi-272">正如<a class="reference external" href="https://www.rfc-editor.org/errata_search.php?rfc=7159">RFC 7159</a>的勘误中所述，JSON允许字符串中的字面值U + 2028（LINE SEPARATOR）和U + 2029（PARAGRAPH SEPARATOR）字符，而JavaScript（ECMAScript Edition 5.1版） 。</span></td></tr></tbody></table></div></div></div></div>