<div class="body" role="main"><div class="section" id="module-telnetlib"><h1><span class="yiyi-st" id="yiyi-10">21.19. <a class="reference internal" href="#module-telnetlib" title="telnetlib: Telnet client class."><code class="xref py py-mod docutils literal"><span class="pre">telnetlib</span></code></a>  -  Telnet客户端</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/telnetlib.py">Lib/telnetlib.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-telnetlib" title="telnetlib: Telnet client class."><code class="xref py py-mod docutils literal"><span class="pre">telnetlib</span></code></a>模块提供了实现Telnet协议的<a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal"><span class="pre">Telnet</span></code></a>类。</span><span class="yiyi-st" id="yiyi-13">有关协议的详细信息，请参见<span class="target" id="index-1"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc854.html"><strong>RFC 854</strong></a>。</span><span class="yiyi-st" id="yiyi-14">此外，它为协议字符（见下文）和telnet选项提供符号常量。</span><span class="yiyi-st" id="yiyi-15">telnet选项的符号名称遵循<code class="docutils literal"><span class="pre">arpa/telnet.h</span></code>中的定义，删除了前导<code class="docutils literal"><span class="pre">TELOPT_</span></code>。</span><span class="yiyi-st" id="yiyi-16">对于传统上不包括在<code class="docutils literal"><span class="pre">arpa/telnet.h</span></code>中的选项的符号名称，请参阅模块源本身。</span></p><p><span class="yiyi-st" id="yiyi-17">telnet命令的符号常量有：IAC，DONT，DO，WONT，WILL，SE（子协议结束），NOP（无操作），DM（数据标记），BRK中止输出），AYT（您有），EC（擦除字符），EL（擦除线），GA（前进），SB（子协商开始）。</span></p><dl class="class"><dt id="telnetlib.Telnet"><span class="yiyi-st" id="yiyi-18"><em class="property">class </em><code class="descclassname">telnetlib.</code><code class="descname">Telnet</code><span class="sig-paren">(</span><em>host=None</em>, <em>port=0</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-19"><a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal"><span class="pre">Telnet</span></code></a>表示到Telnet服务器的连接。</span><span class="yiyi-st" id="yiyi-20">实例最初未默认连接；必须使用<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal"><span class="pre">open()</span></code></a>方法建立连接。</span><span class="yiyi-st" id="yiyi-21">或者，主机名和可选端口号也可以传递给构造函数，在这种情况下，将在构造函数返回之前建立与服务器的连接。</span><span class="yiyi-st" id="yiyi-22">可选的<em>timeout</em>参数指定阻塞操作（如连接尝试）的超时（以秒为单位）（如果未指定，将使用全局默认超时设置）。</span></p><p><span class="yiyi-st" id="yiyi-23">不要重新打开已连接的实例。</span></p><p><span class="yiyi-st" id="yiyi-24">这个类有许多<code class="xref py py-meth docutils literal"><span class="pre">read_*()</span></code>方法。</span><span class="yiyi-st" id="yiyi-25">注意，当读取连接结束时，其中一些引发<a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a>，因为它们可能由于其他原因返回一个空字符串。</span><span class="yiyi-st" id="yiyi-26">请参阅下面的各个说明。</span></p></dd></dl><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-27">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-28"><span class="target" id="index-2"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc854.html"><strong>RFC 854</strong></a>  -  Telnet协议规范</span></dt><dd><span class="yiyi-st" id="yiyi-29">Telnet协议的定义。</span></dd></dl></div><div class="section" id="telnet-objects"><h2><span class="yiyi-st" id="yiyi-30">21.19.1.</span><span class="yiyi-st" id="yiyi-31">Telnet对象</span></h2><p><span class="yiyi-st" id="yiyi-32"><a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal"><span class="pre">Telnet</span></code></a>实例具有以下方法：</span></p><dl class="method"><dt id="telnetlib.Telnet.read_until"><span class="yiyi-st" id="yiyi-33"><code class="descclassname">Telnet.</code><code class="descname">read_until</code><span class="sig-paren">(</span><em>expected</em>, <em>timeout=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-34">读取直到遇到<em>预期</em>的给定字节字符串，或直到<em>超时</em>秒过去。</span></p><p><span class="yiyi-st" id="yiyi-35">当找不到匹配项时，返回可用的可用空间，可能为空字节。</span><span class="yiyi-st" id="yiyi-36">如果连接已关闭且没有可用的已处理过的数据，则引发<a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.read_all"><span class="yiyi-st" id="yiyi-37"><code class="descclassname">Telnet.</code><code class="descname">read_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-38">读取所有数据，直到EOF为字节；阻塞直到连接关闭。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.read_some"><span class="yiyi-st" id="yiyi-39"><code class="descclassname">Telnet.</code><code class="descname">read_some</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-40">读取至少一个字节的处理过的数据，除非命中EOF。</span><span class="yiyi-st" id="yiyi-41">如果命中EOF，返回<code class="docutils literal"><span class="pre">b''</span></code>。</span><span class="yiyi-st" id="yiyi-42">如果没有可用的数据，则阻止。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.read_very_eager"><span class="yiyi-st" id="yiyi-43"><code class="descclassname">Telnet.</code><code class="descname">read_very_eager</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-44">读取I / O（热切）中可以没有阻塞的所有内容。</span></p><p><span class="yiyi-st" id="yiyi-45">如果连接关闭且没有可用的已处理过的数据，则引发<a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a>。</span><span class="yiyi-st" id="yiyi-46">如果没有熟的数据，返回<code class="docutils literal"><span class="pre">b''</span></code>。</span><span class="yiyi-st" id="yiyi-47">除非在IAC序列中间，否则不要阻塞。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.read_eager"><span class="yiyi-st" id="yiyi-48"><code class="descclassname">Telnet.</code><code class="descname">read_eager</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-49">阅读随时可用的数据。</span></p><p><span class="yiyi-st" id="yiyi-50">如果连接关闭且没有可用的已烹饪数据，则提高<a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a>。</span><span class="yiyi-st" id="yiyi-51">如果没有熟的数据，返回<code class="docutils literal"><span class="pre">b''</span></code>。</span><span class="yiyi-st" id="yiyi-52">除非在IAC序列中间，否则不要阻塞。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.read_lazy"><span class="yiyi-st" id="yiyi-53"><code class="descclassname">Telnet.</code><code class="descname">read_lazy</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-54">处理和返回队列中已有的数据（延迟）。</span></p><p><span class="yiyi-st" id="yiyi-55">如果连接关闭且无可用数据，则提升<a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a>。</span><span class="yiyi-st" id="yiyi-56">如果没有熟的数据，返回<code class="docutils literal"><span class="pre">b''</span></code>。</span><span class="yiyi-st" id="yiyi-57">除非在IAC序列中间，否则不要阻塞。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.read_very_lazy"><span class="yiyi-st" id="yiyi-58"><code class="descclassname">Telnet.</code><code class="descname">read_very_lazy</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-59">返回在cooked队列中可用的任何数据（非常懒惰）。</span></p><p><span class="yiyi-st" id="yiyi-60">如果连接关闭且无可用数据，则提升<a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a>。</span><span class="yiyi-st" id="yiyi-61">如果没有熟的数据，返回<code class="docutils literal"><span class="pre">b''</span></code>。</span><span class="yiyi-st" id="yiyi-62">这种方法永远不会阻塞。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.read_sb_data"><span class="yiyi-st" id="yiyi-63"><code class="descclassname">Telnet.</code><code class="descname">read_sb_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-64">返回在SB / SE对之间收集的数据（子选项开始/结束）。</span><span class="yiyi-st" id="yiyi-65">当使用<code class="docutils literal"><span class="pre">SE</span></code>命令调用时，回调应该访问这些数据。</span><span class="yiyi-st" id="yiyi-66">这种方法永远不会阻塞。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.open"><span class="yiyi-st" id="yiyi-67"><code class="descclassname">Telnet.</code><code class="descname">open</code><span class="sig-paren">(</span><em>host</em>, <em>port=0</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-68">连接到主机。</span><span class="yiyi-st" id="yiyi-69">可选的第二个参数是端口号，默认为标准Telnet端口（23）。</span><span class="yiyi-st" id="yiyi-70">可选的<em>timeout</em>参数指定阻塞操作（如连接尝试）的超时（以秒为单位）（如果未指定，将使用全局默认超时设置）。</span></p><p><span class="yiyi-st" id="yiyi-71">不要尝试重新打开已连接的实例。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.msg"><span class="yiyi-st" id="yiyi-72"><code class="descclassname">Telnet.</code><code class="descname">msg</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-73">当调试级别为<code class="docutils literal"><span class="pre">&gt;</span></code> 0时，打印调试消息。</span><span class="yiyi-st" id="yiyi-74">如果存在额外的参数，它们将在消息中使用标准字符串格式化运算符进行替换。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.set_debuglevel"><span class="yiyi-st" id="yiyi-75"><code class="descclassname">Telnet.</code><code class="descname">set_debuglevel</code><span class="sig-paren">(</span><em>debuglevel</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-76">设置调试级别。</span><span class="yiyi-st" id="yiyi-77"><em>debuglevel</em>的值越高，您获得的调试输出越多（在<code class="docutils literal"><span class="pre">sys.stdout</span></code>）。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.close"><span class="yiyi-st" id="yiyi-78"><code class="descclassname">Telnet.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-79">关闭连接。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.get_socket"><span class="yiyi-st" id="yiyi-80"><code class="descclassname">Telnet.</code><code class="descname">get_socket</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">返回内部使用的套接字对象。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.fileno"><span class="yiyi-st" id="yiyi-82"><code class="descclassname">Telnet.</code><code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">返回内部使用的套接字对象的文件描述符。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.write"><span class="yiyi-st" id="yiyi-84"><code class="descclassname">Telnet.</code><code class="descname">write</code><span class="sig-paren">(</span><em>buffer</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-85">向套接字写入一个字节字符串，将任何IAC字符加倍。</span><span class="yiyi-st" id="yiyi-86">这可以阻止连接被阻止。</span><span class="yiyi-st" id="yiyi-87">如果连接关闭，可能会产生<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-88"><span class="versionmodified">在版本3.3中已更改：</span>此方法用于引发<a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a>，现在是<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>的别名。</span></p></div></dd></dl><dl class="method"><dt id="telnetlib.Telnet.interact"><span class="yiyi-st" id="yiyi-89"><code class="descclassname">Telnet.</code><code class="descname">interact</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">交互功能，模拟一个非常笨的Telnet客户端。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.mt_interact"><span class="yiyi-st" id="yiyi-91"><code class="descclassname">Telnet.</code><code class="descname">mt_interact</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-92"><a class="reference internal" href="#telnetlib.Telnet.interact" title="telnetlib.Telnet.interact"><code class="xref py py-meth docutils literal"><span class="pre">interact()</span></code></a>的多线程版本。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.expect"><span class="yiyi-st" id="yiyi-93"><code class="descclassname">Telnet.</code><code class="descname">expect</code><span class="sig-paren">(</span><em>list</em>, <em>timeout=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">直到从正则表达式列表中匹配到一个为止。</span></p><p><span class="yiyi-st" id="yiyi-95">第一个参数是正则表达式的列表，其被编译（<a class="reference internal" href="re.html#re-objects"><span>regex objects</span></a>）或未编译（字节串）。</span><span class="yiyi-st" id="yiyi-96">可选的第二个参数是超时，以秒为单位；默认是无限期阻塞。</span></p><p><span class="yiyi-st" id="yiyi-97">返回三个项的元组：匹配的第一个正则表达式的列表中的索引；返回匹配对象；和字节读取直到并包括匹配。</span></p><p><span class="yiyi-st" id="yiyi-98">如果找到文件结尾且未读取任何字节，请提出<a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a>。</span><span class="yiyi-st" id="yiyi-99">Otherwise, when nothing matches, return <code class="docutils literal"><span class="pre">(-1,</span> <span class="pre">None,</span> <span class="pre">data)</span></code> where <em>data</em> is the bytes received so far (may be empty bytes if a timeout happened).</span></p><p><span class="yiyi-st" id="yiyi-100">如果正则表达式以贪婪匹配（例如<code class="docutils literal"><span class="pre">.*</span></code>）结束或者如果多个表达式可以匹配相同的输入，则结果是非确定性的，并且可能取决于I / O定时。</span></p></dd></dl><dl class="method"><dt id="telnetlib.Telnet.set_option_negotiation_callback"><span class="yiyi-st" id="yiyi-101"><code class="descclassname">Telnet.</code><code class="descname">set_option_negotiation_callback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-102">每次在输入流上读取telnet选项时，使用以下参数调用此<em>回调</em>（如果设置）：callback（telnet socket，command（DO / DONT / WILL / WONT） 。</span><span class="yiyi-st" id="yiyi-103">其后没有其他操作由telnetlib完成。</span></p></dd></dl></div><div class="section" id="telnet-example"><h2><span class="yiyi-st" id="yiyi-104">21.19.2.</span><span class="yiyi-st" id="yiyi-105">Telnet示例</span></h2><p><span class="yiyi-st" id="yiyi-106">一个简单的例子说明典型的使用：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">getpass</span>
<span class="kn">import</span> <span class="nn">telnetlib</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s2">"localhost"</span>
<span class="n">user</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Enter your remote account: "</span><span class="p">)</span>
<span class="n">password</span> <span class="o">=</span> <span class="n">getpass</span><span class="o">.</span><span class="n">getpass</span><span class="p">()</span>

<span class="n">tn</span> <span class="o">=</span> <span class="n">telnetlib</span><span class="o">.</span><span class="n">Telnet</span><span class="p">(</span><span class="n">HOST</span><span class="p">)</span>

<span class="n">tn</span><span class="o">.</span><span class="n">read_until</span><span class="p">(</span><span class="n">b</span><span class="s2">"login: "</span><span class="p">)</span>
<span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">'ascii'</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">password</span><span class="p">:</span>
    <span class="n">tn</span><span class="o">.</span><span class="n">read_until</span><span class="p">(</span><span class="n">b</span><span class="s2">"Password: "</span><span class="p">)</span>
    <span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">password</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">'ascii'</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>

<span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s2">"ls</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s2">"exit</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">tn</span><span class="o">.</span><span class="n">read_all</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">'ascii'</span><span class="p">))</span>
</code></pre></div></div></div>