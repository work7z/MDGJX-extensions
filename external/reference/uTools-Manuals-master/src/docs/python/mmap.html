<div class="body" role="main"><div class="section" id="module-mmap"><h1><span class="yiyi-st" id="yiyi-10">18.9。 <a class="reference internal" href="#module-mmap" title="mmap: Interface to memory-mapped files for Unix and Windows."><code class="xref py py-mod docutils literal"><span class="pre">mmap</span></code></a>  - 内存映射文件支持</span></h1><p><span class="yiyi-st" id="yiyi-11">内存映射文件对象的行为像<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>和像<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file objects</span></a>。</span><span class="yiyi-st" id="yiyi-12">您可以在预期<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>的大多数地方使用mmap对象；例如，您可以使用<a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a>模块搜索内存映射文件。</span><span class="yiyi-st" id="yiyi-13">您还可以通过执行<code class="docutils literal"><span class="pre">obj [index]</span> <span class="pre">=</span> <span class="pre">97</span></code>更改单个字节，到切片：<code class="docutils literal"><span class="pre">obj [i1：i2]</span> <span class="pre">=</span> <span class="pre">b'...'</span></code>。</span><span class="yiyi-st" id="yiyi-14">您还可以从当前文件位置开始读取和写入数据，并通过文件将<code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code>写入不同位置。</span></p><p><span class="yiyi-st" id="yiyi-15">内存映射文件由<a class="reference internal" href="#module-mmap" title="mmap: Interface to memory-mapped files for Unix and Windows."><code class="xref py py-class docutils literal"><span class="pre">mmap</span></code></a>构造函数创建，在Unix和Windows上是不同的。</span><span class="yiyi-st" id="yiyi-16">在任一情况下，您必须为打开以进行更新的文件提供文件描述器。</span><span class="yiyi-st" id="yiyi-17">如果要映射现有的Python文件对象，请使用<code class="xref py py-meth docutils literal"><span class="pre">fileno()</span></code>方法为<em>fileno</em>参数获取正确的值。</span><span class="yiyi-st" id="yiyi-18">否则，您可以使用<a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>函数打开文件，该函数直接返回一个文件描述器（该文件在完成后仍然需要关闭）。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-19">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-20">如果要为可写，缓冲的文件创建内存映射，应首先<a class="reference internal" href="io.html#io.IOBase.flush" title="io.IOBase.flush"><code class="xref py py-func docutils literal"><span class="pre">flush()</span></code></a>。</span><span class="yiyi-st" id="yiyi-21">这是必要的，以确保对缓冲区的本地修改实际上可用于映射。</span></p></div><p><span class="yiyi-st" id="yiyi-22">对于Unix和Windows版本的构造函数，可以将<em>访问</em>指定为可选的关键字参数。</span><span class="yiyi-st" id="yiyi-23"><em>访问</em>接受以下三个值之一：<code class="xref py py-const docutils literal"><span class="pre">ACCESS_READ</span></code>，<code class="xref py py-const docutils literal"><span class="pre">ACCESS_WRITE</span></code>或<code class="xref py py-const docutils literal"><span class="pre">ACCESS_COPY</span></code>以指定只读，或写时复写存储器。</span><span class="yiyi-st" id="yiyi-24"><em>访问</em>可以在Unix和Windows上使用。</span><span class="yiyi-st" id="yiyi-25">如果未指定<em>访问</em>，则Windows mmap会返回直写映射。</span><span class="yiyi-st" id="yiyi-26">所有三种访问类型的初始内存值取自指定的文件。</span><span class="yiyi-st" id="yiyi-27">分配给<code class="xref py py-const docutils literal"><span class="pre">ACCESS_READ</span></code>内存映射引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-28">分配给<code class="xref py py-const docutils literal"><span class="pre">ACCESS_WRITE</span></code>内存映射会影响内存和基础文件。</span><span class="yiyi-st" id="yiyi-29">分配给<code class="xref py py-const docutils literal"><span class="pre">ACCESS_COPY</span></code>内存映射会影响内存，但不会更新基础文件。</span></p><p><span class="yiyi-st" id="yiyi-30">要映射匿名内存，-1应该作为fileno与长度一起传递。</span></p><dl class="class"><dt id="mmap.mmap"><span class="yiyi-st" id="yiyi-31"> <em class="property">class </em><code class="descclassname">mmap.</code><code class="descname">mmap</code><span class="sig-paren">(</span><em>fileno</em>, <em>length</em>, <em>tagname=None</em>, <em>access=ACCESS_DEFAULT</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-32"><strong>（Windows版本）</strong>从文件句柄<em>fileno</em>指定的文件中映射<em>长度</em>字节，并创建一个mmap对象。</span><span class="yiyi-st" id="yiyi-33">如果<em>length</em>大于文件的当前大小，则文件将扩展为包含<em>长度</em>字节。</span><span class="yiyi-st" id="yiyi-34">如果<em>length</em>为<code class="docutils literal"><span class="pre">0</span></code>，则映射的最大长度为文件的当前大小，除非文件为空。Windows引发异常（您不能创建空在Windows上映射）。</span></p><p><span class="yiyi-st" id="yiyi-35"><em>标记名</em>（如果指定）而不是<code class="docutils literal"><span class="pre">None</span></code>，是为映射提供标记名称的字符串。</span><span class="yiyi-st" id="yiyi-36">Windows允许您对同一个文件有许多不同的映射。</span><span class="yiyi-st" id="yiyi-37">如果指定现有标记的名称，那么将打开该标记，否则将创建此名称的新标记。</span><span class="yiyi-st" id="yiyi-38">如果省略此参数或<code class="docutils literal"><span class="pre">None</span></code>，则将创建没有名称的映射。</span><span class="yiyi-st" id="yiyi-39">避免使用tag参数将有助于在Unix和Windows之间移植代码。</span></p><p><span class="yiyi-st" id="yiyi-40"><em>offset</em>可以指定为非负整数偏移。</span><span class="yiyi-st" id="yiyi-41">mmap引用将相对于从文件开头的偏移量。</span><span class="yiyi-st" id="yiyi-42"><em>offset</em>默认为0. <em>offset</em>必须是ALLOCATIONGRANULARITY的倍数。</span></p></dd></dl><dl class="class"><dt><span class="yiyi-st" id="yiyi-43"><em class="property">class</em> <code class="descclassname">mmap。</code> <code class="descname">mmap</code> <span class="sig-paren">（</span> <em>fileno</em>，<em>length</em> ，<em>flags = MAP_SHARED</em>，<em>prot = PROT_WRITE | PROT_READ</em>，<em>access = ACCESS_DEFAULT</em> <span class="optional">[</span>，<em>t10&gt; <span class="optional">]</span> <span class="sig-paren">）</span></em></span></dt><dd><p><span class="yiyi-st" id="yiyi-44"><strong>（Unix版本）</strong>从文件描述器<em>fileno</em>指定的文件中映射<em>长度</em>字节，并返回一个mmap对象。</span><span class="yiyi-st" id="yiyi-45">如果<em>length</em>是<code class="docutils literal"><span class="pre">0</span></code>，则调用<a class="reference internal" href="#module-mmap" title="mmap: Interface to memory-mapped files for Unix and Windows."><code class="xref py py-class docutils literal"><span class="pre">mmap</span></code></a>时，映射的最大长度将是文件的当前大小。</span></p><p><span class="yiyi-st" id="yiyi-46"><em>flags</em>指定映射的性质。</span><span class="yiyi-st" id="yiyi-47"><code class="xref py py-const docutils literal"><span class="pre">MAP_PRIVATE</span></code>创建私有写入副本映射，因此对mmap对象的内容的更改将对此进程是专用的，<code class="xref py py-const docutils literal"><span class="pre">MAP_SHARED</span></code>创建与所有共享的映射其他进程映射文件的相同区域。</span><span class="yiyi-st" id="yiyi-48">默认值为<code class="xref py py-const docutils literal"><span class="pre">MAP_SHARED</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-49"><em>prot</em>如果指定，给出所需的内存保护；两个最有用的值是<code class="xref py py-const docutils literal"><span class="pre">PROT_READ</span></code>和<code class="xref py py-const docutils literal"><span class="pre">PROT_WRITE</span></code>，用于指定可以读取或写入页面。</span><span class="yiyi-st" id="yiyi-50"><em>prot</em>默认为<code class="xref py py-const docutils literal"><span class="pre">PROT_READ</span> <span class="pre">|</span> <span class="pre">PROT_WRITE</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-51">可以指定<em>访问</em>代替<em>标志</em>和<em>prot</em>作为可选的关键字参数。</span><span class="yiyi-st" id="yiyi-52">指定<em>标志</em>，<em>prot</em>和<em>访问</em>是错误的。</span><span class="yiyi-st" id="yiyi-53">有关如何使用此参数的信息，请参见上述<em>访问</em>的说明。</span></p><p><span class="yiyi-st" id="yiyi-54"><em>offset</em>可以指定为非负整数偏移。</span><span class="yiyi-st" id="yiyi-55">mmap引用将相对于从文件开头的偏移量。</span><span class="yiyi-st" id="yiyi-56"><em>offset</em>默认为0. <em>offset</em>必须是PAGESIZE或ALLOCATIONGRANULARITY的倍数。</span></p><p><span class="yiyi-st" id="yiyi-57">为了确保创建的内存映射的有效性，由描述器<em>fileno</em>指定的文件在内部自动与Mac OS X和OpenVMS上的物理后备存储同步。</span></p><p><span class="yiyi-st" id="yiyi-58">此示例显示了使用<a class="reference internal" href="#module-mmap" title="mmap: Interface to memory-mapped files for Unix and Windows."><code class="xref py py-class docutils literal"><span class="pre">mmap</span></code></a>的一种简单方法：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">mmap</span>

<span class="c1"># write a simple example file</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"hello.txt"</span><span class="p">,</span> <span class="s2">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s2">"Hello Python!</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"hello.txt"</span><span class="p">,</span> <span class="s2">"r+b"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># memory-map the file, size 0 means whole file</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="n">mmap</span><span class="o">.</span><span class="n">mmap</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># read content via standard file methods</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># prints b"Hello Python!\n"</span>
    <span class="c1"># read content via slice notation</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">mm</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># prints b"Hello"</span>
    <span class="c1"># update content using slice notation;</span>
    <span class="c1"># note that new content must have same size</span>
    <span class="n">mm</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span> <span class="o">=</span> <span class="n">b</span><span class="s2">" world!</span><span class="se">\n</span><span class="s2">"</span>
    <span class="c1"># ... and read again using standard file methods</span>
    <span class="n">mm</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># prints b"Hello  world!\n"</span>
    <span class="c1"># close the map</span>
    <span class="n">mm</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-59"><a class="reference internal" href="#module-mmap" title="mmap: Interface to memory-mapped files for Unix and Windows."><code class="xref py py-class docutils literal"><span class="pre">mmap</span></code></a>也可以用作<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句中的上下文管理器。</span><span class="yiyi-st" id="yiyi-60">：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">mmap</span>

<span class="k">with</span> <span class="n">mmap</span><span class="o">.</span><span class="n">mmap</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span> <span class="k">as</span> <span class="n">mm</span><span class="p">:</span>
    <span class="n">mm</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s2">"Hello world!"</span><span class="p">)</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-61"><span class="versionmodified">版本3.2中的新功能：</span>上下文管理器支持。</span></p></div><p><span class="yiyi-st" id="yiyi-62">下一个示例演示如何创建匿名地图并在父进程和子进程之间交换数据：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">mmap</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">mm</span> <span class="o">=</span> <span class="n">mmap</span><span class="o">.</span><span class="n">mmap</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="n">mm</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s2">"Hello world!"</span><span class="p">)</span>

<span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>

<span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># In a child process</span>
    <span class="n">mm</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">readline</span><span class="p">())</span>

    <span class="n">mm</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-63">内存映射文件对象支持以下方法：</span></p><dl class="method"><dt id="mmap.mmap.close"><span class="yiyi-st" id="yiyi-64"> <code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-65">关闭mmap。</span><span class="yiyi-st" id="yiyi-66">对对象的其他方法的后续调用将导致产生ValueError异常。</span><span class="yiyi-st" id="yiyi-67">这将不会关闭打开的文件。</span></p></dd></dl><dl class="attribute"><dt id="mmap.mmap.closed"><span class="yiyi-st" id="yiyi-68"> <code class="descname">closed</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-69"><code class="docutils literal"><span class="pre">True</span></code>如果文件已关闭。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-70"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="mmap.mmap.find"><span class="yiyi-st" id="yiyi-71"> <code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-72">返回发现子序列<em>sub</em>的对象中的最低索引，以使<em>sub</em>包含在范围[<em>start</em>，<em>end </em>]。</span><span class="yiyi-st" id="yiyi-73">可选参数<em>start</em>和<em>end</em>被解释为切片表示法。</span><span class="yiyi-st" id="yiyi-74">失败时返回<code class="docutils literal"><span class="pre">-1</span></code>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-75"><span class="versionmodified">在版本3.5中已更改：</span>可写入<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>现已接受。</span></p></div></dd></dl><dl class="method"><dt id="mmap.mmap.flush"><span class="yiyi-st" id="yiyi-76"> <code class="descname">flush</code><span class="sig-paren">(</span><span class="optional">[</span><em>offset</em><span class="optional">[</span>, <em>size</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-77">将对文件的内存中副本所做的更改刷新回磁盘。</span><span class="yiyi-st" id="yiyi-78">不使用此调用，不能保证在对象被销毁之前写回更改。</span><span class="yiyi-st" id="yiyi-79">如果指定<em>offset</em>和<em>size</em>，只有对给定字节范围的更改才会刷新到磁盘；否则，映射的整个范围被刷新。</span></p><p><span class="yiyi-st" id="yiyi-80"><strong>（Windows版本）</strong>返回非零值表示成功；零表示失败。</span></p><p><span class="yiyi-st" id="yiyi-81"><strong>（Unix版本）</strong>返回零值以指示成功。</span><span class="yiyi-st" id="yiyi-82">调用失败时引发异常。</span></p></dd></dl><dl class="method"><dt id="mmap.mmap.move"><span class="yiyi-st" id="yiyi-83"> <code class="descname">move</code><span class="sig-paren">(</span><em>dest</em>, <em>src</em>, <em>count</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-84">将从偏移<em>src</em>开始的<em>计数</em>字节复制到目标索引<em>dest</em>。</span><span class="yiyi-st" id="yiyi-85">如果mmap是用<code class="xref py py-const docutils literal"><span class="pre">ACCESS_READ</span></code>创建的，那么对move的调用将引发一个<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>异常。</span></p></dd></dl><dl class="method"><dt id="mmap.mmap.read"><span class="yiyi-st" id="yiyi-86"> <code class="descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em>n</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-87">返回一个<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>，其中包含从当前文件位置开始的<em>n</em>个字节。</span><span class="yiyi-st" id="yiyi-88">如果省略参数，<em>无</em>或否定，将所有字节从当前文件位置返回到映射结束。</span><span class="yiyi-st" id="yiyi-89">文件位置更新为指向返回的字节。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-90"><span class="versionmodified">在版本3.3中更改：</span>参数可以省略或<em>无</em>。</span></p></div></dd></dl><dl class="method"><dt id="mmap.mmap.read_byte"><span class="yiyi-st" id="yiyi-91"> <code class="descname">read_byte</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-92">以当前文件位置为单位返回一个字节，并将文件位置前移1。</span></p></dd></dl><dl class="method"><dt id="mmap.mmap.readline"><span class="yiyi-st" id="yiyi-93"> <code class="descname">readline</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">返回单个行，从当前文件位置开始，直到下一个换行符。</span></p></dd></dl><dl class="method"><dt id="mmap.mmap.resize"><span class="yiyi-st" id="yiyi-95"> <code class="descname">resize</code><span class="sig-paren">(</span><em>newsize</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-96">调整地图和底层文件（如果有）。</span><span class="yiyi-st" id="yiyi-97">如果使用<code class="xref py py-const docutils literal"><span class="pre">ACCESS_READ</span></code>或<code class="xref py py-const docutils literal"><span class="pre">ACCESS_COPY</span></code>创建mmap，则调整地图大小将引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>异常。</span></p></dd></dl><dl class="method"><dt id="mmap.mmap.rfind"><span class="yiyi-st" id="yiyi-98"> <code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-99">返回发现子序列<em>sub</em>的对象中的最高索引，以使<em>sub</em>包含在范围[<em>start</em>，<em>end </em>]。</span><span class="yiyi-st" id="yiyi-100">可选参数<em>start</em>和<em>end</em>被解释为切片表示法。</span><span class="yiyi-st" id="yiyi-101">失败时返回<code class="docutils literal"><span class="pre">-1</span></code>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-102"><span class="versionmodified">在版本3.5中已更改：</span>可写入<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>现已接受。</span></p></div></dd></dl><dl class="method"><dt id="mmap.mmap.seek"><span class="yiyi-st" id="yiyi-103"> <code class="descname">seek</code><span class="sig-paren">(</span><em>pos</em><span class="optional">[</span>, <em>whence</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">设置文件的当前位置。</span><span class="yiyi-st" id="yiyi-105"><em>whence</em>参数是可选的，默认为<code class="docutils literal"><span class="pre">os.SEEK_SET</span></code>或<code class="docutils literal"><span class="pre">0</span></code>其他值为<code class="docutils literal"><span class="pre">os.SEEK_CUR</span></code>或<code class="docutils literal"><span class="pre">1</span></code>（相对于当前位置寻找）和<code class="docutils literal"><span class="pre">os.SEEK_END</span></code>或<code class="docutils literal"><span class="pre">2</span></code> （相对于文件的结尾）。</span></p></dd></dl><dl class="method"><dt id="mmap.mmap.size"><span class="yiyi-st" id="yiyi-106"> <code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">返回文件的长度，可以大于内存映射区域的大小。</span></p></dd></dl><dl class="method"><dt id="mmap.mmap.tell"><span class="yiyi-st" id="yiyi-108"> <code class="descname">tell</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-109">返回文件指针的当前位置。</span></p></dd></dl><dl class="method"><dt id="mmap.mmap.write"><span class="yiyi-st" id="yiyi-110"> <code class="descname">write</code><span class="sig-paren">(</span><em>bytes</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">将<em>字节</em>中的字节写入文件指针当前位置的存储器；文件位置更新为指向写入的字节之后。</span><span class="yiyi-st" id="yiyi-112">如果使用<code class="xref py py-const docutils literal"><span class="pre">ACCESS_READ</span></code>创建mmap，则写入它将引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>异常。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-113"><span class="versionmodified">在版本3.5中已更改：</span>可写入<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>现已接受。</span></p></div></dd></dl><dl class="method"><dt id="mmap.mmap.write_byte"><span class="yiyi-st" id="yiyi-114"> <code class="descname">write_byte</code><span class="sig-paren">(</span><em>byte</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-115">将整数<em>字节</em>写入文件指针当前位置的内存中；文件位置提前<code class="docutils literal"><span class="pre">1</span></code>。</span><span class="yiyi-st" id="yiyi-116">如果使用<code class="xref py py-const docutils literal"><span class="pre">ACCESS_READ</span></code>创建mmap，则写入它将引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>异常。</span></p></dd></dl></dd></dl></div></div>