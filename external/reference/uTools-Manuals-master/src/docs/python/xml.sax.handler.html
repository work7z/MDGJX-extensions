<div class="body" role="main"><div class="section" id="module-xml.sax.handler"><h1><span class="yiyi-st" id="yiyi-10">20.10. <a class="reference internal" href="#module-xml.sax.handler" title="xml.sax.handler: Base classes for SAX event handlers."><code class="xref py py-mod docutils literal"><span class="pre">xml.sax.handler</span></code></a>  -  SAX处理程序的基类</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/xml/sax/handler.py">Lib / xml / sax / handler.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">SAX API定义了四种处理程序：内容处理程序，DTD处理程序，错误处理程序和实体解析程序。</span><span class="yiyi-st" id="yiyi-13">应用程序通常只需要实现他们感兴趣的事件的接口；它们可以在单个对象或多个对象中实现接口。</span><span class="yiyi-st" id="yiyi-14">Handler实现应该继承模块<a class="reference internal" href="#module-xml.sax.handler" title="xml.sax.handler: Base classes for SAX event handlers."><code class="xref py py-mod docutils literal"><span class="pre">xml.sax.handler</span></code></a>中提供的基类，以便所有方法都获得默认实现。</span></p><dl class="class"><dt id="xml.sax.handler.ContentHandler"><span class="yiyi-st" id="yiyi-15"> <em class="property">class </em><code class="descclassname">xml.sax.handler.</code><code class="descname">ContentHandler</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-16">这是SAX中的主要回调接口，并且是应用程序最重要的接口。</span><span class="yiyi-st" id="yiyi-17">此接口中的事件顺序反映文档中信息的顺序。</span></p></dd></dl><dl class="class"><dt id="xml.sax.handler.DTDHandler"><span class="yiyi-st" id="yiyi-18"> <em class="property">class </em><code class="descclassname">xml.sax.handler.</code><code class="descname">DTDHandler</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-19">处理DTD事件。</span></p><p><span class="yiyi-st" id="yiyi-20">此接口仅指定基本解析所需的DTD事件（未解析的实体和属性）。</span></p></dd></dl><dl class="class"><dt id="xml.sax.handler.EntityResolver"><span class="yiyi-st" id="yiyi-21"> <em class="property">class </em><code class="descclassname">xml.sax.handler.</code><code class="descname">EntityResolver</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-22">用于解析实体的基本接口。</span><span class="yiyi-st" id="yiyi-23">如果创建实现此接口的对象，则向解析器注册对象，解析器将调用对象中的方法来解析所有外部实体。</span></p></dd></dl><dl class="class"><dt id="xml.sax.handler.ErrorHandler"><span class="yiyi-st" id="yiyi-24"> <em class="property">class </em><code class="descclassname">xml.sax.handler.</code><code class="descname">ErrorHandler</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-25">解析器用来向应用程序提供错误和警告消息的接口。</span><span class="yiyi-st" id="yiyi-26">此对象的方法控制错误是否立即转换为异常或以某种其他方式处理。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-27">除了这些类之外，<a class="reference internal" href="#module-xml.sax.handler" title="xml.sax.handler: Base classes for SAX event handlers."><code class="xref py py-mod docutils literal"><span class="pre">xml.sax.handler</span></code></a>还提供了要素和属性名称的符号常量。</span></p><dl class="data"><dt id="xml.sax.handler.feature_namespaces"><span class="yiyi-st" id="yiyi-28"> <code class="descclassname">xml.sax.handler.</code><code class="descname">feature_namespaces</code></span></dt><dd><div class="line-block"><div class="line"><span class="yiyi-st" id="yiyi-29">值：<code class="docutils literal"><span class="pre">"http://xml.org/sax/features/namespaces"</span></code></span></div><div class="line"><span class="yiyi-st" id="yiyi-30">true：执行命名空间处理。</span></div><div class="line"><span class="yiyi-st" id="yiyi-31">false：可选不执行命名空间处理（隐含命名空间前缀；默认）。</span></div><div class="line"><span class="yiyi-st" id="yiyi-32">访问：（解析）只读； （不解析）读/写</span></div></div></dd></dl><dl class="data"><dt id="xml.sax.handler.feature_namespace_prefixes"><span class="yiyi-st" id="yiyi-33"> <code class="descclassname">xml.sax.handler.</code><code class="descname">feature_namespace_prefixes</code></span></dt><dd><div class="line-block"><div class="line"><span class="yiyi-st" id="yiyi-34">值：<code class="docutils literal"><span class="pre">"http://xml.org/sax/features/namespace-prefixes"</span></code></span></div><div class="line"><span class="yiyi-st" id="yiyi-35">true：报告用于命名空间声明的原始前缀名称和属性。</span></div><div class="line"><span class="yiyi-st" id="yiyi-36">false：不报告用于命名空间声明的属性，并且可选地不报告原始的前缀名称（默认）。</span></div><div class="line"><span class="yiyi-st" id="yiyi-37">访问：（解析）只读； （不解析）读/写</span></div></div></dd></dl><dl class="data"><dt id="xml.sax.handler.feature_string_interning"><span class="yiyi-st" id="yiyi-38"> <code class="descclassname">xml.sax.handler.</code><code class="descname">feature_string_interning</code></span></dt><dd><div class="line-block"><div class="line"><span class="yiyi-st" id="yiyi-39">值：<code class="docutils literal"><span class="pre">"http://xml.org/sax/features/string-interning"</span></code></span></div><div class="line"><span class="yiyi-st" id="yiyi-40">true：使用内建intern函数实现所有元素名称，前缀，属性名称，命名空间URI和本地名称。</span></div><div class="line"><span class="yiyi-st" id="yiyi-41">false：名称不一定是interned，虽然他们可能是（默认）。</span></div><div class="line"><span class="yiyi-st" id="yiyi-42">访问：（解析）只读； （不解析）读/写</span></div></div></dd></dl><dl class="data"><dt id="xml.sax.handler.feature_validation"><span class="yiyi-st" id="yiyi-43"> <code class="descclassname">xml.sax.handler.</code><code class="descname">feature_validation</code></span></dt><dd><div class="line-block"><div class="line"><span class="yiyi-st" id="yiyi-44">值：<code class="docutils literal"><span class="pre">"http://xml.org/sax/features/validation"</span></code></span></div><div class="line"><span class="yiyi-st" id="yiyi-45">true：报告所有验证错误（暗示外部通用实体和外部参数实体）。</span></div><div class="line"><span class="yiyi-st" id="yiyi-46">false：不报告验证错误。</span></div><div class="line"><span class="yiyi-st" id="yiyi-47">访问：（解析）只读； （不解析）读/写</span></div></div></dd></dl><dl class="data"><dt id="xml.sax.handler.feature_external_ges"><span class="yiyi-st" id="yiyi-48"> <code class="descclassname">xml.sax.handler.</code><code class="descname">feature_external_ges</code></span></dt><dd><div class="line-block"><div class="line"><span class="yiyi-st" id="yiyi-49">值：<code class="docutils literal"><span class="pre">"http://xml.org/sax/features/external-general-entities"</span></code></span></div><div class="line"><span class="yiyi-st" id="yiyi-50">true：包括所有外部常规（文本）实体。</span></div><div class="line"><span class="yiyi-st" id="yiyi-51">false：不包括外部一般实体。</span></div><div class="line"><span class="yiyi-st" id="yiyi-52">访问：（解析）只读； （不解析）读/写</span></div></div></dd></dl><dl class="data"><dt id="xml.sax.handler.feature_external_pes"><span class="yiyi-st" id="yiyi-53"> <code class="descclassname">xml.sax.handler.</code><code class="descname">feature_external_pes</code></span></dt><dd><div class="line-block"><div class="line"><span class="yiyi-st" id="yiyi-54">值：<code class="docutils literal"><span class="pre">"http://xml.org/sax/features/external-parameter-entities"</span></code></span></div><div class="line"><span class="yiyi-st" id="yiyi-55">true：包括所有外部参数实体，包括外部DTD子集。</span></div><div class="line"><span class="yiyi-st" id="yiyi-56">false：不包括任何外部参数实体，即使是外部DTD子集。</span></div><div class="line"><span class="yiyi-st" id="yiyi-57">访问：（解析）只读； （不解析）读/写</span></div></div></dd></dl><dl class="data"><dt id="xml.sax.handler.all_features"><span class="yiyi-st" id="yiyi-58"> <code class="descclassname">xml.sax.handler.</code><code class="descname">all_features</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-59">所有功能的列表。</span></p></dd></dl><dl class="data"><dt id="xml.sax.handler.property_lexical_handler"><span class="yiyi-st" id="yiyi-60"> <code class="descclassname">xml.sax.handler.</code><code class="descname">property_lexical_handler</code></span></dt><dd><div class="line-block"><div class="line"><span class="yiyi-st" id="yiyi-61">值：<code class="docutils literal"><span class="pre">"http://xml.org/sax/properties/lexical-handler"</span></code></span></div><div class="line"><span class="yiyi-st" id="yiyi-62">数据类型：xml.sax.sax2lib.LexicalHandler（在Python 2中不受支持）</span></div><div class="line"><span class="yiyi-st" id="yiyi-63">description：用于词汇事件的可选扩展处理程序，如注释。</span></div><div class="line"><span class="yiyi-st" id="yiyi-64">访问：读/写</span></div></div></dd></dl><dl class="data"><dt id="xml.sax.handler.property_declaration_handler"><span class="yiyi-st" id="yiyi-65"> <code class="descclassname">xml.sax.handler.</code><code class="descname">property_declaration_handler</code></span></dt><dd><div class="line-block"><div class="line"><span class="yiyi-st" id="yiyi-66">值：<code class="docutils literal"><span class="pre">"http://xml.org/sax/properties/declaration-handler"</span></code></span></div><div class="line"><span class="yiyi-st" id="yiyi-67">数据类型：xml.sax.sax2lib.DeclHandler（Python 2不支持）</span></div><div class="line"><span class="yiyi-st" id="yiyi-68">description：除符号和未解析实体之外的DTD相关事件的可选扩展处理程序。</span></div><div class="line"><span class="yiyi-st" id="yiyi-69">访问：读/写</span></div></div></dd></dl><dl class="data"><dt id="xml.sax.handler.property_dom_node"><span class="yiyi-st" id="yiyi-70"> <code class="descclassname">xml.sax.handler.</code><code class="descname">property_dom_node</code></span></dt><dd><div class="line-block"><div class="line"><span class="yiyi-st" id="yiyi-71">值：<code class="docutils literal"><span class="pre">"http://xml.org/sax/properties/dom-node"</span></code></span></div><div class="line"><span class="yiyi-st" id="yiyi-72">数据类型：org.w3c.dom.Node（Python 2不支持）</span></div><div class="line"><span class="yiyi-st" id="yiyi-73">description：当解析时，如果这是DOM迭代器，则访问当前DOM节点；当不解析时，根DOM节点进行迭代。</span></div><div class="line"><span class="yiyi-st" id="yiyi-74">访问：（解析）只读； （不解析）读/写</span></div></div></dd></dl><dl class="data"><dt id="xml.sax.handler.property_xml_string"><span class="yiyi-st" id="yiyi-75"> <code class="descclassname">xml.sax.handler.</code><code class="descname">property_xml_string</code></span></dt><dd><div class="line-block"><div class="line"><span class="yiyi-st" id="yiyi-76">值：<code class="docutils literal"><span class="pre">"http://xml.org/sax/properties/xml-string"</span></code></span></div><div class="line"><span class="yiyi-st" id="yiyi-77">数据类型：字符串</span></div><div class="line"><span class="yiyi-st" id="yiyi-78">description：作为当前事件源的字面值字符串。</span></div><div class="line"><span class="yiyi-st" id="yiyi-79">访问：只读</span></div></div></dd></dl><dl class="data"><dt id="xml.sax.handler.all_properties"><span class="yiyi-st" id="yiyi-80"> <code class="descclassname">xml.sax.handler.</code><code class="descname">all_properties</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">所有已知属性名称的列表。</span></p></dd></dl><div class="section" id="contenthandler-objects"><h2><span class="yiyi-st" id="yiyi-82">20.10.1. </span><span class="yiyi-st" id="yiyi-83">ContentHandler Objects</span></h2><p><span class="yiyi-st" id="yiyi-84">用户需要子类化<a class="reference internal" href="#xml.sax.handler.ContentHandler" title="xml.sax.handler.ContentHandler"><code class="xref py py-class docutils literal"><span class="pre">ContentHandler</span></code></a>以支持他们的应用程序。</span><span class="yiyi-st" id="yiyi-85">解析器对输入文档中的相应事件调用以下方法：</span></p><dl class="method"><dt id="xml.sax.handler.ContentHandler.setDocumentLocator"><span class="yiyi-st" id="yiyi-86"> <code class="descclassname">ContentHandler.</code><code class="descname">setDocumentLocator</code><span class="sig-paren">(</span><em>locator</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-87">由解析器调用以向应用程序提供用于定位文档事件的起源的定位器。</span></p><p><span class="yiyi-st" id="yiyi-88">强烈鼓励（虽然不是绝对需要）提供定位器的SAX解析器：如果它这样做，它必须通过调用此方法在调用DocumentHandler接口中的任何其他方法之前提供定位器到应用程序。</span></p><p><span class="yiyi-st" id="yiyi-89">定位器允许应用程序确定任何文档相关事件的结束位置，即使解析器未报告错误。</span><span class="yiyi-st" id="yiyi-90">通常，应用程序将使用此信息来报告其自身的错误（例如，与应用程序的业务规则不匹配的字符内容）。</span><span class="yiyi-st" id="yiyi-91">定位器返回的信息可能不足以用于搜索引擎。</span></p><p><span class="yiyi-st" id="yiyi-92">注意，定位器将仅在调用该接口中的事件时返回正确的信息。</span><span class="yiyi-st" id="yiyi-93">应用程序不应尝试在任何其他时间使用它。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.startDocument"><span class="yiyi-st" id="yiyi-94"> <code class="descclassname">ContentHandler.</code><code class="descname">startDocument</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-95">接收文档开头的通知。</span></p><p><span class="yiyi-st" id="yiyi-96">SAX解析器将只调用此方法一次，在此接口或DTDHandler中的任何其他方法（除了<a class="reference internal" href="#xml.sax.handler.ContentHandler.setDocumentLocator" title="xml.sax.handler.ContentHandler.setDocumentLocator"><code class="xref py py-meth docutils literal"><span class="pre">setDocumentLocator()</span></code></a>）之前。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.endDocument"><span class="yiyi-st" id="yiyi-97"> <code class="descclassname">ContentHandler.</code><code class="descname">endDocument</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-98">接收文档结束的通知。</span></p><p><span class="yiyi-st" id="yiyi-99">SAX解析器将仅调用此方法一次，它将是解析期间调用的最后一个方法。</span><span class="yiyi-st" id="yiyi-100">解析器不应调用此方法，直到它放弃了解析（因为一个不可恢复的错误）或达到输入的结束。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.startPrefixMapping"><span class="yiyi-st" id="yiyi-101"> <code class="descclassname">ContentHandler.</code><code class="descname">startPrefixMapping</code><span class="sig-paren">(</span><em>prefix</em>, <em>uri</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-102">开始前缀URI范围的命名空间映射。</span></p><p><span class="yiyi-st" id="yiyi-103">来自此事件的信息对于正常的命名空间处理不是必需的：当启用<code class="docutils literal"><span class="pre">feature_namespaces</span></code>功能（默认值）时，SAX XML阅读器将自动替换元素和属性名称的前缀。</span></p><p><span class="yiyi-st" id="yiyi-104">但是，有些情况下，应用程序需要在字符数据或属性值中使用前缀，这些前缀不能安全地自动扩展；如果需要，<a class="reference internal" href="#xml.sax.handler.ContentHandler.startPrefixMapping" title="xml.sax.handler.ContentHandler.startPrefixMapping"><code class="xref py py-meth docutils literal"><span class="pre">startPrefixMapping()</span></code></a>和<a class="reference internal" href="#xml.sax.handler.ContentHandler.endPrefixMapping" title="xml.sax.handler.ContentHandler.endPrefixMapping"><code class="xref py py-meth docutils literal"><span class="pre">endPrefixMapping()</span></code></a>事件将信息提供给应用程序以扩展这些上下文中的前缀。</span></p><p><span class="yiyi-st" id="yiyi-105">请注意，不保证<a class="reference internal" href="#xml.sax.handler.ContentHandler.startPrefixMapping" title="xml.sax.handler.ContentHandler.startPrefixMapping"><code class="xref py py-meth docutils literal"><span class="pre">startPrefixMapping()</span></code></a>和<a class="reference internal" href="#xml.sax.handler.ContentHandler.endPrefixMapping" title="xml.sax.handler.ContentHandler.endPrefixMapping"><code class="xref py py-meth docutils literal"><span class="pre">endPrefixMapping()</span></code></a>事件相对于每个其他事件都正确嵌套：所有<a class="reference internal" href="#xml.sax.handler.ContentHandler.startPrefixMapping" title="xml.sax.handler.ContentHandler.startPrefixMapping"><code class="xref py py-meth docutils literal"><span class="pre">startPrefixMapping()</span></code></a>发生在相应的<a class="reference internal" href="#xml.sax.handler.ContentHandler.startElement" title="xml.sax.handler.ContentHandler.startElement"><code class="xref py py-meth docutils literal"><span class="pre">startElement()</span></code></a>事件之前，并且所有<a class="reference internal" href="#xml.sax.handler.ContentHandler.endPrefixMapping" title="xml.sax.handler.ContentHandler.endPrefixMapping"><code class="xref py py-meth docutils literal"><span class="pre">endPrefixMapping()</span></code></a>事件将发生在相应的<a class="reference internal" href="#xml.sax.handler.ContentHandler.endElement" title="xml.sax.handler.ContentHandler.endElement"><code class="xref py py-meth docutils literal"><span class="pre">endElement()</span></code></a>事件之后，不保证。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.endPrefixMapping"><span class="yiyi-st" id="yiyi-106"> <code class="descclassname">ContentHandler.</code><code class="descname">endPrefixMapping</code><span class="sig-paren">(</span><em>prefix</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">结束前缀URI映射的范围。</span></p><p><span class="yiyi-st" id="yiyi-108">有关详细信息，请参见<a class="reference internal" href="#xml.sax.handler.ContentHandler.startPrefixMapping" title="xml.sax.handler.ContentHandler.startPrefixMapping"><code class="xref py py-meth docutils literal"><span class="pre">startPrefixMapping()</span></code></a>。</span><span class="yiyi-st" id="yiyi-109">此事件将始终在相应的<a class="reference internal" href="#xml.sax.handler.ContentHandler.endElement" title="xml.sax.handler.ContentHandler.endElement"><code class="xref py py-meth docutils literal"><span class="pre">endElement()</span></code></a>事件之后发生，但<a class="reference internal" href="#xml.sax.handler.ContentHandler.endPrefixMapping" title="xml.sax.handler.ContentHandler.endPrefixMapping"><code class="xref py py-meth docutils literal"><span class="pre">endPrefixMapping()</span></code></a>事件的顺序不另行保证。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.startElement"><span class="yiyi-st" id="yiyi-110"> <code class="descclassname">ContentHandler.</code><code class="descname">startElement</code><span class="sig-paren">(</span><em>name</em>, <em>attrs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">用信号通知非命名空间模式下元素的开始。</span></p><p><span class="yiyi-st" id="yiyi-112"><em>name</em>参数包含元素类型的原始XML 1.0名称作为字符串，<em>attrs</em>参数保存<code class="xref py py-class docutils literal"><span class="pre">Attributes</span></code>接口的对象<a class="reference internal" href="xml.sax.reader.html#attributes-objects"><span>The Attributes Interface</span></a>）包含元素的属性。</span><span class="yiyi-st" id="yiyi-113">作为<em>attrs</em>传递的对象可以由解析器重用；保持对它的引用不是保持属性的副本的可靠方式。</span><span class="yiyi-st" id="yiyi-114">要保留属性的副本，请使用<em>attrs</em>对象的<a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code></a>方法。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.endElement"><span class="yiyi-st" id="yiyi-115"> <code class="descclassname">ContentHandler.</code><code class="descname">endElement</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-116">以非命名空间模式表示元素的结尾。</span></p><p><span class="yiyi-st" id="yiyi-117"><em>name</em>参数包含元素类型的名称，与<a class="reference internal" href="#xml.sax.handler.ContentHandler.startElement" title="xml.sax.handler.ContentHandler.startElement"><code class="xref py py-meth docutils literal"><span class="pre">startElement()</span></code></a>事件一样。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.startElementNS"><span class="yiyi-st" id="yiyi-118"> <code class="descclassname">ContentHandler.</code><code class="descname">startElementNS</code><span class="sig-paren">(</span><em>name</em>, <em>qname</em>, <em>attrs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-119">在命名空间模式中用信号通知元素的开始。</span></p><p><span class="yiyi-st" id="yiyi-120"><em>name</em>参数包含<code class="docutils literal"><span class="pre">（uri，</span> <span class="pre">localname）</span></code>元组类型的名称，<em> qname</em>参数包含源文档中使用的原始XML 1.0名称，<em>attrs</em>参数保存<code class="xref py py-class docutils literal"><span class="pre">AttributesNS</span></code>界面的实例（请参阅<a class="reference internal" href="xml.sax.reader.html#attributes-ns-objects"><span>The AttributesNS Interface</span></a>）包含元素的属性。</span><span class="yiyi-st" id="yiyi-121">如果没有与元素相关联的命名空间，则<em>名称</em>的<em>uri</em>组件将为<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-122">作为<em>attrs</em>传递的对象可以由解析器重用；保持对它的引用不是保持属性的副本的可靠方式。</span><span class="yiyi-st" id="yiyi-123">要保留属性的副本，请使用<em>attrs</em>对象的<a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code></a>方法。</span></p><p><span class="yiyi-st" id="yiyi-124">解析器可以将<em>qname</em>参数设置为<code class="docutils literal"><span class="pre">None</span></code>，除非激活<code class="docutils literal"><span class="pre">feature_namespace_prefixes</span></code>功能。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.endElementNS"><span class="yiyi-st" id="yiyi-125"> <code class="descclassname">ContentHandler.</code><code class="descname">endElementNS</code><span class="sig-paren">(</span><em>name</em>, <em>qname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-126">在命名空间模式中用信号通知元素的结尾。</span></p><p><span class="yiyi-st" id="yiyi-127"><em>name</em>参数包含元素类型的名称，与<a class="reference internal" href="#xml.sax.handler.ContentHandler.startElementNS" title="xml.sax.handler.ContentHandler.startElementNS"><code class="xref py py-meth docutils literal"><span class="pre">startElementNS()</span></code></a>方法一样，与<em>qname</em>参数一样。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.characters"><span class="yiyi-st" id="yiyi-128"> <code class="descclassname">ContentHandler.</code><code class="descname">characters</code><span class="sig-paren">(</span><em>content</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-129">接收字符数据的通知。</span></p><p><span class="yiyi-st" id="yiyi-130">解析器将调用此方法来报告每个字符数据块。</span><span class="yiyi-st" id="yiyi-131">SAX解析器可以返回单个块中的所有连续字符数据，或者它们可以将其拆分成几个块；然而，任何单个事件中的所有字符必须来自相同的外部实体，以便定位器提供有用的信息。</span></p><p><span class="yiyi-st" id="yiyi-132"><em>内容</em>可以是字符串或字节实例； <code class="docutils literal"><span class="pre">expat</span></code>阅读器模块总是生成字符串。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-133">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-134">Python XML Special Interest Group提供的较早的SAX 1接口为此方法使用了更类似Java的接口。</span><span class="yiyi-st" id="yiyi-135">由于从Python使用的大多数解析器没有利用旧的接口，选择更简单的声明来替换它。</span><span class="yiyi-st" id="yiyi-136">要将旧代码转换为新界面，请使用<em>content</em>而不是使用旧的<em>偏移</em>和<em>长度</em>参数对内容进行切片。</span></p></div></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.ignorableWhitespace"><span class="yiyi-st" id="yiyi-137"> <code class="descclassname">ContentHandler.</code><code class="descname">ignorableWhitespace</code><span class="sig-paren">(</span><em>whitespace</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-138">在元素内容中接收可忽略的空格的通知。</span></p><p><span class="yiyi-st" id="yiyi-139">验证解析器必须使用此方法来报告每个块的可忽略的空格（请参阅W3C XML 1.0建议，2.10节）：如果非验证解析器能够解析和使用内容模型，则它们也可以使用此方法。</span></p><p><span class="yiyi-st" id="yiyi-140">SAX解析器可以返回单个块中的所有连续空格，或者它们可以将其拆分成几个块；然而，任何单个事件中的所有字符必须来自同一外部实体，以便定位器提供有用的信息。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.processingInstruction"><span class="yiyi-st" id="yiyi-141"> <code class="descclassname">ContentHandler.</code><code class="descname">processingInstruction</code><span class="sig-paren">(</span><em>target</em>, <em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-142">接收处理指令的通知。</span></p><p><span class="yiyi-st" id="yiyi-143">对于找到的每个处理指令，解析器将调用该方法一次：注意，处理指令可以发生在主文档元素之前或之后。</span></p><p><span class="yiyi-st" id="yiyi-144">SAX解析器不应该使用此方法报告XML声明（XML 1.0，第2.8节）或文本声明（XML 1.0，第4.3.1节）。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ContentHandler.skippedEntity"><span class="yiyi-st" id="yiyi-145"> <code class="descclassname">ContentHandler.</code><code class="descname">skippedEntity</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-146">接收跳过的实体的通知。</span></p><p><span class="yiyi-st" id="yiyi-147">对于每个跳过的实体，解析器将调用此方法一次。</span><span class="yiyi-st" id="yiyi-148">非验证处理器可以跳过实体，如果它们没有看到声明（因为例如实体在外部DTD子集中声明）。</span><span class="yiyi-st" id="yiyi-149">所有处理器可能会跳过外部实体，具体取决于<code class="docutils literal"><span class="pre">feature_external_ges</span></code>和<code class="docutils literal"><span class="pre">feature_external_pes</span></code>属性的值。</span></p></dd></dl></div><div class="section" id="dtdhandler-objects"><h2><span class="yiyi-st" id="yiyi-150">20.10.2. </span><span class="yiyi-st" id="yiyi-151">DTDHandler Objects</span></h2><p><span class="yiyi-st" id="yiyi-152"><a class="reference internal" href="#xml.sax.handler.DTDHandler" title="xml.sax.handler.DTDHandler"><code class="xref py py-class docutils literal"><span class="pre">DTDHandler</span></code></a>实例提供以下方法：</span></p><dl class="method"><dt id="xml.sax.handler.DTDHandler.notationDecl"><span class="yiyi-st" id="yiyi-153"> <code class="descclassname">DTDHandler.</code><code class="descname">notationDecl</code><span class="sig-paren">(</span><em>name</em>, <em>publicId</em>, <em>systemId</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-154">处理符号声明事件。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.DTDHandler.unparsedEntityDecl"><span class="yiyi-st" id="yiyi-155"> <code class="descclassname">DTDHandler.</code><code class="descname">unparsedEntityDecl</code><span class="sig-paren">(</span><em>name</em>, <em>publicId</em>, <em>systemId</em>, <em>ndata</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156">处理未解析的实体声明事件。</span></p></dd></dl></div><div class="section" id="entityresolver-objects"><h2><span class="yiyi-st" id="yiyi-157">20.10.3. </span><span class="yiyi-st" id="yiyi-158">EntityResolver Objects</span></h2><dl class="method"><dt id="xml.sax.handler.EntityResolver.resolveEntity"><span class="yiyi-st" id="yiyi-159"> <code class="descclassname">EntityResolver.</code><code class="descname">resolveEntity</code><span class="sig-paren">(</span><em>publicId</em>, <em>systemId</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-160">解析实体的系统标识符，并返回要作为字符串读取的系统标识符或要读取的InputSource。</span><span class="yiyi-st" id="yiyi-161">默认实现返回<em>systemId</em>。</span></p></dd></dl></div><div class="section" id="errorhandler-objects"><h2><span class="yiyi-st" id="yiyi-162">20.10.4. </span><span class="yiyi-st" id="yiyi-163">ErrorHandler Objects</span></h2><p><span class="yiyi-st" id="yiyi-164">具有此接口的对象用于从<a class="reference internal" href="xml.sax.reader.html#xml.sax.xmlreader.XMLReader" title="xml.sax.xmlreader.XMLReader"><code class="xref py py-class docutils literal"><span class="pre">XMLReader</span></code></a>接收错误和警告信息。</span><span class="yiyi-st" id="yiyi-165">如果创建实现此接口的对象，则使用<a class="reference internal" href="xml.sax.reader.html#xml.sax.xmlreader.XMLReader" title="xml.sax.xmlreader.XMLReader"><code class="xref py py-class docutils literal"><span class="pre">XMLReader</span></code></a>注册该对象，解析器将调用对象中的方法以报告所有警告和错误。</span><span class="yiyi-st" id="yiyi-166">有三个级别的错误可用：警告，（可能）可恢复错误和不可恢复的错误。</span><span class="yiyi-st" id="yiyi-167">所有方法都将<code class="xref py py-exc docutils literal"><span class="pre">SAXParseException</span></code>作为唯一参数。</span><span class="yiyi-st" id="yiyi-168">通过提高传入的异常对象，错误和警告可能会转换为异常。</span></p><dl class="method"><dt id="xml.sax.handler.ErrorHandler.error"><span class="yiyi-st" id="yiyi-169"> <code class="descclassname">ErrorHandler.</code><code class="descname">error</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-170">当解析器遇到可恢复的错误时调用。</span><span class="yiyi-st" id="yiyi-171">如果此方法不引发异常，则解析可以继续，但应用程序不应该期望进一步的文档信息。</span><span class="yiyi-st" id="yiyi-172">允许解析器继续可以允许在输入文档中发现附加的错误。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ErrorHandler.fatalError"><span class="yiyi-st" id="yiyi-173"> <code class="descclassname">ErrorHandler.</code><code class="descname">fatalError</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-174">在解析器遇到错误时调用，无法从中恢复；此方法返回时，解析预期会终止。</span></p></dd></dl><dl class="method"><dt id="xml.sax.handler.ErrorHandler.warning"><span class="yiyi-st" id="yiyi-175"> <code class="descclassname">ErrorHandler.</code><code class="descname">warning</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-176">当解析器向应用程序提供次要警告信息时调用。</span><span class="yiyi-st" id="yiyi-177">此方法返回时，解析将继续，并且文档信息将继续传递到应用程序。</span><span class="yiyi-st" id="yiyi-178">在此方法中引发异常将导致解析结束。</span></p></dd></dl></div></div></div>