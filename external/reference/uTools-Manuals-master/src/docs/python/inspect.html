<div class="body" role="main"><div class="section" id="module-inspect"><h1><span class="yiyi-st" id="yiyi-10">29.12.  <a class="reference internal" href="#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal"><span class="pre">inspect</span></code></a>  - 检查活动对象</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源程序代码︰</strong><a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/inspect.py">Lib/inspect.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal"><span class="pre">inspect</span></code></a>模块提供了一些有用的函数来帮助获取有关活动对象（如模块，类，方法，函数，跟踪，框架对象和代码对象）的信息。</span><span class="yiyi-st" id="yiyi-13">例如，它可以帮助您检查类的内容，检索方法的源代码，提取和格式化函数的参数列表，或获取显示详细追溯所需的所有信息。</span></p><p><span class="yiyi-st" id="yiyi-14">这个模块提供了四种主要的服务：类型检查，获取源代码，检查类和函数，以及检查解释器堆栈。</span></p><div class="section" id="types-and-members"><h2><span class="yiyi-st" id="yiyi-15">29.12.1. </span><span class="yiyi-st" id="yiyi-16">类型和成员 </span></h2><p><span class="yiyi-st" id="yiyi-17"><a class="reference internal" href="#inspect.getmembers" title="inspect.getmembers"><code class="xref py py-func docutils literal"><span class="pre">getmembers()</span></code></a>函数检索诸如类或模块的对象的成员。</span><span class="yiyi-st" id="yiyi-18">以“is”名称开头的函数主要作为对<a class="reference internal" href="#inspect.getmembers" title="inspect.getmembers"><code class="xref py py-func docutils literal"><span class="pre">getmembers()</span></code></a>的第二个参数的便捷选择。</span><span class="yiyi-st" id="yiyi-19">它们还帮助您确定何时可以期望找到以下特殊属性：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-20">类型</span></th><th class="head"><span class="yiyi-st" id="yiyi-21">属性</span></th><th class="head"><span class="yiyi-st" id="yiyi-22">描述</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-23">module</span></td><td><span class="yiyi-st" id="yiyi-24">__doc__</span></td><td><span class="yiyi-st" id="yiyi-25">文档字符串</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-26">__file__</span></td><td><span class="yiyi-st" id="yiyi-27">文件名（内置模块缺失）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-28">class</span></td><td><span class="yiyi-st" id="yiyi-29">__doc__</span></td><td><span class="yiyi-st" id="yiyi-30">文档字符串</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-31">__name__</span></td><td><span class="yiyi-st" id="yiyi-32">这个类被定义的名称</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-33">__qualname__</span></td><td><span class="yiyi-st" id="yiyi-34">限定名称</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-35">__module__</span></td><td><span class="yiyi-st" id="yiyi-36">在这个类中定义的模块的名称</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-37">method</span></td><td><span class="yiyi-st" id="yiyi-38">__doc__</span></td><td><span class="yiyi-st" id="yiyi-39">文档字符串</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-40">__name__</span></td><td><span class="yiyi-st" id="yiyi-41">这个方法被定义的名称</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-42">__qualname__</span></td><td><span class="yiyi-st" id="yiyi-43">限定名称</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-44">__func__</span></td><td><span class="yiyi-st" id="yiyi-45">包含方法实现的函数对象</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-46">__self__</span></td><td><span class="yiyi-st" id="yiyi-47">该方法绑定到的实例，或<code class="docutils literal"><span class="pre">None</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-48">function</span></td><td><span class="yiyi-st" id="yiyi-49">__doc__</span></td><td><span class="yiyi-st" id="yiyi-50">文档字符串</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-51">__name__</span></td><td><span class="yiyi-st" id="yiyi-52">这个函数被定义的名字</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-53">__qualname__</span></td><td><span class="yiyi-st" id="yiyi-54">限定名称</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-55">__code__</span></td><td><span class="yiyi-st" id="yiyi-56">包含编译函数<a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>的代码对象</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-57">__defaults__</span></td><td><span class="yiyi-st" id="yiyi-58">用于位置或关键字参数的任何默认值的元组</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-59">__kwdefaults__</span></td><td><span class="yiyi-st" id="yiyi-60">为关键字参数映射任何默认值</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-61">__globals__</span></td><td><span class="yiyi-st" id="yiyi-62">在其中定义了该函数的全局名称空间</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-63">__annotations__</span></td><td><span class="yiyi-st" id="yiyi-64">mapping of parameters names to annotations; <code class="docutils literal"><span class="pre">"return"</span></code> key is reserved for return annotations.</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-65">traceback</span></td><td><span class="yiyi-st" id="yiyi-66">tb_frame</span></td><td><span class="yiyi-st" id="yiyi-67">在这个级别的框架对象</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-68">tb_lasti</span></td><td><span class="yiyi-st" id="yiyi-69">字节码中最后一次尝试指令的索引</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-70">tb_lineno</span></td><td><span class="yiyi-st" id="yiyi-71">Python源代码中的当前行号</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-72">tb_next</span></td><td><span class="yiyi-st" id="yiyi-73">下一个内部追踪对象（由此级别调用）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-74">frame</span></td><td><span class="yiyi-st" id="yiyi-75">f_back</span></td><td><span class="yiyi-st" id="yiyi-76">下一个外框对象（这个框架的调用者）</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-77">f_builtins</span></td><td><span class="yiyi-st" id="yiyi-78">建立了这个框架所看到的名字空间</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-79">f_code</span></td><td><span class="yiyi-st" id="yiyi-80">代码对象在这个框架中被执行</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-81">f_globals</span></td><td><span class="yiyi-st" id="yiyi-82">全局名称空间由此框架看到</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-83">f_lasti</span></td><td><span class="yiyi-st" id="yiyi-84">字节码中最后一次尝试指令的索引</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-85">f_lineno</span></td><td><span class="yiyi-st" id="yiyi-86">Python源代码中的当前行号</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-87">f_locals</span></td><td><span class="yiyi-st" id="yiyi-88">本框架所看到的本地名称空间</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-89">f_restricted</span></td><td><span class="yiyi-st" id="yiyi-90">如果帧处于受限执行模式，则为0或1</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-91">f_trace</span></td><td><span class="yiyi-st" id="yiyi-92">追踪此帧的功能，或<code class="docutils literal"><span class="pre">None</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-93">code</span></td><td><span class="yiyi-st" id="yiyi-94">co_argcount</span></td><td><span class="yiyi-st" id="yiyi-95">参数数量（不包括*或**参数）</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-96">co_code</span></td><td><span class="yiyi-st" id="yiyi-97">原始编译的字节码字符串</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-98">co_consts</span></td><td><span class="yiyi-st" id="yiyi-99">字节码中使用的常量元组</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-100">co_filename</span></td><td><span class="yiyi-st" id="yiyi-101">此代码对象在其中创建的文件的名称</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-102">co_firstlineno</span></td><td><span class="yiyi-st" id="yiyi-103">Python源代码中的第一行数</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-104">co_flags</span></td><td><span class="yiyi-st" id="yiyi-105">位图：1 =优化<code class="docutils literal"><span class="pre">|</span></code> 2 = newlocals <code class="docutils literal"><span class="pre">|</span></code> 4 = * arg <code class="docutils literal"><span class="pre">|</span></code> 8 = ** arg</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-106">co_lnotab</span></td><td><span class="yiyi-st" id="yiyi-107">将行号编码为字节码索引</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-108">co_name</span></td><td><span class="yiyi-st" id="yiyi-109">这个代码对象被定义的名称</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-110">co_names</span></td><td><span class="yiyi-st" id="yiyi-111">局部变量名称的元组</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-112">co_nlocals</span></td><td><span class="yiyi-st" id="yiyi-113">局部变量的数量</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-114">co_stacksize</span></td><td><span class="yiyi-st" id="yiyi-115">所需的虚拟机堆栈空间</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-116">co_varnames</span></td><td><span class="yiyi-st" id="yiyi-117">参数名称和局部变量的元组</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-118">generator</span></td><td><span class="yiyi-st" id="yiyi-119">__name__</span></td><td><span class="yiyi-st" id="yiyi-120">名称</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-121">__qualname__</span></td><td><span class="yiyi-st" id="yiyi-122">限定名称</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-123">gi_frame</span></td><td><span class="yiyi-st" id="yiyi-124">帧</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-125">gi_running</span></td><td><span class="yiyi-st" id="yiyi-126">发电机正在运转吗？</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-127">gi_code</span></td><td><span class="yiyi-st" id="yiyi-128">码</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-129">gi_yieldfrom</span></td><td><span class="yiyi-st" id="yiyi-130">对象由<code class="docutils literal"><span class="pre">从</span></code>产生 <span class="pre">，或<code class="docutils literal"><span class="pre">None</span></code></span></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-131">coroutine</span></td><td><span class="yiyi-st" id="yiyi-132">__name__</span></td><td><span class="yiyi-st" id="yiyi-133">名称</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-134">__qualname__</span></td><td><span class="yiyi-st" id="yiyi-135">限定名称</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-136">cr_await</span></td><td><span class="yiyi-st" id="yiyi-137">对象正在等待，或<code class="docutils literal"><span class="pre">None</span></code></span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-138">cr_frame</span></td><td><span class="yiyi-st" id="yiyi-139">帧</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-140">cr_running</span></td><td><span class="yiyi-st" id="yiyi-141">协程运行？</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-142">cr_code</span></td><td><span class="yiyi-st" id="yiyi-143">码</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-144">builtin</span></td><td><span class="yiyi-st" id="yiyi-145">__doc__</span></td><td><span class="yiyi-st" id="yiyi-146">文档字符串</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-147">__name__</span></td><td><span class="yiyi-st" id="yiyi-148">此功能或方法的原始名称</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-149">__qualname__</span></td><td><span class="yiyi-st" id="yiyi-150">限定名称</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-151">__self__</span></td><td><span class="yiyi-st" id="yiyi-152">绑定方法的实例，或<code class="docutils literal"><span class="pre">None</span></code></span></td></tr></tbody></table><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-153"><span class="versionmodified">版本3.5中的更改：</span>将<code class="docutils literal"><span class="pre">__qualname__</span></code>和<code class="docutils literal"><span class="pre">gi_yieldfrom</span></code>属性添加到生成器。</span></p><p><span class="yiyi-st" id="yiyi-154">现在生成器的<code class="docutils literal"><span class="pre">__ name __</span></code>属性是根据函数名称中设置的，而不是代码名称，并且可以修改。</span></p></div><dl class="function"><dt id="inspect.getmembers"><span class="yiyi-st" id="yiyi-155"> <code class="descclassname">inspect.</code><code class="descname">getmembers</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>predicate</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156">返回按名称排序的（name, value)列表中的所有成员对象。</span><span class="yiyi-st" id="yiyi-157">如果提供了可选的<em>predicate</em>参数，则只包含predicate返回true值的成员。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-158">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-159">当参数是一个类时，<a class="reference internal" href="#inspect.getmembers" title="inspect.getmembers"><code class="xref py py-func docutils literal"><span class="pre">getmembers()</span></code></a>只会返回已定义在元类中的类属性，并且这些属性已经列在元类的自定义<a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal"><span class="pre">__ dir __()</span></code></a>中。</span></p></div></dd></dl><dl class="function"><dt id="inspect.getmoduleinfo"><span class="yiyi-st" id="yiyi-160"> <code class="descclassname">inspect.</code><code class="descname">getmoduleinfo</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-161">返回一个<a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">命名元组</span></a> <code class="docutils literal"><span class="pre">ModuleInfo（name，</span> <span class="pre">suffix，</span> <span class="pre">mode，</span> <span class="pre">module_type）</span></code>描述Python如何解释由<em>path</em>标识的文件是模块，或者返回<code class="docutils literal"><span class="pre">None</span></code>，如果没被标识为模块。</span><span class="yiyi-st" id="yiyi-162">In that tuple, <em>name</em> is the name of the module without the name of any enclosing package, <em>suffix</em> is the trailing part of the file name (which may not be a dot-delimited extension), <em>mode</em> is the <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> mode that would be used (<code class="docutils literal"><span class="pre">'r'</span></code> or <code class="docutils literal"><span class="pre">'rb'</span></code>), and <em>module_type</em> is an integer giving the type of the module. </span><span class="yiyi-st" id="yiyi-163"><em>module_type</em>将具有可与<a class="reference internal" href="imp.html#module-imp" title="imp: Access the implementation of the import statement. (deprecated)"><code class="xref py py-mod docutils literal"><span class="pre">imp</span></code></a>模块中定义的常量进行比较的值；有关模块类型的更多信息，请参阅该模块的文档。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-164"><span class="versionmodified">从版本3.3开始弃用：</span>您可以根据<a class="reference internal" href="importlib.html#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal"><span class="pre">importlib.machinery</span></code></a>中列出的受支持后缀检查文件路径的后缀，以推断相同的信息。</span></p></div></dd></dl><dl class="function"><dt id="inspect.getmodulename"><span class="yiyi-st" id="yiyi-165"> <code class="descclassname">inspect.</code><code class="descname">getmodulename</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-166">返回由文件<em>path</em>命名的模块的名称，不包括封装包的名称。</span><span class="yiyi-st" id="yiyi-167">文件扩展名将根据<a class="reference internal" href="importlib.html#importlib.machinery.all_suffixes" title="importlib.machinery.all_suffixes"><code class="xref py py-func docutils literal"><span class="pre">importlib.machinery.all_suffixes()</span></code></a>中的所有条目进行检查。</span><span class="yiyi-st" id="yiyi-168">如果匹配，则返回最终路径组件，并删除扩展名。</span><span class="yiyi-st" id="yiyi-169">否则，返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-170">请注意，此函数仅<em></em>为实际Python模块返回一个有意义的名称 - 可能引用Python包的路径仍将返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-171"><span class="versionmodified">版本3.3中更改：</span>此函数现在直接基于<a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal"><span class="pre">importlib</span></code></a>，而不是已弃用的<a class="reference internal" href="#inspect.getmoduleinfo" title="inspect.getmoduleinfo"><code class="xref py py-func docutils literal"><span class="pre">getmoduleinfo()</span></code></a>。</span></p></div></dd></dl><dl class="function"><dt id="inspect.ismodule"><span class="yiyi-st" id="yiyi-172"> <code class="descclassname">inspect.</code><code class="descname">ismodule</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-173">如果对象是模块，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.isclass"><span class="yiyi-st" id="yiyi-174"> <code class="descclassname">inspect.</code><code class="descname">isclass</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-175">如果对象是一个类，无论是内置的还是用Python代码创建的，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.ismethod"><span class="yiyi-st" id="yiyi-176"> <code class="descclassname">inspect.</code><code class="descname">ismethod</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-177">如果对象是用Python编写的绑定方法，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.isfunction"><span class="yiyi-st" id="yiyi-178"> <code class="descclassname">inspect.</code><code class="descname">isfunction</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-179">如果对象是一个Python函数（包含由<a class="reference internal" href="../glossary.html#term-lambda"><span class="xref std std-term">lambda</span></a>表达式创建的函数），则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.isgeneratorfunction"><span class="yiyi-st" id="yiyi-180"> <code class="descclassname">inspect.</code><code class="descname">isgeneratorfunction</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-181">如果对象是Python生成器函数，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.isgenerator"><span class="yiyi-st" id="yiyi-182"> <code class="descclassname">inspect.</code><code class="descname">isgenerator</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-183">如果对象是一个生成器，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.iscoroutinefunction"><span class="yiyi-st" id="yiyi-184"> <code class="descclassname">inspect.</code><code class="descname">iscoroutinefunction</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-185">如果对象是<a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a>（用<a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a>语法定义的函数），则返回true。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-186"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="inspect.iscoroutine"><span class="yiyi-st" id="yiyi-187"> <code class="descclassname">inspect.</code><code class="descname">iscoroutine</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-188">如果对象是由<a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a>函数创建的<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>，则返回true。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-189"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="inspect.isawaitable"><span class="yiyi-st" id="yiyi-190"> <code class="descclassname">inspect.</code><code class="descname">isawaitable</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-191">如果对象可以在<a class="reference internal" href="../reference/expressions.html#await"><code class="xref std std-keyword docutils literal"><span class="pre">await</span></code></a>表达式中使用，则返回true。</span></p><p><span class="yiyi-st" id="yiyi-192">也可以用来区分基于生成器的协程和常规生成器：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
    <span class="k">yield</span>
<span class="nd">@types</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">gen_coro</span><span class="p">():</span>
    <span class="k">yield</span>

<span class="k">assert</span> <span class="ow">not</span> <span class="n">isawaitable</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span>
<span class="k">assert</span> <span class="n">isawaitable</span><span class="p">(</span><span class="n">gen_coro</span><span class="p">())</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-193"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="inspect.istraceback"><span class="yiyi-st" id="yiyi-194"> <code class="descclassname">inspect.</code><code class="descname">istraceback</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-195">如果对象是回溯，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.isframe"><span class="yiyi-st" id="yiyi-196"> <code class="descclassname">inspect.</code><code class="descname">isframe</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-197">如果对象是一个框架，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.iscode"><span class="yiyi-st" id="yiyi-198"> <code class="descclassname">inspect.</code><code class="descname">iscode</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-199">如果对象是代码，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.isbuiltin"><span class="yiyi-st" id="yiyi-200"> <code class="descclassname">inspect.</code><code class="descname">isbuiltin</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-201">如果对象是内置函数或绑定的内置方法，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.isroutine"><span class="yiyi-st" id="yiyi-202"> <code class="descclassname">inspect.</code><code class="descname">isroutine</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-203">如果对象是用户定义的或内置的函数或方法，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.isabstract"><span class="yiyi-st" id="yiyi-204"> <code class="descclassname">inspect.</code><code class="descname">isabstract</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-205">如果对象是抽象基类，则返回true。</span></p></dd></dl><dl class="function"><dt id="inspect.ismethoddescriptor"><span class="yiyi-st" id="yiyi-206"> <code class="descclassname">inspect.</code><code class="descname">ismethoddescriptor</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-207">如果对象是方法描述符，则返回true，但如果<a class="reference internal" href="#inspect.ismethod" title="inspect.ismethod"><code class="xref py py-func docutils literal"><span class="pre">ismethod()</span></code></a>，<a class="reference internal" href="#inspect.isclass" title="inspect.isclass"><code class="xref py py-func docutils literal"><span class="pre">isclass()</span></code></a>，<a class="reference internal" href="#inspect.isfunction" title="inspect.isfunction"><code class="xref py py-func docutils literal"><span class="pre">isfunction()</span></code></a>或<a class="reference internal" href="#inspect.isbuiltin" title="inspect.isbuiltin"><code class="xref py py-func docutils literal"><span class="pre">isbuiltin()</span></code></a>是真的。</span></p><p><span class="yiyi-st" id="yiyi-208">例如，这对于<code class="docutils literal"><span class="pre">int.__add__</span></code>是真的。</span><span class="yiyi-st" id="yiyi-209">通过此测试的对象有一个<a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a>方法，但不包含<a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a>方法，但除此之外，该组属性会发生变化。</span><span class="yiyi-st" id="yiyi-210">一个<a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a>属性通常是合理的，常常是<code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-211">Methods implemented via descriptors that also pass one of the other tests return false from the <a class="reference internal" href="#inspect.ismethoddescriptor" title="inspect.ismethoddescriptor"><code class="xref py py-func docutils literal"><span class="pre">ismethoddescriptor()</span></code></a> test, simply because the other tests promise more – you can, e.g., count on having the <code class="xref py py-attr docutils literal"><span class="pre">__func__</span></code> attribute (etc) when an object passes <a class="reference internal" href="#inspect.ismethod" title="inspect.ismethod"><code class="xref py py-func docutils literal"><span class="pre">ismethod()</span></code></a>.</span></p></dd></dl><dl class="function"><dt id="inspect.isdatadescriptor"><span class="yiyi-st" id="yiyi-212"> <code class="descclassname">inspect.</code><code class="descname">isdatadescriptor</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-213">如果对象是数据描述符，则返回true。</span></p><p><span class="yiyi-st" id="yiyi-214">数据描述符有一个<a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-attr docutils literal"><span class="pre">__get__</span></code></a>和一个<a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-attr docutils literal"><span class="pre">__set__</span></code></a>方法。</span><span class="yiyi-st" id="yiyi-215">示例是属性（在Python中定义），getset和成员。</span><span class="yiyi-st" id="yiyi-216">后两种是在C中定义的，并且这些类型有更多特定的测试可用，这在Python实现中是健壮的。</span><span class="yiyi-st" id="yiyi-217">通常情况下，数据描述符也将具有<a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a>和<code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code>属性（属性，getset和成员都具有这两个属性），但不能保证。</span></p></dd></dl><dl class="function"><dt id="inspect.isgetsetdescriptor"><span class="yiyi-st" id="yiyi-218"> <code class="descclassname">inspect.</code><code class="descname">isgetsetdescriptor</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-219">如果对象是getset描述符，则返回true。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-220"><strong>CPython implementation detail:</strong> getsets are attributes defined in extension modules via <code class="xref c c-type docutils literal"><span class="pre">PyGetSetDef</span></code> structures. </span><span class="yiyi-st" id="yiyi-221">对于没有这种类型的Python实现，此方法将始终返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></div></dd></dl><dl class="function"><dt id="inspect.ismemberdescriptor"><span class="yiyi-st" id="yiyi-222"> <code class="descclassname">inspect.</code><code class="descname">ismemberdescriptor</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-223">如果对象是成员描述符，则返回true。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-224"><strong>CPython implementation detail:</strong> Member descriptors are attributes defined in extension modules via <a class="reference internal" href="../c-api/structures.html#c.PyMemberDef" title="PyMemberDef"><code class="xref c c-type docutils literal"><span class="pre">PyMemberDef</span></code></a> structures. </span><span class="yiyi-st" id="yiyi-225">对于没有这种类型的Python实现，此方法将始终返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></div></dd></dl></div><div class="section" id="retrieving-source-code"><h2><span class="yiyi-st" id="yiyi-226">29.12.2. </span><span class="yiyi-st" id="yiyi-227">检索源代码</span></h2><dl class="function"><dt id="inspect.getdoc"><span class="yiyi-st" id="yiyi-228"> <code class="descclassname">inspect.</code><code class="descname">getdoc</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-229">获取一个对象的文档字符串，用<a class="reference internal" href="#inspect.cleandoc" title="inspect.cleandoc"><code class="xref py py-func docutils literal"><span class="pre">cleandoc()</span></code></a>清理。</span><span class="yiyi-st" id="yiyi-230">如果未提供对象的文档字符串，并且该对象是类，方法，属性或描述符，则从继承层次结构中检索文档字符串。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-231"><span class="versionmodified">版本3.5中已更改：</span>文档字符串现在如果未被覆盖，现在将被继承。</span></p></div></dd></dl><dl class="function"><dt id="inspect.getcomments"><span class="yiyi-st" id="yiyi-232"> <code class="descclassname">inspect.</code><code class="descname">getcomments</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-233">在单个字符串中返回紧接在对象源代码之前（对于类，函数或方法）或Python源文件顶部（如果对象是模块）的任何注释行。</span></p></dd></dl><dl class="function"><dt id="inspect.getfile"><span class="yiyi-st" id="yiyi-234"> <code class="descclassname">inspect.</code><code class="descname">getfile</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-235">返回定义了对象的（文本或二进制）文件的名称。</span><span class="yiyi-st" id="yiyi-236">如果对象是内置的模块，类或函数，则这会失败，并带有<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="inspect.getmodule"><span class="yiyi-st" id="yiyi-237"> <code class="descclassname">inspect.</code><code class="descname">getmodule</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-238">尝试猜测某个对象是在哪个模块中定义的。</span></p></dd></dl><dl class="function"><dt id="inspect.getsourcefile"><span class="yiyi-st" id="yiyi-239"> <code class="descclassname">inspect.</code><code class="descname">getsourcefile</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-240">返回定义了对象的Python源文件的名称。</span><span class="yiyi-st" id="yiyi-241">如果对象是内置的模块，类或函数，则这会失败，并带有<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="inspect.getsourcelines"><span class="yiyi-st" id="yiyi-242"> <code class="descclassname">inspect.</code><code class="descname">getsourcelines</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-243">返回一个对象的源代码行和起始行号的列表。</span><span class="yiyi-st" id="yiyi-244">参数可以是模块，类，方法，函数，追溯，框架或代码对象。</span><span class="yiyi-st" id="yiyi-245">源代码作为与对象相对应的行列表返回，行号指示在原始源文件中找到第一行代码的位置。</span><span class="yiyi-st" id="yiyi-246">如果无法检索源代码，则会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-247"><span class="versionmodified">在版本3.3中更改：</span> <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>被引发而不是<a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a>，现在是前者的别名。</span></p></div></dd></dl><dl class="function"><dt id="inspect.getsource"><span class="yiyi-st" id="yiyi-248"> <code class="descclassname">inspect.</code><code class="descname">getsource</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-249">返回一个对象的源代码文本。</span><span class="yiyi-st" id="yiyi-250">参数可以是模块，类，方法，函数，追溯，框架或代码对象。</span><span class="yiyi-st" id="yiyi-251">源代码作为单个字符串返回。</span><span class="yiyi-st" id="yiyi-252">如果无法检索源代码，则会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-253"><span class="versionmodified">在版本3.3中更改：</span> <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>被引发而不是<a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a>，现在是前者的别名。</span></p></div></dd></dl><dl class="function"><dt id="inspect.cleandoc"><span class="yiyi-st" id="yiyi-254"> <code class="descclassname">inspect.</code><code class="descname">cleandoc</code><span class="sig-paren">(</span><em>doc</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-255">清除缩排以排列代码块的文档字符串中的缩进。</span></p><p><span class="yiyi-st" id="yiyi-256">从第一行删除所有主要的空白字符。</span><span class="yiyi-st" id="yiyi-257">任何可从第二行向前均匀删除的空白字符将被删除。</span><span class="yiyi-st" id="yiyi-258">随后删除开头和结尾的空行。</span><span class="yiyi-st" id="yiyi-259">此外，所有选项卡都扩展为空格。</span></p></dd></dl></div><div class="section" id="introspecting-callables-with-the-signature-object"><h2><span class="yiyi-st" id="yiyi-260">29.12.3. </span><span class="yiyi-st" id="yiyi-261">使用Signature对象抽象可调式对象</span></h2><div class="versionadded"><p><span class="yiyi-st" id="yiyi-262"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><p><span class="yiyi-st" id="yiyi-263">Signature对象表示可调用对象的调用签名及其返回注释。</span><span class="yiyi-st" id="yiyi-264">要检索签名对象，请使用<a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal"><span class="pre">signature()</span></code></a>函数。</span></p><dl class="function"><dt id="inspect.signature"><span class="yiyi-st" id="yiyi-265"> <code class="descclassname">inspect.</code><code class="descname">signature</code><span class="sig-paren">(</span><em>callable</em>, <em>*</em>, <em>follow_wrapped=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-266">为给定的<code class="docutils literal"><span class="pre">callable</span></code>返回一个<a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code class="xref py py-class docutils literal"><span class="pre">Signature</span></code></a>对象：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
<span class="go">'(a, *, b:int, **kwargs)'</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'b'</span><span class="p">])</span>
<span class="go">'b:int'</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'b'</span><span class="p">]</span><span class="o">.</span><span class="n">annotation</span>
<span class="go">&lt;class 'int'&gt;</span>
</code></pre><p><span class="yiyi-st" id="yiyi-267">从普通函数和类到<a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></code></a>对象接受大量的python可调参数。</span></p><p><span class="yiyi-st" id="yiyi-268">如果不提供签名，则引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>；如果不支持该类型的对象，则引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-269"><span class="versionmodified">版本3.5中的新功能：</span> <code class="docutils literal"><span class="pre">follow_wrapped</span></code>参数。</span><span class="yiyi-st" id="yiyi-270">通过<code class="docutils literal"><span class="pre">False</span></code>获得<code class="docutils literal"><span class="pre">callable</span></code>的特征（<code class="docutils literal"><span class="pre">callable.__wrapped__</span></code>不会用于解开装饰可调用）。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-271">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-272">在Python的某些实现中，某些可调用对象可能不是内省的。</span><span class="yiyi-st" id="yiyi-273">例如，在CPython中，C中定义的一些内置函数不提供关于它们参数的元数据。</span></p></div></dd></dl><dl class="class"><dt id="inspect.Signature"><span class="yiyi-st" id="yiyi-274"> <em class="property">class </em><code class="descclassname">inspect.</code><code class="descname">Signature</code><span class="sig-paren">(</span><em>parameters=None</em>, <em>*</em>, <em>return_annotation=Signature.empty</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-275">Signature对象表示函数的调用签名及其返回注释。</span><span class="yiyi-st" id="yiyi-276">对于函数接受的每个参数，它都会在<a class="reference internal" href="#inspect.Signature.parameters" title="inspect.Signature.parameters"><code class="xref py py-attr docutils literal"><span class="pre">parameters</span></code></a>集合中存储<a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal"><span class="pre">Parameter</span></code></a>对象。</span></p><p><span class="yiyi-st" id="yiyi-277">可选的<em>参数</em>参数是一系列<a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal"><span class="pre">Parameter</span></code></a>对象，经过验证可以检查是否没有带重复名称的参数，并且参数的顺序是正确的</span><span class="yiyi-st" id="yiyi-278">首先是位置，然后是位置或关键字，并且具有默认值的参数遵循没有默认值的参数。</span></p><p><span class="yiyi-st" id="yiyi-279">可选的<em>return_annotation</em>参数可以是一个任意的Python对象，是可调用对象的“返回”注释。</span></p><p><span class="yiyi-st" id="yiyi-280">签名对象是<em>不可变的</em>。</span><span class="yiyi-st" id="yiyi-281">使用<a class="reference internal" href="#inspect.Signature.replace" title="inspect.Signature.replace"><code class="xref py py-meth docutils literal"><span class="pre">Signature.replace()</span></code></a>进行修改后的副本。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-282"><span class="versionmodified">在版本3.5中更改：</span>签名对象是可挑选和可散列的。</span></p></div><dl class="attribute"><dt id="inspect.Signature.empty"><span class="yiyi-st" id="yiyi-283"> <code class="descname">empty</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-284">一种特殊的级别标记，用于指定缺少返回注释。</span></p></dd></dl><dl class="attribute"><dt id="inspect.Signature.parameters"><span class="yiyi-st" id="yiyi-285"> <code class="descname">parameters</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-286">参数名称到相应的<a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal"><span class="pre">Parameter</span></code></a>对象的有序映射。</span></p></dd></dl><dl class="attribute"><dt id="inspect.Signature.return_annotation"><span class="yiyi-st" id="yiyi-287"> <code class="descname">return_annotation</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-288">可调用的“返回”注释。</span><span class="yiyi-st" id="yiyi-289">如果可调用对象没有“返回”注释，则将此属性设置为<a class="reference internal" href="#inspect.Signature.empty" title="inspect.Signature.empty"><code class="xref py py-attr docutils literal"><span class="pre">Signature.empty</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="inspect.Signature.bind"><span class="yiyi-st" id="yiyi-290"> <code class="descname">bind</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-291">从位置和关键字参数创建一个映射到参数。</span><span class="yiyi-st" id="yiyi-292">如果<code class="docutils literal"><span class="pre">*args</span></code>和<code class="docutils literal"><span class="pre">**kwargs</span></code>匹配签名，或者引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>，则返回<a class="reference internal" href="#inspect.BoundArguments" title="inspect.BoundArguments"><code class="xref py py-class docutils literal"><span class="pre">BoundArguments</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="inspect.Signature.bind_partial"><span class="yiyi-st" id="yiyi-293"> <code class="descname">bind_partial</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-294">与<a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code class="xref py py-meth docutils literal"><span class="pre">Signature.bind()</span></code></a>的工作方式相同，但允许省略一些必需的参数（模仿<a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></code></a>行为）。</span><span class="yiyi-st" id="yiyi-295">如果传递的参数与签名不匹配，则返回<a class="reference internal" href="#inspect.BoundArguments" title="inspect.BoundArguments"><code class="xref py py-class docutils literal"><span class="pre">BoundArguments</span></code></a>，否则引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="inspect.Signature.replace"><span class="yiyi-st" id="yiyi-296"> <code class="descname">replace</code><span class="sig-paren">(</span><em>*[, parameters][, return_annotation]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-297">根据调用的实例替换创建新的Signature实例。</span><span class="yiyi-st" id="yiyi-298">可以传递不同的<code class="docutils literal"><span class="pre">parameters</span></code>和/或<code class="docutils literal"><span class="pre">return_annotation</span></code>来覆盖基本签名的相应属性。</span><span class="yiyi-st" id="yiyi-299">要从复制的签名中删除return_annotation，请传入<a class="reference internal" href="#inspect.Signature.empty" title="inspect.Signature.empty"><code class="xref py py-attr docutils literal"><span class="pre">Signature.empty</span></code></a>。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">return_annotation</span><span class="o">=</span><span class="s2">"new return anno"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">new_sig</span><span class="p">)</span>
<span class="go">"(a, b) -&gt; 'new return anno'"</span>
</code></pre></dd></dl><dl class="classmethod"><dt id="inspect.Signature.from_callable"><span class="yiyi-st" id="yiyi-300"> <em class="property">classmethod </em><code class="descname">from_callable</code><span class="sig-paren">(</span><em>obj</em>, <em>*</em>, <em>follow_wrapped=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-301">为给定的可调用<code class="docutils literal"><span class="pre">obj</span></code>返回一个<a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code class="xref py py-class docutils literal"><span class="pre">Signature</span></code></a>（或其子类）对象。</span><span class="yiyi-st" id="yiyi-302">Pass <code class="docutils literal"><span class="pre">follow_wrapped=False</span></code> to get a signature of <code class="docutils literal"><span class="pre">obj</span></code> without unwrapping its <code class="docutils literal"><span class="pre">__wrapped__</span></code> chain.</span></p><p><span class="yiyi-st" id="yiyi-303">该方法简化了<a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code class="xref py py-class docutils literal"><span class="pre">Signature</span></code></a>的子类化：</span></p><pre><code class="language-python"><span></span><span class="k">class</span> <span class="nc">MySignature</span><span class="p">(</span><span class="n">Signature</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">sig</span> <span class="o">=</span> <span class="n">MySignature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">MySignature</span><span class="p">)</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-304"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl></dd></dl><dl class="class"><dt id="inspect.Parameter"><span class="yiyi-st" id="yiyi-305"> <em class="property">class </em><code class="descclassname">inspect.</code><code class="descname">Parameter</code><span class="sig-paren">(</span><em>name</em>, <em>kind</em>, <em>*</em>, <em>default=Parameter.empty</em>, <em>annotation=Parameter.empty</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-306">参数对象是<em>不可变的</em>。</span><span class="yiyi-st" id="yiyi-307">您可以使用<a class="reference internal" href="#inspect.Parameter.replace" title="inspect.Parameter.replace"><code class="xref py py-meth docutils literal"><span class="pre">Parameter.replace()</span></code></a>创建修改的副本，而不是修改Parameter对象。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-308"><span class="versionmodified">在版本3.5中更改：</span>参数对象是可挑选和可散列的。</span></p></div><dl class="attribute"><dt id="inspect.Parameter.empty"><span class="yiyi-st" id="yiyi-309"> <code class="descname">empty</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-310">一种特殊的级别标记，用于指定缺省值和注释的缺失。</span></p></dd></dl><dl class="attribute"><dt id="inspect.Parameter.name"><span class="yiyi-st" id="yiyi-311"> <code class="descname">name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-312">参数的名称作为字符串。</span><span class="yiyi-st" id="yiyi-313">该名称必须是有效的Python标识符。</span></p></dd></dl><dl class="attribute"><dt id="inspect.Parameter.default"><span class="yiyi-st" id="yiyi-314"> <code class="descname">default</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-315">参数的默认值。</span><span class="yiyi-st" id="yiyi-316">如果该参数没有默认值，则将此属性设置为<a class="reference internal" href="#inspect.Parameter.empty" title="inspect.Parameter.empty"><code class="xref py py-attr docutils literal"><span class="pre">Parameter.empty</span></code></a>。</span></p></dd></dl><dl class="attribute"><dt id="inspect.Parameter.annotation"><span class="yiyi-st" id="yiyi-317"> <code class="descname">annotation</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-318">参数的注释。</span><span class="yiyi-st" id="yiyi-319">如果该参数没有注释，则该属性设置为<a class="reference internal" href="#inspect.Parameter.empty" title="inspect.Parameter.empty"><code class="xref py py-attr docutils literal"><span class="pre">Parameter.empty</span></code></a>。</span></p></dd></dl><dl class="attribute"><dt id="inspect.Parameter.kind"><span class="yiyi-st" id="yiyi-320"> <code class="descname">kind</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-321">描述参数值如何绑定到参数。</span><span class="yiyi-st" id="yiyi-322">可能的值（可通过<a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal"><span class="pre">Parameter</span></code></a>访问，如<code class="docutils literal"><span class="pre">Parameter.KEYWORD_ONLY</span></code>）：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-323">名称</span></th><th class="head"><span class="yiyi-st" id="yiyi-324">含义</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-325"><em>POSITIONAL_ONLY</em></span></td><td><p class="first"><span class="yiyi-st" id="yiyi-326">值必须作为位置参数提供。</span></p><p class="last"><span class="yiyi-st" id="yiyi-327">Python没有明确的定义位置参数的语法，但是许多内置和扩展模块函数（特别是只接受一个或两个参数的函数）接受它们。</span></p></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-328"><em>POSITIONAL_OR_KEYWORD</em></span></td><td><span class="yiyi-st" id="yiyi-329">值可以作为关键字或位置参数提供（这是用Python实现的函数的标准绑定行为。）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-330"><em>VAR_POSITIONAL</em></span></td><td><span class="yiyi-st" id="yiyi-331">位置参数的元组没有绑定到任何其他参数。</span><span class="yiyi-st" id="yiyi-332">这对应于Python函数定义中的<code class="docutils literal"><span class="pre">*args</span></code>参数。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-333"><em>KEYWORD_ONLY</em></span></td><td><span class="yiyi-st" id="yiyi-334">值必须作为关键字参数提供。</span><span class="yiyi-st" id="yiyi-335">仅限关键字参数是在Python函数定义中的<code class="docutils literal"><span class="pre">*</span></code>或<code class="docutils literal"><span class="pre">*args</span></code>条目之后出现的参数。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-336"><em>VAR_KEYWORD</em></span></td><td><span class="yiyi-st" id="yiyi-337">没有绑定到任何其他参数的关键字参数的字典。</span><span class="yiyi-st" id="yiyi-338">这对应于Python函数定义中的<code class="docutils literal"><span class="pre">**kwargs</span></code>参数。</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-339">例如：打印没有默认值的所有关键字参数：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span> <span class="ow">and</span>
<span class="gp">... </span>                       <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">'Parameter:'</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
<span class="go">Parameter: c</span>
</code></pre></dd></dl><dl class="method"><dt id="inspect.Parameter.replace"><span class="yiyi-st" id="yiyi-340"> <code class="descname">replace</code><span class="sig-paren">(</span><em>*[, name][, kind][, default][, annotation]</em><span class="sig-paren">)</span></span></dt><dd><span class="yiyi-st" id="yiyi-343"><blockquote> <div><p>Create a new Parameter instance based on the instance replaced was invoked on. To override a <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal"><span class="pre">Parameter</span></code></a> attribute, pass the corresponding argument. To remove a default value or/and an annotation from a Parameter, pass <a class="reference internal" href="#inspect.Parameter.empty" title="inspect.Parameter.empty"><code class="xref py py-attr docutils literal"><span class="pre">Parameter.empty</span></code></a>.</p> <pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">Parameter</span> <span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span> <span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="go">'foo=42'</span> <span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">())</span> <span class="c1"># Will create a shallow copy of 'param'</span> <span class="go">'foo=42'</span> <span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="s1">'spam'</span><span class="p">))</span> <span class="go">"foo:'spam'"</span> </code></pre> </div></blockquote></span><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-341"><span class="versionmodified">Changed in version 3.4: </span>In Python 3.3 Parameter objects were allowed to have <code class="docutils literal"><span class="pre">name</span></code> set to <code class="docutils literal"><span class="pre">None</span></code> if their <code class="docutils literal"><span class="pre">kind</span></code> was set to <code class="docutils literal"><span class="pre">POSITIONAL_ONLY</span></code>. </span><span class="yiyi-st" id="yiyi-342">这不再被允许。</span></p></div></dd></dl></dd></dl><dl class="class"><dt id="inspect.BoundArguments"><span class="yiyi-st" id="yiyi-344"> <em class="property">class </em><code class="descclassname">inspect.</code><code class="descname">BoundArguments</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-345"><a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code class="xref py py-meth docutils literal"><span class="pre">Signature.bind()</span></code></a>或<a class="reference internal" href="#inspect.Signature.bind_partial" title="inspect.Signature.bind_partial"><code class="xref py py-meth docutils literal"><span class="pre">Signature.bind_partial()</span></code></a>调用的结果。</span><span class="yiyi-st" id="yiyi-346">保存参数映射到函数的参数。</span></p><dl class="attribute"><dt id="inspect.BoundArguments.arguments"><span class="yiyi-st" id="yiyi-347"> <code class="descname">arguments</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-348">参数'名称到参数'值的有序可变映射（<a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal"><span class="pre">collections.OrderedDict</span></code></a>）。</span><span class="yiyi-st" id="yiyi-349">仅包含显式绑定的参数。</span><span class="yiyi-st" id="yiyi-350"><a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code class="xref py py-attr docutils literal"><span class="pre">arguments</span></code></a>将反映在<a class="reference internal" href="#inspect.BoundArguments.args" title="inspect.BoundArguments.args"><code class="xref py py-attr docutils literal"><span class="pre">args</span></code></a>和<a class="reference internal" href="#inspect.BoundArguments.kwargs" title="inspect.BoundArguments.kwargs"><code class="xref py py-attr docutils literal"><span class="pre">kwargs</span></code></a>中。</span></p><p><span class="yiyi-st" id="yiyi-351">应该与<a class="reference internal" href="#inspect.Signature.parameters" title="inspect.Signature.parameters"><code class="xref py py-attr docutils literal"><span class="pre">Signature.parameters</span></code></a>一起用于任何参数处理目的。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-352">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-353">其中<a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code class="xref py py-meth docutils literal"><span class="pre">Signature.bind()</span></code></a>或<a class="reference internal" href="#inspect.Signature.bind_partial" title="inspect.Signature.bind_partial"><code class="xref py py-meth docutils literal"><span class="pre">Signature.bind_partial()</span></code></a>依赖于默认值的参数将被跳过。</span><span class="yiyi-st" id="yiyi-354">但是，如果需要，可以使用<a class="reference internal" href="#inspect.BoundArguments.apply_defaults" title="inspect.BoundArguments.apply_defaults"><code class="xref py py-meth docutils literal"><span class="pre">BoundArguments.apply_defaults()</span></code></a>来添加它们。</span></p></div></dd></dl><dl class="attribute"><dt id="inspect.BoundArguments.args"><span class="yiyi-st" id="yiyi-355"> <code class="descname">args</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-356">位置参数值的元组。</span><span class="yiyi-st" id="yiyi-357">从<a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code class="xref py py-attr docutils literal"><span class="pre">arguments</span></code></a>属性动态计算。</span></p></dd></dl><dl class="attribute"><dt id="inspect.BoundArguments.kwargs"><span class="yiyi-st" id="yiyi-358"> <code class="descname">kwargs</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-359">关键字参数值的字典。</span><span class="yiyi-st" id="yiyi-360">从<a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code class="xref py py-attr docutils literal"><span class="pre">arguments</span></code></a>属性动态计算。</span></p></dd></dl><dl class="attribute"><dt id="inspect.BoundArguments.signature"><span class="yiyi-st" id="yiyi-361"> <code class="descname">signature</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-362">对父<a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code class="xref py py-class docutils literal"><span class="pre">Signature</span></code></a>对象的引用。</span></p></dd></dl><dl class="method"><dt id="inspect.BoundArguments.apply_defaults"><span class="yiyi-st" id="yiyi-363"> <code class="descname">apply_defaults</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-364">为缺少的参数设置默认值。</span></p><p><span class="yiyi-st" id="yiyi-365">对于变量位置参数（<code class="docutils literal"><span class="pre">*args</span></code>），默认值是一个空元组。</span></p><p><span class="yiyi-st" id="yiyi-366">对于变量关键字参数（<code class="docutils literal"><span class="pre">**kwargs</span></code>），默认为空字典。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s1">'ham'</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ba</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ba</span><span class="o">.</span><span class="n">apply_defaults</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ba</span><span class="o">.</span><span class="n">arguments</span>
<span class="go">OrderedDict([('a', 'spam'), ('b', 'ham'), ('args', ())])</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-367"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-368"><a class="reference internal" href="#inspect.BoundArguments.args" title="inspect.BoundArguments.args"><code class="xref py py-attr docutils literal"><span class="pre">args</span></code></a>和<a class="reference internal" href="#inspect.BoundArguments.kwargs" title="inspect.BoundArguments.kwargs"><code class="xref py py-attr docutils literal"><span class="pre">kwargs</span></code></a>属性可用于调用函数：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="n">ba</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="o">*</span><span class="n">ba</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">ba</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></dd></dl><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-369">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-370"><span class="target" id="index-0"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0362"><strong>PEP 362</strong></a>  - 功能签名对象。</span></dt><dd><span class="yiyi-st" id="yiyi-371">详细的规范，实现细节和示例。</span></dd></dl></div></div><div class="section" id="classes-and-functions"><h2><span class="yiyi-st" id="yiyi-372">29.12.4. </span><span class="yiyi-st" id="yiyi-373">类和函数</span></h2><dl class="function"><dt id="inspect.getclasstree"><span class="yiyi-st" id="yiyi-374"> <code class="descclassname">inspect.</code><code class="descname">getclasstree</code><span class="sig-paren">(</span><em>classes</em>, <em>unique=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-375">将给定的类列表排列成嵌套列表的层次结构。</span><span class="yiyi-st" id="yiyi-376">在出现嵌套列表的情况下，它包含从其条目紧接在列表之前的类派生的类。</span><span class="yiyi-st" id="yiyi-377">每个条目都是一个2元组，其中包含一个类和其基类的元组。</span><span class="yiyi-st" id="yiyi-378">如果<em>唯一</em>参数为true，则给定列表中每个类的返回结构中只会出现一个条目。</span><span class="yiyi-st" id="yiyi-379">否则，使用多重继承的类和它们的后代将多次出现。</span></p></dd></dl><dl class="function"><dt id="inspect.getargspec"><span class="yiyi-st" id="yiyi-380"> <code class="descclassname">inspect.</code><code class="descname">getargspec</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-381">获取Python函数参数的名称和默认值。</span><span class="yiyi-st" id="yiyi-382"><a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code class="docutils literal"><span class="pre">ArgSpec（args，</span> <span class="pre">varargs，</span> <span class="pre">关键字，</span> <span class="pre">默认值） t6 &gt;</span></code>返回。</span><span class="yiyi-st" id="yiyi-383"><em>args</em>是参数名称的列表。</span><span class="yiyi-st" id="yiyi-384"><em>varargs</em>和<em>关键字</em>是<code class="docutils literal"><span class="pre">*</span></code>和<code class="docutils literal"><span class="pre">**</span></code>参数的名称或<code class="docutils literal"><span class="pre">None</span></code> 。</span><span class="yiyi-st" id="yiyi-385"><em>默认值</em>是默认参数值的元组，或<code class="docutils literal"><span class="pre">None</span></code>，如果没有默认参数的话；如果这个元组具有<em>n</em>元素，则它们对应于<em>args</em>中列出的最后一个<em>n</em>元素。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-386"><span class="versionmodified">从版本3.0开始弃用：</span>使用<a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal"><span class="pre">signature()</span></code></a>和<a class="reference internal" href="#inspect-signature-object"><span>Signature Object</span></a>，为可调参数提供更好的内省API。</span></p></div></dd></dl><dl class="function"><dt id="inspect.getfullargspec"><span class="yiyi-st" id="yiyi-387"> <code class="descclassname">inspect.</code><code class="descname">getfullargspec</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-388">获取Python函数参数的名称和默认值。</span><span class="yiyi-st" id="yiyi-389">A <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> is returned:</span></p><p><span class="yiyi-st" id="yiyi-390"><code class="docutils literal"><span class="pre">FullArgSpec(args,</span> <span class="pre">varargs,</span> <span class="pre">varkw,</span> <span class="pre">defaults,</span> <span class="pre">kwonlyargs,</span> <span class="pre">kwonlydefaults,</span> <span class="pre">annotations)</span></code></span></p><p><span class="yiyi-st" id="yiyi-391"><em>args</em>是参数名称的列表。</span><span class="yiyi-st" id="yiyi-392"><em>varargs</em>和<em>varkw</em>是<code class="docutils literal"><span class="pre">*</span></code>和<code class="docutils literal"><span class="pre">**</span></code>参数的名称或<code class="docutils literal"><span class="pre">None</span></code> 。</span><span class="yiyi-st" id="yiyi-393"><em>默认值</em>是最后一个<em>n</em>参数的默认值的<em>n</em>值，或<code class="docutils literal"><span class="pre">None</span></code>默认参数。</span><span class="yiyi-st" id="yiyi-394"><em>kwonlyargs</em>是关键字参数名称列表。</span><span class="yiyi-st" id="yiyi-395"><em>kwonlydefaults</em>是将kwonlyargs中的名称映射为默认值的字典。</span><span class="yiyi-st" id="yiyi-396"><em>注释</em>是将参数名称映射到注释的字典。</span></p><p><span class="yiyi-st" id="yiyi-397">元组中的前四项对应于<a class="reference internal" href="#inspect.getargspec" title="inspect.getargspec"><code class="xref py py-func docutils literal"><span class="pre">getargspec()</span></code></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-398"><span class="versionmodified">在版本3.4中更改：</span>此函数现在基于<a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal"><span class="pre">signature()</span></code></a>，但仍忽略<code class="docutils literal"><span class="pre">__wrapped__</span></code>属性，并包含已绑定的第一个参数绑定方法的签名输出。</span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-399"><span class="versionmodified">从版本3.5开始不推荐使用：</span>使用<a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal"><span class="pre">signature()</span></code></a>和<a class="reference internal" href="#inspect-signature-object"><span>Signature Object</span></a>，为可调参数提供更好的内省API。</span></p></div></dd></dl><dl class="function"><dt id="inspect.getargvalues"><span class="yiyi-st" id="yiyi-400"> <code class="descclassname">inspect.</code><code class="descname">getargvalues</code><span class="sig-paren">(</span><em>frame</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-401">获取有关传递到特定框架的参数的信息。</span><span class="yiyi-st" id="yiyi-402">A <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code class="docutils literal"><span class="pre">ArgInfo(args,</span> <span class="pre">varargs,</span> <span class="pre">keywords,</span> <span class="pre">locals)</span></code> is returned. </span><span class="yiyi-st" id="yiyi-403"><em>args</em>是参数名称的列表。</span><span class="yiyi-st" id="yiyi-404"><em>varargs</em>和<em>关键字</em>是<code class="docutils literal"><span class="pre">*</span></code>和<code class="docutils literal"><span class="pre">**</span></code>参数的名称或<code class="docutils literal"><span class="pre">None</span></code> 。</span><span class="yiyi-st" id="yiyi-405"><em>locals</em> is the locals dictionary of the given frame.</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-406"><span class="versionmodified">从版本3.5开始不推荐使用：</span>使用<a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal"><span class="pre">signature()</span></code></a>和<a class="reference internal" href="#inspect-signature-object"><span>Signature Object</span></a>，为可调参数提供更好的内省API。</span></p></div></dd></dl><dl class="function"><dt id="inspect.formatargspec"><span class="yiyi-st" id="yiyi-407"> <code class="descclassname">inspect.</code><code class="descname">formatargspec</code><span class="sig-paren">(</span><em>args</em><span class="optional">[</span>, <em>varargs</em>, <em>varkw</em>, <em>defaults</em>, <em>kwonlyargs</em>, <em>kwonlydefaults</em>, <em>annotations</em><span class="optional">[</span>, <em>formatarg</em>, <em>formatvarargs</em>, <em>formatvarkw</em>, <em>formatvalue</em>, <em>formatreturns</em>, <em>formatannotations</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-408">根据<a class="reference internal" href="#inspect.getargspec" title="inspect.getargspec"><code class="xref py py-func docutils literal"><span class="pre">getargspec()</span></code></a>或<a class="reference internal" href="#inspect.getfullargspec" title="inspect.getfullargspec"><code class="xref py py-func docutils literal"><span class="pre">getfullargspec()</span></code></a>返回的值格式化漂亮的参数规范。</span></p><p><span class="yiyi-st" id="yiyi-409">前七个参数是（<code class="docutils literal"><span class="pre">args</span></code>，<code class="docutils literal"><span class="pre">varargs</span></code>，<code class="docutils literal"><span class="pre">varkw</span></code>，<code class="docutils literal"><span class="pre">defaults</span></code>，<code class="docutils literal"><span class="pre">kwonlyargs</span></code> ，<code class="docutils literal"><span class="pre">kwonlydefaults</span></code>，<code class="docutils literal"><span class="pre">annotations</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-410">The other six arguments are functions that are called to turn argument names, <code class="docutils literal"><span class="pre">*</span></code> argument name, <code class="docutils literal"><span class="pre">**</span></code> argument name, default values, return annotation and individual annotations into strings, respectively.</span></p><p><span class="yiyi-st" id="yiyi-411">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">formatargspec</span><span class="p">,</span> <span class="n">getfullargspec</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">formatargspec</span><span class="p">(</span><span class="o">*</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">'(a: int, b: float)'</span>
</code></pre><div class="deprecated"><p><span class="yiyi-st" id="yiyi-412"><span class="versionmodified">从版本3.5开始不推荐使用：</span>使用<a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal"><span class="pre">signature()</span></code></a>和<a class="reference internal" href="#inspect-signature-object"><span>Signature Object</span></a>，为可调参数提供更好的内省API。</span></p></div></dd></dl><dl class="function"><dt id="inspect.formatargvalues"><span class="yiyi-st" id="yiyi-413"> <code class="descclassname">inspect.</code><code class="descname">formatargvalues</code><span class="sig-paren">(</span><em>args</em><span class="optional">[</span>, <em>varargs</em>, <em>varkw</em>, <em>locals</em>, <em>formatarg</em>, <em>formatvarargs</em>, <em>formatvarkw</em>, <em>formatvalue</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-414">根据<a class="reference internal" href="#inspect.getargvalues" title="inspect.getargvalues"><code class="xref py py-func docutils literal"><span class="pre">getargvalues()</span></code></a>返回的四个值格式化漂亮的参数规范。</span><span class="yiyi-st" id="yiyi-415">格式*参数是相应的可选格式函数，被称为将名称和值转换为字符串。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-416"><span class="versionmodified">从版本3.5开始不推荐使用：</span>使用<a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal"><span class="pre">signature()</span></code></a>和<a class="reference internal" href="#inspect-signature-object"><span>Signature Object</span></a>，为可调参数提供更好的内省API。</span></p></div></dd></dl><dl class="function"><dt id="inspect.getmro"><span class="yiyi-st" id="yiyi-417"> <code class="descclassname">inspect.</code><code class="descname">getmro</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-418">以方法解析顺序返回cls基类的元组，包括cls。</span><span class="yiyi-st" id="yiyi-419">这个元组中不会出现多次类。</span><span class="yiyi-st" id="yiyi-420">请注意，方法解析顺序取决于cls的类型。</span><span class="yiyi-st" id="yiyi-421">除非使用非常独特的用户定义的元类型，否则cls将是元组的第一个元素。</span></p></dd></dl><dl class="function"><dt id="inspect.getcallargs"><span class="yiyi-st" id="yiyi-422"> <code class="descclassname">inspect.</code><code class="descname">getcallargs</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-423">将<em>args</em>和<em>kwds</em>绑定到Python函数或方法<em>func</em>的参数名称，就好像它们是用它们调用的一样。</span><span class="yiyi-st" id="yiyi-424">对于绑定方法，还要将第一个参数（通常名为<code class="docutils literal"><span class="pre">self</span></code>）绑定到关联的实例。</span><span class="yiyi-st" id="yiyi-425">返回一个字典，将参数名称（包括<code class="docutils literal"><span class="pre">*</span></code>和<code class="docutils literal"><span class="pre">**</span></code>参数的名称，如果有的话）映射到<em>args</em>和<em>kwds</em>。</span><span class="yiyi-st" id="yiyi-426">在错误地调用<em>func</em>的情况下，即</span><span class="yiyi-st" id="yiyi-427">每当<code class="docutils literal"><span class="pre">func（* args，</span> <span class="pre">** kwds）</span></code>会引发异常，因为签名不兼容，相同类型的异常或相同类似的消息被提出。</span><span class="yiyi-st" id="yiyi-428">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">getcallargs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">**</span><span class="n">named</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcallargs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">'a'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'named'</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">'b'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)}</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcallargs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">'a'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'named'</span><span class="p">:</span> <span class="p">{</span><span class="s1">'x'</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span> <span class="s1">'b'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'pos'</span><span class="p">:</span> <span class="p">()}</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcallargs</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">f() missing 1 required positional argument: 'a'</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-429"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-430"><span class="versionmodified">从版本3.5开始弃用：</span>改为使用<a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code class="xref py py-meth docutils literal"><span class="pre">Signature.bind()</span></code></a>和<a class="reference internal" href="#inspect.Signature.bind_partial" title="inspect.Signature.bind_partial"><code class="xref py py-meth docutils literal"><span class="pre">Signature.bind_partial()</span></code></a>。</span></p></div></dd></dl><dl class="function"><dt id="inspect.getclosurevars"><span class="yiyi-st" id="yiyi-431"> <code class="descclassname">inspect.</code><code class="descname">getclosurevars</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-432">获取Python函数或方法<em>func</em>中的外部名称引用到其当前值的映射。</span><span class="yiyi-st" id="yiyi-433"><a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code class="docutils literal"><span class="pre">ClosureVars（nonlocals，</span> <span class="pre">全局变量，</span> <span class="pre">内置变量，</span> <span class="pre">未绑定） t6 &gt;</span></code>返回。</span><span class="yiyi-st" id="yiyi-434"><em>nonlocals</em>将引用名称映射到词法封闭变量，将<em>globals</em>映射到函数的模块全局变量，将<em>builtins</em>映射到可从函数体可见的内建变量。</span><span class="yiyi-st" id="yiyi-435"><em>unbound</em>是函数中引用的名称集，根据当前的模块全局变量和内建函数，它们根本无法解析。</span></p><p><span class="yiyi-st" id="yiyi-436"><a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> is raised if <em>func</em> is not a Python function or method.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-437"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="inspect.unwrap"><span class="yiyi-st" id="yiyi-438"> <code class="descclassname">inspect.</code><code class="descname">unwrap</code><span class="sig-paren">(</span><em>func</em>, <em>*</em>, <em>stop=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-439">获取由<em>func</em>包装的对象。</span><span class="yiyi-st" id="yiyi-440">它遵循返回链中最后一个对象的<code class="xref py py-attr docutils literal"><span class="pre">__wrapped__</span></code>属性链。</span></p><p><span class="yiyi-st" id="yiyi-441"><em>stop</em>是一个可选的回调函数，它接受包装链中的一个对象作为唯一参数，如果回调函数返回一个真正的值，则允许提前终止解包。</span><span class="yiyi-st" id="yiyi-442">如果回调从不返回真值，则链中的最后一个对象将照常返回。</span><span class="yiyi-st" id="yiyi-443">例如，如果链中的任何对象具有定义的<code class="docutils literal"><span class="pre">__signature__</span></code>属性，那么<a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal"><span class="pre">signature()</span></code></a>使用它来停止解包。</span></p><p><span class="yiyi-st" id="yiyi-444"><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> is raised if a cycle is encountered.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-445"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="the-interpreter-stack"><h2><span class="yiyi-st" id="yiyi-446">29.12.5. </span><span class="yiyi-st" id="yiyi-447">解释器堆栈</span></h2><p><span class="yiyi-st" id="yiyi-448">When the following functions return “frame records,” each record is a <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code class="docutils literal"><span class="pre">FrameInfo(frame,</span> <span class="pre">filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code>. </span><span class="yiyi-st" id="yiyi-449">该元组包含框架对象，文件名，当前行的行号，函数名称，源代码中的上下文行列表以及该列表中当前行的索引。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-450"><span class="versionmodified">版本3.5中更改：</span>返回一个命名的元组而不是元组。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-451">注意</span></p><p><span class="yiyi-st" id="yiyi-452">保持对框架对象的引用，如框架记录的第一个元素中所记录的这些函数返回，可能会导致程序创建引用循环。</span><span class="yiyi-st" id="yiyi-453">一旦创建了一个引用循环，即使启用了Python的可选循环检测器，所有可以从形成循环的对象访问的所有对象的生命周期也可能变得更长。</span><span class="yiyi-st" id="yiyi-454">如果必须创建这样的周期，重要的是要确保它们被明确分解以避免对象的延迟破坏和增加的内存消耗。</span></p><p><span class="yiyi-st" id="yiyi-455">虽然周期检测器会捕获这些，但通过删除<a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a>子句中的周期，可以确定帧（和局部变量）被破坏。</span><span class="yiyi-st" id="yiyi-456">如果在编译Python或使用<a class="reference internal" href="gc.html#gc.disable" title="gc.disable"><code class="xref py py-func docutils literal"><span class="pre">gc.disable()</span></code></a>时禁用周期检测器，这也很重要。</span><span class="yiyi-st" id="yiyi-457">例如：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">handle_stackframe_without_leak</span><span class="p">():</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># do something with the frame</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">frame</span>
</code></pre><p class="last"><span class="yiyi-st" id="yiyi-458">如果要保留框架（例如稍后打印回溯），还可以使用<a class="reference internal" href="../reference/datamodel.html#frame.clear" title="frame.clear"><code class="xref py py-meth docutils literal"><span class="pre">frame.clear()</span></code></a>方法来中断参考周期。</span></p></div><p><span class="yiyi-st" id="yiyi-459">大多数这些函数支持的可选<em>context</em>参数指定要返回的上下文的行数，它们以当前行为中心。</span></p><dl class="function"><dt id="inspect.getframeinfo"><span class="yiyi-st" id="yiyi-460"> <code class="descclassname">inspect.</code><code class="descname">getframeinfo</code><span class="sig-paren">(</span><em>frame</em>, <em>context=1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-461">获取关于帧或追溯对象的信息。</span><span class="yiyi-st" id="yiyi-462">A <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code class="docutils literal"><span class="pre">Traceback(filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code> is returned.</span></p></dd></dl><dl class="function"><dt id="inspect.getouterframes"><span class="yiyi-st" id="yiyi-463"> <code class="descclassname">inspect.</code><code class="descname">getouterframes</code><span class="sig-paren">(</span><em>frame</em>, <em>context=1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-464">获取一个帧和所有外部帧的帧记录列表。</span><span class="yiyi-st" id="yiyi-465">这些帧表示导致创建<em>帧</em>的调用。</span><span class="yiyi-st" id="yiyi-466">返回列表中的第一个条目表示<em>框架</em>；最后一个条目代表<em>frame</em>堆栈上的最外层调用。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-467"><span class="versionmodified">Changed in version 3.5: </span>A list of <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuples</span></a> <code class="docutils literal"><span class="pre">FrameInfo(frame,</span> <span class="pre">filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code> is returned.</span></p></div></dd></dl><dl class="function"><dt id="inspect.getinnerframes"><span class="yiyi-st" id="yiyi-468"> <code class="descclassname">inspect.</code><code class="descname">getinnerframes</code><span class="sig-paren">(</span><em>traceback</em>, <em>context=1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-469">获取追踪帧和所有内部帧的帧记录列表。</span><span class="yiyi-st" id="yiyi-470">这些框架表示由<em>框架</em>引起的调用。</span><span class="yiyi-st" id="yiyi-471">列表中的第一个条目表示<em>traceback</em>；最后一个条目表示引发异常的位置。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-472"><span class="versionmodified">Changed in version 3.5: </span>A list of <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuples</span></a> <code class="docutils literal"><span class="pre">FrameInfo(frame,</span> <span class="pre">filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code> is returned.</span></p></div></dd></dl><dl class="function"><dt id="inspect.currentframe"><span class="yiyi-st" id="yiyi-473"> <code class="descclassname">inspect.</code><code class="descname">currentframe</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-474">返回当前调用者的堆栈框架的框架对象。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-475"><strong>CPython implementation detail:</strong> This function relies on Python stack frame support in the interpreter, which isn’t guaranteed to exist in all implementations of Python. </span><span class="yiyi-st" id="yiyi-476">如果在没有Python堆栈帧支持的实现中运行，该函数返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p></div></dd></dl><dl class="function"><dt id="inspect.stack"><span class="yiyi-st" id="yiyi-477"> <code class="descclassname">inspect.</code><code class="descname">stack</code><span class="sig-paren">(</span><em>context=1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-478">返回调用者堆栈的帧记录列表。</span><span class="yiyi-st" id="yiyi-479">返回列表中的第一个条目表示调用者；最后一个条目代表堆叠上最外面的呼叫。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-480"><span class="versionmodified">Changed in version 3.5: </span>A list of <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuples</span></a> <code class="docutils literal"><span class="pre">FrameInfo(frame,</span> <span class="pre">filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code> is returned.</span></p></div></dd></dl><dl class="function"><dt id="inspect.trace"><span class="yiyi-st" id="yiyi-481"> <code class="descclassname">inspect.</code><code class="descname">trace</code><span class="sig-paren">(</span><em>context=1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-482">返回当前帧与当前正在处理异常的帧之间的堆栈的帧记录列表。</span><span class="yiyi-st" id="yiyi-483">列表中的第一项代表呼叫者；最后一个条目表示引发异常的位置。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-484"><span class="versionmodified">Changed in version 3.5: </span>A list of <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuples</span></a> <code class="docutils literal"><span class="pre">FrameInfo(frame,</span> <span class="pre">filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code> is returned.</span></p></div></dd></dl></div><div class="section" id="fetching-attributes-statically"><h2><span class="yiyi-st" id="yiyi-485">29.12.6. </span><span class="yiyi-st" id="yiyi-486">静态获取属性</span></h2><p><span class="yiyi-st" id="yiyi-487">当获取或检查属性的存在时，<a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a>和<a class="reference internal" href="functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal"><span class="pre">hasattr()</span></code></a>都可以触发代码执行。</span><span class="yiyi-st" id="yiyi-488">描述符（如属性）将被调用，并且可以调用<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a>和<a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-489">对于需要被动内省的情况，如文档工具，这可能不方便。</span><span class="yiyi-st" id="yiyi-490"><a class="reference internal" href="#inspect.getattr_static" title="inspect.getattr_static"><code class="xref py py-func docutils literal"><span class="pre">getattr_static()</span></code></a> has the same signature as <a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a> but avoids executing code when it fetches attributes.</span></p><dl class="function"><dt id="inspect.getattr_static"><span class="yiyi-st" id="yiyi-491"> <code class="descclassname">inspect.</code><code class="descname">getattr_static</code><span class="sig-paren">(</span><em>obj</em>, <em>attr</em>, <em>default=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-492">通过描述符协议，<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a>或<a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a>检索属性而不触发动态查找。</span></p><p><span class="yiyi-st" id="yiyi-493">注意：此函数可能无法检索getattr可以获取的所有属性（如动态创建的属性），并可能找到getattr无法使用的属性（如引发AttributeError的描述符）。</span><span class="yiyi-st" id="yiyi-494">它也可以返回描述符对象而不是实例成员。</span></p><p><span class="yiyi-st" id="yiyi-495">如果实例<a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>被另一个成员（例如属性）遮蔽，则该函数将无法找到实例成员。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-496"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-497"><a class="reference internal" href="#inspect.getattr_static" title="inspect.getattr_static"><code class="xref py py-func docutils literal"><span class="pre">getattr_static()</span></code></a>不解析描述符，例如在C中实现的对象上的槽描述符或getset描述符。返回描述符对象而不是底层属性。</span></p><p><span class="yiyi-st" id="yiyi-498">您可以使用如下代码处理这些问题。</span><span class="yiyi-st" id="yiyi-499">请注意，对于任意getset描述符，调用这些描述符可能会触发代码执行：</span></p><pre><code class="language-python"><span></span><span class="c1"># example code for resolving the builtin descriptor types</span>
<span class="k">class</span> <span class="nc">_foo</span><span class="p">:</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'foo'</span><span class="p">]</span>

<span class="n">slot_descriptor</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">_foo</span><span class="o">.</span><span class="n">foo</span><span class="p">)</span>
<span class="n">getset_descriptor</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">__file__</span><span class="p">))</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="n">wrapper_descriptor</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s1">'__add__'</span><span class="p">])</span>
<span class="n">descriptor_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">slot_descriptor</span><span class="p">,</span> <span class="n">getset_descriptor</span><span class="p">,</span> <span class="n">wrapper_descriptor</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">getattr_static</span><span class="p">(</span><span class="n">some_object</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">in</span> <span class="n">descriptor_types</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__get__</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># descriptors can raise AttributeError to</span>
        <span class="c1"># indicate there is no underlying value</span>
        <span class="c1"># in which case the descriptor itself will</span>
        <span class="c1"># have to do</span>
        <span class="k">pass</span>
</code></pre></div><div class="section" id="current-state-of-generators-and-coroutines"><h2><span class="yiyi-st" id="yiyi-500">29.12.7. </span><span class="yiyi-st" id="yiyi-501">发生器和协程的当前状态</span></h2><p><span class="yiyi-st" id="yiyi-502">在实现协程调度程序和生成器的其他高级用途时，确定生成器当前是否正在执行，是否正在等待启动或恢复或执行或已经终止会很有用。</span><span class="yiyi-st" id="yiyi-503"><a class="reference internal" href="#inspect.getgeneratorstate" title="inspect.getgeneratorstate"><code class="xref py py-func docutils literal"><span class="pre">getgeneratorstate()</span></code></a> allows the current state of a generator to be determined easily.</span></p><dl class="function"><dt id="inspect.getgeneratorstate"><span class="yiyi-st" id="yiyi-504"> <code class="descclassname">inspect.</code><code class="descname">getgeneratorstate</code><span class="sig-paren">(</span><em>generator</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-505">获取生成器迭代器的当前状态。</span></p><dl class="docutils"><dt><span class="yiyi-st" id="yiyi-506">可能的状态是：</span></dt><dd><ul class="first last simple"><li><span class="yiyi-st" id="yiyi-507">GEN_CREATED：等待开始执行。</span></li><li><span class="yiyi-st" id="yiyi-508">GEN_RUNNING：目前正在由解释器执行。</span></li><li><span class="yiyi-st" id="yiyi-509">GEN_SUSPENDED：目前暂停在产量表达式。</span></li><li><span class="yiyi-st" id="yiyi-510">GEN_CLOSED：执行已完成。</span></li></ul></dd></dl><div class="versionadded"><p><span class="yiyi-st" id="yiyi-511"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="inspect.getcoroutinestate"><span class="yiyi-st" id="yiyi-512"> <code class="descclassname">inspect.</code><code class="descname">getcoroutinestate</code><span class="sig-paren">(</span><em>coroutine</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-513">获取协程对象的当前状态。</span><span class="yiyi-st" id="yiyi-514">该函数旨在与由<a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a>函数创建的协程对象一起使用，但会接受任何具有<code class="docutils literal"><span class="pre">cr_running</span></code>和<code class="docutils literal"><span class="pre">cr_frame</span></code>属性。</span></p><dl class="docutils"><dt><span class="yiyi-st" id="yiyi-515">可能的状态是：</span></dt><dd><ul class="first last simple"><li><span class="yiyi-st" id="yiyi-516">CORO_CREATED：等待开始执行。</span></li><li><span class="yiyi-st" id="yiyi-517">CORO_RUNNING：目前正在由解释器执行。</span></li><li><span class="yiyi-st" id="yiyi-518">CORO_SUSPENDED：目前暂停等待表达。</span></li><li><span class="yiyi-st" id="yiyi-519">CORO_CLOSED：执行已完成。</span></li></ul></dd></dl><div class="versionadded"><p><span class="yiyi-st" id="yiyi-520"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-521">发电机当前的内部状态也可以查询。</span><span class="yiyi-st" id="yiyi-522">这对于测试目的非常有用，以确保内部状态按预期进行更新：</span></p><dl class="function"><dt id="inspect.getgeneratorlocals"><span class="yiyi-st" id="yiyi-523"> <code class="descclassname">inspect.</code><code class="descname">getgeneratorlocals</code><span class="sig-paren">(</span><em>generator</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-524">获取<em>generator</em>中的实时局部变量映射到它们的当前值。</span><span class="yiyi-st" id="yiyi-525">返回的字典从变量名称映射到值。</span><span class="yiyi-st" id="yiyi-526">这相当于在生成器的主体中调用<a class="reference internal" href="functions.html#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a>，并且所有相同的注意事项都适用。</span></p><p><span class="yiyi-st" id="yiyi-527">如果<em>generator</em>是<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>，并且没有当前关联的帧，则返回空字典。</span><span class="yiyi-st" id="yiyi-528"><a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> is raised if <em>generator</em> is not a Python generator object.</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-529"><strong>CPython implementation detail:</strong> This function relies on the generator exposing a Python stack frame for introspection, which isn’t guaranteed to be the case in all implementations of Python. </span><span class="yiyi-st" id="yiyi-530">在这种情况下，该函数将始终返回一个空字典。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-531"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="inspect.getcoroutinelocals"><span class="yiyi-st" id="yiyi-532"> <code class="descclassname">inspect.</code><code class="descname">getcoroutinelocals</code><span class="sig-paren">(</span><em>coroutine</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-533">这个函数类似于<a class="reference internal" href="#inspect.getgeneratorlocals" title="inspect.getgeneratorlocals"><code class="xref py py-func docutils literal"><span class="pre">getgeneratorlocals()</span></code></a>，但是对由<a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a>函数创建的协程对象起作用。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-534"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="command-line-interface"><h2><span class="yiyi-st" id="yiyi-535">29.12.8. </span><span class="yiyi-st" id="yiyi-536">命令行界面</span></h2><p><span class="yiyi-st" id="yiyi-537"><a class="reference internal" href="#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal"><span class="pre">inspect</span></code></a>模块还提供了来自命令行的基本内省功能。</span></p><p><span class="yiyi-st" id="yiyi-538">默认情况下，接受模块的名称并打印该模块的来源。</span><span class="yiyi-st" id="yiyi-539">可以通过附加冒号和目标对象的限定名称来打印模块内的类或函数。</span></p><dl class="cmdoption"><dt id="cmdoption-inspect--details"><span class="yiyi-st" id="yiyi-540"> <code class="descname">--details</code><code class="descclassname"></code></span></dt><dd><p><span class="yiyi-st" id="yiyi-541">打印有关指定对象而不是源代码的信息</span></p></dd></dl></div></div></div>