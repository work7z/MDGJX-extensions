<div class="body" role="main"><div class="section" id="module-pdb"><h1><span class="yiyi-st" id="yiyi-10">27.3. <a class="reference internal" href="#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal"><span class="pre">pdb</span></code></a>  -  Python调试器</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/pdb.py">Lib/pdb.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">模块<a class="reference internal" href="#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal"><span class="pre">pdb</span></code></a>为Python程序定义了一个交互式源代码调试器。</span><span class="yiyi-st" id="yiyi-13">它支持在任何堆栈帧的上下文中设置（条件）断点和在源行级别的单步，检查堆栈帧，源代码列表和评估任意Python代码。</span><span class="yiyi-st" id="yiyi-14">它还支持事后调试，并且可以在程序控制下调用。</span></p><p id="index-1"><span class="yiyi-st" id="yiyi-15">调试器是可扩展的 — 它实际上被定义为类<a class="reference internal" href="#pdb.Pdb" title="pdb.Pdb"><code class="xref py py-class docutils literal"><span class="pre">Pdb</span></code></a>。</span><span class="yiyi-st" id="yiyi-16">它目前没有文档，但通过阅读源码很容易理解。</span><span class="yiyi-st" id="yiyi-17">扩展接口使用模块 <a class="reference internal" href="bdb.html#module-bdb" title="bdb: Debugger framework."><code class="xref py py-mod docutils literal"><span class="pre">bdb</span></code></a> 和 <a class="reference internal" href="cmd.html#module-cmd" title="cmd: Build line-oriented command interpreters."><code class="xref py py-mod docutils literal"><span class="pre">cmd</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-18">调试器的提示符为<code class="docutils literal"><span class="pre">(Pdb)</span></code>。</span><span class="yiyi-st" id="yiyi-19">在调试器的控制下运行程序的典型用法是：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pdb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mymodule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdb</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">'mymodule.test()'</span><span class="p">)</span>
<span class="go">&gt; &lt;string&gt;(0)?()</span>
<span class="go">(Pdb) continue</span>
<span class="go">&gt; &lt;string&gt;(1)?()</span>
<span class="go">(Pdb) continue</span>
<span class="go">NameError: 'spam'</span>
<span class="go">&gt; &lt;string&gt;(1)?()</span>
<span class="go">(Pdb)</span>
</code></pre><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-20"><span class="versionmodified">版本3.3中的更改：</span>通过<a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">readline</span></code></a>模块命令和命令参数可用Tab自动补全，例如</span><span class="yiyi-st" id="yiyi-21">当前全局和局部名称作为<code class="docutils literal"><span class="pre">p</span></code>命令的参数提供。</span></p></div><p><span class="yiyi-st" id="yiyi-22"><code class="file docutils literal"><span class="pre">pdb.py</span></code>也可以作为脚本调用来调试其他脚本。</span><span class="yiyi-st" id="yiyi-23">例如：</span></p><pre><code class="language-python"><span></span><span class="n">python3</span> <span class="o">-</span><span class="n">m</span> <span class="n">pdb</span> <span class="n">myscript</span><span class="o">.</span><span class="n">py</span>
</code></pre><p><span class="yiyi-st" id="yiyi-24">当作为脚本调用时，如果正在调试的程序异常退出，pdb将自动进入事后调试。</span><span class="yiyi-st" id="yiyi-25">经过事后调试（或正常退出程序后），pdb将重新启动程序。</span><span class="yiyi-st" id="yiyi-26">自动重新启动保留pdb的状态（例如断点），并且在大多数情况下比程序退出时退出调试器更有用。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-27"><span class="versionmodified">版本3.2中的新功能：</span> <code class="file docutils literal"><span class="pre">pdb.py</span></code>现在接受<code class="docutils literal"><span class="pre">-c</span></code>选项，该选项执行命令，就像在<code class="file docutils literal"><span class="pre">.pdbrc</span></code>文件中给出的一样，参见<a class="reference internal" href="#debugger-commands"><span>调试器命令</span></a>。</span></p></div><p><span class="yiyi-st" id="yiyi-28">从正在运行的程序中断入调试器的典型用法是插入</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span> <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-29">到你想要插入调试器的位置。</span><span class="yiyi-st" id="yiyi-30">然后，你可以按照逐步执行此语句后面的代码，并使用<a class="reference internal" href="#pdbcommand-continue"><code class="xref std std-pdbcmd docutils literal"><span class="pre">continue</span></code></a>命令继续运行，而不使用调试器。</span></p><p><span class="yiyi-st" id="yiyi-31">检查崩溃程序的典型用法是：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pdb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mymodule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymodule</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">"./mymodule.py"</span>, line <span class="m">4</span>, in <span class="n">test</span>
    <span class="n">test2</span><span class="p">()</span>
  File <span class="nb">"./mymodule.py"</span>, line <span class="m">3</span>, in <span class="n">test2</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">spam</span><span class="p">)</span>
<span class="gr">NameError</span>: <span class="n">spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdb</span><span class="o">.</span><span class="n">pm</span><span class="p">()</span>
<span class="go">&gt; ./mymodule.py(3)test2()</span>
<span class="go">-&gt; print(spam)</span>
<span class="go">(Pdb)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-32">该模块定义了以下函数：每个函数进入调试器的方式稍微不同：</span></p><dl class="function"><dt id="pdb.run"><span class="yiyi-st" id="yiyi-33"> <code class="descclassname">pdb.</code><code class="descname">run</code><span class="sig-paren">(</span><em>statement</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-34">在调试器控制下执行<em>statement</em>（作为字符串或代码对象）。</span><span class="yiyi-st" id="yiyi-35">在任何代码执行之前出现调试器提示；您可以设置断点并键入<a class="reference internal" href="#pdbcommand-continue"><code class="xref std std-pdbcmd docutils literal"><span class="pre">continue</span></code></a>，也可以使用<a class="reference internal" href="#pdbcommand-step"><code class="xref std std-pdbcmd docutils literal"><span class="pre">step</span></code></a>或<a class="reference internal" href="#pdbcommand-next"><code class="xref std std-pdbcmd docutils literal"><span class="pre">next</span></code></a>逐步执行该语句（所有这些命令将在下面说明）。</span><span class="yiyi-st" id="yiyi-36">可选的<em>全局变量</em>和<em>局部变量</em>参数指定执行代码的环境；默认使用模块的字典<a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal"><span class="pre">__main__</span></code></a>。</span><span class="yiyi-st" id="yiyi-37">（请参阅内建<a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>或<a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>函数的解释。）</span></p></dd></dl><dl class="function"><dt id="pdb.runeval"><span class="yiyi-st" id="yiyi-38"> <code class="descclassname">pdb.</code><code class="descname">runeval</code><span class="sig-paren">(</span><em>expression</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-39">在调试器控制下计算<em>表达式</em>（作为字符串或代码对象）。</span><span class="yiyi-st" id="yiyi-40">当<a class="reference internal" href="#pdb.runeval" title="pdb.runeval"><code class="xref py py-func docutils literal"><span class="pre">runeval()</span></code></a>返回时，它返回表达式的值。</span><span class="yiyi-st" id="yiyi-41">否则，此函数类似于<a class="reference internal" href="#pdb.run" title="pdb.run"><code class="xref py py-func docutils literal"><span class="pre">run()</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="pdb.runcall"><span class="yiyi-st" id="yiyi-42"> <code class="descclassname">pdb.</code><code class="descname">runcall</code><span class="sig-paren">(</span><em>function</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-43">使用给定的参数调用<em>函数</em>（函数或方法对象，而不是字符串）。</span><span class="yiyi-st" id="yiyi-44">当<a class="reference internal" href="#pdb.runcall" title="pdb.runcall"><code class="xref py py-func docutils literal"><span class="pre">runcall()</span></code></a>返回时，它返回所返回的任何函数调用。</span><span class="yiyi-st" id="yiyi-45">一旦输入该函数，就会显示调试器提示。</span></p></dd></dl><dl class="function"><dt id="pdb.set_trace"><span class="yiyi-st" id="yiyi-46"> <code class="descclassname">pdb.</code><code class="descname">set_trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-47">在调用堆栈框架处输入调试器。</span><span class="yiyi-st" id="yiyi-48">这对于在程序中的给定点硬编码断点是有用的，即使代码没有被另外调试（例如，</span><span class="yiyi-st" id="yiyi-49">当断言失败时）。</span></p></dd></dl><dl class="function"><dt id="pdb.post_mortem"><span class="yiyi-st" id="yiyi-50"> <code class="descclassname">pdb.</code><code class="descname">post_mortem</code><span class="sig-paren">(</span><em>traceback=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-51">输入给定<em>traceback</em>对象的事后调试。</span><span class="yiyi-st" id="yiyi-52">如果未给出<em>traceback</em>，则使用当前正在处理的异常（如果使用缺省值，则必须处理异常）。</span></p></dd></dl><dl class="function"><dt id="pdb.pm"><span class="yiyi-st" id="yiyi-53"> <code class="descclassname">pdb.</code><code class="descname">pm</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-54">输入在<a class="reference internal" href="sys.html#sys.last_traceback" title="sys.last_traceback"><code class="xref py py-data docutils literal"><span class="pre">sys.last_traceback</span></code></a>中找到的回溯的事后调试。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-55"><code class="docutils literal"><span class="pre">run*</span></code>函数和<a class="reference internal" href="#pdb.set_trace" title="pdb.set_trace"><code class="xref py py-func docutils literal"><span class="pre">set_trace()</span></code></a>是用于实例化<a class="reference internal" href="#pdb.Pdb" title="pdb.Pdb"><code class="xref py py-class docutils literal"><span class="pre">Pdb</span></code></a>类和调用同名方法的别名。</span><span class="yiyi-st" id="yiyi-56">如果你想访问更多的功能，你必须自己这样做：</span></p><dl class="class"><dt id="pdb.Pdb"><span class="yiyi-st" id="yiyi-57"> <em class="property">class </em><code class="descclassname">pdb.</code><code class="descname">Pdb</code><span class="sig-paren">(</span><em>completekey='tab'</em>, <em>stdin=None</em>, <em>stdout=None</em>, <em>skip=None</em>, <em>nosigint=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-58"><a class="reference internal" href="#pdb.Pdb" title="pdb.Pdb"><code class="xref py py-class docutils literal"><span class="pre">Pdb</span></code></a>是调试器类。</span></p><p><span class="yiyi-st" id="yiyi-59"><em>completekey</em>，<em>stdin</em>和<em>stdout</em>参数传递给底层的<a class="reference internal" href="cmd.html#cmd.Cmd" title="cmd.Cmd"><code class="xref py py-class docutils literal"><span class="pre">cmd.Cmd</span></code></a>看到那里的描述。</span></p><p><span class="yiyi-st" id="yiyi-60">如果给定了<em>skip</em>参数，则必须是可重复的glob样式模块名称模式。</span><span class="yiyi-st" id="yiyi-61">调试器不会步入到源于与这些模式之一匹配的模块中的帧。</span><span class="yiyi-st" id="yiyi-62"><a class="footnote-reference" href="#id3" id="id1">[1]</a></span></p><p><span class="yiyi-st" id="yiyi-63">默认情况下，当您给出<code class="docutils literal"><span class="pre">continue</span></code>命令时，Pdb会为SIGINT信号设置处理程序（当用户在控制台上按<code class="kbd docutils literal"><span class="pre">Ctrl-C</span></code>时发送）。</span><span class="yiyi-st" id="yiyi-64">这允许您通过按<code class="kbd docutils literal"><span class="pre">Ctrl-C</span></code>再次进入调试器。</span><span class="yiyi-st" id="yiyi-65">如果要让Pdb不触摸SIGINT处理程序，请将<em>nosigint</em>设置为true。</span></p><p><span class="yiyi-st" id="yiyi-66">使用<em>skip</em>启用跟踪的示例调用：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span> <span class="n">pdb</span><span class="o">.</span><span class="n">Pdb</span><span class="p">(</span><span class="n">skip</span><span class="o">=</span><span class="p">[</span><span class="s1">'django.*'</span><span class="p">])</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-67"><span class="versionmodified">版本3.1中的新功能：</span> <em>跳过</em>参数。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-68"><span class="versionmodified">版本3.2中的新功能：</span> <em>nosigint</em>参数。</span><span class="yiyi-st" id="yiyi-69">以前，一个SIGINT处理程序从来没有被Pdb设置。</span></p></div><dl class="method"><dt id="pdb.Pdb.run"><span class="yiyi-st" id="yiyi-70"> <code class="descname">run</code><span class="sig-paren">(</span><em>statement</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span></span></dt><dt id="pdb.Pdb.runeval"><span class="yiyi-st" id="yiyi-71"> <code class="descname">runeval</code><span class="sig-paren">(</span><em>expression</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span></span></dt><dt id="pdb.Pdb.runcall"><span class="yiyi-st" id="yiyi-72"> <code class="descname">runcall</code><span class="sig-paren">(</span><em>function</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span></span></dt><dt id="pdb.Pdb.set_trace"><span class="yiyi-st" id="yiyi-73"> <code class="descname">set_trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-74">请参阅上述功能的文档。</span></p></dd></dl></dd></dl><div class="section" id="debugger-commands"><h2><span class="yiyi-st" id="yiyi-75">27.3.1. </span><span class="yiyi-st" id="yiyi-76">Debugger Commands</span></h2><p><span class="yiyi-st" id="yiyi-77">调试器识别的命令如下所示。</span><span class="yiyi-st" id="yiyi-78">大多数命令可以缩写为一个或两个字母，如图所示；例如</span><span class="yiyi-st" id="yiyi-79"><code class="docutils literal"><span class="pre">h(elp)</span></code> means that either <code class="docutils literal"><span class="pre">h</span></code> or <code class="docutils literal"><span class="pre">help</span></code> can be used to enter the help command (but not <code class="docutils literal"><span class="pre">he</span></code> or <code class="docutils literal"><span class="pre">hel</span></code>, nor <code class="docutils literal"><span class="pre">H</span></code> or <code class="docutils literal"><span class="pre">Help</span></code> or <code class="docutils literal"><span class="pre">HELP</span></code>). </span><span class="yiyi-st" id="yiyi-80">命令的参数必须由空格（空格或制表符）分隔。</span><span class="yiyi-st" id="yiyi-81">可选参数在命令语法中用方括号（<code class="docutils literal"><span class="pre">[]</span></code>）括起来；不得输入方括号。</span><span class="yiyi-st" id="yiyi-82">命令语法中的其他选项通过垂直条（<code class="docutils literal"><span class="pre">|</span></code>）分隔。</span></p><p><span class="yiyi-st" id="yiyi-83">输入空行重复输入的最后一个命令。</span><span class="yiyi-st" id="yiyi-84">异常：如果最后一个命令是<a class="reference internal" href="#pdbcommand-list"><code class="xref std std-pdbcmd docutils literal"><span class="pre">list</span></code></a>命令，则会列出接下来的11行。</span></p><p><span class="yiyi-st" id="yiyi-85">调试器不能识别的命令假定为Python语句，并在正在调试的程序的上下文中执行。</span><span class="yiyi-st" id="yiyi-86">Python语句也可以带有感叹号（<code class="docutils literal"><span class="pre">!</span></code>）作为前缀。</span><span class="yiyi-st" id="yiyi-87">这是一种检查被调试程序的有效方法；甚至可以改变变量或调用函数。</span><span class="yiyi-st" id="yiyi-88">当在此类语句中发生异常时，将打印异常名称，但调试器的状态不会更改。</span></p><p><span class="yiyi-st" id="yiyi-89">调试器支持<a class="reference internal" href="#debugger-aliases"><span>aliases</span></a>。</span><span class="yiyi-st" id="yiyi-90">别名可以具有允许对检查的上下文具有一定水平的适应性的参数。</span></p><p><span class="yiyi-st" id="yiyi-91">多个命令可以在单行上输入，由<code class="docutils literal"><span class="pre">;;</span></code>分隔。</span><span class="yiyi-st" id="yiyi-92">（不使用单个<code class="docutils literal"><span class="pre">;</span></code>，因为它是传递给Python解析器的行中的多个命令的分隔符。）</span><span class="yiyi-st" id="yiyi-93">没有智能用于分离命令；输入在第一个<code class="docutils literal"><span class="pre">;;</span></code>对处拆分，即使它位于带引号的字符串的中间。</span></p><p id="index-2"><span class="yiyi-st" id="yiyi-94">如果文件<code class="file docutils literal"><span class="pre">.pdbrc</span></code>存在于用户的主目录或当前目录中，则会读入该文件并执行，就好像它在调试器提示符处键入。</span><span class="yiyi-st" id="yiyi-95">这对别名特别有用。</span><span class="yiyi-st" id="yiyi-96">如果两个文件都存在，那么首先读取主目录中的一个文件，并在那里定义的别名可以被本地文件覆盖。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-97"><span class="versionmodified">在版本3.2中更改：</span> <code class="file docutils literal"><span class="pre">.pdbrc</span></code>现在可以包含继续调试的命令，例如<a class="reference internal" href="#pdbcommand-continue"><code class="xref std std-pdbcmd docutils literal"><span class="pre">continue</span></code></a>或<a class="reference internal" href="#pdbcommand-next"><code class="xref std std-pdbcmd docutils literal"><span class="pre">next</span></code></a>。</span><span class="yiyi-st" id="yiyi-98">以前，这些命令没有效果。</span></p></div><dl class="pdbcommand"><dt id="pdbcommand-help"><span class="yiyi-st" id="yiyi-99"> <code class="descname">h(elp)</code><code class="descclassname"> [command]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-100">无参数时，打印可用命令的列表。</span><span class="yiyi-st" id="yiyi-101">使用<em>命令</em>作为参数，打印有关该命令的帮助。</span><span class="yiyi-st" id="yiyi-102"><code class="docutils literal"><span class="pre">help</span> <span class="pre">pdb</span></code>显示完整文档（<a class="reference internal" href="#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal"><span class="pre">pdb</span></code></a>模块的文档字符串）。</span><span class="yiyi-st" id="yiyi-103">Since the <em>command</em> argument must be an identifier, <code class="docutils literal"><span class="pre">help</span> <span class="pre">exec</span></code> must be entered to get help on the <code class="docutils literal"><span class="pre">!</span></code></span><span class="yiyi-st" id="yiyi-104">命令。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-where"><span class="yiyi-st" id="yiyi-105"> <code class="descname">w(here)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-106">打印堆栈跟踪，最新的帧在底部。</span><span class="yiyi-st" id="yiyi-107">箭头表示当前帧，它确定大多数命令的上下文。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-down"><span class="yiyi-st" id="yiyi-108"> <code class="descname">d(own)</code><code class="descclassname"> [count]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-109">将当前帧<em>计数</em>（默认一个）向下移动到堆栈跟踪（更新的帧）。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-up"><span class="yiyi-st" id="yiyi-110"> <code class="descname">u(p)</code><code class="descclassname"> [count]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">将当前帧<em>计数</em>（默认值）移动到堆栈跟踪（到较早的帧）。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-break"><span class="yiyi-st" id="yiyi-112"> <code class="descname">b(reak)</code><code class="descclassname"> [([filename:]lineno | function) [, condition]]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-113">使用<em>lineno</em>参数，在当前文件中设置断点。</span><span class="yiyi-st" id="yiyi-114">使用<em>函数</em>参数，在该函数中的第一个可执行语句中设置断点。</span><span class="yiyi-st" id="yiyi-115">行号可以用文件名和冒号作为前缀，以在另一个文件（可能是尚未加载的文件）中指定断点。</span><span class="yiyi-st" id="yiyi-116">在<a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a>上搜索文件。</span><span class="yiyi-st" id="yiyi-117">请注意，每个断点都分配有一个数字，所有其他断点命令都引用该数字。</span></p><p><span class="yiyi-st" id="yiyi-118">如果存在第二个参数，它是一个表达式，在断点被执行之前必须计算为true。</span></p><p><span class="yiyi-st" id="yiyi-119">无参数，列出所有中断，包括每个断点，断点被命中的次数，当前忽略计数和相关条件（如果有）。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-tbreak"><span class="yiyi-st" id="yiyi-120"> <code class="descname">tbreak</code><code class="descclassname"> [([filename:]lineno | function) [, condition]]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-121">临时断点，当它第一次被击中时被自动删除。</span><span class="yiyi-st" id="yiyi-122">参数与<a class="reference internal" href="#pdbcommand-break"><code class="xref std std-pdbcmd docutils literal"><span class="pre">break</span></code></a>相同。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-clear"><span class="yiyi-st" id="yiyi-123"> <code class="descname">cl(ear)</code><code class="descclassname"> [filename:lineno | bpnumber [bpnumber ...]]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-124">使用<em>filename：lineno</em>参数，清除此行的所有断点。</span><span class="yiyi-st" id="yiyi-125">用断点号的空格分隔列表，清除那些断点。</span><span class="yiyi-st" id="yiyi-126">没有论证，清除所有休息（但首先要求确认）。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-disable"><span class="yiyi-st" id="yiyi-127"> <code class="descname">disable</code><code class="descclassname"> [bpnumber [bpnumber ...]]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-128">禁用以空格分隔的断点号列表形式给出的断点。</span><span class="yiyi-st" id="yiyi-129">禁用断点意​​味着它不能导致程序停止执行，但是与清除断点不同，它保留在断点列表中，并且可以（重新）启用。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-enable"><span class="yiyi-st" id="yiyi-130"> <code class="descname">enable</code><code class="descclassname"> [bpnumber [bpnumber ...]]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-131">启用指定的断点。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-ignore"><span class="yiyi-st" id="yiyi-132"> <code class="descname">ignore</code><code class="descclassname"> bpnumber [count]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-133">设置给定断点号的忽略计数。</span><span class="yiyi-st" id="yiyi-134">如果省略count，则忽略计数设置为0。</span><span class="yiyi-st" id="yiyi-135">当忽略计数为零时，断点变为活动状态。</span><span class="yiyi-st" id="yiyi-136">当非零时，每次达到断点时计数递减，并且不禁用断点，并且任何关联条件的计算结果为true。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-condition"><span class="yiyi-st" id="yiyi-137"> <code class="descname">condition</code><code class="descclassname"> bpnumber [condition]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-138">为断点设置新的<em>条件</em>，这是在断点被执行之前必须计算为true的表达式。</span><span class="yiyi-st" id="yiyi-139">如果<em>条件</em>不存在，则删除任何现有条件；即断点是无条件的。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-commands"><span class="yiyi-st" id="yiyi-140"> <code class="descname">commands</code><code class="descclassname"> [bpnumber]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-141">指定断点号<em>bpnumber</em>的命令列表。</span><span class="yiyi-st" id="yiyi-142">命令本身显示在以下行。</span><span class="yiyi-st" id="yiyi-143">键入仅包含<code class="docutils literal"><span class="pre">end</span></code>的行以终止命令。</span><span class="yiyi-st" id="yiyi-144">一个例子：</span></p><pre><code class="language-python"><span></span><span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="n">commands</span> <span class="mi">1</span>
<span class="p">(</span><span class="n">com</span><span class="p">)</span> <span class="n">p</span> <span class="n">some_variable</span>
<span class="p">(</span><span class="n">com</span><span class="p">)</span> <span class="n">end</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-145">要从断点中删除所有命令，请键入命令，并立即使用<code class="docutils literal"><span class="pre">end</span></code>；即，不给出命令。</span></p><p><span class="yiyi-st" id="yiyi-146">没有<em>bpnumber</em>参数，命令引用最后一个断点集。</span></p><p><span class="yiyi-st" id="yiyi-147">您可以使用断点命令重新启动程序。</span><span class="yiyi-st" id="yiyi-148">只需使用continue命令，或step，或任何其他恢复执行的命令。</span></p><p><span class="yiyi-st" id="yiyi-149">指定任何恢复执行的命令（当前继续，步骤，下一步，返回，跳转，退出和它们的缩写）终止命令列表（就好像该命令紧接着结束）。</span><span class="yiyi-st" id="yiyi-150">这是因为任何时候你恢复执行（即使有一个简单的下一步或步骤），你可能会遇到另一个断点，这可能有自己的命令列表，导致执行列表的模糊。</span></p><p><span class="yiyi-st" id="yiyi-151">如果在命令列表中使用“silent”命令，则不会打印关于在断点处停止的常见消息。</span><span class="yiyi-st" id="yiyi-152">这对于打印特定消息然后继续的断点可能是合乎需要的。</span><span class="yiyi-st" id="yiyi-153">如果没有其他命令打印任何东西，您看不到到达断点的迹象。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-step"><span class="yiyi-st" id="yiyi-154"> <code class="descname">s(tep)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-155">执行当前行，在第一个可能的时间停止（在调用的函数中或当前函数中的下一行）。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-next"><span class="yiyi-st" id="yiyi-156"> <code class="descname">n(ext)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-157">继续执行直到到达当前函数中的下一行或返回。</span><span class="yiyi-st" id="yiyi-158">（<a class="reference internal" href="#pdbcommand-next"><code class="xref std std-pdbcmd docutils literal"><span class="pre">next</span></code></a>和<a class="reference internal" href="#pdbcommand-step"><code class="xref std std-pdbcmd docutils literal"><span class="pre">step</span></code></a>之间的区别是<a class="reference internal" href="#pdbcommand-step"><code class="xref std std-pdbcmd docutils literal"><span class="pre">step</span></code></a>在被调用函数内停止，而<a class="reference internal" href="#pdbcommand-next"><code class="xref std std-pdbcmd docutils literal"><span class="pre">next</span></code></a> （几乎）全速，只在当前功能的下一行停止。）</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-until"><span class="yiyi-st" id="yiyi-159"> <code class="descname">unt(il)</code><code class="descclassname"> [lineno]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-160">如果没有参数，继续执行直到到达具有大于当前数字的数字的行。</span></p><p><span class="yiyi-st" id="yiyi-161">使用行号，继续执行，直到到达具有大于或等于的数字的行。</span><span class="yiyi-st" id="yiyi-162">在这两种情况下，当当前帧返回时也停止。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-163"><span class="versionmodified">在版本3.2中更改：</span>允许给出明确的行号。</span></p></div></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-return"><span class="yiyi-st" id="yiyi-164"> <code class="descname">r(eturn)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-165">继续执行直到当前函数返回。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-continue"><span class="yiyi-st" id="yiyi-166"> <code class="descname">c(ont(inue))</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-167">继续执行，只有在遇到断点时停止。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-jump"><span class="yiyi-st" id="yiyi-168"> <code class="descname">j(ump)</code><code class="descclassname"> lineno</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-169">设置将要执行的下一行。</span><span class="yiyi-st" id="yiyi-170">仅在最下面的框架中可用。</span><span class="yiyi-st" id="yiyi-171">这允许您跳回并再次执行代码，或者向前跳转以跳过您不想运行的代码。</span></p><p><span class="yiyi-st" id="yiyi-172">应该注意的是，不是所有的跳转都被允许 - 对于实例，不可能跳到<a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a>循环中或从<a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a>子句。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-list"><span class="yiyi-st" id="yiyi-173"> <code class="descname">l(ist)</code><code class="descclassname"> [first[, last]]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-174">列出当前文件的源代码。</span><span class="yiyi-st" id="yiyi-175">如果没有参数，请列出当前行周围的11行或继续上一个列表。</span><span class="yiyi-st" id="yiyi-176">使用<code class="docutils literal"><span class="pre">.</span></code></span><span class="yiyi-st" id="yiyi-177">作为参数，列出当前行周围的11行。</span><span class="yiyi-st" id="yiyi-178">使用一个参数，在该行列出11行。</span><span class="yiyi-st" id="yiyi-179">有两个参数，列出给定的范围；如果第二个参数小于第一个，它将被解释为计数。</span></p><p><span class="yiyi-st" id="yiyi-180">当前帧中的当前行由<code class="docutils literal"><span class="pre">-&gt;</span></code>指示。</span><span class="yiyi-st" id="yiyi-181">如果正在调试异常，则异常最初提出或传播的行由<code class="docutils literal"><span class="pre">&gt;&gt;</span></code>指示，如果它与当前行不同。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-182"><span class="versionmodified">版本3.2中的新功能：</span> <code class="docutils literal"><span class="pre">&gt;&gt;</span></code>标记。</span></p></div></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-ll"><span class="yiyi-st" id="yiyi-183"> <code class="descname">ll</code><code class="descclassname"> | longlist</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-184">列出当前函数或框架的所有源代码。</span><span class="yiyi-st" id="yiyi-185">有趣的行标记为<a class="reference internal" href="#pdbcommand-list"><code class="xref std std-pdbcmd docutils literal"><span class="pre">list</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-186"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-args"><span class="yiyi-st" id="yiyi-187"> <code class="descname">a(rgs)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-188">打印当前函数的参数列表。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-p"><span class="yiyi-st" id="yiyi-189"> <code class="descname">p</code><code class="descclassname"> expression</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-190">计算当前上下文中的<em>表达式</em>并打印其值。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-191">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-192"><code class="docutils literal"><span class="pre">print()</span></code>也可以使用，但不是调试器命令 - 这将执行Python <a class="reference internal" href="functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a>函数。</span></p></div></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-pp"><span class="yiyi-st" id="yiyi-193"> <code class="descname">pp</code><code class="descclassname"> expression</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-194">像<a class="reference internal" href="#pdbcommand-p"><code class="xref std std-pdbcmd docutils literal"><span class="pre">p</span></code></a>命令，除了表达式的值是使用<a class="reference internal" href="pprint.html#module-pprint" title="pprint: Data pretty printer."><code class="xref py py-mod docutils literal"><span class="pre">pprint</span></code></a>模块打印的。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-whatis"><span class="yiyi-st" id="yiyi-195"> <code class="descname">whatis</code><code class="descclassname"> expression</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-196">打印<em>表达式</em>的类型。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-source"><span class="yiyi-st" id="yiyi-197"> <code class="descname">source</code><code class="descclassname"> expression</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-198">尝试获取给定对象的源代码并显示它。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-199"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-display"><span class="yiyi-st" id="yiyi-200"> <code class="descname">display</code><code class="descclassname"> [expression]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-201">如果表达式更改，则每次在当前帧中停止执行时，显示表达式的值。</span></p><p><span class="yiyi-st" id="yiyi-202">不带表达式时，列出当前帧的所有显示表达式。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-203"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-undisplay"><span class="yiyi-st" id="yiyi-204"> <code class="descname">undisplay</code><code class="descclassname"> [expression]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-205">不要在当前框架中再显示表达式。</span><span class="yiyi-st" id="yiyi-206">如果没有表达式，请清除当前框架的所有显示表达式。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-207"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-interact"><span class="yiyi-st" id="yiyi-208"> <code class="descname">interact</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-209">启动一个交互式解释器（使用<a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal"><span class="pre">code</span></code></a>模块），其全局命名空间包含当前范围中找到的所有（全局和局部）名称。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-210"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-alias"><span class="yiyi-st" id="yiyi-211"> <code class="descname">alias</code><code class="descclassname"> [name [command]]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-212">创建一个名为<em>name</em>的执行<em>​​命令</em>的别名。</span><span class="yiyi-st" id="yiyi-213">The command must <em>not</em> be enclosed in quotes. </span><span class="yiyi-st" id="yiyi-214">可替换参数可由<code class="docutils literal"><span class="pre">%1</span></code>，<code class="docutils literal"><span class="pre">%2</span></code>等指示，而<code class="docutils literal"><span class="pre">%*</span></code>由所有参数替换。</span><span class="yiyi-st" id="yiyi-215">如果未给出命令，则会显示<em>名称</em>的当前别名。</span><span class="yiyi-st" id="yiyi-216">如果没有给出参数，则列出所有别名。</span></p><p><span class="yiyi-st" id="yiyi-217">别名可以嵌套，并且可以包含可以在pdb提示符下合法输入的任何内容。</span><span class="yiyi-st" id="yiyi-218">请注意，内部pdb命令<em>可以</em>被别名覆盖。</span><span class="yiyi-st" id="yiyi-219">然后隐藏这样的命令，直到去除别名。</span><span class="yiyi-st" id="yiyi-220">别名被递归地应用于命令行的第一个字；所有其他单词在行中都是孤独的。</span></p><p><span class="yiyi-st" id="yiyi-221">例如，这里有两个有用的别名（尤其是放在<code class="file docutils literal"><span class="pre">.pdbrc</span></code>文件中）：</span></p><pre><code class="language-python"><span></span><span class="c1"># Print instance variables (usage "pi classInst")</span>
<span class="n">alias</span> <span class="n">pi</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="o">%</span><span class="mf">1.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="nb">print</span><span class="p">(</span><span class="s2">"%1."</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="s2">"="</span><span class="p">,</span><span class="o">%</span><span class="mf">1.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
<span class="c1"># Print instance variables in self</span>
<span class="n">alias</span> <span class="n">ps</span> <span class="n">pi</span> <span class="bp">self</span>
</code></pre></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-unalias"><span class="yiyi-st" id="yiyi-222"> <code class="descname">unalias</code><code class="descclassname"> name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-223">删除指定的别名。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-!"><span class="yiyi-st" id="yiyi-224"><code class="descname">！</code></span><span class="yiyi-st" id="yiyi-225"><code class="descclassname"> statement</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-226">在当前堆栈帧的上下文中执行（一行）<em>语句</em>。</span><span class="yiyi-st" id="yiyi-227">可以省略感叹号，除非语句的第一个单词类似于调试器命令。</span><span class="yiyi-st" id="yiyi-228">要设置全局变量，您可以在同一行上使用<a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a>语句为赋值命令添加前缀，例如。</span><span class="yiyi-st" id="yiyi-229">：</span></p><pre><code class="language-python"><span></span><span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="k">global</span> <span class="n">list_options</span><span class="p">;</span> <span class="n">list_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'-l'</span><span class="p">]</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span>
</code></pre></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-run"><span class="yiyi-st" id="yiyi-230"> <code class="descname">run</code><code class="descclassname"> [args ...]</code></span></dt><dt id="pdbcommand-restart"><span class="yiyi-st" id="yiyi-231"> <code class="descname">restart</code><code class="descclassname"> [args ...]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-232">重新启动调试的Python程序。</span><span class="yiyi-st" id="yiyi-233">如果提供了参数，则使用<a class="reference internal" href="shlex.html#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal"><span class="pre">shlex</span></code></a>进行分割，并将结果用作新的<a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal"><span class="pre">sys.argv</span></code></a>。</span><span class="yiyi-st" id="yiyi-234">历史，断点，动作和调试器选项被保留。</span><span class="yiyi-st" id="yiyi-235"><a class="reference internal" href="#pdbcommand-restart"><code class="xref std std-pdbcmd docutils literal"><span class="pre">restart</span></code></a>是<a class="reference internal" href="#pdbcommand-run"><code class="xref std std-pdbcmd docutils literal"><span class="pre">run</span></code></a>的别名。</span></p></dd></dl><dl class="pdbcommand"><dt id="pdbcommand-quit"><span class="yiyi-st" id="yiyi-236"> <code class="descname">q(uit)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-237">从调试器中退出。</span><span class="yiyi-st" id="yiyi-238">正在执行的程序中止。</span></p></dd></dl><p class="rubric"><span class="yiyi-st" id="yiyi-239">脚注</span></p><table class="docutils footnote" frame="void" id="id3" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-240"><a class="fn-backref" href="#id1">[1]</a></span></td><td><span class="yiyi-st" id="yiyi-241">帧是否被认为源于某个模块由帧全局中的<code class="docutils literal"><span class="pre">__name__</span></code>确定。</span></td></tr></tbody></table></div></div></div>