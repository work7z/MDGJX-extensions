<div class="body" role="main"><div class="section" id="module-unittest.mock"><h1><span class="yiyi-st" id="yiyi-10">26.5。 <a class="reference internal" href="#module-unittest.mock" title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal"><span class="pre">unittest.mock</span></code></a>  - 模拟对象库</span></h1><div class="versionadded"><p><span class="yiyi-st" id="yiyi-11"><span class="versionmodified">New in version 3.3.</span></span></p></div><p><span class="yiyi-st" id="yiyi-12"><strong>Source code:</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/unittest/mock.py">Lib/unittest/mock.py</a></span></p><p><span class="yiyi-st" id="yiyi-13"><a class="reference internal" href="#module-unittest.mock" title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal"><span class="pre">unittest.mock</span></code></a>是一个用于Python测试的库。</span><span class="yiyi-st" id="yiyi-14">它允许您用模拟对象替换测试系统的某些部分，并断言它们是如何使用的。</span></p><p><span class="yiyi-st" id="yiyi-15"><a class="reference internal" href="#module-unittest.mock" title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal"><span class="pre">unittest.mock</span></code></a> provides a core <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> class removing the need to create a host of stubs throughout your test suite. </span><span class="yiyi-st" id="yiyi-16">After performing an action, you can make assertions about which methods / attributes were used and arguments they were called with. </span><span class="yiyi-st" id="yiyi-17">You can also specify return values and set needed attributes in the normal way.</span></p><p><span class="yiyi-st" id="yiyi-18">Additionally, mock provides a <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> decorator that handles patching module and class level attributes within the scope of a test, along with <a class="reference internal" href="#unittest.mock.sentinel" title="unittest.mock.sentinel"><code class="xref py py-const docutils literal"><span class="pre">sentinel</span></code></a> for creating unique objects. </span><span class="yiyi-st" id="yiyi-19">See the <a class="reference internal" href="#quick-guide">quick guide</a> for some examples of how to use <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a>, <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> and <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-20">Mock is very easy to use and is designed for use with <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a>. </span><span class="yiyi-st" id="yiyi-21">Mock is based on the ‘action -&gt; assertion’ pattern instead of ‘record -&gt; replay’ used by many mocking frameworks.</span></p><p><span class="yiyi-st" id="yiyi-22">There is a backport of <a class="reference internal" href="#module-unittest.mock" title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal"><span class="pre">unittest.mock</span></code></a> for earlier versions of Python, available as <a class="reference external" href="https://pypi.python.org/pypi/mock">mock on PyPI</a>.</span></p><div class="section" id="quick-guide"><h2><span class="yiyi-st" id="yiyi-23">26.5.1. </span><span class="yiyi-st" id="yiyi-24">Quick Guide</span></h2><p><span class="yiyi-st" id="yiyi-25"><a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> and <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> objects create all attributes and methods as you access them and store details of how they have been used. </span><span class="yiyi-st" id="yiyi-26">You can configure them, to specify return values or limit what attributes are available, and then make assertions about how they have been used:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="k">import</span> <span class="n">MagicMock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thing</span> <span class="o">=</span> <span class="n">ProductionClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thing</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thing</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">'value'</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thing</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">'value'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-27"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code> allows you to perform side effects, including raising an exception when a mock is called:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="ne">KeyError</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
 <span class="c">...</span>
<span class="gr">KeyError</span>: <span class="n">'foo'</span>
</code></pre><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'a'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">side_effect</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">side_effect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="s1">'a'</span><span class="p">),</span> <span class="n">mock</span><span class="p">(</span><span class="s1">'b'</span><span class="p">),</span> <span class="n">mock</span><span class="p">(</span><span class="s1">'c'</span><span class="p">)</span>
<span class="go">(1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(),</span> <span class="n">mock</span><span class="p">(),</span> <span class="n">mock</span><span class="p">()</span>
<span class="go">(5, 4, 3)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-28">Mock has many other ways you can configure it and control its behaviour. </span><span class="yiyi-st" id="yiyi-29">For example the <em>spec</em> argument configures the mock to take its specification from another object. </span><span class="yiyi-st" id="yiyi-30">Attempting to access attributes or methods on the mock that don’t exist on the spec will fail with an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-31">The <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> decorator / context manager makes it easy to mock classes or objects in a module under test. </span><span class="yiyi-st" id="yiyi-32">The object you specify will be replaced with a mock (or other object) during the test and restored when the test ends:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="k">import</span> <span class="n">patch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="p">(</span><span class="s1">'module.ClassName2'</span><span class="p">)</span>
<span class="gp">... </span><span class="nd">@patch</span><span class="p">(</span><span class="s1">'module.ClassName1'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">MockClass1</span><span class="p">,</span> <span class="n">MockClass2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">module</span><span class="o">.</span><span class="n">ClassName1</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">module</span><span class="o">.</span><span class="n">ClassName2</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">MockClass1</span> <span class="ow">is</span> <span class="n">module</span><span class="o">.</span><span class="n">ClassName1</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">MockClass2</span> <span class="ow">is</span> <span class="n">module</span><span class="o">.</span><span class="n">ClassName2</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">MockClass1</span><span class="o">.</span><span class="n">called</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">MockClass2</span><span class="o">.</span><span class="n">called</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">()</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-33">Note</span></p><p><span class="yiyi-st" id="yiyi-34">当您嵌套修补程序装饰器时，这些模拟会按照它们应用的顺序（装饰器应用的正常<em>python</em>顺序）传递到装饰函数中。</span><span class="yiyi-st" id="yiyi-35">这意味着从下往上，在上面的示例中，首先传递<code class="docutils literal"><span class="pre">module.ClassName1</span></code>给模拟对象。</span></p><p class="last"><span class="yiyi-st" id="yiyi-36">使用<a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>时，重要的是您可以在查找它们的名称空间中修补对象。</span><span class="yiyi-st" id="yiyi-37">这通常很直接，但为了快速指导，请阅读<a class="reference internal" href="#where-to-patch"><span>哪里需要补丁</span></a>。</span></p></div><p><span class="yiyi-st" id="yiyi-38">As well as a decorator <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> can be used as a context manager in a with statement:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="n">ProductionClass</span><span class="p">,</span> <span class="s1">'method'</span><span class="p">,</span> <span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_method</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">thing</span> <span class="o">=</span> <span class="n">ProductionClass</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">thing</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_method</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-39">There is also <a class="reference internal" href="#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal"><span class="pre">patch.dict()</span></code></a> for setting values in a dictionary just during a scope and restoring the dictionary to its original state when the test ends:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'key'</span><span class="p">:</span> <span class="s1">'value'</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="p">{</span><span class="s1">'newkey'</span><span class="p">:</span> <span class="s1">'newvalue'</span><span class="p">},</span> <span class="n">clear</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">foo</span> <span class="o">==</span> <span class="p">{</span><span class="s1">'newkey'</span><span class="p">:</span> <span class="s1">'newvalue'</span><span class="p">}</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">foo</span> <span class="o">==</span> <span class="n">original</span>
</code></pre><p><span class="yiyi-st" id="yiyi-40">Mock supports the mocking of Python <a class="reference internal" href="#magic-methods"><span>magic methods</span></a>. </span><span class="yiyi-st" id="yiyi-41">The easiest way of using magic methods is with the <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> class. </span><span class="yiyi-st" id="yiyi-42">It allows you to do things like:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__str__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s1">'foobarbaz'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">'foobarbaz'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__str__</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-43">Mock allows you to assign functions (or other Mock instances) to magic methods and they will be called appropriately. </span><span class="yiyi-st" id="yiyi-44">The <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> class is just a Mock variant that has all of the magic methods pre-created for you (well, all the useful ones anyway).</span></p><p><span class="yiyi-st" id="yiyi-45">The following is an example of using magic methods with the ordinary Mock class:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__str__</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="s1">'wheeeeee'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">'wheeeeee'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-46">For ensuring that the mock objects in your tests have the same api as the objects they are replacing, you can use <a class="reference internal" href="#auto-speccing"><span>auto-speccing</span></a>. </span><span class="yiyi-st" id="yiyi-47">Auto-speccing can be done through the <em>autospec</em> argument to patch, or the <a class="reference internal" href="#unittest.mock.create_autospec" title="unittest.mock.create_autospec"><code class="xref py py-func docutils literal"><span class="pre">create_autospec()</span></code></a> function. </span><span class="yiyi-st" id="yiyi-48">Auto-speccing creates mock objects that have the same attributes and methods as the objects they are replacing, and any functions and methods (including constructors) have the same call signature as the real object.</span></p><p><span class="yiyi-st" id="yiyi-49">This ensures that your mocks will fail in the same way as your production code if they are used incorrectly:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="k">import</span> <span class="n">create_autospec</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_function</span> <span class="o">=</span> <span class="n">create_autospec</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">return_value</span><span class="o">=</span><span class="s1">'fishy'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_function</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">'fishy'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_function</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_function</span><span class="p">(</span><span class="s1">'wrong arguments'</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
 <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&lt;lambda&gt;() takes exactly 3 arguments (1 given)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-50"><a class="reference internal" href="#unittest.mock.create_autospec" title="unittest.mock.create_autospec"><code class="xref py py-func docutils literal"><span class="pre">create_autospec()</span></code></a> can also be used on classes, where it copies the signature of the <code class="docutils literal"><span class="pre">__init__</span></code> method, and on callable objects where it copies the signature of the <code class="docutils literal"><span class="pre">__call__</span></code> method.</span></p></div><div class="section" id="the-mock-class"><h2><span class="yiyi-st" id="yiyi-51">26.5.2. </span><span class="yiyi-st" id="yiyi-52">The Mock Class</span></h2><p><span class="yiyi-st" id="yiyi-53"><a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> is a flexible mock object intended to replace the use of stubs and test doubles throughout your code. </span><span class="yiyi-st" id="yiyi-54">Mocks are callable and create attributes as new mocks when you access them <a class="footnote-reference" href="#id3" id="id1">[1]</a>. </span><span class="yiyi-st" id="yiyi-55">Accessing the same attribute will always return the same mock. </span><span class="yiyi-st" id="yiyi-56">Mocks record how you use them, allowing you to make assertions about what your code has done to them.</span></p><p><span class="yiyi-st" id="yiyi-57"><a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> is a subclass of <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> with all the magic methods pre-created and ready to use. </span><span class="yiyi-st" id="yiyi-58">There are also non-callable variants, useful when you are mocking out objects that aren’t callable: <a class="reference internal" href="#unittest.mock.NonCallableMock" title="unittest.mock.NonCallableMock"><code class="xref py py-class docutils literal"><span class="pre">NonCallableMock</span></code></a> and <a class="reference internal" href="#unittest.mock.NonCallableMagicMock" title="unittest.mock.NonCallableMagicMock"><code class="xref py py-class docutils literal"><span class="pre">NonCallableMagicMock</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-59">The <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> decorators makes it easy to temporarily replace classes in a particular module with a <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> object. </span><span class="yiyi-st" id="yiyi-60">By default <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> will create a <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> for you. </span><span class="yiyi-st" id="yiyi-61">You can specify an alternative class of <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> using the <em>new_callable</em> argument to <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>.</span></p><dl class="class"><dt id="unittest.mock.Mock"><span class="yiyi-st" id="yiyi-62"> <em class="property">class </em><code class="descclassname">unittest.mock.</code><code class="descname">Mock</code><span class="sig-paren">(</span><em>spec=None</em>, <em>side_effect=None</em>, <em>return_value=DEFAULT</em>, <em>wraps=None</em>, <em>name=None</em>, <em>spec_set=None</em>, <em>unsafe=False</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-63">Create a new <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> object. </span><span class="yiyi-st" id="yiyi-64"><a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> takes several optional arguments that specify the behaviour of the Mock object:</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-65"><em>spec</em>: This can be either a list of strings or an existing object (a class or instance) that acts as the specification for the mock object. </span><span class="yiyi-st" id="yiyi-66">If you pass in an object then a list of strings is formed by calling dir on the object (excluding unsupported magic attributes and methods). </span><span class="yiyi-st" id="yiyi-67">Accessing any attribute not in this list will raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-68">If <em>spec</em> is an object (rather than a list of strings) then <a class="reference internal" href="stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal"><span class="pre">__class__</span></code></a> returns the class of the spec object. </span><span class="yiyi-st" id="yiyi-69">This allows mocks to pass <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> tests.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-70"><em>spec_set</em>: A stricter variant of <em>spec</em>. </span><span class="yiyi-st" id="yiyi-71">If used, attempting to <em>set</em> or get an attribute on the mock that isn’t on the object passed as <em>spec_set</em> will raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-72"><em>side_effect</em>: A function to be called whenever the Mock is called. </span><span class="yiyi-st" id="yiyi-73">See the <a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a> attribute. </span><span class="yiyi-st" id="yiyi-74">Useful for raising exceptions or dynamically changing return values. </span><span class="yiyi-st" id="yiyi-75">The function is called with the same arguments as the mock, and unless it returns <a class="reference internal" href="#unittest.mock.DEFAULT" title="unittest.mock.DEFAULT"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT</span></code></a>, the return value of this function is used as the return value.</span></p><p><span class="yiyi-st" id="yiyi-76">Alternatively <em>side_effect</em> can be an exception class or instance. </span><span class="yiyi-st" id="yiyi-77">In this case the exception will be raised when the mock is called.</span></p><p><span class="yiyi-st" id="yiyi-78">If <em>side_effect</em> is an iterable then each call to the mock will return the next value from the iterable.</span></p><p><span class="yiyi-st" id="yiyi-79">A <em>side_effect</em> can be cleared by setting it to <code class="docutils literal"><span class="pre">None</span></code>.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-80"><em>return_value</em>: The value returned when the mock is called. </span><span class="yiyi-st" id="yiyi-81">By default this is a new Mock (created on first access). </span><span class="yiyi-st" id="yiyi-82">See the <a class="reference internal" href="#unittest.mock.Mock.return_value" title="unittest.mock.Mock.return_value"><code class="xref py py-attr docutils literal"><span class="pre">return_value</span></code></a> attribute.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-83"><em>unsafe</em>: By default if any attribute starts with <em>assert</em> or <em>assret</em> will raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>. </span><span class="yiyi-st" id="yiyi-84">Passing <code class="docutils literal"><span class="pre">unsafe=True</span></code> will allow access to these attributes.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-85"><span class="versionmodified">New in version 3.5.</span></span></p></div></li><li><p class="first"><span class="yiyi-st" id="yiyi-86"><em>wraps</em>: Item for the mock object to wrap. </span><span class="yiyi-st" id="yiyi-87">If <em>wraps</em> is not None then calling the Mock will pass the call through to the wrapped object (returning the real result). </span><span class="yiyi-st" id="yiyi-88">Attribute access on the mock will return a Mock object that wraps the corresponding attribute of the wrapped object (so attempting to access an attribute that doesn’t exist will raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>).</span></p><p><span class="yiyi-st" id="yiyi-89">If the mock has an explicit <em>return_value</em> set then calls are not passed to the wrapped object and the <em>return_value</em> is returned instead.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-90"><em>name</em>: If the mock has a name then it will be used in the repr of the mock. </span><span class="yiyi-st" id="yiyi-91">This can be useful for debugging. </span><span class="yiyi-st" id="yiyi-92">The name is propagated to child mocks.</span></p></li></ul><p><span class="yiyi-st" id="yiyi-93">Mocks can also be called with arbitrary keyword arguments. </span><span class="yiyi-st" id="yiyi-94">These will be used to set attributes on the mock after it is created. </span><span class="yiyi-st" id="yiyi-95">See the <a class="reference internal" href="#unittest.mock.Mock.configure_mock" title="unittest.mock.Mock.configure_mock"><code class="xref py py-meth docutils literal"><span class="pre">configure_mock()</span></code></a> method for details.</span></p><dl class="method"><dt id="unittest.mock.Mock.assert_called_with"><span class="yiyi-st" id="yiyi-96"> <code class="descname">assert_called_with</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-97">This method is a convenient way of asserting that calls are made in a particular way:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="s1">'wow'</span><span class="p">)</span>
<span class="go">&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="s1">'wow'</span><span class="p">)</span>
</code></pre></dd></dl><dl class="method"><dt id="unittest.mock.Mock.assert_called_once_with"><span class="yiyi-st" id="yiyi-98"> <code class="descname">assert_called_once_with</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-99">Assert that the mock was called exactly once and with the specified arguments.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="s1">'baz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="s1">'baz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="s1">'baz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="s1">'baz'</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">Expected 'mock' to be called once. Called 2 times.</span>
</code></pre></dd></dl><dl class="method"><dt id="unittest.mock.Mock.assert_any_call"><span class="yiyi-st" id="yiyi-100"> <code class="descname">assert_any_call</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-101">assert the mock has been called with the specified arguments.</span></p><p><span class="yiyi-st" id="yiyi-102">The assert passes if the mock has <em>ever</em> been called, unlike <a class="reference internal" href="#unittest.mock.Mock.assert_called_with" title="unittest.mock.Mock.assert_called_with"><code class="xref py py-meth docutils literal"><span class="pre">assert_called_with()</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.assert_called_once_with" title="unittest.mock.Mock.assert_called_once_with"><code class="xref py py-meth docutils literal"><span class="pre">assert_called_once_with()</span></code></a> that only pass if the call is the most recent one.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="s1">'thing'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="s1">'some'</span><span class="p">,</span> <span class="s1">'thing'</span><span class="p">,</span> <span class="s1">'else'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_any_call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="s1">'thing'</span><span class="p">)</span>
</code></pre></dd></dl><dl class="method"><dt id="unittest.mock.Mock.assert_has_calls"><span class="yiyi-st" id="yiyi-103"> <code class="descname">assert_has_calls</code><span class="sig-paren">(</span><em>calls</em>, <em>any_order=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">assert the mock has been called with the specified calls. </span><span class="yiyi-st" id="yiyi-105">The <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a> list is checked for the calls.</span></p><p><span class="yiyi-st" id="yiyi-106">If <em>any_order</em> is false (the default) then the calls must be sequential. </span><span class="yiyi-st" id="yiyi-107">There can be extra calls before or after the specified calls.</span></p><p><span class="yiyi-st" id="yiyi-108">If <em>any_order</em> is true then the calls can be in any order, but they must all appear in <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a>.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calls</span> <span class="o">=</span> <span class="p">[</span><span class="n">call</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">call</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_has_calls</span><span class="p">(</span><span class="n">calls</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calls</span> <span class="o">=</span> <span class="p">[</span><span class="n">call</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">call</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">call</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_has_calls</span><span class="p">(</span><span class="n">calls</span><span class="p">,</span> <span class="n">any_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></dd></dl><dl class="method"><dt id="unittest.mock.Mock.assert_not_called"><span class="yiyi-st" id="yiyi-109"> <code class="descname">assert_not_called</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-110">Assert the mock was never called.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hello</span><span class="o">.</span><span class="n">assert_not_called</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hello</span><span class="o">.</span><span class="n">assert_not_called</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">Expected 'hello' to not have been called. Called 1 times.</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-111"><span class="versionmodified">New in version 3.5.</span></span></p></div></dd></dl><dl class="method"><dt id="unittest.mock.Mock.reset_mock"><span class="yiyi-st" id="yiyi-112"> <code class="descname">reset_mock</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-113">The reset_mock method resets all the call attributes on a mock object:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">called</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">reset_mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">called</span>
<span class="go">False</span>
</code></pre><p><span class="yiyi-st" id="yiyi-114">This can be useful where you want to make a series of assertions that reuse the same object. </span><span class="yiyi-st" id="yiyi-115">Note that <a class="reference internal" href="#unittest.mock.Mock.reset_mock" title="unittest.mock.Mock.reset_mock"><code class="xref py py-meth docutils literal"><span class="pre">reset_mock()</span></code></a> <em>doesn’t</em> clear the return value, <a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a> or any child attributes you have set using normal assignment. </span><span class="yiyi-st" id="yiyi-116">Child mocks and the return value mock (if any) are reset as well.</span></p></dd></dl><dl class="method"><dt id="unittest.mock.Mock.mock_add_spec"><span class="yiyi-st" id="yiyi-117"> <code class="descname">mock_add_spec</code><span class="sig-paren">(</span><em>spec</em>, <em>spec_set=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-118">Add a spec to a mock. </span><span class="yiyi-st" id="yiyi-119"><em>spec</em> can either be an object or a list of strings. </span><span class="yiyi-st" id="yiyi-120">Only attributes on the <em>spec</em> can be fetched as attributes from the mock.</span></p><p><span class="yiyi-st" id="yiyi-121">If <em>spec_set</em> is true then only attributes on the spec can be set.</span></p></dd></dl><dl class="method"><dt id="unittest.mock.Mock.attach_mock"><span class="yiyi-st" id="yiyi-122"> <code class="descname">attach_mock</code><span class="sig-paren">(</span><em>mock</em>, <em>attribute</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-123">Attach a mock as an attribute of this one, replacing its name and parent. </span><span class="yiyi-st" id="yiyi-124">Calls to the attached mock will be recorded in the <a class="reference internal" href="#unittest.mock.Mock.method_calls" title="unittest.mock.Mock.method_calls"><code class="xref py py-attr docutils literal"><span class="pre">method_calls</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a> attributes of this one.</span></p></dd></dl><dl class="method"><dt id="unittest.mock.Mock.configure_mock"><span class="yiyi-st" id="yiyi-125"> <code class="descname">configure_mock</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-126">Set attributes on the mock through keyword arguments.</span></p><p><span class="yiyi-st" id="yiyi-127">Attributes plus return values and side effects can be set on child mocks using standard dot notation and unpacking a dictionary in the method call:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'method.return_value'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'other.side_effect'</span><span class="p">:</span> <span class="ne">KeyError</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">configure_mock</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">other</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">KeyError</span>
</code></pre><p><span class="yiyi-st" id="yiyi-128">The same thing can be achieved in the constructor call to mocks:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'method.return_value'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'other.side_effect'</span><span class="p">:</span> <span class="ne">KeyError</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">some_attribute</span><span class="o">=</span><span class="s1">'eggs'</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">some_attribute</span>
<span class="go">'eggs'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">other</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">KeyError</span>
</code></pre><p><span class="yiyi-st" id="yiyi-129"><a class="reference internal" href="#unittest.mock.Mock.configure_mock" title="unittest.mock.Mock.configure_mock"><code class="xref py py-meth docutils literal"><span class="pre">configure_mock()</span></code></a> exists to make it easier to do configuration after the mock has been created.</span></p></dd></dl><dl class="method"><dt id="unittest.mock.Mock.__dir__"><span class="yiyi-st" id="yiyi-130"> <code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-131"><a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> objects limit the results of <code class="docutils literal"><span class="pre">dir(some_mock)</span></code> to useful results. </span><span class="yiyi-st" id="yiyi-132">For mocks with a <em>spec</em> this includes all the permitted attributes for the mock.</span></p><p><span class="yiyi-st" id="yiyi-133">See <a class="reference internal" href="#unittest.mock.FILTER_DIR" title="unittest.mock.FILTER_DIR"><code class="xref py py-data docutils literal"><span class="pre">FILTER_DIR</span></code></a> for what this filtering does, and how to switch it off.</span></p></dd></dl><dl class="method"><dt id="unittest.mock.Mock._get_child_mock"><span class="yiyi-st" id="yiyi-134"> <code class="descname">_get_child_mock</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-135">Create the child mocks for attributes and return value. </span><span class="yiyi-st" id="yiyi-136">By default child mocks will be the same type as the parent. </span><span class="yiyi-st" id="yiyi-137">Subclasses of Mock may want to override this to customize the way child mocks are made.</span></p><p><span class="yiyi-st" id="yiyi-138">For non-callable mocks the callable variant will be used (rather than any custom subclass).</span></p></dd></dl><dl class="attribute"><dt id="unittest.mock.Mock.called"><span class="yiyi-st" id="yiyi-139"> <code class="descname">called</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-140">A boolean representing whether or not the mock object has been called:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">called</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">called</span>
<span class="go">True</span>
</code></pre></dd></dl><dl class="attribute"><dt id="unittest.mock.Mock.call_count"><span class="yiyi-st" id="yiyi-141"> <code class="descname">call_count</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-142">An integer telling you how many times the mock object has been called:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_count</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_count</span>
<span class="go">2</span>
</code></pre></dd></dl><dl class="attribute"><dt id="unittest.mock.Mock.return_value"><span class="yiyi-st" id="yiyi-143"> <code class="descname">return_value</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-144">Set this to configure the value returned by calling the mock:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s1">'fish'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="go">'fish'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-145">The default return value is a mock object and you can configure it in the normal way:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">Attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">return_value</span><span class="p">()</span>
<span class="go">&lt;Mock name='mock()()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-146"><a class="reference internal" href="#unittest.mock.Mock.return_value" title="unittest.mock.Mock.return_value"><code class="xref py py-attr docutils literal"><span class="pre">return_value</span></code></a> can also be set in the constructor:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">return_value</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="go">3</span>
</code></pre></dd></dl><dl class="attribute"><dt id="unittest.mock.Mock.side_effect"><span class="yiyi-st" id="yiyi-147"> <code class="descname">side_effect</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-148">This can either be a function to be called when the mock is called, an iterable or an exception (class or instance) to be raised.</span></p><p><span class="yiyi-st" id="yiyi-149">If you pass in a function it will be called with same arguments as the mock and unless the function returns the <a class="reference internal" href="#unittest.mock.DEFAULT" title="unittest.mock.DEFAULT"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT</span></code></a> singleton the call to the mock will then return whatever the function returns. </span><span class="yiyi-st" id="yiyi-150">If the function returns <a class="reference internal" href="#unittest.mock.DEFAULT" title="unittest.mock.DEFAULT"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT</span></code></a> then the mock will return its normal value (from the <a class="reference internal" href="#unittest.mock.Mock.return_value" title="unittest.mock.Mock.return_value"><code class="xref py py-attr docutils literal"><span class="pre">return_value</span></code></a>).</span></p><p><span class="yiyi-st" id="yiyi-151">If you pass in an iterable, it is used to retrieve an iterator which must yield a value on every call. </span><span class="yiyi-st" id="yiyi-152">This value can either be an exception instance to be raised, or a value to be returned from the call to the mock (<a class="reference internal" href="#unittest.mock.DEFAULT" title="unittest.mock.DEFAULT"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT</span></code></a> handling is identical to the function case).</span></p><p><span class="yiyi-st" id="yiyi-153">An example of a mock that raises an exception (to test exception handling of an API):</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Boom!'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">Exception</span>: <span class="n">Boom!</span>
</code></pre><p><span class="yiyi-st" id="yiyi-154">Using <a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a> to return a sequence of values:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(),</span> <span class="n">mock</span><span class="p">(),</span> <span class="n">mock</span><span class="p">()</span>
<span class="go">(3, 2, 1)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-155">Using a callable:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">side_effect</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">DEFAULT</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">side_effect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="go">3</span>
</code></pre><p><span class="yiyi-st" id="yiyi-156"><a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a> can be set in the constructor. </span><span class="yiyi-st" id="yiyi-157">Here’s an example that adds one to the value the mock is called with and returns it:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">side_effect</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="n">side_effect</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span>
<span class="go">-7</span>
</code></pre><p><span class="yiyi-st" id="yiyi-158">Setting <a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a> to <code class="docutils literal"><span class="pre">None</span></code> clears it:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="ne">KeyError</span><span class="p">,</span> <span class="n">return_value</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
 <span class="c">...</span>
<span class="gr">KeyError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="go">3</span>
</code></pre></dd></dl><dl class="attribute"><dt id="unittest.mock.Mock.call_args"><span class="yiyi-st" id="yiyi-159"> <code class="descname">call_args</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-160">This is either <code class="docutils literal"><span class="pre">None</span></code> (if the mock hasn’t been called), or the arguments that the mock was last called with. </span><span class="yiyi-st" id="yiyi-161">This will be in the form of a tuple: the first member is any ordered arguments the mock was called with (or an empty tuple) and the second member is any keyword arguments (or an empty dictionary).</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mock</span><span class="o">.</span><span class="n">call_args</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_args</span>
<span class="go">call()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_args</span> <span class="o">==</span> <span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_args</span>
<span class="go">call(3, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_args</span> <span class="o">==</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">'fish'</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="s1">'w00t!'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_args</span>
<span class="go">call(3, 4, 5, key='fish', next='w00t!')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-162"><a class="reference internal" href="#unittest.mock.Mock.call_args" title="unittest.mock.Mock.call_args"><code class="xref py py-attr docutils literal"><span class="pre">call_args</span></code></a>, along with members of the lists <a class="reference internal" href="#unittest.mock.Mock.call_args_list" title="unittest.mock.Mock.call_args_list"><code class="xref py py-attr docutils literal"><span class="pre">call_args_list</span></code></a>, <a class="reference internal" href="#unittest.mock.Mock.method_calls" title="unittest.mock.Mock.method_calls"><code class="xref py py-attr docutils literal"><span class="pre">method_calls</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a> are <a class="reference internal" href="#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-data docutils literal"><span class="pre">call</span></code></a> objects. </span><span class="yiyi-st" id="yiyi-163">These are tuples, so they can be unpacked to get at the individual arguments and make more complex assertions. </span><span class="yiyi-st" id="yiyi-164">See <a class="reference internal" href="#calls-as-tuples"><span>calls as tuples</span></a>.</span></p></dd></dl><dl class="attribute"><dt id="unittest.mock.Mock.call_args_list"><span class="yiyi-st" id="yiyi-165"> <code class="descname">call_args_list</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-166">This is a list of all the calls made to the mock object in sequence (so the length of the list is the number of times it has been called). </span><span class="yiyi-st" id="yiyi-167">Before any calls have been made it is an empty list. </span><span class="yiyi-st" id="yiyi-168">The <a class="reference internal" href="#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-data docutils literal"><span class="pre">call</span></code></a> object can be used for conveniently constructing lists of calls to compare with <a class="reference internal" href="#unittest.mock.Mock.call_args_list" title="unittest.mock.Mock.call_args_list"><code class="xref py py-attr docutils literal"><span class="pre">call_args_list</span></code></a>.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">'fish'</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="s1">'w00t!'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_args_list</span>
<span class="go">[call(), call(3, 4), call(key='fish', next='w00t!')]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expected</span> <span class="o">=</span> <span class="p">[(),</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),),</span> <span class="p">({</span><span class="s1">'key'</span><span class="p">:</span> <span class="s1">'fish'</span><span class="p">,</span> <span class="s1">'next'</span><span class="p">:</span> <span class="s1">'w00t!'</span><span class="p">},)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_args_list</span> <span class="o">==</span> <span class="n">expected</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-169">Members of <a class="reference internal" href="#unittest.mock.Mock.call_args_list" title="unittest.mock.Mock.call_args_list"><code class="xref py py-attr docutils literal"><span class="pre">call_args_list</span></code></a> are <a class="reference internal" href="#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-data docutils literal"><span class="pre">call</span></code></a> objects. </span><span class="yiyi-st" id="yiyi-170">These can be unpacked as tuples to get at the individual arguments. </span><span class="yiyi-st" id="yiyi-171">See <a class="reference internal" href="#calls-as-tuples"><span>calls as tuples</span></a>.</span></p></dd></dl><dl class="attribute"><dt id="unittest.mock.Mock.method_calls"><span class="yiyi-st" id="yiyi-172"> <code class="descname">method_calls</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-173">As well as tracking calls to themselves, mocks also track calls to methods and attributes, and <em>their</em> methods and attributes:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
<span class="go">&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">property</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">attribute</span><span class="p">()</span>
<span class="go">&lt;Mock name='mock.property.method.attribute()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method_calls</span>
<span class="go">[call.method(), call.property.method.attribute()]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-174">Members of <a class="reference internal" href="#unittest.mock.Mock.method_calls" title="unittest.mock.Mock.method_calls"><code class="xref py py-attr docutils literal"><span class="pre">method_calls</span></code></a> are <a class="reference internal" href="#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-data docutils literal"><span class="pre">call</span></code></a> objects. </span><span class="yiyi-st" id="yiyi-175">These can be unpacked as tuples to get at the individual arguments. </span><span class="yiyi-st" id="yiyi-176">See <a class="reference internal" href="#calls-as-tuples"><span>calls as tuples</span></a>.</span></p></dd></dl><dl class="attribute"><dt id="unittest.mock.Mock.mock_calls"><span class="yiyi-st" id="yiyi-177"> <code class="descname">mock_calls</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-178"><a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a> records <em>all</em> calls to the mock object, its methods, magic methods <em>and</em> return value mocks.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&lt;MagicMock name='mock.first()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">second</span><span class="p">()</span>
<span class="go">&lt;MagicMock name='mock.second()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;MagicMock name='mock()()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expected</span> <span class="o">=</span> <span class="p">[</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">call</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">call</span><span class="o">.</span><span class="n">second</span><span class="p">(),</span>
<span class="gp">... </span><span class="n">call</span><span class="o">.</span><span class="n">__int__</span><span class="p">(),</span> <span class="n">call</span><span class="p">()(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">mock_calls</span> <span class="o">==</span> <span class="n">expected</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-179">Members of <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a> are <a class="reference internal" href="#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-data docutils literal"><span class="pre">call</span></code></a> objects. </span><span class="yiyi-st" id="yiyi-180">These can be unpacked as tuples to get at the individual arguments. </span><span class="yiyi-st" id="yiyi-181">See <a class="reference internal" href="#calls-as-tuples"><span>calls as tuples</span></a>.</span></p></dd></dl><dl class="attribute"><dt id="unittest.mock.Mock.__class__"><span class="yiyi-st" id="yiyi-182"> <code class="descname">__class__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-183">Normally the <a class="reference internal" href="#unittest.mock.Mock.__class__" title="unittest.mock.Mock.__class__"><code class="xref py py-attr docutils literal"><span class="pre">__class__</span></code></a> attribute of an object will return its type. </span><span class="yiyi-st" id="yiyi-184">For a mock object with a <code class="xref py py-attr docutils literal"><span class="pre">spec</span></code>, <code class="docutils literal"><span class="pre">__class__</span></code> returns the spec class instead. </span><span class="yiyi-st" id="yiyi-185">This allows mock objects to pass <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> tests for the object they are replacing / masquerading as:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-186"><a class="reference internal" href="#unittest.mock.Mock.__class__" title="unittest.mock.Mock.__class__"><code class="xref py py-attr docutils literal"><span class="pre">__class__</span></code></a> is assignable to, this allows a mock to pass an <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> check without forcing you to use a spec:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__class__</span> <span class="o">=</span> <span class="nb">dict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
<span class="go">True</span>
</code></pre></dd></dl></dd></dl><dl class="class"><dt id="unittest.mock.NonCallableMock"><span class="yiyi-st" id="yiyi-187"> <em class="property">class </em><code class="descclassname">unittest.mock.</code><code class="descname">NonCallableMock</code><span class="sig-paren">(</span><em>spec=None</em>, <em>wraps=None</em>, <em>name=None</em>, <em>spec_set=None</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-188">A non-callable version of <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a>. </span><span class="yiyi-st" id="yiyi-189">The constructor parameters have the same meaning of <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a>, with the exception of <em>return_value</em> and <em>side_effect</em> which have no meaning on a non-callable mock.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-190">Mock objects that use a class or an instance as a <code class="xref py py-attr docutils literal"><span class="pre">spec</span></code> or <code class="xref py py-attr docutils literal"><span class="pre">spec_set</span></code> are able to pass <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> tests:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">SomeClass</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">SomeClass</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">spec_set</span><span class="o">=</span><span class="n">SomeClass</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">SomeClass</span><span class="p">)</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-191">The <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> classes have support for mocking magic methods. </span><span class="yiyi-st" id="yiyi-192">See <a class="reference internal" href="#magic-methods"><span>magic methods</span></a> for the full details.</span></p><p><span class="yiyi-st" id="yiyi-193">The mock classes and the <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> decorators all take arbitrary keyword arguments for configuration. </span><span class="yiyi-st" id="yiyi-194">For the <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> decorators the keywords are passed to the constructor of the mock being created. </span><span class="yiyi-st" id="yiyi-195">The keyword arguments are for configuring attributes of the mock:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">attribute</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s1">'fish'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">attribute</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">other</span>
<span class="go">'fish'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-196">The return value and side effect of child mocks can be set in the same way, using dotted notation. </span><span class="yiyi-st" id="yiyi-197">As you can’t use dotted names directly in a call you have to create a dictionary and unpack it using <code class="docutils literal"><span class="pre">**</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'method.return_value'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'other.side_effect'</span><span class="p">:</span> <span class="ne">KeyError</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">some_attribute</span><span class="o">=</span><span class="s1">'eggs'</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">some_attribute</span>
<span class="go">'eggs'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">other</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">KeyError</span>
</code></pre><p><span class="yiyi-st" id="yiyi-198">A callable mock which was created with a <em>spec</em> (or a <em>spec_set</em>) will introspect the specification object’s signature when matching calls to the mock. </span><span class="yiyi-st" id="yiyi-199">Therefore, it can match the actual call’s arguments regardless of whether they were passed positionally or by name:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&lt;Mock name='mock()' id='140161580456576'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-200">This applies to <a class="reference internal" href="#unittest.mock.Mock.assert_called_with" title="unittest.mock.Mock.assert_called_with"><code class="xref py py-meth docutils literal"><span class="pre">assert_called_with()</span></code></a>, <a class="reference internal" href="#unittest.mock.Mock.assert_called_once_with" title="unittest.mock.Mock.assert_called_once_with"><code class="xref py py-meth docutils literal"><span class="pre">assert_called_once_with()</span></code></a>, <a class="reference internal" href="#unittest.mock.Mock.assert_has_calls" title="unittest.mock.Mock.assert_has_calls"><code class="xref py py-meth docutils literal"><span class="pre">assert_has_calls()</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.assert_any_call" title="unittest.mock.Mock.assert_any_call"><code class="xref py py-meth docutils literal"><span class="pre">assert_any_call()</span></code></a>. </span><span class="yiyi-st" id="yiyi-201">When <a class="reference internal" href="#auto-speccing"><span>Autospeccing</span></a>, it will also apply to method calls on the mock object.</span></p><span class="yiyi-st" id="yiyi-254"> <blockquote> <div><div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4: </span>Added signature introspection on specced and autospecced mock objects.</p> </div> </div></blockquote></span><dl class="class"><dt id="unittest.mock.PropertyMock"><span class="yiyi-st" id="yiyi-202"> <em class="property">class </em><code class="descclassname">unittest.mock.</code><code class="descname">PropertyMock</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-203">A mock intended to be used as a property, or other descriptor, on a class. </span><span class="yiyi-st" id="yiyi-204"><a class="reference internal" href="#unittest.mock.PropertyMock" title="unittest.mock.PropertyMock"><code class="xref py py-class docutils literal"><span class="pre">PropertyMock</span></code></a> provides <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a> methods so you can specify a return value when it is fetched.</span></p><p><span class="yiyi-st" id="yiyi-205">Fetching a <a class="reference internal" href="#unittest.mock.PropertyMock" title="unittest.mock.PropertyMock"><code class="xref py py-class docutils literal"><span class="pre">PropertyMock</span></code></a> instance from an object calls the mock, with no args. </span><span class="yiyi-st" id="yiyi-206">Setting it calls the mock with the value being set.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nd">@property</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s1">'something'</span>
<span class="gp">... </span>    <span class="nd">@foo</span><span class="o">.</span><span class="n">setter</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.Foo.foo'</span><span class="p">,</span> <span class="n">new_callable</span><span class="o">=</span><span class="n">PropertyMock</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_foo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">mock_foo</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s1">'mockity-mock'</span>
<span class="gp">... </span>    <span class="n">this_foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">this_foo</span><span class="o">.</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">this_foo</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">...</span>
<span class="go">mockity-mock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_foo</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call(), call(6)]</span>
</code></pre></dd></dl><p><span class="yiyi-st" id="yiyi-207">Because of the way mock attributes are stored you can’t directly attach a <a class="reference internal" href="#unittest.mock.PropertyMock" title="unittest.mock.PropertyMock"><code class="xref py py-class docutils literal"><span class="pre">PropertyMock</span></code></a> to a mock object. </span><span class="yiyi-st" id="yiyi-208">Instead you can attach it to the mock type object:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PropertyMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="n">p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">foo</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">()</span>
</code></pre><div class="section" id="calling"><h3><span class="yiyi-st" id="yiyi-209">26.5.2.1. </span><span class="yiyi-st" id="yiyi-210">Calling</span></h3><p><span class="yiyi-st" id="yiyi-211">Mock objects are callable. </span><span class="yiyi-st" id="yiyi-212">The call will return the value set as the <a class="reference internal" href="#unittest.mock.Mock.return_value" title="unittest.mock.Mock.return_value"><code class="xref py py-attr docutils literal"><span class="pre">return_value</span></code></a> attribute. </span><span class="yiyi-st" id="yiyi-213">The default return value is a new Mock object; it is created the first time the return value is accessed (either explicitly or by calling the Mock) - but it is stored and the same one returned each time.</span></p><p><span class="yiyi-st" id="yiyi-214">Calls made to the object will be recorded in the attributes like <a class="reference internal" href="#unittest.mock.Mock.call_args" title="unittest.mock.Mock.call_args"><code class="xref py py-attr docutils literal"><span class="pre">call_args</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.call_args_list" title="unittest.mock.Mock.call_args_list"><code class="xref py py-attr docutils literal"><span class="pre">call_args_list</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-215">If <a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a> is set then it will be called after the call has been recorded, so if <code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code> raises an exception the call is still recorded.</span></p><p><span class="yiyi-st" id="yiyi-216">The simplest way to make a mock raise an exception when called is to make <a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a> an exception class or instance:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="ne">IndexError</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">IndexError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call(1, 2, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">'Bang!'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="s1">'two'</span><span class="p">,</span> <span class="s1">'three'</span><span class="p">,</span> <span class="s1">'four'</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">KeyError</span>: <span class="n">'Bang!'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call(1, 2, 3), call('two', 'three', 'four')]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-217">If <code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code> is a function then whatever that function returns is what calls to the mock return. </span><span class="yiyi-st" id="yiyi-218">The <code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code> function is called with the same arguments as the mock. </span><span class="yiyi-st" id="yiyi-219">This allows you to vary the return value of the call dynamically, based on the input:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">side_effect</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="n">side_effect</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call(1), call(2)]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-220">If you want the mock to still return the default return value (a new mock), or any set return value, then there are two ways of doing this. </span><span class="yiyi-st" id="yiyi-221">Either return <code class="xref py py-attr docutils literal"><span class="pre">mock.return_value</span></code> from inside <code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code>, or return <a class="reference internal" href="#unittest.mock.DEFAULT" title="unittest.mock.DEFAULT"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT</span></code></a>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">side_effect</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">return_value</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">side_effect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">side_effect</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">DEFAULT</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">side_effect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="go">3</span>
</code></pre><p><span class="yiyi-st" id="yiyi-222">To remove a <code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code>, and return to the default behaviour, set the <code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code> to <code class="docutils literal"><span class="pre">None</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">side_effect</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">3</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">side_effect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="go">6</span>
</code></pre><p><span class="yiyi-st" id="yiyi-223">The <code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code> can also be any iterable object. </span><span class="yiyi-st" id="yiyi-224">Repeated calls to the mock will return values from the iterable (until the iterable is exhausted and a <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> is raised):</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">StopIteration</span>
</code></pre><p><span class="yiyi-st" id="yiyi-225">If any members of the iterable are exceptions they will be raised instead of returned:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iterable</span> <span class="o">=</span> <span class="p">(</span><span class="mi">33</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="mi">66</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="n">iterable</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="go">33</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
 <span class="c">...</span>
<span class="gr">ValueError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="go">66</span>
</code></pre></div><div class="section" id="deleting-attributes"><h3><span class="yiyi-st" id="yiyi-226">26.5.2.2. </span><span class="yiyi-st" id="yiyi-227">Deleting Attributes</span></h3><p><span class="yiyi-st" id="yiyi-228">Mock objects create attributes on demand. </span><span class="yiyi-st" id="yiyi-229">This allows them to pretend to be objects of any type.</span></p><p><span class="yiyi-st" id="yiyi-230">You may want a mock object to return <code class="docutils literal"><span class="pre">False</span></code> to a <a class="reference internal" href="functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal"><span class="pre">hasattr()</span></code></a> call, or raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> when an attribute is fetched. </span><span class="yiyi-st" id="yiyi-231">You can do this by providing an object as a <code class="xref py py-attr docutils literal"><span class="pre">spec</span></code> for a mock, but that isn’t always convenient.</span></p><p><span class="yiyi-st" id="yiyi-232">You “block” attributes by deleting them. </span><span class="yiyi-st" id="yiyi-233">Once deleted, accessing an attribute will raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="s1">'m'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">mock</span><span class="o">.</span><span class="n">m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="s1">'m'</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">mock</span><span class="o">.</span><span class="n">f</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">f</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AttributeError</span>: <span class="n">f</span>
</code></pre></div><div class="section" id="mock-names-and-the-name-attribute"><h3><span class="yiyi-st" id="yiyi-234">26.5.2.3. </span><span class="yiyi-st" id="yiyi-235">Mock names and the name attribute</span></h3><p><span class="yiyi-st" id="yiyi-236">Since “name” is an argument to the <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> constructor, if you want your mock object to have a “name” attribute you can’t just pass it in at creation time. </span><span class="yiyi-st" id="yiyi-237">There are two alternatives. </span><span class="yiyi-st" id="yiyi-238">One option is to use <a class="reference internal" href="#unittest.mock.Mock.configure_mock" title="unittest.mock.Mock.configure_mock"><code class="xref py py-meth docutils literal"><span class="pre">configure_mock()</span></code></a>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">configure_mock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'my_name'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">name</span>
<span class="go">'my_name'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-239">A simpler option is to simply set the “name” attribute after mock creation:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"foo"</span>
</code></pre></div><div class="section" id="attaching-mocks-as-attributes"><h3><span class="yiyi-st" id="yiyi-240">26.5.2.4. </span><span class="yiyi-st" id="yiyi-241">Attaching Mocks as Attributes</span></h3><p><span class="yiyi-st" id="yiyi-242">When you attach a mock as an attribute of another mock (or as the return value) it becomes a “child” of that mock. </span><span class="yiyi-st" id="yiyi-243">Calls to the child are recorded in the <a class="reference internal" href="#unittest.mock.Mock.method_calls" title="unittest.mock.Mock.method_calls"><code class="xref py py-attr docutils literal"><span class="pre">method_calls</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a> attributes of the parent. </span><span class="yiyi-st" id="yiyi-244">This is useful for configuring child mocks and then attaching them to the parent, or for attaching mocks to a parent that records all calls to the children and allows you to make assertions about the order of calls between mocks:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child1</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child2</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">child1</span> <span class="o">=</span> <span class="n">child1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">child2</span> <span class="o">=</span> <span class="n">child2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child2</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call.child1(1), call.child2(2)]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-245">The exception to this is if the mock has a name. </span><span class="yiyi-st" id="yiyi-246">This allows you to prevent the “parenting” if for some reason you don’t want it to happen.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_a_child</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'not-a-child'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">not_a_child</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">attribute</span><span class="p">()</span>
<span class="go">&lt;MagicMock name='not-a-child()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-247">Mocks created for you by <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> are automatically given names. </span><span class="yiyi-st" id="yiyi-248">To attach mocks that have names to a parent you use the <a class="reference internal" href="#unittest.mock.Mock.attach_mock" title="unittest.mock.Mock.attach_mock"><code class="xref py py-meth docutils literal"><span class="pre">attach_mock()</span></code></a> method:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thing1</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thing2</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.thing1'</span><span class="p">,</span> <span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">as</span> <span class="n">child1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.thing2'</span><span class="p">,</span> <span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">as</span> <span class="n">child2</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">parent</span><span class="o">.</span><span class="n">attach_mock</span><span class="p">(</span><span class="n">child1</span><span class="p">,</span> <span class="s1">'child1'</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">parent</span><span class="o">.</span><span class="n">attach_mock</span><span class="p">(</span><span class="n">child2</span><span class="p">,</span> <span class="s1">'child2'</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">child1</span><span class="p">(</span><span class="s1">'one'</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">child2</span><span class="p">(</span><span class="s1">'two'</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call.child1('one'), call.child2('two')]</span>
</code></pre><table class="docutils footnote" frame="void" id="id3" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-249"><a class="fn-backref" href="#id1">[1]</a></span></td><td><span class="yiyi-st" id="yiyi-250">The only exceptions are magic methods and attributes (those that have leading and trailing double underscores). </span><span class="yiyi-st" id="yiyi-251">Mock doesn’t create these but instead raises an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>. </span><span class="yiyi-st" id="yiyi-252">This is because the interpreter will often implicitly request these methods, and gets <em>very</em> confused to get a new Mock object when it expects a magic method. </span><span class="yiyi-st" id="yiyi-253">If you need magic method support see <a class="reference internal" href="#magic-methods"><span>magic methods</span></a>.</span></td></tr></tbody></table></div></div><div class="section" id="the-patchers"><h2><span class="yiyi-st" id="yiyi-255">26.5.3. </span><span class="yiyi-st" id="yiyi-256">The patchers</span></h2><p><span class="yiyi-st" id="yiyi-257">The patch decorators are used for patching objects only within the scope of the function they decorate. </span><span class="yiyi-st" id="yiyi-258">They automatically handle the unpatching for you, even if exceptions are raised. </span><span class="yiyi-st" id="yiyi-259">All of these functions can also be used in with statements or as class decorators.</span></p><div class="section" id="patch"><h3><span class="yiyi-st" id="yiyi-260">26.5.3.1. patch</span></h3><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-261">Note</span></p><p class="last"><span class="yiyi-st" id="yiyi-262"><a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> is straightforward to use. </span><span class="yiyi-st" id="yiyi-263">The key is to do the patching in the right namespace. </span><span class="yiyi-st" id="yiyi-264">See the section <a class="reference internal" href="#id5">where to patch</a>.</span></p></div><dl class="function"><dt id="unittest.mock.patch"><span class="yiyi-st" id="yiyi-265"> <code class="descclassname">unittest.mock.</code><code class="descname">patch</code><span class="sig-paren">(</span><em>target</em>, <em>new=DEFAULT</em>, <em>spec=None</em>, <em>create=False</em>, <em>spec_set=None</em>, <em>autospec=None</em>, <em>new_callable=None</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-266"><a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> acts as a function decorator, class decorator or a context manager. </span><span class="yiyi-st" id="yiyi-267">Inside the body of the function or with statement, the <em>target</em> is patched with a <em>new</em> object. </span><span class="yiyi-st" id="yiyi-268">When the function/with statement exits the patch is undone.</span></p><p><span class="yiyi-st" id="yiyi-269">If <em>new</em> is omitted, then the target is replaced with a <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a>. </span><span class="yiyi-st" id="yiyi-270">If <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> is used as a decorator and <em>new</em> is omitted, the created mock is passed in as an extra argument to the decorated function. </span><span class="yiyi-st" id="yiyi-271">If <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> is used as a context manager the created mock is returned by the context manager.</span></p><p><span class="yiyi-st" id="yiyi-272"><em>target</em> should be a string in the form <code class="docutils literal"><span class="pre">'package.module.ClassName'</span></code>. </span><span class="yiyi-st" id="yiyi-273">The <em>target</em> is imported and the specified object replaced with the <em>new</em> object, so the <em>target</em> must be importable from the environment you are calling <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> from. </span><span class="yiyi-st" id="yiyi-274">The target is imported when the decorated function is executed, not at decoration time.</span></p><p><span class="yiyi-st" id="yiyi-275">The <em>spec</em> and <em>spec_set</em> keyword arguments are passed to the <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> if patch is creating one for you.</span></p><p><span class="yiyi-st" id="yiyi-276">In addition you can pass <code class="docutils literal"><span class="pre">spec=True</span></code> or <code class="docutils literal"><span class="pre">spec_set=True</span></code>, which causes patch to pass in the object being mocked as the spec/spec_set object.</span></p><p><span class="yiyi-st" id="yiyi-277"><em>new_callable</em> allows you to specify a different class, or callable object, that will be called to create the <em>new</em> object. </span><span class="yiyi-st" id="yiyi-278">By default <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> is used.</span></p><p><span class="yiyi-st" id="yiyi-279">A more powerful form of <em>spec</em> is <em>autospec</em>. </span><span class="yiyi-st" id="yiyi-280">If you set <code class="docutils literal"><span class="pre">autospec=True</span></code> then the mock will be created with a spec from the object being replaced. </span><span class="yiyi-st" id="yiyi-281">All attributes of the mock will also have the spec of the corresponding attribute of the object being replaced. </span><span class="yiyi-st" id="yiyi-282">Methods and functions being mocked will have their arguments checked and will raise a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> if they are called with the wrong signature. </span><span class="yiyi-st" id="yiyi-283">For mocks replacing a class, their return value (the ‘instance’) will have the same spec as the class. </span><span class="yiyi-st" id="yiyi-284">See the <a class="reference internal" href="#unittest.mock.create_autospec" title="unittest.mock.create_autospec"><code class="xref py py-func docutils literal"><span class="pre">create_autospec()</span></code></a> function and <a class="reference internal" href="#auto-speccing"><span>Autospeccing</span></a>.</span></p><p><span class="yiyi-st" id="yiyi-285">Instead of <code class="docutils literal"><span class="pre">autospec=True</span></code> you can pass <code class="docutils literal"><span class="pre">autospec=some_object</span></code> to use an arbitrary object as the spec instead of the one being replaced.</span></p><p><span class="yiyi-st" id="yiyi-286">By default <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> will fail to replace attributes that don’t exist. </span><span class="yiyi-st" id="yiyi-287">If you pass in <code class="docutils literal"><span class="pre">create=True</span></code>, and the attribute doesn’t exist, patch will create the attribute for you when the patched function is called, and delete it again afterwards. </span><span class="yiyi-st" id="yiyi-288">This is useful for writing tests against attributes that your production code creates at runtime. </span><span class="yiyi-st" id="yiyi-289">It is off by default because it can be dangerous. </span><span class="yiyi-st" id="yiyi-290">With it switched on you can write passing tests against APIs that don’t actually exist!</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-291">Note</span></p><div class="last versionchanged"><p><span class="yiyi-st" id="yiyi-292"><span class="versionmodified">Changed in version 3.5: </span>If you are patching builtins in a module then you don’t need to pass <code class="docutils literal"><span class="pre">create=True</span></code>, it will be added by default.</span></p></div></div><p><span class="yiyi-st" id="yiyi-293">Patch can be used as a <code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code> class decorator. </span><span class="yiyi-st" id="yiyi-294">It works by decorating each test method in the class. </span><span class="yiyi-st" id="yiyi-295">This reduces the boilerplate code when your test methods share a common patchings set. </span><span class="yiyi-st" id="yiyi-296"><a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> finds tests by looking for method names that start with <code class="docutils literal"><span class="pre">patch.TEST_PREFIX</span></code>. </span><span class="yiyi-st" id="yiyi-297">By default this is <code class="docutils literal"><span class="pre">'test'</span></code>, which matches the way <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> finds tests. </span><span class="yiyi-st" id="yiyi-298">You can specify an alternative prefix by setting <code class="docutils literal"><span class="pre">patch.TEST_PREFIX</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-299">Patch can be used as a context manager, with the with statement. </span><span class="yiyi-st" id="yiyi-300">Here the patching applies to the indented block after the with statement. </span><span class="yiyi-st" id="yiyi-301">If you use “as” then the patched object will be bound to the name after the “as”; very useful if <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> is creating a mock object for you.</span></p><p><span class="yiyi-st" id="yiyi-302"><a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> takes arbitrary keyword arguments. </span><span class="yiyi-st" id="yiyi-303">These will be passed to the <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> (or <em>new_callable</em>) on construction.</span></p><p><span class="yiyi-st" id="yiyi-304"><code class="docutils literal"><span class="pre">patch.dict(...)</span></code>, <code class="docutils literal"><span class="pre">patch.multiple(...)</span></code> and <code class="docutils literal"><span class="pre">patch.object(...)</span></code> are available for alternate use-cases.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-305"><a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> as function decorator, creating the mock for you and passing it into the decorated function:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="p">(</span><span class="s1">'__main__.SomeClass'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">normal_argument</span><span class="p">,</span> <span class="n">mock_class</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">mock_class</span> <span class="ow">is</span> <span class="n">SomeClass</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">function</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-306">Patching a class replaces the class with a <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> <em>instance</em>. </span><span class="yiyi-st" id="yiyi-307">If the class is instantiated in the code under test then it will be the <a class="reference internal" href="#unittest.mock.Mock.return_value" title="unittest.mock.Mock.return_value"><code class="xref py py-attr docutils literal"><span class="pre">return_value</span></code></a> of the mock that will be used.</span></p><p><span class="yiyi-st" id="yiyi-308">If the class is instantiated multiple times you could use <a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a> to return a new mock each time. </span><span class="yiyi-st" id="yiyi-309">Alternatively you can set the <em>return_value</em> to be anything you want.</span></p><p><span class="yiyi-st" id="yiyi-310">To configure return values on methods of <em>instances</em> on the patched class you must do this on the <code class="xref py py-attr docutils literal"><span class="pre">return_value</span></code>. </span><span class="yiyi-st" id="yiyi-311">For example:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Class</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.Class'</span><span class="p">)</span> <span class="k">as</span> <span class="n">MockClass</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">instance</span> <span class="o">=</span> <span class="n">MockClass</span><span class="o">.</span><span class="n">return_value</span>
<span class="gp">... </span>    <span class="n">instance</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s1">'foo'</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">Class</span><span class="p">()</span> <span class="ow">is</span> <span class="n">instance</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">Class</span><span class="p">()</span><span class="o">.</span><span class="n">method</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'foo'</span>
<span class="gp">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-312">If you use <em>spec</em> or <em>spec_set</em> and <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> is replacing a <em>class</em>, then the return value of the created mock will have the same spec.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Original</span> <span class="o">=</span> <span class="n">Class</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patcher</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.Class'</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MockClass</span> <span class="o">=</span> <span class="n">patcher</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">instance</span> <span class="o">=</span> <span class="n">MockClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">Original</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patcher</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-313">The <em>new_callable</em> argument is useful where you want to use an alternative class to the default <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> for the created mock. </span><span class="yiyi-st" id="yiyi-314">For example, if you wanted a <a class="reference internal" href="#unittest.mock.NonCallableMock" title="unittest.mock.NonCallableMock"><code class="xref py py-class docutils literal"><span class="pre">NonCallableMock</span></code></a> to be used:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thing</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.thing'</span><span class="p">,</span> <span class="n">new_callable</span><span class="o">=</span><span class="n">NonCallableMock</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_thing</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">thing</span> <span class="ow">is</span> <span class="n">mock_thing</span>
<span class="gp">... </span>    <span class="n">thing</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">'NonCallableMock' object is not callable</span>
</code></pre><p><span class="yiyi-st" id="yiyi-315">Another use case might be to replace an object with an <a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a> instance:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'Something'</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="p">(</span><span class="s1">'sys.stdout'</span><span class="p">,</span> <span class="n">new_callable</span><span class="o">=</span><span class="n">StringIO</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">mock_stdout</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">foo</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">mock_stdout</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'Something</span><span class="se">\n</span><span class="s1">'</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-316">When <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> is creating a mock for you, it is common that the first thing you need to do is to configure the mock. </span><span class="yiyi-st" id="yiyi-317">Some of that configuration can be done in the call to patch. </span><span class="yiyi-st" id="yiyi-318">Any arbitrary keywords you pass into the call will be used to set attributes on the created mock:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">patcher</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.thing'</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="s1">'one'</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="s1">'two'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_thing</span> <span class="o">=</span> <span class="n">patcher</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_thing</span><span class="o">.</span><span class="n">first</span>
<span class="go">'one'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_thing</span><span class="o">.</span><span class="n">second</span>
<span class="go">'two'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-319">As well as attributes on the created mock attributes, like the <a class="reference internal" href="#unittest.mock.Mock.return_value" title="unittest.mock.Mock.return_value"><code class="xref py py-attr docutils literal"><span class="pre">return_value</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a>, of child mocks can also be configured. </span><span class="yiyi-st" id="yiyi-320">These aren’t syntactically valid to pass in directly as keyword arguments, but a dictionary with these as keys can still be expanded into a <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> call using <code class="docutils literal"><span class="pre">**</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'method.return_value'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'other.side_effect'</span><span class="p">:</span> <span class="ne">KeyError</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patcher</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.thing'</span><span class="p">,</span> <span class="o">**</span><span class="n">config</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_thing</span> <span class="o">=</span> <span class="n">patcher</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_thing</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_thing</span><span class="o">.</span><span class="n">other</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">KeyError</span>
</code></pre></div><div class="section" id="patch-object"><h3><span class="yiyi-st" id="yiyi-321">26.5.3.2. patch.object</span></h3><dl class="function"><dt id="unittest.mock.patch.object"><span class="yiyi-st" id="yiyi-322"> <code class="descclassname">patch.</code><code class="descname">object</code><span class="sig-paren">(</span><em>target</em>, <em>attribute</em>, <em>new=DEFAULT</em>, <em>spec=None</em>, <em>create=False</em>, <em>spec_set=None</em>, <em>autospec=None</em>, <em>new_callable=None</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-323">patch the named member (<em>attribute</em>) on an object (<em>target</em>) with a mock object.</span></p><p><span class="yiyi-st" id="yiyi-324"><a class="reference internal" href="#unittest.mock.patch.object" title="unittest.mock.patch.object"><code class="xref py py-func docutils literal"><span class="pre">patch.object()</span></code></a> can be used as a decorator, class decorator or a context manager. </span><span class="yiyi-st" id="yiyi-325">Arguments <em>new</em>, <em>spec</em>, <em>create</em>, <em>spec_set</em>, <em>autospec</em> and <em>new_callable</em> have the same meaning as for <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>. </span><span class="yiyi-st" id="yiyi-326">Like <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>, <a class="reference internal" href="#unittest.mock.patch.object" title="unittest.mock.patch.object"><code class="xref py py-func docutils literal"><span class="pre">patch.object()</span></code></a> takes arbitrary keyword arguments for configuring the mock object it creates.</span></p><p><span class="yiyi-st" id="yiyi-327">When used as a class decorator <a class="reference internal" href="#unittest.mock.patch.object" title="unittest.mock.patch.object"><code class="xref py py-func docutils literal"><span class="pre">patch.object()</span></code></a> honours <code class="docutils literal"><span class="pre">patch.TEST_PREFIX</span></code> for choosing which methods to wrap.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-328">You can either call <a class="reference internal" href="#unittest.mock.patch.object" title="unittest.mock.patch.object"><code class="xref py py-func docutils literal"><span class="pre">patch.object()</span></code></a> with three arguments or two arguments. </span><span class="yiyi-st" id="yiyi-329">The three argument form takes the object to be patched, the attribute name and the object to replace the attribute with.</span></p><p><span class="yiyi-st" id="yiyi-330">When calling with the two argument form you omit the replacement object, and a mock is created for you and passed in as an extra argument to the decorated function:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">'class_method'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">mock_method</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">SomeClass</span><span class="o">.</span><span class="n">class_method</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">mock_method</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-331"><em>spec</em>, <em>create</em> and the other arguments to <a class="reference internal" href="#unittest.mock.patch.object" title="unittest.mock.patch.object"><code class="xref py py-func docutils literal"><span class="pre">patch.object()</span></code></a> have the same meaning as they do for <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>.</span></p></div><div class="section" id="patch-dict"><h3><span class="yiyi-st" id="yiyi-332">26.5.3.3. patch.dict</span></h3><dl class="function"><dt id="unittest.mock.patch.dict"><span class="yiyi-st" id="yiyi-333"> <code class="descclassname">patch.</code><code class="descname">dict</code><span class="sig-paren">(</span><em>in_dict</em>, <em>values=()</em>, <em>clear=False</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-334">Patch a dictionary, or dictionary like object, and restore the dictionary to its original state after the test.</span></p><p><span class="yiyi-st" id="yiyi-335"><em>in_dict</em> can be a dictionary or a mapping like container. </span><span class="yiyi-st" id="yiyi-336">If it is a mapping then it must at least support getting, setting and deleting items plus iterating over keys.</span></p><p><span class="yiyi-st" id="yiyi-337"><em>in_dict</em> can also be a string specifying the name of the dictionary, which will then be fetched by importing it.</span></p><p><span class="yiyi-st" id="yiyi-338"><em>values</em> can be a dictionary of values to set in the dictionary. </span><span class="yiyi-st" id="yiyi-339"><em>values</em> can also be an iterable of <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> pairs.</span></p><p><span class="yiyi-st" id="yiyi-340">If <em>clear</em> is true then the dictionary will be cleared before the new values are set.</span></p><p><span class="yiyi-st" id="yiyi-341"><a class="reference internal" href="#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal"><span class="pre">patch.dict()</span></code></a> can also be called with arbitrary keyword arguments to set values in the dictionary.</span></p><p><span class="yiyi-st" id="yiyi-342"><a class="reference internal" href="#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal"><span class="pre">patch.dict()</span></code></a> can be used as a context manager, decorator or class decorator. </span><span class="yiyi-st" id="yiyi-343">When used as a class decorator <a class="reference internal" href="#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal"><span class="pre">patch.dict()</span></code></a> honours <code class="docutils literal"><span class="pre">patch.TEST_PREFIX</span></code> for choosing which methods to wrap.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-344"><a class="reference internal" href="#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal"><span class="pre">patch.dict()</span></code></a> can be used to add members to a dictionary, or simply let a test change a dictionary, and ensure the dictionary is restored when the test ends.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="p">{</span><span class="s1">'newkey'</span><span class="p">:</span> <span class="s1">'newvalue'</span><span class="p">}):</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">foo</span> <span class="o">==</span> <span class="p">{</span><span class="s1">'newkey'</span><span class="p">:</span> <span class="s1">'newvalue'</span><span class="p">}</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">foo</span> <span class="o">==</span> <span class="p">{}</span>
</code></pre><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="s1">'os.environ'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'newkey'</span><span class="p">:</span> <span class="s1">'newvalue'</span><span class="p">}):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">'newkey'</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">newvalue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="s1">'newkey'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span>
</code></pre><p><span class="yiyi-st" id="yiyi-345">Keywords can be used in the <a class="reference internal" href="#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal"><span class="pre">patch.dict()</span></code></a> call to set values in the dictionary:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mymodule</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymodule</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s1">'fish'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="s1">'sys.modules'</span><span class="p">,</span> <span class="n">mymodule</span><span class="o">=</span><span class="n">mymodule</span><span class="p">):</span>
<span class="gp">... </span>    <span class="kn">import</span> <span class="nn">mymodule</span>
<span class="gp">... </span>    <span class="n">mymodule</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="s1">'some'</span><span class="p">,</span> <span class="s1">'args'</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">'fish'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-346"><a class="reference internal" href="#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal"><span class="pre">patch.dict()</span></code></a> can be used with dictionary like objects that aren’t actually dictionaries. </span><span class="yiyi-st" id="yiyi-347">At the very minimum they must support item getting, setting, deleting and either iteration or membership test. </span><span class="yiyi-st" id="yiyi-348">This corresponds to the magic methods <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal"><span class="pre">__delitem__()</span></code></a> and either <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> or <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a>.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Container</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thing</span> <span class="o">=</span> <span class="n">Container</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thing</span><span class="p">[</span><span class="s1">'one'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">one</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">thing</span><span class="p">[</span><span class="s1">'one'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">thing</span><span class="p">[</span><span class="s1">'two'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">thing</span><span class="p">[</span><span class="s1">'one'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">'one'</span><span class="p">]</span>
</code></pre></div><div class="section" id="patch-multiple"><h3><span class="yiyi-st" id="yiyi-349">26.5.3.4. patch.multiple</span></h3><dl class="function"><dt id="unittest.mock.patch.multiple"><span class="yiyi-st" id="yiyi-350"> <code class="descclassname">patch.</code><code class="descname">multiple</code><span class="sig-paren">(</span><em>target</em>, <em>spec=None</em>, <em>create=False</em>, <em>spec_set=None</em>, <em>autospec=None</em>, <em>new_callable=None</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-351">Perform multiple patches in a single call. </span><span class="yiyi-st" id="yiyi-352">It takes the object to be patched (either as an object or a string to fetch the object by importing) and keyword arguments for the patches:</span></p><pre><code class="language-python"><span></span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">multiple</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">FIRST_PATCH</span><span class="o">=</span><span class="s1">'one'</span><span class="p">,</span> <span class="n">SECOND_PATCH</span><span class="o">=</span><span class="s1">'two'</span><span class="p">):</span>
    <span class="o">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-353">Use <a class="reference internal" href="#unittest.mock.DEFAULT" title="unittest.mock.DEFAULT"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT</span></code></a> as the value if you want <a class="reference internal" href="#unittest.mock.patch.multiple" title="unittest.mock.patch.multiple"><code class="xref py py-func docutils literal"><span class="pre">patch.multiple()</span></code></a> to create mocks for you. </span><span class="yiyi-st" id="yiyi-354">In this case the created mocks are passed into a decorated function by keyword, and a dictionary is returned when <a class="reference internal" href="#unittest.mock.patch.multiple" title="unittest.mock.patch.multiple"><code class="xref py py-func docutils literal"><span class="pre">patch.multiple()</span></code></a> is used as a context manager.</span></p><p><span class="yiyi-st" id="yiyi-355"><a class="reference internal" href="#unittest.mock.patch.multiple" title="unittest.mock.patch.multiple"><code class="xref py py-func docutils literal"><span class="pre">patch.multiple()</span></code></a> can be used as a decorator, class decorator or a context manager. </span><span class="yiyi-st" id="yiyi-356">The arguments <em>spec</em>, <em>spec_set</em>, <em>create</em>, <em>autospec</em> and <em>new_callable</em> have the same meaning as for <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>. </span><span class="yiyi-st" id="yiyi-357">These arguments will be applied to <em>all</em> patches done by <a class="reference internal" href="#unittest.mock.patch.multiple" title="unittest.mock.patch.multiple"><code class="xref py py-func docutils literal"><span class="pre">patch.multiple()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-358">When used as a class decorator <a class="reference internal" href="#unittest.mock.patch.multiple" title="unittest.mock.patch.multiple"><code class="xref py py-func docutils literal"><span class="pre">patch.multiple()</span></code></a> honours <code class="docutils literal"><span class="pre">patch.TEST_PREFIX</span></code> for choosing which methods to wrap.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-359">If you want <a class="reference internal" href="#unittest.mock.patch.multiple" title="unittest.mock.patch.multiple"><code class="xref py py-func docutils literal"><span class="pre">patch.multiple()</span></code></a> to create mocks for you, then you can use <a class="reference internal" href="#unittest.mock.DEFAULT" title="unittest.mock.DEFAULT"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT</span></code></a> as the value. </span><span class="yiyi-st" id="yiyi-360">If you use <a class="reference internal" href="#unittest.mock.patch.multiple" title="unittest.mock.patch.multiple"><code class="xref py py-func docutils literal"><span class="pre">patch.multiple()</span></code></a> as a decorator then the created mocks are passed into the decorated function by keyword.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thing</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
</code></pre><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="o">.</span><span class="n">multiple</span><span class="p">(</span><span class="s1">'__main__'</span><span class="p">,</span> <span class="n">thing</span><span class="o">=</span><span class="n">DEFAULT</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">DEFAULT</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test_function</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">MagicMock</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MagicMock</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_function</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-361"><a class="reference internal" href="#unittest.mock.patch.multiple" title="unittest.mock.patch.multiple"><code class="xref py py-func docutils literal"><span class="pre">patch.multiple()</span></code></a> can be nested with other <code class="docutils literal"><span class="pre">patch</span></code> decorators, but put arguments passed by keyword <em>after</em> any of the standard arguments created by <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="p">(</span><span class="s1">'sys.exit'</span><span class="p">)</span>
<span class="gp">... </span><span class="nd">@patch</span><span class="o">.</span><span class="n">multiple</span><span class="p">(</span><span class="s1">'__main__'</span><span class="p">,</span> <span class="n">thing</span><span class="o">=</span><span class="n">DEFAULT</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">DEFAULT</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test_function</span><span class="p">(</span><span class="n">mock_exit</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">thing</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="s1">'other'</span> <span class="ow">in</span> <span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="s1">'thing'</span> <span class="ow">in</span> <span class="nb">repr</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="s1">'exit'</span> <span class="ow">in</span> <span class="nb">repr</span><span class="p">(</span><span class="n">mock_exit</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_function</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-362">If <a class="reference internal" href="#unittest.mock.patch.multiple" title="unittest.mock.patch.multiple"><code class="xref py py-func docutils literal"><span class="pre">patch.multiple()</span></code></a> is used as a context manager, the value returned by the context manger is a dictionary where created mocks are keyed by name:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">multiple</span><span class="p">(</span><span class="s1">'__main__'</span><span class="p">,</span> <span class="n">thing</span><span class="o">=</span><span class="n">DEFAULT</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">DEFAULT</span><span class="p">)</span> <span class="k">as</span> <span class="n">values</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="s1">'other'</span> <span class="ow">in</span> <span class="nb">repr</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s1">'other'</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="s1">'thing'</span> <span class="ow">in</span> <span class="nb">repr</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s1">'thing'</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">values</span><span class="p">[</span><span class="s1">'thing'</span><span class="p">]</span> <span class="ow">is</span> <span class="n">thing</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">values</span><span class="p">[</span><span class="s1">'other'</span><span class="p">]</span> <span class="ow">is</span> <span class="n">other</span>
<span class="gp">...</span>
</code></pre></div><div class="section" id="patch-methods-start-and-stop"><h3><span class="yiyi-st" id="yiyi-363">26.5.3.5. patch methods: start and stop</span></h3><p><span class="yiyi-st" id="yiyi-364">All the patchers have <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code> methods. </span><span class="yiyi-st" id="yiyi-365">These make it simpler to do patching in <code class="docutils literal"><span class="pre">setUp</span></code> methods or where you want to do multiple patches without nesting decorators or with statements.</span></p><p><span class="yiyi-st" id="yiyi-366">To use them call <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>, <a class="reference internal" href="#unittest.mock.patch.object" title="unittest.mock.patch.object"><code class="xref py py-func docutils literal"><span class="pre">patch.object()</span></code></a> or <a class="reference internal" href="#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal"><span class="pre">patch.dict()</span></code></a> as normal and keep a reference to the returned <code class="docutils literal"><span class="pre">patcher</span></code> object. </span><span class="yiyi-st" id="yiyi-367">You can then call <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code> to put the patch in place and <code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code> to undo it.</span></p><p><span class="yiyi-st" id="yiyi-368">If you are using <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> to create a mock for you then it will be returned by the call to <code class="docutils literal"><span class="pre">patcher.start</span></code>.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">patcher</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'package.module.ClassName'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">package</span> <span class="k">import</span> <span class="n">module</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">ClassName</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_mock</span> <span class="o">=</span> <span class="n">patcher</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">module</span><span class="o">.</span><span class="n">ClassName</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">original</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">module</span><span class="o">.</span><span class="n">ClassName</span> <span class="ow">is</span> <span class="n">new_mock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patcher</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">module</span><span class="o">.</span><span class="n">ClassName</span> <span class="ow">is</span> <span class="n">original</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">module</span><span class="o">.</span><span class="n">ClassName</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">new_mock</span>
</code></pre><p><span class="yiyi-st" id="yiyi-369">A typical use case for this might be for doing multiple patches in the <code class="docutils literal"><span class="pre">setUp</span></code> method of a <code class="xref py py-class docutils literal"><span class="pre">TestCase</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">patcher1</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'package.module.Class1'</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">patcher2</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'package.module.Class2'</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">MockClass1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">patcher1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">MockClass2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">patcher2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">patcher1</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">patcher2</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_something</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="n">package</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">Class1</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">MockClass1</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="n">package</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">Class2</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">MockClass2</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">'test_something'</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre><div class="admonition caution"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-370">Caution</span></p><p><span class="yiyi-st" id="yiyi-371">If you use this technique you must ensure that the patching is “undone” by calling <code class="docutils literal"><span class="pre">stop</span></code>. </span><span class="yiyi-st" id="yiyi-372">This can be fiddlier than you might think, because if an exception is raised in the <code class="docutils literal"><span class="pre">setUp</span></code> then <code class="docutils literal"><span class="pre">tearDown</span></code> is not called. </span><span class="yiyi-st" id="yiyi-373"><a class="reference internal" href="unittest.html#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal"><span class="pre">unittest.TestCase.addCleanup()</span></code></a> makes this easier:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">patcher</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'package.module.Class'</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">MockClass</span> <span class="o">=</span> <span class="n">patcher</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">addCleanup</span><span class="p">(</span><span class="n">patcher</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_something</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="n">package</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">Class</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">MockClass</span>
<span class="gp">...</span>
</code></pre><p class="last"><span class="yiyi-st" id="yiyi-374">As an added bonus you no longer need to keep a reference to the <code class="docutils literal"><span class="pre">patcher</span></code> object.</span></p></div><p><span class="yiyi-st" id="yiyi-375">It is also possible to stop all patches which have been started by using <a class="reference internal" href="#unittest.mock.patch.stopall" title="unittest.mock.patch.stopall"><code class="xref py py-func docutils literal"><span class="pre">patch.stopall()</span></code></a>.</span></p><dl class="function"><dt id="unittest.mock.patch.stopall"><span class="yiyi-st" id="yiyi-376"> <code class="descclassname">patch.</code><code class="descname">stopall</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-377">Stop all active patches. </span><span class="yiyi-st" id="yiyi-378">Only stops patches started with <code class="docutils literal"><span class="pre">start</span></code>.</span></p></dd></dl></div><div class="section" id="patch-builtins"><h3><span class="yiyi-st" id="yiyi-379">26.5.3.6. patch builtins</span></h3><p><span class="yiyi-st" id="yiyi-380">You can patch any builtins within a module. </span><span class="yiyi-st" id="yiyi-381">The following example patches builtin <a class="reference internal" href="functions.html#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="p">(</span><span class="s1">'__main__.ord'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">mock_ord</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mock_ord</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="mi">101</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">'c'</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">()</span>
<span class="go">101</span>
</code></pre></div><div class="section" id="test-prefix"><h3><span class="yiyi-st" id="yiyi-382">26.5.3.7. </span><span class="yiyi-st" id="yiyi-383">TEST_PREFIX</span></h3><p><span class="yiyi-st" id="yiyi-384">All of the patchers can be used as class decorators. </span><span class="yiyi-st" id="yiyi-385">When used in this way they wrap every test method on the class. </span><span class="yiyi-st" id="yiyi-386">The patchers recognise methods that start with <code class="docutils literal"><span class="pre">'test'</span></code> as being test methods. </span><span class="yiyi-st" id="yiyi-387">This is the same way that the <a class="reference internal" href="unittest.html#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal"><span class="pre">unittest.TestLoader</span></code></a> finds test methods by default.</span></p><p><span class="yiyi-st" id="yiyi-388">It is possible that you want to use a different prefix for your tests. </span><span class="yiyi-st" id="yiyi-389">You can inform the patchers of the different prefix by setting <code class="docutils literal"><span class="pre">patch.TEST_PREFIX</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">patch</span><span class="o">.</span><span class="n">TEST_PREFIX</span> <span class="o">=</span> <span class="s1">'foo'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="p">(</span><span class="s1">'__main__.value'</span><span class="p">,</span> <span class="s1">'not three'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">Thing</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">foo_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">foo_two</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Thing</span><span class="p">()</span><span class="o">.</span><span class="n">foo_one</span><span class="p">()</span>
<span class="go">not three</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Thing</span><span class="p">()</span><span class="o">.</span><span class="n">foo_two</span><span class="p">()</span>
<span class="go">not three</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span>
<span class="go">3</span>
</code></pre></div><div class="section" id="nesting-patch-decorators"><h3><span class="yiyi-st" id="yiyi-390">26.5.3.8. </span><span class="yiyi-st" id="yiyi-391">Nesting Patch Decorators</span></h3><p><span class="yiyi-st" id="yiyi-392">If you want to perform multiple patches then you can simply stack up the decorators.</span></p><p><span class="yiyi-st" id="yiyi-393">You can stack up multiple patch decorators using this pattern:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">'class_method'</span><span class="p">)</span>
<span class="gp">... </span><span class="nd">@patch</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">'static_method'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">mock1</span><span class="p">,</span> <span class="n">mock2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">SomeClass</span><span class="o">.</span><span class="n">static_method</span> <span class="ow">is</span> <span class="n">mock1</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">SomeClass</span><span class="o">.</span><span class="n">class_method</span> <span class="ow">is</span> <span class="n">mock2</span>
<span class="gp">... </span>    <span class="n">SomeClass</span><span class="o">.</span><span class="n">static_method</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">SomeClass</span><span class="o">.</span><span class="n">class_method</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">mock1</span><span class="p">,</span> <span class="n">mock2</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock1</span><span class="p">,</span> <span class="n">mock2</span> <span class="o">=</span> <span class="n">test</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock1</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock2</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-394">Note that the decorators are applied from the bottom upwards. </span><span class="yiyi-st" id="yiyi-395">This is the standard way that Python applies decorators. </span><span class="yiyi-st" id="yiyi-396">The order of the created mocks passed into your test function matches this order.</span></p></div><div class="section" id="where-to-patch"><h3><span class="yiyi-st" id="yiyi-397">26.5.3.9. </span><span class="yiyi-st" id="yiyi-398">Where to patch</span></h3><p><span class="yiyi-st" id="yiyi-399"><a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> works by (temporarily) changing the object that a <em>name</em> points to with another one. </span><span class="yiyi-st" id="yiyi-400">There can be many names pointing to any individual object, so for patching to work you must ensure that you patch the name used by the system under test.</span></p><p><span class="yiyi-st" id="yiyi-401">The basic principle is that you patch where an object is <em>looked up</em>, which is not necessarily the same place as where it is defined. </span><span class="yiyi-st" id="yiyi-402">A couple of examples will help to clarify this.</span></p><p><span class="yiyi-st" id="yiyi-403">Imagine we have a project that we want to test with the following structure:</span></p><pre><code class="language-python"><span></span><span class="n">a</span><span class="o">.</span><span class="n">py</span>
    <span class="o">-&gt;</span> <span class="n">Defines</span> <span class="n">SomeClass</span>

<span class="n">b</span><span class="o">.</span><span class="n">py</span>
    <span class="o">-&gt;</span> <span class="kn">from</span> <span class="nn">a</span> <span class="k">import</span> <span class="n">SomeClass</span>
    <span class="o">-&gt;</span> <span class="n">some_function</span> <span class="n">instantiates</span> <span class="n">SomeClass</span>
</code></pre><p><span class="yiyi-st" id="yiyi-404">Now we want to test <code class="docutils literal"><span class="pre">some_function</span></code> but we want to mock out <code class="docutils literal"><span class="pre">SomeClass</span></code> using <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>. </span><span class="yiyi-st" id="yiyi-405">The problem is that when we import module b, which we will have to do then it imports <code class="docutils literal"><span class="pre">SomeClass</span></code> from module a. </span><span class="yiyi-st" id="yiyi-406">If we use <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> to mock out <code class="docutils literal"><span class="pre">a.SomeClass</span></code> then it will have no effect on our test; module b already has a reference to the <em>real</em> <code class="docutils literal"><span class="pre">SomeClass</span></code> and it looks like our patching had no effect.</span></p><p><span class="yiyi-st" id="yiyi-407">The key is to patch out <code class="docutils literal"><span class="pre">SomeClass</span></code> where it is used (or where it is looked up ). </span><span class="yiyi-st" id="yiyi-408">In this case <code class="docutils literal"><span class="pre">some_function</span></code> will actually look up <code class="docutils literal"><span class="pre">SomeClass</span></code> in module b, where we have imported it. </span><span class="yiyi-st" id="yiyi-409">The patching should look like:</span></p><pre><code class="language-python"><span></span><span class="nd">@patch</span><span class="p">(</span><span class="s1">'b.SomeClass'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-410">However, consider the alternative scenario where instead of <code class="docutils literal"><span class="pre">from</span> <span class="pre">a</span> <span class="pre">import</span> <span class="pre">SomeClass</span></code> module b does <code class="docutils literal"><span class="pre">import</span> <span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">some_function</span></code> uses <code class="docutils literal"><span class="pre">a.SomeClass</span></code>. </span><span class="yiyi-st" id="yiyi-411">Both of these import forms are common. </span><span class="yiyi-st" id="yiyi-412">In this case the class we want to patch is being looked up in the module and so we have to patch <code class="docutils literal"><span class="pre">a.SomeClass</span></code> instead:</span></p><pre><code class="language-python"><span></span><span class="nd">@patch</span><span class="p">(</span><span class="s1">'a.SomeClass'</span><span class="p">)</span>
</code></pre></div><div class="section" id="patching-descriptors-and-proxy-objects"><h3><span class="yiyi-st" id="yiyi-413">26.5.3.10. </span><span class="yiyi-st" id="yiyi-414">Patching Descriptors and Proxy Objects</span></h3><p><span class="yiyi-st" id="yiyi-415">Both <a class="reference internal" href="#patch">patch</a> and <a class="reference internal" href="#patch-object">patch.object</a> correctly patch and restore descriptors: class methods, static methods and properties. </span><span class="yiyi-st" id="yiyi-416">You should patch these on the <em>class</em> rather than an instance. </span><span class="yiyi-st" id="yiyi-417">They also work with <em>some</em> objects that proxy attribute access, like the <a class="reference external" href="http://www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198">django settings object</a>.</span></p></div></div><div class="section" id="magicmock-and-magic-method-support"><h2><span class="yiyi-st" id="yiyi-418">26.5.4. </span><span class="yiyi-st" id="yiyi-419">MagicMock and magic method support</span></h2><div class="section" id="mocking-magic-methods"><h3><span class="yiyi-st" id="yiyi-420">26.5.4.1. </span><span class="yiyi-st" id="yiyi-421">Mocking Magic Methods</span></h3><p><span class="yiyi-st" id="yiyi-422"><a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> supports mocking the Python protocol methods, also known as “magic methods”. </span><span class="yiyi-st" id="yiyi-423">This allows mock objects to replace containers or other objects that implement Python protocols.</span></p><p><span class="yiyi-st" id="yiyi-424">Because magic methods are looked up differently from normal methods <a class="footnote-reference" href="#id8" id="id6">[2]</a>, this support has been specially implemented. </span><span class="yiyi-st" id="yiyi-425">This means that only specific magic methods are supported. </span><span class="yiyi-st" id="yiyi-426">The supported list includes <em>almost</em> all of them. </span><span class="yiyi-st" id="yiyi-427">If there are any missing that you need please let us know.</span></p><p><span class="yiyi-st" id="yiyi-428">You mock magic methods by setting the method you are interested in to a function or a mock instance. </span><span class="yiyi-st" id="yiyi-429">If you are using a function then it <em>must</em> take <code class="docutils literal"><span class="pre">self</span></code> as the first argument <a class="footnote-reference" href="#id9" id="id7">[3]</a>.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s1">'fooble'</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__str__</span> <span class="o">=</span> <span class="n">__str__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">'fooble'</span>
</code></pre><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__str__</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__str__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s1">'fooble'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">'fooble'</span>
</code></pre><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__iter__</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="nb">iter</span><span class="p">([]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">[]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-430">One use case for this is for mocking objects used as context managers in a <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__enter__</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__exit__</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mock</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">'foo'</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__enter__</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__exit__</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-431">Calls to magic methods do not appear in <a class="reference internal" href="#unittest.mock.Mock.method_calls" title="unittest.mock.Mock.method_calls"><code class="xref py py-attr docutils literal"><span class="pre">method_calls</span></code></a>, but they are recorded in <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a>.</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-432">Note</span></p><p class="last"><span class="yiyi-st" id="yiyi-433">If you use the <em>spec</em> keyword argument to create a mock then attempting to set a magic method that isn’t in the spec will raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>.</span></p></div><p><span class="yiyi-st" id="yiyi-434">The full list of supported magic methods is:</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-435"><code class="docutils literal"><span class="pre">__hash__</span></code>, <code class="docutils literal"><span class="pre">__sizeof__</span></code>, <code class="docutils literal"><span class="pre">__repr__</span></code> and <code class="docutils literal"><span class="pre">__str__</span></code></span></li><li><span class="yiyi-st" id="yiyi-436"><code class="docutils literal"><span class="pre">__dir__</span></code>, <code class="docutils literal"><span class="pre">__format__</span></code> and <code class="docutils literal"><span class="pre">__subclasses__</span></code></span></li><li><span class="yiyi-st" id="yiyi-437"><code class="docutils literal"><span class="pre">__floor__</span></code>, <code class="docutils literal"><span class="pre">__trunc__</span></code> and <code class="docutils literal"><span class="pre">__ceil__</span></code></span></li><li><span class="yiyi-st" id="yiyi-438">Comparisons: <code class="docutils literal"><span class="pre">__lt__</span></code>, <code class="docutils literal"><span class="pre">__gt__</span></code>, <code class="docutils literal"><span class="pre">__le__</span></code>, <code class="docutils literal"><span class="pre">__ge__</span></code>, <code class="docutils literal"><span class="pre">__eq__</span></code> and <code class="docutils literal"><span class="pre">__ne__</span></code></span></li><li><span class="yiyi-st" id="yiyi-439">Container methods: <code class="docutils literal"><span class="pre">__getitem__</span></code>, <code class="docutils literal"><span class="pre">__setitem__</span></code>, <code class="docutils literal"><span class="pre">__delitem__</span></code>, <code class="docutils literal"><span class="pre">__contains__</span></code>, <code class="docutils literal"><span class="pre">__len__</span></code>, <code class="docutils literal"><span class="pre">__iter__</span></code>, <code class="docutils literal"><span class="pre">__reversed__</span></code> and <code class="docutils literal"><span class="pre">__missing__</span></code></span></li><li><span class="yiyi-st" id="yiyi-440">Context manager: <code class="docutils literal"><span class="pre">__enter__</span></code> and <code class="docutils literal"><span class="pre">__exit__</span></code></span></li><li><span class="yiyi-st" id="yiyi-441">Unary numeric methods: <code class="docutils literal"><span class="pre">__neg__</span></code>, <code class="docutils literal"><span class="pre">__pos__</span></code> and <code class="docutils literal"><span class="pre">__invert__</span></code></span></li><li><span class="yiyi-st" id="yiyi-442">The numeric methods (including right hand and in-place variants): <code class="docutils literal"><span class="pre">__add__</span></code>, <code class="docutils literal"><span class="pre">__sub__</span></code>, <code class="docutils literal"><span class="pre">__mul__</span></code>, <code class="docutils literal"><span class="pre">__matmul__</span></code>, <code class="docutils literal"><span class="pre">__div__</span></code>, <code class="docutils literal"><span class="pre">__truediv__</span></code>, <code class="docutils literal"><span class="pre">__floordiv__</span></code>, <code class="docutils literal"><span class="pre">__mod__</span></code>, <code class="docutils literal"><span class="pre">__divmod__</span></code>, <code class="docutils literal"><span class="pre">__lshift__</span></code>, <code class="docutils literal"><span class="pre">__rshift__</span></code>, <code class="docutils literal"><span class="pre">__and__</span></code>, <code class="docutils literal"><span class="pre">__xor__</span></code>, <code class="docutils literal"><span class="pre">__or__</span></code>, and <code class="docutils literal"><span class="pre">__pow__</span></code></span></li><li><span class="yiyi-st" id="yiyi-443">Numeric conversion methods: <code class="docutils literal"><span class="pre">__complex__</span></code>, <code class="docutils literal"><span class="pre">__int__</span></code>, <code class="docutils literal"><span class="pre">__float__</span></code> and <code class="docutils literal"><span class="pre">__index__</span></code></span></li><li><span class="yiyi-st" id="yiyi-444">Descriptor methods: <code class="docutils literal"><span class="pre">__get__</span></code>, <code class="docutils literal"><span class="pre">__set__</span></code> and <code class="docutils literal"><span class="pre">__delete__</span></code></span></li><li><span class="yiyi-st" id="yiyi-445">Pickling: <code class="docutils literal"><span class="pre">__reduce__</span></code>, <code class="docutils literal"><span class="pre">__reduce_ex__</span></code>, <code class="docutils literal"><span class="pre">__getinitargs__</span></code>, <code class="docutils literal"><span class="pre">__getnewargs__</span></code>, <code class="docutils literal"><span class="pre">__getstate__</span></code> and <code class="docutils literal"><span class="pre">__setstate__</span></code></span></li></ul><p><span class="yiyi-st" id="yiyi-446">The following methods exist but are <em>not</em> supported as they are either in use by mock, can’t be set dynamically, or can cause problems:</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-447"><code class="docutils literal"><span class="pre">__getattr__</span></code>, <code class="docutils literal"><span class="pre">__setattr__</span></code>, <code class="docutils literal"><span class="pre">__init__</span></code> and <code class="docutils literal"><span class="pre">__new__</span></code></span></li><li><span class="yiyi-st" id="yiyi-448"><code class="docutils literal"><span class="pre">__prepare__</span></code>, <code class="docutils literal"><span class="pre">__instancecheck__</span></code>, <code class="docutils literal"><span class="pre">__subclasscheck__</span></code>, <code class="docutils literal"><span class="pre">__del__</span></code></span></li></ul></div><div class="section" id="magic-mock"><h3><span class="yiyi-st" id="yiyi-449">26.5.4.2. </span><span class="yiyi-st" id="yiyi-450">Magic Mock</span></h3><p><span class="yiyi-st" id="yiyi-451">There are two <code class="docutils literal"><span class="pre">MagicMock</span></code> variants: <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> and <a class="reference internal" href="#unittest.mock.NonCallableMagicMock" title="unittest.mock.NonCallableMagicMock"><code class="xref py py-class docutils literal"><span class="pre">NonCallableMagicMock</span></code></a>.</span></p><dl class="class"><dt id="unittest.mock.MagicMock"><span class="yiyi-st" id="yiyi-452"> <em class="property">class </em><code class="descclassname">unittest.mock.</code><code class="descname">MagicMock</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-453"><code class="docutils literal"><span class="pre">MagicMock</span></code> is a subclass of <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> with default implementations of most of the magic methods. </span><span class="yiyi-st" id="yiyi-454">You can use <code class="docutils literal"><span class="pre">MagicMock</span></code> without having to configure the magic methods yourself.</span></p><p><span class="yiyi-st" id="yiyi-455">The constructor parameters have the same meaning as for <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-456">If you use the <em>spec</em> or <em>spec_set</em> arguments then <em>only</em> magic methods that exist in the spec will be created.</span></p></dd></dl><dl class="class"><dt id="unittest.mock.NonCallableMagicMock"><span class="yiyi-st" id="yiyi-457"> <em class="property">class </em><code class="descclassname">unittest.mock.</code><code class="descname">NonCallableMagicMock</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-458">A non-callable version of <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-459">The constructor parameters have the same meaning as for <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a>, with the exception of <em>return_value</em> and <em>side_effect</em> which have no meaning on a non-callable mock.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-460">The magic methods are setup with <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> objects, so you can configure them and use them in the usual way:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'fish'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__setitem__</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'fish'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__getitem__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s1">'result'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">'result'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-461">By default many of the protocol methods are required to return objects of a specific type. </span><span class="yiyi-st" id="yiyi-462">These methods are preconfigured with a default return value, so that they can be used without you having to do anything if you aren’t interested in the return value. </span><span class="yiyi-st" id="yiyi-463">You can still <em>set</em> the return value manually if you want to change the default.</span></p><p><span class="yiyi-st" id="yiyi-464">Methods and their defaults:</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-465"><code class="docutils literal"><span class="pre">__lt__</span></code>: NotImplemented</span></li><li><span class="yiyi-st" id="yiyi-466"><code class="docutils literal"><span class="pre">__gt__</span></code>: NotImplemented</span></li><li><span class="yiyi-st" id="yiyi-467"><code class="docutils literal"><span class="pre">__le__</span></code>: NotImplemented</span></li><li><span class="yiyi-st" id="yiyi-468"><code class="docutils literal"><span class="pre">__ge__</span></code>: NotImplemented</span></li><li><span class="yiyi-st" id="yiyi-469"><code class="docutils literal"><span class="pre">__int__</span></code>: 1</span></li><li><span class="yiyi-st" id="yiyi-470"><code class="docutils literal"><span class="pre">__contains__</span></code>: False</span></li><li><span class="yiyi-st" id="yiyi-471"><code class="docutils literal"><span class="pre">__len__</span></code>: 0</span></li><li><span class="yiyi-st" id="yiyi-472"><code class="docutils literal"><span class="pre">__iter__</span></code>: iter([])</span></li><li><span class="yiyi-st" id="yiyi-473"><code class="docutils literal"><span class="pre">__exit__</span></code>: False</span></li><li><span class="yiyi-st" id="yiyi-474"><code class="docutils literal"><span class="pre">__complex__</span></code>: 1j</span></li><li><span class="yiyi-st" id="yiyi-475"><code class="docutils literal"><span class="pre">__float__</span></code>: 1.0</span></li><li><span class="yiyi-st" id="yiyi-476"><code class="docutils literal"><span class="pre">__bool__</span></code>: True</span></li><li><span class="yiyi-st" id="yiyi-477"><code class="docutils literal"><span class="pre">__index__</span></code>: 1</span></li><li><span class="yiyi-st" id="yiyi-478"><code class="docutils literal"><span class="pre">__hash__</span></code>: default hash for the mock</span></li><li><span class="yiyi-st" id="yiyi-479"><code class="docutils literal"><span class="pre">__str__</span></code>: default str for the mock</span></li><li><span class="yiyi-st" id="yiyi-480"><code class="docutils literal"><span class="pre">__sizeof__</span></code>: default sizeof for the mock</span></li></ul><p><span class="yiyi-st" id="yiyi-481">For example:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">object</span><span class="p">()</span> <span class="ow">in</span> <span class="n">mock</span>
<span class="go">False</span>
</code></pre><p><span class="yiyi-st" id="yiyi-482">The two equality methods, <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal"><span class="pre">__ne__()</span></code></a>, are special. </span><span class="yiyi-st" id="yiyi-483">They do the default equality comparison on identity, using the <a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a> attribute, unless you change their return value to return something else:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MagicMock</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MagicMock</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__eq__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">==</span> <span class="mi">3</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-484">The return value of <code class="xref py py-meth docutils literal"><span class="pre">MagicMock.__iter__()</span></code> can be any iterable object and isn’t required to be an iterator:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__iter__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">['a', 'b', 'c']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">['a', 'b', 'c']</span>
</code></pre><p><span class="yiyi-st" id="yiyi-485">If the return value <em>is</em> an iterator, then iterating over it once will consume it and subsequent iterations will result in an empty list:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">__iter__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">['a', 'b', 'c']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="go">[]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-486"><code class="docutils literal"><span class="pre">MagicMock</span></code> has all of the supported magic methods configured except for some of the obscure and obsolete ones. </span><span class="yiyi-st" id="yiyi-487">You can still set these up if you want.</span></p><p><span class="yiyi-st" id="yiyi-488">Magic methods that are supported but not setup by default in <code class="docutils literal"><span class="pre">MagicMock</span></code> are:</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-489"><code class="docutils literal"><span class="pre">__subclasses__</span></code></span></li><li><span class="yiyi-st" id="yiyi-490"><code class="docutils literal"><span class="pre">__dir__</span></code></span></li><li><span class="yiyi-st" id="yiyi-491"><code class="docutils literal"><span class="pre">__format__</span></code></span></li><li><span class="yiyi-st" id="yiyi-492"><code class="docutils literal"><span class="pre">__get__</span></code>, <code class="docutils literal"><span class="pre">__set__</span></code> and <code class="docutils literal"><span class="pre">__delete__</span></code></span></li><li><span class="yiyi-st" id="yiyi-493"><code class="docutils literal"><span class="pre">__reversed__</span></code> and <code class="docutils literal"><span class="pre">__missing__</span></code></span></li><li><span class="yiyi-st" id="yiyi-494"><code class="docutils literal"><span class="pre">__reduce__</span></code>, <code class="docutils literal"><span class="pre">__reduce_ex__</span></code>, <code class="docutils literal"><span class="pre">__getinitargs__</span></code>, <code class="docutils literal"><span class="pre">__getnewargs__</span></code>, <code class="docutils literal"><span class="pre">__getstate__</span></code> and <code class="docutils literal"><span class="pre">__setstate__</span></code></span></li><li><span class="yiyi-st" id="yiyi-495"><code class="docutils literal"><span class="pre">__getformat__</span></code> and <code class="docutils literal"><span class="pre">__setformat__</span></code></span></li></ul><table class="docutils footnote" frame="void" id="id8" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-496"><a class="fn-backref" href="#id6">[2]</a></span></td><td><span class="yiyi-st" id="yiyi-497">Magic methods <em>should</em> be looked up on the class rather than the instance. </span><span class="yiyi-st" id="yiyi-498">Different versions of Python are inconsistent about applying this rule. </span><span class="yiyi-st" id="yiyi-499">The supported protocol methods should work with all supported versions of Python.</span></td></tr></tbody></table><table class="docutils footnote" frame="void" id="id9" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-500"><a class="fn-backref" href="#id7">[3]</a></span></td><td><span class="yiyi-st" id="yiyi-501">The function is basically hooked up to the class, but each <code class="docutils literal"><span class="pre">Mock</span></code> instance is kept isolated from the others.</span></td></tr></tbody></table></div></div><div class="section" id="helpers"><h2><span class="yiyi-st" id="yiyi-502">26.5.5. </span><span class="yiyi-st" id="yiyi-503">Helpers</span></h2><div class="section" id="sentinel"><h3><span class="yiyi-st" id="yiyi-504">26.5.5.1. sentinel</span></h3><dl class="data"><dt id="unittest.mock.sentinel"><span class="yiyi-st" id="yiyi-505"> <code class="descclassname">unittest.mock.</code><code class="descname">sentinel</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-506">The <code class="docutils literal"><span class="pre">sentinel</span></code> object provides a convenient way of providing unique objects for your tests.</span></p><p><span class="yiyi-st" id="yiyi-507">Attributes are created on demand when you access them by name. </span><span class="yiyi-st" id="yiyi-508">Accessing the same attribute will always return the same object. </span><span class="yiyi-st" id="yiyi-509">The objects returned have a sensible repr so that test failure messages are readable.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-510">Sometimes when testing you need to test that a specific object is passed as an argument to another method, or returned. </span><span class="yiyi-st" id="yiyi-511">It can be common to create named sentinel objects to test this. </span><span class="yiyi-st" id="yiyi-512"><a class="reference internal" href="#unittest.mock.sentinel" title="unittest.mock.sentinel"><code class="xref py py-data docutils literal"><span class="pre">sentinel</span></code></a> provides a convenient way of creating and testing the identity of objects like this.</span></p><p><span class="yiyi-st" id="yiyi-513">In this example we monkey patch <code class="docutils literal"><span class="pre">method</span></code> to return <code class="docutils literal"><span class="pre">sentinel.some_object</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">ProductionClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">"method"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">some_object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">real</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">some_object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sentinel</span><span class="o">.</span><span class="n">some_object</span>
<span class="go">sentinel.some_object</span>
</code></pre></div><div class="section" id="default"><h3><span class="yiyi-st" id="yiyi-514">26.5.5.2. </span><span class="yiyi-st" id="yiyi-515">DEFAULT</span></h3><dl class="data"><dt id="unittest.mock.DEFAULT"><span class="yiyi-st" id="yiyi-516"> <code class="descclassname">unittest.mock.</code><code class="descname">DEFAULT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-517">The <a class="reference internal" href="#unittest.mock.DEFAULT" title="unittest.mock.DEFAULT"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT</span></code></a> object is a pre-created sentinel (actually <code class="docutils literal"><span class="pre">sentinel.DEFAULT</span></code>). </span><span class="yiyi-st" id="yiyi-518">It can be used by <a class="reference internal" href="#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal"><span class="pre">side_effect</span></code></a> functions to indicate that the normal return value should be used.</span></p></dd></dl></div><div class="section" id="call"><h3><span class="yiyi-st" id="yiyi-519">26.5.5.3. call</span></h3><dl class="function"><dt id="unittest.mock.call"><span class="yiyi-st" id="yiyi-520"> <code class="descclassname">unittest.mock.</code><code class="descname">call</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-521"><a class="reference internal" href="#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-func docutils literal"><span class="pre">call()</span></code></a> is a helper object for making simpler assertions, for comparing with <a class="reference internal" href="#unittest.mock.Mock.call_args" title="unittest.mock.Mock.call_args"><code class="xref py py-attr docutils literal"><span class="pre">call_args</span></code></a>, <a class="reference internal" href="#unittest.mock.Mock.call_args_list" title="unittest.mock.Mock.call_args_list"><code class="xref py py-attr docutils literal"><span class="pre">call_args_list</span></code></a>, <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.method_calls" title="unittest.mock.Mock.method_calls"><code class="xref py py-attr docutils literal"><span class="pre">method_calls</span></code></a>. </span><span class="yiyi-st" id="yiyi-522"><a class="reference internal" href="#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-func docutils literal"><span class="pre">call()</span></code></a> can also be used with <a class="reference internal" href="#unittest.mock.Mock.assert_has_calls" title="unittest.mock.Mock.assert_has_calls"><code class="xref py py-meth docutils literal"><span class="pre">assert_has_calls()</span></code></a>.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">call_args_list</span> <span class="o">==</span> <span class="p">[</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s1">'bar'</span><span class="p">),</span> <span class="n">call</span><span class="p">()]</span>
<span class="go">True</span>
</code></pre></dd></dl><dl class="method"><dt id="unittest.mock.call.call_list"><span class="yiyi-st" id="yiyi-523"> <code class="descclassname">call.</code><code class="descname">call_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-524">For a call object that represents multiple calls, <a class="reference internal" href="#unittest.mock.call.call_list" title="unittest.mock.call.call_list"><code class="xref py py-meth docutils literal"><span class="pre">call_list()</span></code></a> returns a list of all the intermediate calls as well as the final call.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-525"><code class="docutils literal"><span class="pre">call_list</span></code> is particularly useful for making assertions on “chained calls”. </span><span class="yiyi-st" id="yiyi-526">A chained call is multiple calls on a single line of code. </span><span class="yiyi-st" id="yiyi-527">This results in multiple entries in <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a> on a mock. </span><span class="yiyi-st" id="yiyi-528">Manually constructing the sequence of calls can be tedious.</span></p><p><span class="yiyi-st" id="yiyi-529"><a class="reference internal" href="#unittest.mock.call.call_list" title="unittest.mock.call.call_list"><code class="xref py py-meth docutils literal"><span class="pre">call_list()</span></code></a> can construct the sequence of calls from the same chained call:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="s1">'foo'</span><span class="p">)</span><span class="o">.</span><span class="n">other</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="go">&lt;MagicMock name='mock().method().other()()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kall</span> <span class="o">=</span> <span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="s1">'foo'</span><span class="p">)</span><span class="o">.</span><span class="n">other</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kall</span><span class="o">.</span><span class="n">call_list</span><span class="p">()</span>
<span class="go">[call(1),</span>
<span class="go"> call().method(arg='foo'),</span>
<span class="go"> call().method().other('bar'),</span>
<span class="go"> call().method().other()(2.0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">mock_calls</span> <span class="o">==</span> <span class="n">kall</span><span class="o">.</span><span class="n">call_list</span><span class="p">()</span>
<span class="go">True</span>
</code></pre><p id="calls-as-tuples"><span class="yiyi-st" id="yiyi-530">A <code class="docutils literal"><span class="pre">call</span></code> object is either a tuple of (positional args, keyword args) or (name, positional args, keyword args) depending on how it was constructed. </span><span class="yiyi-st" id="yiyi-531">When you construct them yourself this isn’t particularly interesting, but the <code class="docutils literal"><span class="pre">call</span></code> objects that are in the <a class="reference internal" href="#unittest.mock.Mock.call_args" title="unittest.mock.Mock.call_args"><code class="xref py py-attr docutils literal"><span class="pre">Mock.call_args</span></code></a>, <a class="reference internal" href="#unittest.mock.Mock.call_args_list" title="unittest.mock.Mock.call_args_list"><code class="xref py py-attr docutils literal"><span class="pre">Mock.call_args_list</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">Mock.mock_calls</span></code></a> attributes can be introspected to get at the individual arguments they contain.</span></p><p><span class="yiyi-st" id="yiyi-532">The <code class="docutils literal"><span class="pre">call</span></code> objects in <a class="reference internal" href="#unittest.mock.Mock.call_args" title="unittest.mock.Mock.call_args"><code class="xref py py-attr docutils literal"><span class="pre">Mock.call_args</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.call_args_list" title="unittest.mock.Mock.call_args_list"><code class="xref py py-attr docutils literal"><span class="pre">Mock.call_args_list</span></code></a> are two-tuples of (positional args, keyword args) whereas the <code class="docutils literal"><span class="pre">call</span></code> objects in <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">Mock.mock_calls</span></code></a>, along with ones you construct yourself, are three-tuples of (name, positional args, keyword args).</span></p><p><span class="yiyi-st" id="yiyi-533">You can use their “tupleness” to pull out the individual arguments for more complex introspection and assertions. </span><span class="yiyi-st" id="yiyi-534">The positional arguments are a tuple (an empty tuple if there are no positional arguments) and the keyword arguments are a dictionary:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="s1">'one'</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="s1">'two'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kall</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">call_args</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kall</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span>
<span class="go">(1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kwargs</span>
<span class="go">{'arg2': 'two', 'arg': 'one'}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="ow">is</span> <span class="n">kall</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kwargs</span> <span class="ow">is</span> <span class="n">kall</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</code></pre><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="s1">'two'</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="s1">'three'</span><span class="p">)</span>
<span class="go">&lt;MagicMock name='mock.foo()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kall</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">mock_calls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kall</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>
<span class="go">'foo'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span>
<span class="go">(4, 5, 6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kwargs</span>
<span class="go">{'arg2': 'three', 'arg': 'two'}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="ow">is</span> <span class="n">m</span><span class="o">.</span><span class="n">mock_calls</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
</code></pre></div><div class="section" id="create-autospec"><h3><span class="yiyi-st" id="yiyi-535">26.5.5.4. create_autospec</span></h3><dl class="function"><dt id="unittest.mock.create_autospec"><span class="yiyi-st" id="yiyi-536"> <code class="descclassname">unittest.mock.</code><code class="descname">create_autospec</code><span class="sig-paren">(</span><em>spec</em>, <em>spec_set=False</em>, <em>instance=False</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-537">Create a mock object using another object as a spec. </span><span class="yiyi-st" id="yiyi-538">Attributes on the mock will use the corresponding attribute on the <em>spec</em> object as their spec.</span></p><p><span class="yiyi-st" id="yiyi-539">Functions or methods being mocked will have their arguments checked to ensure that they are called with the correct signature.</span></p><p><span class="yiyi-st" id="yiyi-540">If <em>spec_set</em> is <code class="docutils literal"><span class="pre">True</span></code> then attempting to set attributes that don’t exist on the spec object will raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-541">If a class is used as a spec then the return value of the mock (the instance of the class) will have the same spec. </span><span class="yiyi-st" id="yiyi-542">You can use a class as the spec for an instance object by passing <code class="docutils literal"><span class="pre">instance=True</span></code>. </span><span class="yiyi-st" id="yiyi-543">The returned mock will only be callable if instances of the mock are callable.</span></p><p><span class="yiyi-st" id="yiyi-544"><a class="reference internal" href="#unittest.mock.create_autospec" title="unittest.mock.create_autospec"><code class="xref py py-func docutils literal"><span class="pre">create_autospec()</span></code></a> also takes arbitrary keyword arguments that are passed to the constructor of the created mock.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-545">See <a class="reference internal" href="#auto-speccing"><span>Autospeccing</span></a> for examples of how to use auto-speccing with <a class="reference internal" href="#unittest.mock.create_autospec" title="unittest.mock.create_autospec"><code class="xref py py-func docutils literal"><span class="pre">create_autospec()</span></code></a> and the <em>autospec</em> argument to <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a>.</span></p></div><div class="section" id="any"><h3><span class="yiyi-st" id="yiyi-546">26.5.5.5. </span><span class="yiyi-st" id="yiyi-547">ANY</span></h3><dl class="data"><dt id="unittest.mock.ANY"><span class="yiyi-st" id="yiyi-548"> <code class="descclassname">unittest.mock.</code><code class="descname">ANY</code></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-549">Sometimes you may need to make assertions about <em>some</em> of the arguments in a call to mock, but either not care about some of the arguments or want to pull them individually out of <a class="reference internal" href="#unittest.mock.Mock.call_args" title="unittest.mock.Mock.call_args"><code class="xref py py-attr docutils literal"><span class="pre">call_args</span></code></a> and make more complex assertions on them.</span></p><p><span class="yiyi-st" id="yiyi-550">To ignore certain arguments you can pass in objects that compare equal to <em>everything</em>. </span><span class="yiyi-st" id="yiyi-551">Calls to <a class="reference internal" href="#unittest.mock.Mock.assert_called_with" title="unittest.mock.Mock.assert_called_with"><code class="xref py py-meth docutils literal"><span class="pre">assert_called_with()</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.assert_called_once_with" title="unittest.mock.Mock.assert_called_once_with"><code class="xref py py-meth docutils literal"><span class="pre">assert_called_once_with()</span></code></a> will then succeed no matter what was passed in.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="nb">object</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="n">ANY</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-552"><a class="reference internal" href="#unittest.mock.ANY" title="unittest.mock.ANY"><code class="xref py py-data docutils literal"><span class="pre">ANY</span></code></a> can also be used in comparisons with call lists like <a class="reference internal" href="#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal"><span class="pre">mock_calls</span></code></a>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="nb">object</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">mock_calls</span> <span class="o">==</span> <span class="p">[</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">ANY</span><span class="p">]</span>
<span class="go">True</span>
</code></pre></div><div class="section" id="filter-dir"><h3><span class="yiyi-st" id="yiyi-553">26.5.5.6. </span><span class="yiyi-st" id="yiyi-554">FILTER_DIR</span></h3><dl class="data"><dt id="unittest.mock.FILTER_DIR"><span class="yiyi-st" id="yiyi-555"> <code class="descclassname">unittest.mock.</code><code class="descname">FILTER_DIR</code></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-556"><a class="reference internal" href="#unittest.mock.FILTER_DIR" title="unittest.mock.FILTER_DIR"><code class="xref py py-data docutils literal"><span class="pre">FILTER_DIR</span></code></a> is a module level variable that controls the way mock objects respond to <a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> (only for Python 2.6 or more recent). </span><span class="yiyi-st" id="yiyi-557">The default is <code class="docutils literal"><span class="pre">True</span></code>, which uses the filtering described below, to only show useful members. </span><span class="yiyi-st" id="yiyi-558">If you dislike this filtering, or need to switch it off for diagnostic purposes, then set <code class="docutils literal"><span class="pre">mock.FILTER_DIR</span> <span class="pre">=</span> <span class="pre">False</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-559">With filtering on, <code class="docutils literal"><span class="pre">dir(some_mock)</span></code> shows only useful attributes and will include any dynamically created attributes that wouldn’t normally be shown. </span><span class="yiyi-st" id="yiyi-560">If the mock was created with a <em>spec</em> (or <em>autospec</em> of course) then all the attributes from the original are shown, even if they haven’t been accessed yet:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">Mock</span><span class="p">())</span>
<span class="go">['assert_any_call',</span>
<span class="go"> 'assert_called_once_with',</span>
<span class="go"> 'assert_called_with',</span>
<span class="go"> 'assert_has_calls',</span>
<span class="go"> 'attach_mock',</span>
<span class="go"> ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib</span> <span class="k">import</span> <span class="n">request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">request</span><span class="p">))</span>
<span class="go">['AbstractBasicAuthHandler',</span>
<span class="go"> 'AbstractDigestAuthHandler',</span>
<span class="go"> 'AbstractHTTPHandler',</span>
<span class="go"> 'BaseHandler',</span>
<span class="go"> ...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-561">Many of the not-very-useful (private to <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> rather than the thing being mocked) underscore and double underscore prefixed attributes have been filtered from the result of calling <a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> on a <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a>. </span><span class="yiyi-st" id="yiyi-562">If you dislike this behaviour you can switch it off by setting the module level switch <a class="reference internal" href="#unittest.mock.FILTER_DIR" title="unittest.mock.FILTER_DIR"><code class="xref py py-data docutils literal"><span class="pre">FILTER_DIR</span></code></a>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest</span> <span class="k">import</span> <span class="n">mock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">FILTER_DIR</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">mock</span><span class="o">.</span><span class="n">Mock</span><span class="p">())</span>
<span class="go">['_NonCallableMock__get_return_value',</span>
<span class="go"> '_NonCallableMock__get_side_effect',</span>
<span class="go"> '_NonCallableMock__return_value_doc',</span>
<span class="go"> '_NonCallableMock__set_return_value',</span>
<span class="go"> '_NonCallableMock__set_side_effect',</span>
<span class="go"> '__call__',</span>
<span class="go"> '__class__',</span>
<span class="go"> ...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-563">Alternatively you can just use <code class="docutils literal"><span class="pre">vars(my_mock)</span></code> (instance members) and <code class="docutils literal"><span class="pre">dir(type(my_mock))</span></code> (type members) to bypass the filtering irrespective of <code class="xref py py-data docutils literal"><span class="pre">mock.FILTER_DIR</span></code>.</span></p></div><div class="section" id="mock-open"><h3><span class="yiyi-st" id="yiyi-564">26.5.5.7. mock_open</span></h3><dl class="function"><dt id="unittest.mock.mock_open"><span class="yiyi-st" id="yiyi-565"> <code class="descclassname">unittest.mock.</code><code class="descname">mock_open</code><span class="sig-paren">(</span><em>mock=None</em>, <em>read_data=None</em><span class="sig-paren">)</span></span></dt><dd><span class="yiyi-st" id="yiyi-569"><blockquote> <div><p>A helper function to create a mock to replace the use of <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>. It works for <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> called directly or used as a context manager.</p> <p>The <em>mock</em> argument is the mock object to configure. If <code class="docutils literal"><span class="pre">None</span></code> (the default) then a <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> will be created for you, with the API limited to methods or attributes available on standard file handles.</p> <p><em>read_data</em> is a string for the <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>, <a class="reference internal" href="io.html#io.IOBase.readline" title="io.IOBase.readline"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a>, and <a class="reference internal" href="io.html#io.IOBase.readlines" title="io.IOBase.readlines"><code class="xref py py-meth docutils literal"><span class="pre">readlines()</span></code></a> methods of the file handle to return. Calls to those methods will take data from <em>read_data</em> until it is depleted. The mock of these methods is pretty simplistic: every time the <em>mock</em> is called, the <em>read_data</em> is rewound to the start. If you need more control over the data that you are feeding to the tested code you will need to customize this mock for yourself. When that is insufficient, one of the in-memory filesystem packages on <a class="reference external" href="https://pypi.python.org/pypi">PyPI</a> can offer a realistic filesystem for testing.</p> </div></blockquote></span><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-566"><span class="versionmodified">Changed in version 3.4: </span>Added <a class="reference internal" href="io.html#io.IOBase.readline" title="io.IOBase.readline"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a> and <a class="reference internal" href="io.html#io.IOBase.readlines" title="io.IOBase.readlines"><code class="xref py py-meth docutils literal"><span class="pre">readlines()</span></code></a> support. </span><span class="yiyi-st" id="yiyi-567">The mock of <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> changed to consume <em>read_data</em> rather than returning it on each call.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-568"><span class="versionmodified">Changed in version 3.5: </span><em>read_data</em> is now reset on each call to the <em>mock</em>.</span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-570">Using <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> as a context manager is a great way to ensure your file handles are closed properly and is becoming common:</span></p><pre><code class="language-python"><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'/some/path'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'something'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-571">The issue is that even if you mock out the call to <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> it is the <em>returned object</em> that is used as a context manager (and has <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> called).</span></p><p><span class="yiyi-st" id="yiyi-572">Mocking context managers with a <a class="reference internal" href="#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal"><span class="pre">MagicMock</span></code></a> is common enough and fiddly enough that a helper function is useful.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">mock_open</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.open'</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">h</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">h</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'some stuff'</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call('foo', 'w'),</span>
<span class="go"> call().__enter__(),</span>
<span class="go"> call().write('some stuff'),</span>
<span class="go"> call().__exit__(None, None, None)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">handle</span> <span class="o">=</span> <span class="n">m</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s1">'some stuff'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-573">And for reading files:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.open'</span><span class="p">,</span> <span class="n">mock_open</span><span class="p">(</span><span class="n">read_data</span><span class="o">=</span><span class="s1">'bibble'</span><span class="p">))</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span> <span class="k">as</span> <span class="n">h</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">result</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="s1">'bibble'</span>
</code></pre></div><div class="section" id="autospeccing"><h3><span class="yiyi-st" id="yiyi-574">26.5.5.8. </span><span class="yiyi-st" id="yiyi-575">Autospeccing</span></h3><p><span class="yiyi-st" id="yiyi-576">Autospeccing is based on the existing <code class="xref py py-attr docutils literal"><span class="pre">spec</span></code> feature of mock. </span><span class="yiyi-st" id="yiyi-577">It limits the api of mocks to the api of an original object (the spec), but it is recursive (implemented lazily) so that attributes of mocks only have the same api as the attributes of the spec. </span><span class="yiyi-st" id="yiyi-578">In addition mocked functions / methods have the same call signature as the original so they raise a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> if they are called incorrectly.</span></p><p><span class="yiyi-st" id="yiyi-579">Before I explain how auto-speccing works, here’s why it is needed.</span></p><p><span class="yiyi-st" id="yiyi-580"><a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> is a very powerful and flexible object, but it suffers from two flaws when used to mock out objects from a system under test. </span><span class="yiyi-st" id="yiyi-581">One of these flaws is specific to the <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> api and the other is a more general problem with using mock objects.</span></p><p><span class="yiyi-st" id="yiyi-582">First the problem specific to <a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a>. </span><span class="yiyi-st" id="yiyi-583"><a class="reference internal" href="#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal"><span class="pre">Mock</span></code></a> has two assert methods that are extremely handy: <a class="reference internal" href="#unittest.mock.Mock.assert_called_with" title="unittest.mock.Mock.assert_called_with"><code class="xref py py-meth docutils literal"><span class="pre">assert_called_with()</span></code></a> and <a class="reference internal" href="#unittest.mock.Mock.assert_called_once_with" title="unittest.mock.Mock.assert_called_once_with"><code class="xref py py-meth docutils literal"><span class="pre">assert_called_once_with()</span></code></a>.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'Thing'</span><span class="p">,</span> <span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
 <span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">Expected 'mock' to be called once. Called 2 times.</span>
</code></pre><p><span class="yiyi-st" id="yiyi-584">Because mocks auto-create attributes on demand, and allow you to call them with arbitrary arguments, if you misspell one of these assert methods then your assertion is gone:</span></p><div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'Thing'</span><span class="p">,</span> <span class="n">return_value</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assret_called_once_with</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-585">Your tests can pass silently and incorrectly because of the typo.</span></p><p><span class="yiyi-st" id="yiyi-586">The second issue is more general to mocking. </span><span class="yiyi-st" id="yiyi-587">If you refactor some of your code, rename members and so on, any tests for code that is still using the <em>old api</em> but uses mocks instead of the real objects will still pass. </span><span class="yiyi-st" id="yiyi-588">This means your tests can all pass even though your code is broken.</span></p><p><span class="yiyi-st" id="yiyi-589">Note that this is another reason why you need integration tests as well as unit tests. </span><span class="yiyi-st" id="yiyi-590">Testing everything in isolation is all fine and dandy, but if you don’t test how your units are “wired together” there is still lots of room for bugs that tests might have caught.</span></p><p><span class="yiyi-st" id="yiyi-591"><code class="xref py py-mod docutils literal"><span class="pre">mock</span></code> already provides a feature to help with this, called speccing. </span><span class="yiyi-st" id="yiyi-592">If you use a class or instance as the <code class="xref py py-attr docutils literal"><span class="pre">spec</span></code> for a mock then you can only access attributes on the mock that exist on the real class:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib</span> <span class="k">import</span> <span class="n">request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assret_called_with</span>
<span class="gt">Traceback (most recent call last):</span>
 <span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">Mock object has no attribute 'assret_called_with'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-593">The spec only applies to the mock itself, so we still have the same issue with any methods on the mock:</span></p><div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">has_data</span><span class="p">()</span>
<span class="go">&lt;mock.Mock object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">has_data</span><span class="o">.</span><span class="n">assret_called_with</span><span class="p">()</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-594">Auto-speccing solves this problem. </span><span class="yiyi-st" id="yiyi-595">You can either pass <code class="docutils literal"><span class="pre">autospec=True</span></code> to <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> / <a class="reference internal" href="#unittest.mock.patch.object" title="unittest.mock.patch.object"><code class="xref py py-func docutils literal"><span class="pre">patch.object()</span></code></a> or use the <a class="reference internal" href="#unittest.mock.create_autospec" title="unittest.mock.create_autospec"><code class="xref py py-func docutils literal"><span class="pre">create_autospec()</span></code></a> function to create a mock with a spec. </span><span class="yiyi-st" id="yiyi-596">If you use the <code class="docutils literal"><span class="pre">autospec=True</span></code> argument to <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> then the object that is being replaced will be used as the spec object. </span><span class="yiyi-st" id="yiyi-597">Because the speccing is done “lazily” (the spec is created as attributes on the mock are accessed) you can use it with very complex or deeply nested objects (like modules that import modules that import modules) without a big performance hit.</span></p><p><span class="yiyi-st" id="yiyi-598">Here’s an example of it in use:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib</span> <span class="k">import</span> <span class="n">request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patcher</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.request'</span><span class="p">,</span> <span class="n">autospec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_request</span> <span class="o">=</span> <span class="n">patcher</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span> <span class="ow">is</span> <span class="n">mock_request</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_request</span><span class="o">.</span><span class="n">Request</span>
<span class="go">&lt;MagicMock name='request.Request' spec='Request' id='...'&gt;</span>
</code></pre><p><span class="yiyi-st" id="yiyi-599">You can see that <code class="xref py py-class docutils literal"><span class="pre">request.Request</span></code> has a spec. </span><span class="yiyi-st" id="yiyi-600"><code class="xref py py-class docutils literal"><span class="pre">request.Request</span></code> takes two arguments in the constructor (one of which is <em>self</em>). </span><span class="yiyi-st" id="yiyi-601">Here’s what happens if we try to call it incorrectly:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">req</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
 <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&lt;lambda&gt;() takes at least 2 arguments (1 given)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-602">The spec also applies to instantiated classes (i.e. </span><span class="yiyi-st" id="yiyi-603">the return value of specced mocks):</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">req</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span>
<span class="go">&lt;NonCallableMagicMock name='request.Request()' spec='Request' id='...'&gt;</span>
</code></pre><p><span class="yiyi-st" id="yiyi-604"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code> objects are not callable, so the return value of instantiating our mocked out <code class="xref py py-class docutils literal"><span class="pre">request.Request</span></code> is a non-callable mock. </span><span class="yiyi-st" id="yiyi-605">With the spec in place any typos in our asserts will raise the correct error:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">,</span> <span class="s1">'eggs'</span><span class="p">)</span>
<span class="go">&lt;MagicMock name='request.Request().add_header()' id='...'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="o">.</span><span class="n">assret_called_with</span>
<span class="gt">Traceback (most recent call last):</span>
 <span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">Mock object has no attribute 'assret_called_with'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">,</span> <span class="s1">'eggs'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-606">In many cases you will just be able to add <code class="docutils literal"><span class="pre">autospec=True</span></code> to your existing <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> calls and then be protected against bugs due to typos and api changes.</span></p><p><span class="yiyi-st" id="yiyi-607">As well as using <em>autospec</em> through <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> there is a <a class="reference internal" href="#unittest.mock.create_autospec" title="unittest.mock.create_autospec"><code class="xref py py-func docutils literal"><span class="pre">create_autospec()</span></code></a> for creating autospecced mocks directly:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib</span> <span class="k">import</span> <span class="n">request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_request</span> <span class="o">=</span> <span class="n">create_autospec</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">)</span>
<span class="go">&lt;NonCallableMagicMock name='mock.Request()' spec='Request' id='...'&gt;</span>
</code></pre><p><span class="yiyi-st" id="yiyi-608">This isn’t without caveats and limitations however, which is why it is not the default behaviour. </span><span class="yiyi-st" id="yiyi-609">In order to know what attributes are available on the spec object, autospec has to introspect (access attributes) the spec. </span><span class="yiyi-st" id="yiyi-610">As you traverse attributes on the mock a corresponding traversal of the original object is happening under the hood. </span><span class="yiyi-st" id="yiyi-611">If any of your specced objects have properties or descriptors that can trigger code execution then you may not be able to use autospec. </span><span class="yiyi-st" id="yiyi-612">On the other hand it is much better to design your objects so that introspection is safe <a class="footnote-reference" href="#id11" id="id10">[4]</a>.</span></p><p><span class="yiyi-st" id="yiyi-613">A more serious problem is that it is common for instance attributes to be created in the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> method and not to exist on the class at all. </span><span class="yiyi-st" id="yiyi-614"><em>autospec</em> can’t know about any dynamically created attributes and restricts the api to visible attributes.</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Something</span><span class="p">:</span>
<span class="gp">... </span>  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">33</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.Something'</span><span class="p">,</span> <span class="n">autospec</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>  <span class="n">thing</span> <span class="o">=</span> <span class="n">Something</span><span class="p">()</span>
<span class="gp">... </span>  <span class="n">thing</span><span class="o">.</span><span class="n">a</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">Mock object has no attribute 'a'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-615">There are a few different ways of resolving this problem. </span><span class="yiyi-st" id="yiyi-616">The easiest, but not necessarily the least annoying, way is to simply set the required attributes on the mock after creation. </span><span class="yiyi-st" id="yiyi-617">Just because <em>autospec</em> doesn’t allow you to fetch attributes that don’t exist on the spec it doesn’t prevent you setting them:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.Something'</span><span class="p">,</span> <span class="n">autospec</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>  <span class="n">thing</span> <span class="o">=</span> <span class="n">Something</span><span class="p">()</span>
<span class="gp">... </span>  <span class="n">thing</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">33</span>
<span class="gp">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-618">There is a more aggressive version of both <em>spec</em> and <em>autospec</em> that <em>does</em> prevent you setting non-existent attributes. </span><span class="yiyi-st" id="yiyi-619">This is useful if you want to ensure your code only <em>sets</em> valid attributes too, but obviously it prevents this particular scenario:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.Something'</span><span class="p">,</span> <span class="n">autospec</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">spec_set</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>  <span class="n">thing</span> <span class="o">=</span> <span class="n">Something</span><span class="p">()</span>
<span class="gp">... </span>  <span class="n">thing</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">33</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
 <span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">Mock object has no attribute 'a'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-620">Probably the best way of solving the problem is to add class attributes as default values for instance members initialised in <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a>. </span><span class="yiyi-st" id="yiyi-621">Note that if you are only setting default attributes in <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> then providing them via class attributes (shared between instances of course) is faster too. </span><span class="yiyi-st" id="yiyi-622">e.g.</span></p><div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Something</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">33</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-623">This brings up another issue. </span><span class="yiyi-st" id="yiyi-624">It is relatively common to provide a default value of <code class="docutils literal"><span class="pre">None</span></code> for members that will later be an object of a different type. </span><span class="yiyi-st" id="yiyi-625"><code class="docutils literal"><span class="pre">None</span></code> would be useless as a spec because it wouldn’t let you access <em>any</em> attributes or methods on it. </span><span class="yiyi-st" id="yiyi-626">As <code class="docutils literal"><span class="pre">None</span></code> is <em>never</em> going to be useful as a spec, and probably indicates a member that will normally of some other type, autospec doesn’t use a spec for members that are set to <code class="docutils literal"><span class="pre">None</span></code>. </span><span class="yiyi-st" id="yiyi-627">These will just be ordinary mocks (well - MagicMocks):</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Something</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">member</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">create_autospec</span><span class="p">(</span><span class="n">Something</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">foo</span><span class="o">.</span><span class="n">bar</span><span class="o">.</span><span class="n">baz</span><span class="p">()</span>
<span class="go">&lt;MagicMock name='mock.member.foo.bar.baz()' id='...'&gt;</span>
</code></pre><p><span class="yiyi-st" id="yiyi-628">If modifying your production classes to add defaults isn’t to your liking then there are more options. </span><span class="yiyi-st" id="yiyi-629">One of these is simply to use an instance as the spec rather than the class. </span><span class="yiyi-st" id="yiyi-630">The other is to create a subclass of the production class and add the defaults to the subclass without affecting the production class. </span><span class="yiyi-st" id="yiyi-631">Both of these require you to use an alternative object as the spec. </span><span class="yiyi-st" id="yiyi-632">Thankfully <a class="reference internal" href="#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal"><span class="pre">patch()</span></code></a> supports this - you can simply pass the alternative object as the <em>autospec</em> argument:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Something</span><span class="p">:</span>
<span class="gp">... </span>  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">33</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">SomethingForTest</span><span class="p">(</span><span class="n">Something</span><span class="p">):</span>
<span class="gp">... </span>  <span class="n">a</span> <span class="o">=</span> <span class="mi">33</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">'__main__.Something'</span><span class="p">,</span> <span class="n">autospec</span><span class="o">=</span><span class="n">SomethingForTest</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">a</span>
<span class="go">&lt;NonCallableMagicMock name='Something.a' spec='int' id='...'&gt;</span>
</code></pre><table class="docutils footnote" frame="void" id="id11" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-633"><a class="fn-backref" href="#id10">[4]</a></span></td><td><span class="yiyi-st" id="yiyi-634">This only applies to classes or already instantiated objects. </span><span class="yiyi-st" id="yiyi-635">Calling a mocked class to create a mock instance <em>does not</em> create a real instance. </span><span class="yiyi-st" id="yiyi-636">It is only attribute lookups - along with calls to <a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> - that are done.</span></td></tr></tbody></table></div></div></div></div>