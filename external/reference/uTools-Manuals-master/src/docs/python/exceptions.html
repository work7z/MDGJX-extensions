<div class="body" role="main"><div class="section" id="built-in-exceptions"><h1><span class="yiyi-st" id="yiyi-9">5。</span><span class="yiyi-st" id="yiyi-10">内建异常</span></h1><p id="index-0"><span class="yiyi-st" id="yiyi-11">在 Python 中，所有的异常必须是从 <a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-class docutils literal"><span class="pre">BaseException</span></code></a>中派生的类的实例.</span><span class="yiyi-st" id="yiyi-12">在带有提及特定类的<a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a>子句的<a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>语句中，该子句还处理从该类派生的任何异常类（但不包括<em></em>）。</span><span class="yiyi-st" id="yiyi-13">通过子类化得到的两个不相关的异常类永远不会相等，即便它们具有相同的名称。</span></p><p id="index-1"><span class="yiyi-st" id="yiyi-14">下列内建异常可以通过解释器或者内建函数来生成。</span><span class="yiyi-st" id="yiyi-15">除了提到的那些地方，它们还有“关联值 (associated value)”指示错误的详细的原因。</span><span class="yiyi-st" id="yiyi-16">这可以是字符串或包含几个信息项（例如，错误码和解释错误码的字符串）的元组。</span><span class="yiyi-st" id="yiyi-17">这些关联值通常会作为参数，传递给异常类的构造函数。</span></p><p><span class="yiyi-st" id="yiyi-18">用户代码可产生内建异常。</span><span class="yiyi-st" id="yiyi-19">这样可以用于测试异常处理程序或报告错误条件，模拟解析器发生了相同的异常情况；但请注意，没有任何手段可以防止用户代码引起不适当的异常。</span></p><p><span class="yiyi-st" id="yiyi-20">内建异常类可以被子类化以定义新异常；建议程序员从<a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a>类或其子类中的一个派生新异常，而不是从<a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a>派生新异常。</span><span class="yiyi-st" id="yiyi-21">有关定义异常的详细信息可以查阅《Python 教程》中的 <a class="reference internal" href="../tutorial/errors.html#tut-userexceptions"><span>User-defined Exceptions</span></a> 一节。</span></p><p><span class="yiyi-st" id="yiyi-22">在<a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a>或<a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a>子句<code class="xref py py-attr docutils literal"><span class="pre">__context__</span></code>中提升（或重新提高）异常时会自动设置为捕获的最后一个异常；如果未处理新的异常，则最终显示的追踪将包括原始异常和最终异常。</span></p><p><span class="yiyi-st" id="yiyi-23">When raising a new exception (rather than using a bare <code class="docutils literal"><span class="pre">raise</span></code> to re-raise the exception currently being handled), the implicit exception context can be supplemented with an explicit cause by using <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> with <a class="reference internal" href="../reference/simple_stmts.html#raise"><code class="xref std std-keyword docutils literal"><span class="pre">raise</span></code></a>:</span></p><pre><code class="language-python"><span></span><span class="k">raise</span> <span class="n">new_exc</span> <span class="kn">from</span> <span class="nn">original_exc</span>
</code></pre><p><span class="yiyi-st" id="yiyi-24">The expression following <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> must be an exception or <code class="docutils literal"><span class="pre">None</span></code>. </span><span class="yiyi-st" id="yiyi-25">它将在引发异常上设置为<code class="xref py py-attr docutils literal"><span class="pre">__cause__</span></code>。</span><span class="yiyi-st" id="yiyi-26">设置<code class="xref py py-attr docutils literal"><span class="pre">__ cause __</span></code>还会将<code class="xref py py-attr docutils literal"><span class="pre">__ suppress_context __</span></code>属性隐式设置为<code class="docutils literal"><span class="pre">True</span></code>，以便使用<code class="docutils literal"><span class="pre">raise</span> <span class="pre">new_exc </span> <span class="pre">from</span> <span class="pre">None</span></code>有效地替换旧的异常用于显示目的。</span><span class="yiyi-st" id="yiyi-27">将<a class="reference internal" href="#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>转换为<a class="reference internal" href="#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>，同时在调试时保留<code class="xref py py-attr docutils literal"><span class="pre">__context__</span></code>中的旧异常可用于内省。</span></p><p><span class="yiyi-st" id="yiyi-28">默认回溯显示代码显示这些链接异常以及异常本身的追溯。</span><span class="yiyi-st" id="yiyi-29"><code class="xref py py-attr docutils literal"><span class="pre">__cause__</span></code>中的显式链接异常在出现时始终显示。</span><span class="yiyi-st" id="yiyi-30">仅当<code class="xref py py-attr docutils literal"><span class="pre">__cause__</span></code>为<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>且<code class="xref py py-attr docutils literal"><span class="pre">__suppress_context__</span></code>为假时，才会显示<code class="xref py py-attr docutils literal"><span class="pre">__context__</span></code>中的隐式链接异常。</span></p><p><span class="yiyi-st" id="yiyi-31">在任何情况下，异常本身始终显示在任何链接异常之后，以便追溯的最后一行总是显示最后引发的异常。</span></p><div class="section" id="base-classes"><h2><span class="yiyi-st" id="yiyi-32">5.1.</span><span class="yiyi-st" id="yiyi-33">基类</span></h2><p><span class="yiyi-st" id="yiyi-34">The following exceptions are used mostly as base classes for other exceptions.</span></p><dl class="exception"><dt id="BaseException"><span class="yiyi-st" id="yiyi-35"><em class="property">exception </em><code class="descname">BaseException</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-36">所有内建的异常的基类。</span><span class="yiyi-st" id="yiyi-37">它并不意味用户定义的类应该直接继承它（因此，请使用 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a>）。</span><span class="yiyi-st" id="yiyi-38">如果对这个类的实例调用<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>，则返回实例的参数（s）的表示，或者当没有参数时返回空字符串。</span></p><dl class="attribute"><dt id="BaseException.args"><span class="yiyi-st" id="yiyi-39"><code class="descname">args</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-40">异常构造函数的参数元组。</span><span class="yiyi-st" id="yiyi-41">一些内建异常（如<a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>）需要一定数量的参数，并为该元组的元素分配特殊含义，而其他异常通常仅使用单个字符串给出错误消息。</span></p></dd></dl><dl class="method"><dt id="BaseException.with_traceback"><span class="yiyi-st" id="yiyi-42"><code class="descname">with_traceback</code><span class="sig-paren">(</span><em>tb</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-43">此方法将<em>tb</em>设置为异常的新跟踪，并返回异常对象。</span><span class="yiyi-st" id="yiyi-44">它通常用于异常处理代码，如下所示：</span></p><pre><code class="language-python"><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">SomeException</span><span class="p">:</span>
    <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">raise</span> <span class="n">OtherException</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
</code></pre></dd></dl></dd></dl><dl class="exception"><dt id="Exception"><span class="yiyi-st" id="yiyi-45"><em class="property">exception </em><code class="descname">Exception</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-46">所有内建的、非系统退出的异常，都是从该类派生的。</span><span class="yiyi-st" id="yiyi-47">此外，应该从该类派生所有用户定义的异常。</span></p></dd></dl><dl class="exception"><dt id="ArithmeticError"><span class="yiyi-st" id="yiyi-48"><em class="property">exception </em><code class="descname">ArithmeticError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-49">各种算术错误引发的内建异常的基类：<a class="reference internal" href="#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a>, <a class="reference internal" href="#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></code></a>, <a class="reference internal" href="#FloatingPointError" title="FloatingPointError"><code class="xref py py-exc docutils literal"><span class="pre">FloatingPointError</span></code></a>。</span></p></dd></dl><dl class="exception"><dt id="BufferError"><span class="yiyi-st" id="yiyi-50"><em class="property">exception </em><code class="descname">BufferError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-51">当 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span>buffer</span></a> 相关的操作无法执行时引发。</span></p></dd></dl><dl class="exception"><dt id="LookupError"><span class="yiyi-st" id="yiyi-52"><em class="property">exception </em><code class="descname">LookupError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-53">当用于映射或序列的键或索引无效时引发的异常的基类：<a class="reference internal" href="#IndexError" title="IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a>, <a class="reference internal" href="#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。</span><span class="yiyi-st" id="yiyi-54">可以直接通过 <a class="reference internal" href="codecs.html#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal"><span class="pre">codecs.lookup()</span></code></a> 引发。</span></p></dd></dl></div><div class="section" id="concrete-exceptions"><h2><span class="yiyi-st" id="yiyi-55">5.2.</span><span class="yiyi-st" id="yiyi-56">具体的异常</span></h2><p><span class="yiyi-st" id="yiyi-57">以下异常是通常引发的异常。</span></p><dl class="exception"><dt id="AssertionError"><span class="yiyi-st" id="yiyi-58"><em class="property">exception </em><code class="descname">AssertionError</code></span></dt><dd><p id="index-2"><span class="yiyi-st" id="yiyi-59">当 <a class="reference internal" href="../reference/simple_stmts.html#assert"><code class="xref std std-keyword docutils literal"><span class="pre">assert</span></code></a> 语句失败时引发。</span></p></dd></dl><dl class="exception"><dt id="AttributeError"><span class="yiyi-st" id="yiyi-60"><em class="property">exception </em><code class="descname">AttributeError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-61">当属性引用（参见 <a class="reference internal" href="../reference/expressions.html#attribute-references"><span>Attribute references</span></a>）或赋值失败时引发。</span><span class="yiyi-st" id="yiyi-62">（当对象根本不支持属性引用或属性赋值时，将引发 <a class="reference internal" href="#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。）</span></p></dd></dl><dl class="exception"><dt id="EOFError"><span class="yiyi-st" id="yiyi-63"><em class="property">exception </em><code class="descname">EOFError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-64">在<a class="reference internal" href="functions.html#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a>函数未读取任何数据时遇到文件结束条件（EOF）时触发。</span><span class="yiyi-st" id="yiyi-65">（N.B.</span><span class="yiyi-st" id="yiyi-66">：<code class="xref py py-meth docutils literal"><span class="pre">io.IOBase.read()</span></code>和<a class="reference internal" href="io.html#io.IOBase.readline" title="io.IOBase.readline"><code class="xref py py-meth docutils literal"><span class="pre">io.IOBase.readline()</span></code></a>方法在命中EOF时会返回一个空字符串。）</span></p></dd></dl><dl class="exception"><dt id="FloatingPointError"><span class="yiyi-st" id="yiyi-67"><em class="property">exception </em><code class="descname">FloatingPointError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-68">当浮点数操作失败时引发。</span><span class="yiyi-st" id="yiyi-69">该异常总是被定义的，但仅能当 Python 用 <code class="docutils literal"><span class="pre">--with-fpectl</span></code> 选项配置时，或当 <code class="file docutils literal"><span class="pre">pyconfig.h</span></code> 文件中定义了 <code class="xref py py-const docutils literal"><span class="pre">WANT_SIGFPE_HANDLER</span></code> 符号时引发。</span></p></dd></dl><dl class="exception"><dt id="GeneratorExit"><span class="yiyi-st" id="yiyi-70"><em class="property">exception </em><code class="descname">GeneratorExit</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-71">在<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>或<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>关闭时触发；参见<a class="reference internal" href="../reference/expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal"><span class="pre">generator.close()</span></code></a>和<a class="reference internal" href="../reference/datamodel.html#coroutine.close" title="coroutine.close"><code class="xref py py-meth docutils literal"><span class="pre">coroutine.close()</span></code></a>。</span><span class="yiyi-st" id="yiyi-72">它直接继承自<a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a>而不是<a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a>，因为它在技术上不是错误。</span></p></dd></dl><dl class="exception"><dt id="ImportError"><span class="yiyi-st" id="yiyi-73"><em class="property">exception </em><code class="descname">ImportError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-74">在<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>语句未能找到模块定义或<code class="docutils literal"><span class="pre">从</span> <span class="pre">...</span> <span class="pre">import</span> </code>无法找到要导入的名称。</span></p><p><span class="yiyi-st" id="yiyi-75">可以使用构造函数的仅关键字参数来设置<code class="xref py py-attr docutils literal"><span class="pre">name</span></code>和<code class="xref py py-attr docutils literal"><span class="pre">path</span></code>属性。</span><span class="yiyi-st" id="yiyi-76">设置时，它们分别表示尝试导入的模块的名称和触发异常的任何文件的路径。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-77"><span class="versionmodified">在版本3.3中已更改：</span>添加了<code class="xref py py-attr docutils literal"><span class="pre">name</span></code>和<code class="xref py py-attr docutils literal"><span class="pre">path</span></code>属性。</span></p></div></dd></dl><dl class="exception"><dt id="IndexError"><span class="yiyi-st" id="yiyi-78"><em class="property">exception </em><code class="descname">IndexError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-79">当序列下标超出取值范围时引发。</span><span class="yiyi-st" id="yiyi-80">（片索引被静默截断到允许的范围内；如果索引不是整数，则会引发<a class="reference internal" href="#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。）</span></p></dd></dl><dl class="exception"><dt id="KeyError"><span class="yiyi-st" id="yiyi-81"><em class="property">exception </em><code class="descname">KeyError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-82">当在现有键的集合中找不到映射的（字典）键时引发。</span></p></dd></dl><dl class="exception"><dt id="KeyboardInterrupt"><span class="yiyi-st" id="yiyi-83"><em class="property">exception </em><code class="descname">KeyboardInterrupt</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-84">当用户按下中断键（通常是 <code class="kbd docutils literal"><span class="pre">Delete</span></code> 或 <code class="kbd docutils literal"><span class="pre">Control-C</span></code>）时引发。</span><span class="yiyi-st" id="yiyi-85">执行期间，会定期检查中断。</span><span class="yiyi-st" id="yiyi-86">该异常继承自 <a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a> ，因此不会被 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a> 的捕获代码意外捕获，以防止解释器退出。</span></p></dd></dl><dl class="exception"><dt id="MemoryError"><span class="yiyi-st" id="yiyi-87"><em class="property">exception </em><code class="descname">MemoryError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-88">当一个操作将内存耗尽，但情况仍可挽救时（通过删除某些对象）时引发。</span><span class="yiyi-st" id="yiyi-89">关联值是一个字符串，它指示哪种（内部）操作耗尽了内存。</span><span class="yiyi-st" id="yiyi-90">注意，由于底层内存管理架构（C的<code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code>函数），解释器可能不总是能够从这种情况完全恢复；它仍然引入了一个异常，以便可以打印堆栈跟踪，以防万一程序失败的原因。</span></p></dd></dl><dl class="exception"><dt id="NameError"><span class="yiyi-st" id="yiyi-91"><em class="property">exception </em><code class="descname">NameError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-92">当找不到本地或全局名称时引发。</span><span class="yiyi-st" id="yiyi-93">这仅适用于不合格的名称。</span><span class="yiyi-st" id="yiyi-94">关联值是一条错误消息，其中包括找不到的名称。</span></p></dd></dl><dl class="exception"><dt id="NotImplementedError"><span class="yiyi-st" id="yiyi-95"><em class="property">exception </em><code class="descname">NotImplementedError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-96">此异常是从 <a class="reference internal" href="#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> 派生的。</span><span class="yiyi-st" id="yiyi-97">当用户定义基类需要派生类重写方法时，抽象方法会引发该异常。</span></p></dd></dl><dl class="exception"><dt id="OSError"><span class="yiyi-st" id="yiyi-98"><em class="property">exception </em><code class="descname">OSError</code><span class="sig-paren">(</span><span class="optional">[</span><em>arg</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-99"><em class="property">exception </em><code class="descname">OSError</code><span class="sig-paren">(</span><em>errno</em>, <em>strerror</em><span class="optional">[</span>, <em>filename</em><span class="optional">[</span>, <em>winerror</em><span class="optional">[</span>, <em>filename2</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p id="index-3"><span class="yiyi-st" id="yiyi-100">This exception is raised when a system function returns a system-related error, including I/O failures such as “file not found” or “disk full” (not for illegal argument types or other incidental errors). </span></p><p><span class="yiyi-st" id="yiyi-101">第二种形式的构造函数设置相应的属性，如下所述。</span><span class="yiyi-st" id="yiyi-102">如果未指定，属性默认为<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>。</span><span class="yiyi-st" id="yiyi-103">为了向后兼容，如果传递了三个参数，则<a class="reference internal" href="#BaseException.args" title="BaseException.args"><code class="xref py py-attr docutils literal"><span class="pre">args</span></code></a>属性只包含前两个构造函数参数的2元组。</span></p><p><span class="yiyi-st" id="yiyi-104">构造函数通常实际返回<a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>的子类，如下面的<a class="reference internal" href="#os-exceptions">OS异常</a>中所述。</span><span class="yiyi-st" id="yiyi-105">特定的子类取决于最终的<a class="reference internal" href="#OSError.errno" title="OSError.errno"><code class="xref py py-attr docutils literal"><span class="pre">errno</span></code></a>值。</span><span class="yiyi-st" id="yiyi-106">此行为仅在直接构造<a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>或通过别名时发生，并且在子类化时不会继承。</span></p><dl class="attribute"><dt id="OSError.errno"><span class="yiyi-st" id="yiyi-107"><code class="descname">errno</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-108">来自C变量<code class="xref c c-data docutils literal"><span class="pre">errno</span></code>的数字错误代码。</span></p></dd></dl><dl class="attribute"><dt id="OSError.winerror"><span class="yiyi-st" id="yiyi-109"><code class="descname">winerror</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-110">在Windows下，这将提供本机Windows错误代码。</span><span class="yiyi-st" id="yiyi-111">因此，<a class="reference internal" href="#OSError.errno" title="OSError.errno"><code class="xref py py-attr docutils literal"><span class="pre">errno</span></code></a>属性是POSIX术语中的本机错误代码的近似翻译。</span></p><p><span class="yiyi-st" id="yiyi-112">在Windows下，如果<em>winerror</em>构造函数参数是整数，则<a class="reference internal" href="#OSError.errno" title="OSError.errno"><code class="xref py py-attr docutils literal"><span class="pre">errno</span></code></a>属性从Windows错误代码确定，并且忽略<em>errno</em> 。</span><span class="yiyi-st" id="yiyi-113">在其他平台上，<em>winerror</em>参数被忽略，并且<a class="reference internal" href="#OSError.winerror" title="OSError.winerror"><code class="xref py py-attr docutils literal"><span class="pre">winerror</span></code></a>属性不存在。</span></p></dd></dl><dl class="attribute"><dt id="OSError.strerror"><span class="yiyi-st" id="yiyi-114"><code class="descname">strerror</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-115">相应的错误消息，由操作系统提供。</span><span class="yiyi-st" id="yiyi-116">它由POSIX下的C函数<code class="xref c c-func docutils literal"><span class="pre">perror()</span></code>和Windows下的<code class="xref c c-func docutils literal"><span class="pre">FormatMessage()</span></code>格式化。</span></p></dd></dl><dl class="attribute"><dt id="OSError.filename"><span class="yiyi-st" id="yiyi-117"><code class="descname">filename</code> </span></dt><dt id="OSError.filename2"><span class="yiyi-st" id="yiyi-118"><code class="descname">filename2</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-119">对于涉及文件系统路径（例如<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>或<a class="reference internal" href="os.html#os.unlink" title="os.unlink"><code class="xref py py-func docutils literal"><span class="pre">os.unlink()</span></code></a>）的异常，<a class="reference internal" href="#OSError.filename" title="OSError.filename"><code class="xref py py-attr docutils literal"><span class="pre">filename</span></code></a>是传递给功能。</span><span class="yiyi-st" id="yiyi-120">对于涉及两个文件系统路径（例如<a class="reference internal" href="os.html#os.rename" title="os.rename"><code class="xref py py-func docutils literal"><span class="pre">os.rename()</span></code></a>）的函数，<a class="reference internal" href="#OSError.filename2" title="OSError.filename2"><code class="xref py py-attr docutils literal"><span class="pre">filename2</span></code></a>对应于传递给函数的第二个文件名。</span></p></dd></dl><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-121"><span class="versionmodified">在版本3.3中已更改：</span> <a class="reference internal" href="#EnvironmentError" title="EnvironmentError"><code class="xref py py-exc docutils literal"><span class="pre">EnvironmentError</span></code></a>，<a class="reference internal" href="#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a>，<a class="reference internal" href="#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal"><span class="pre">WindowsError</span></code></a>，<a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a> <a class="reference internal" href="select.html#select.error" title="select.error"><code class="xref py py-exc docutils literal"><span class="pre">select.error</span></code></a>和<code class="xref py py-exc docutils literal"><span class="pre">mmap.error</span></code>已合并到<a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>中，构造函数可能会返回一个子类。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-122"><span class="versionmodified">在版本3.4中更改：</span> <a class="reference internal" href="#OSError.filename" title="OSError.filename"><code class="xref py py-attr docutils literal"><span class="pre">filename</span></code></a>属性现在是传递给函数的原始文件名，而不是编码到文件系统编码或从文件系统编码解码的名称。</span><span class="yiyi-st" id="yiyi-123">此外，还添加了<em>filename2</em>构造函数参数和属性。</span></p></div></dd></dl><dl class="exception"><dt id="OverflowError"><span class="yiyi-st" id="yiyi-124"><em class="property">exception </em><code class="descname">OverflowError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-125">当要表示算术运算的结果太大时引发。</span><span class="yiyi-st" id="yiyi-126">这不能发生在整数（它宁愿引发<a class="reference internal" href="#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal"><span class="pre">MemoryError</span></code></a>比放弃）。</span><span class="yiyi-st" id="yiyi-127">但是，由于历史原因，OverflowError有时会对超出必需范围的整数产生。</span><span class="yiyi-st" id="yiyi-128">由于C中浮点异常处理缺乏标准化，大多数浮点运算都不会被检查。</span></p></dd></dl><dl class="exception"><dt id="RecursionError"><span class="yiyi-st" id="yiyi-129"><em class="property">exception </em><code class="descname">RecursionError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-130">此异常是从 <a class="reference internal" href="#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> 派生的。</span><span class="yiyi-st" id="yiyi-131">当解释器检测到超出最大递归深度（参见<a class="reference internal" href="sys.html#sys.getrecursionlimit" title="sys.getrecursionlimit"><code class="xref py py-func docutils literal"><span class="pre">sys.getrecursionlimit()</span></code></a>）时，它被引发。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-132"><span class="versionmodified">版本3.5中的新功能：</span>以前，引发了一个平常的<a class="reference internal" href="#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a>。</span></p></div></dd></dl><dl class="exception"><dt id="ReferenceError"><span class="yiyi-st" id="yiyi-133"><em class="property">exception </em><code class="descname">ReferenceError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-134">当用一个由 <a class="reference internal" href="weakref.html#weakref.proxy" title="weakref.proxy"><code class="xref py py-func docutils literal"><span class="pre">weakref.proxy()</span></code></a> 函数创建的弱引用代理，去访问引用者的属性，而该引用者已经被垃圾回收时，会引发此异常。</span><span class="yiyi-st" id="yiyi-135">更多有关弱引用的信息，请参阅 <a class="reference internal" href="weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> 模块。</span></p></dd></dl><dl class="exception"><dt id="RuntimeError"><span class="yiyi-st" id="yiyi-136"><em class="property">exception </em><code class="descname">RuntimeError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-137">当检出错误不属于任何其它类别时引发。</span><span class="yiyi-st" id="yiyi-138">关联值是一个字符串，它指示到底什么地方出错了。</span></p></dd></dl><dl class="exception"><dt id="StopIteration"><span class="yiyi-st" id="yiyi-139"><em class="property">exception </em><code class="descname">StopIteration</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-140">由内建函数<a class="reference internal" href="functions.html#next" title="next"><code class="xref py py-func docutils literal"><span class="pre">next()</span></code></a>和<a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>的<a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a>方法引发， 。</span></p><p><span class="yiyi-st" id="yiyi-141">异常对象具有单个属性<code class="xref py py-attr docutils literal"><span class="pre">value</span></code>，作为构造异常时的参数，默认为<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-142">当<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>或<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>函数返回时，将引发一个新的<a class="reference internal" href="#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a>实例，并将该函数返回的值用作<code class="xref py py-attr docutils literal"><span class="pre">value</span></code>参数指向异常的构造函数。</span></p><p><span class="yiyi-st" id="yiyi-143">如果存在<code class="docutils literal"><span class="pre">从</span> <span class="pre">__未来__</span> <span class="pre">导入</span> <span class="pre">generator_stop</span></code>指令引发<a class="reference internal" href="#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a>，它将被转换为<a class="reference internal" href="#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a>（保留<a class="reference internal" href="#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a>作为新异常的原因）。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-144"><span class="versionmodified">在版本3.3中已更改：</span>添加了<code class="docutils literal"><span class="pre">value</span></code>属性和生成器函数用于返回值的能力。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-145"><span class="versionmodified">在版本3.5中已更改：</span>引入了RuntimeError变换。</span></p></div></dd></dl><dl class="exception"><dt id="StopAsyncIteration"><span class="yiyi-st" id="yiyi-146"><em class="property">exception </em><code class="descname">StopAsyncIteration</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-147">必须通过<a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>对象的<a class="reference internal" href="../reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal"><span class="pre">__anext__()</span></code></a>方法提高以停止迭代。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-148"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="exception"><dt id="SyntaxError"><span class="yiyi-st" id="yiyi-149"><em class="property">exception </em><code class="descname">SyntaxError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-150">当解析器遇到语法错误时引发。</span><span class="yiyi-st" id="yiyi-151">这可能发生在<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>语句中，在调用内建函数<a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>或<a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>脚本或标准输入（也是交互式）。</span></p><p><span class="yiyi-st" id="yiyi-152">该类的实例具有更容易访问相关细节的 <code class="xref py py-attr docutils literal"><span class="pre">filename</span></code>、<code class="xref py py-attr docutils literal"><span class="pre">text</span></code>、<code class="xref py py-attr docutils literal"><span class="pre">lineno</span></code>、<code class="xref py py-attr docutils literal"><span class="pre">offset</span></code> 属性。</span><span class="yiyi-st" id="yiyi-153">向内建函数 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> 传入异常实例，仅会返回错误消息。</span></p></dd></dl><dl class="exception"><dt id="IndentationError"><span class="yiyi-st" id="yiyi-154"><em class="property">exception </em><code class="descname">IndentationError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-155">与不正确的缩进相关的语法错误的基类。</span><span class="yiyi-st" id="yiyi-156">这是 <a class="reference internal" href="#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code></a> 的一个子类。</span></p></dd></dl><dl class="exception"><dt id="TabError"><span class="yiyi-st" id="yiyi-157"><em class="property">exception </em><code class="descname">TabError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-158">当缩进中包含对制表符和空格的混用时引发。</span><span class="yiyi-st" id="yiyi-159">这是 <a class="reference internal" href="#IndentationError" title="IndentationError"><code class="xref py py-exc docutils literal"><span class="pre">IndentationError</span></code></a> 的一个子类。</span></p></dd></dl><dl class="exception"><dt id="SystemError"><span class="yiyi-st" id="yiyi-160"><em class="property">exception </em><code class="descname">SystemError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-161">当解释器发现内部错误，但情况并没有看起来那么严重，不至于到要放弃所有希望的地步，此时会引发本异常。</span><span class="yiyi-st" id="yiyi-162">关联值是一个字符串，它（用底层术语）指示什么出错了。</span></p><p><span class="yiyi-st" id="yiyi-163">您应把这个异常报告给您的 Python 解释器的作者或维护者。</span><span class="yiyi-st" id="yiyi-164">请务必报告您使用的 Python 解释器版本（<code class="docutils literal"><span class="pre">sys.version</span></code>；版本号在 Python 交互会话开始时也会被打印出来），确切的错误消息（异常的关联值），以及错误出发的程序源码（如果您方便提供的话）。</span></p></dd></dl><dl class="exception"><dt id="SystemExit"><span class="yiyi-st" id="yiyi-165"><em class="property">exception </em><code class="descname">SystemExit</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-166">由 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></code></a> 函数引发此异常。</span><span class="yiyi-st" id="yiyi-167">它继承自<a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a>而不是<a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a>，因此它不会被捕获到<a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a>的代码意外捕获。</span><span class="yiyi-st" id="yiyi-168">这允许异常正确地向上传播并导致解释器退出。</span><span class="yiyi-st" id="yiyi-169">当它不被处理时，Python解释器退出；不会打印堆栈跟踪。</span><span class="yiyi-st" id="yiyi-170">构造函数接受传递给<a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></code></a>的相同可选参数。</span><span class="yiyi-st" id="yiyi-171">如果值为整数，则指定系统退出状态（传递给C的<code class="xref c c-func docutils literal"><span class="pre">exit()</span></code>函数）；如果<code class="docutils literal"><span class="pre">None</span></code>，退出状态为零；如果它有另一个类型（例如字符串），则打印对象的值，退出状态为1。</span></p><p><span class="yiyi-st" id="yiyi-172">对 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></code></a> 的调用会被转译成异常，以便执行清理处理程序（<a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> 语句的 <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 从句），因此，调试器会执行脚本，不必冒失去控制的风险。</span><span class="yiyi-st" id="yiyi-173">如果绝对需要程序立即退出（例如，在调用 <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">os.fork()</span></code></a> 后的子进程中），可以使用 <a class="reference internal" href="os.html#os._exit" title="os._exit"><code class="xref py py-func docutils literal"><span class="pre">os._exit()</span></code></a> 函数。</span></p><dl class="attribute"><dt id="SystemExit.code"><span class="yiyi-st" id="yiyi-174"><code class="descname">code</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-175">传递给构造函数的退出状态或错误消息。</span><span class="yiyi-st" id="yiyi-176">（默认为<code class="docutils literal"><span class="pre">None</span></code>。）</span></p></dd></dl></dd></dl><dl class="exception"><dt id="TypeError"><span class="yiyi-st" id="yiyi-177"><em class="property">exception </em><code class="descname">TypeError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-178">当操作或函数应用于不合适类型的对象时引发。</span><span class="yiyi-st" id="yiyi-179">关联值是字符串，它提供有关类型不匹配的详细信息。</span></p></dd></dl><dl class="exception"><dt id="UnboundLocalError"><span class="yiyi-st" id="yiyi-180"><em class="property">exception </em><code class="descname">UnboundLocalError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-181">当引用函数或方法局部变量，但变量没有绑定值时引发。</span><span class="yiyi-st" id="yiyi-182">这是 <a class="reference internal" href="#NameError" title="NameError"><code class="xref py py-exc docutils literal"><span class="pre">NameError</span></code></a> 的一个子类。</span></p></dd></dl><dl class="exception"><dt id="UnicodeError"><span class="yiyi-st" id="yiyi-183"><em class="property">exception </em><code class="descname">UnicodeError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-184">当有关 Unicode 编码或解码错误出现时引发。</span><span class="yiyi-st" id="yiyi-185">它是 <a class="reference internal" href="#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 的一个子类。</span></p><p><span class="yiyi-st" id="yiyi-186"><a class="reference internal" href="#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> 具有描述编码或解码错误的属性。</span><span class="yiyi-st" id="yiyi-187">例如，<code class="docutils literal"><span class="pre">err.object[err.start:err.end]</span></code> 给出了导致解码器失败的特定的无效输入。</span></p><dl class="attribute"><dt id="UnicodeError.encoding"><span class="yiyi-st" id="yiyi-188"><code class="descname">encoding</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-189">引发错误的编码名称。</span></p></dd></dl><dl class="attribute"><dt id="UnicodeError.reason"><span class="yiyi-st" id="yiyi-190"><code class="descname">reason</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-191">一个字符串，它描述特定的解码器错误。</span></p></dd></dl><dl class="attribute"><dt id="UnicodeError.object"><span class="yiyi-st" id="yiyi-192"><code class="descname">object</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-193">解码器试图进行编码或解码的对象。</span></p></dd></dl><dl class="attribute"><dt id="UnicodeError.start"><span class="yiyi-st" id="yiyi-194"><code class="descname">start</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-195"><a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-attr docutils literal"><span class="pre">object</span></code></a> 的第一个索引中数据无效。</span></p></dd></dl><dl class="attribute"><dt id="UnicodeError.end"><span class="yiyi-st" id="yiyi-196"><code class="descname">end</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-197"><a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-attr docutils literal"><span class="pre">object</span></code></a> 的最后一个索引中数据无效。</span></p></dd></dl></dd></dl><dl class="exception"><dt id="UnicodeEncodeError"><span class="yiyi-st" id="yiyi-198"><em class="property">exception </em><code class="descname">UnicodeEncodeError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-199">当编码过程中出现的一个 Unicode 相关的错误时引发。</span><span class="yiyi-st" id="yiyi-200">它是 <a class="reference internal" href="#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> 的一个子类。</span></p></dd></dl><dl class="exception"><dt id="UnicodeDecodeError"><span class="yiyi-st" id="yiyi-201"><em class="property">exception </em><code class="descname">UnicodeDecodeError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-202">当解码过程中出现的一个 Unicode 相关的错误时引发。</span><span class="yiyi-st" id="yiyi-203">它是 <a class="reference internal" href="#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> 的一个子类。</span></p></dd></dl><dl class="exception"><dt id="UnicodeTranslateError"><span class="yiyi-st" id="yiyi-204"><em class="property">exception </em><code class="descname">UnicodeTranslateError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-205">当翻译过程中出现的一个 Unicode 相关的错误时引发。</span><span class="yiyi-st" id="yiyi-206">它是 <a class="reference internal" href="#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> 的一个子类。</span></p></dd></dl><dl class="exception"><dt id="ValueError"><span class="yiyi-st" id="yiyi-207"><em class="property">exception </em><code class="descname">ValueError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-208">当内建操作或函数，接收到类型正确，但值不正确的参数，而且这种情况不能用诸如 <a class="reference internal" href="#IndexError" title="IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> 这样的更精确的异常进行描述时引发。</span></p></dd></dl><dl class="exception"><dt id="ZeroDivisionError"><span class="yiyi-st" id="yiyi-209"><em class="property">exception </em><code class="descname">ZeroDivisionError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-210">当除法或取模运算的第 2 个参数为 0 时引发。</span><span class="yiyi-st" id="yiyi-211">关联值是一个字符串，它指出操作数的类型和运算符。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-212">保留以下例外以与先前版本兼容：从Python 3.3开始，它们是<a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>的别名。</span></p><dl class="exception"><dt id="EnvironmentError"><span class="yiyi-st" id="yiyi-213"><em class="property">exception </em><code class="descname">EnvironmentError</code></span></dt><dd></dd></dl><dl class="exception"><dt id="IOError"><span class="yiyi-st" id="yiyi-214"><em class="property">exception </em><code class="descname">IOError</code></span></dt><dd></dd></dl><dl class="exception"><dt id="WindowsError"><span class="yiyi-st" id="yiyi-215"><em class="property">exception </em><code class="descname">WindowsError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-216">仅在Windows上可用。</span></p></dd></dl><div class="section" id="os-exceptions"><h3><span class="yiyi-st" id="yiyi-217">5.2.1.</span><span class="yiyi-st" id="yiyi-218">操作系统异常</span></h3><p><span class="yiyi-st" id="yiyi-219">以下异常是<a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>的子类，它们根据系统错误代码而产生。</span></p><dl class="exception"><dt id="BlockingIOError"><span class="yiyi-st" id="yiyi-220"><em class="property">exception </em><code class="descname">BlockingIOError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-221">在操作会阻止对象（例如对象）时触发。</span><span class="yiyi-st" id="yiyi-222">套接字）设置为非阻塞操作。</span><span class="yiyi-st" id="yiyi-223">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">EAGAIN</span></code>，<code class="docutils literal"><span class="pre">EALREADY</span></code>，<code class="docutils literal"><span class="pre">EWOULDBLOCK</span></code>和<code class="docutils literal"><span class="pre">EINPROGRESS</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-224">除了<a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>之外，<a class="reference internal" href="#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal"><span class="pre">BlockingIOError</span></code></a>还可以有一个属性：</span></p><dl class="attribute"><dt id="BlockingIOError.characters_written"><span class="yiyi-st" id="yiyi-225"><code class="descname">characters_written</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-226">包含在阻止之前写入流中的字符数的整数。</span><span class="yiyi-st" id="yiyi-227">当使用来自<a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a>模块的缓冲I / O类时，此属性可用。</span></p></dd></dl></dd></dl><dl class="exception"><dt id="ChildProcessError"><span class="yiyi-st" id="yiyi-228"><em class="property">exception </em><code class="descname">ChildProcessError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-229">在子进程上的操作失败时引发。</span><span class="yiyi-st" id="yiyi-230">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">ECHILD</span></code>。</span></p></dd></dl><dl class="exception"><dt id="ConnectionError"><span class="yiyi-st" id="yiyi-231"><em class="property">exception </em><code class="descname">ConnectionError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-232">连接相关问题的基类。</span></p><p><span class="yiyi-st" id="yiyi-233">子类别为<a class="reference internal" href="#BrokenPipeError" title="BrokenPipeError"><code class="xref py py-exc docutils literal"><span class="pre">BrokenPipeError</span></code></a>，<a class="reference internal" href="#ConnectionAbortedError" title="ConnectionAbortedError"><code class="xref py py-exc docutils literal"><span class="pre">ConnectionAbortedError</span></code></a>，<a class="reference internal" href="#ConnectionRefusedError" title="ConnectionRefusedError"><code class="xref py py-exc docutils literal"><span class="pre">ConnectionRefusedError</span></code></a>和<a class="reference internal" href="#ConnectionResetError" title="ConnectionResetError"><code class="xref py py-exc docutils literal"><span class="pre">ConnectionResetError</span></code></a>。</span></p></dd></dl><dl class="exception"><dt id="BrokenPipeError"><span class="yiyi-st" id="yiyi-234"><em class="property">exception </em><code class="descname">BrokenPipeError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-235"><a class="reference internal" href="#ConnectionError" title="ConnectionError"><code class="xref py py-exc docutils literal"><span class="pre">ConnectionError</span></code></a>的子类，在尝试在管道上写入时引发，而另一端已关闭，或试图在已关闭写入的套接字上写入。</span><span class="yiyi-st" id="yiyi-236">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">EPIPE</span></code>和<code class="docutils literal"><span class="pre">ESHUTDOWN</span></code>。</span></p></dd></dl><dl class="exception"><dt id="ConnectionAbortedError"><span class="yiyi-st" id="yiyi-237"><em class="property">exception </em><code class="descname">ConnectionAbortedError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-238">连接尝试被对等体中止时引发的<a class="reference internal" href="#ConnectionError" title="ConnectionError"><code class="xref py py-exc docutils literal"><span class="pre">ConnectionError</span></code></a>的子类。</span><span class="yiyi-st" id="yiyi-239">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">ECONNABORTED</span></code>。</span></p></dd></dl><dl class="exception"><dt id="ConnectionRefusedError"><span class="yiyi-st" id="yiyi-240"><em class="property">exception </em><code class="descname">ConnectionRefusedError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-241">连接尝试被对等体拒绝时引发的<a class="reference internal" href="#ConnectionError" title="ConnectionError"><code class="xref py py-exc docutils literal"><span class="pre">ConnectionError</span></code></a>的子类。</span><span class="yiyi-st" id="yiyi-242">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">ECONNREFUSED</span></code>。</span></p></dd></dl><dl class="exception"><dt id="ConnectionResetError"><span class="yiyi-st" id="yiyi-243"><em class="property">exception </em><code class="descname">ConnectionResetError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-244">当连接被对等体重置时引发的<a class="reference internal" href="#ConnectionError" title="ConnectionError"><code class="xref py py-exc docutils literal"><span class="pre">ConnectionError</span></code></a>的子类。</span><span class="yiyi-st" id="yiyi-245">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">ECONNRESET</span></code>。</span></p></dd></dl><dl class="exception"><dt id="FileExistsError"><span class="yiyi-st" id="yiyi-246"><em class="property">exception </em><code class="descname">FileExistsError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-247">在尝试创建已存在的文件或目录时引发。</span><span class="yiyi-st" id="yiyi-248">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">EEXIST</span></code>。</span></p></dd></dl><dl class="exception"><dt id="FileNotFoundError"><span class="yiyi-st" id="yiyi-249"><em class="property">exception </em><code class="descname">FileNotFoundError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-250">在请求文件或目录但不存在时引发。</span><span class="yiyi-st" id="yiyi-251">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">ENOENT</span></code>。</span></p></dd></dl><dl class="exception"><dt id="InterruptedError"><span class="yiyi-st" id="yiyi-252"><em class="property">exception </em><code class="descname">InterruptedError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-253">在系统调用由传入信号中断时引发。</span><span class="yiyi-st" id="yiyi-254">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <a class="reference internal" href="errno.html#errno.EINTR" title="errno.EINTR"><code class="xref py py-data docutils literal"><span class="pre">EINTR</span></code></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-255"><span class="versionmodified">Changed in version 3.5: </span>Python now retries system calls when a syscall is interrupted by a signal, except if the signal handler raises an exception (see <span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale), instead of raising <a class="reference internal" href="#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a>.</span></p></div></dd></dl><dl class="exception"><dt id="IsADirectoryError"><span class="yiyi-st" id="yiyi-256"><em class="property">exception </em><code class="descname">IsADirectoryError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-257">在目录上请求文件操作（例如<a class="reference internal" href="os.html#os.remove" title="os.remove"><code class="xref py py-func docutils literal"><span class="pre">os.remove()</span></code></a>）时引发。</span><span class="yiyi-st" id="yiyi-258">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">EISDIR</span></code>。</span></p></dd></dl><dl class="exception"><dt id="NotADirectoryError"><span class="yiyi-st" id="yiyi-259"><em class="property">exception </em><code class="descname">NotADirectoryError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-260">在对不是目录的某个目录请求目录操作（例如<a class="reference internal" href="os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal"><span class="pre">os.listdir()</span></code></a>）时引发。</span><span class="yiyi-st" id="yiyi-261">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">ENOTDIR</span></code>。</span></p></dd></dl><dl class="exception"><dt id="PermissionError"><span class="yiyi-st" id="yiyi-262"><em class="property">exception </em><code class="descname">PermissionError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-263">在尝试运行没有足够访问权限的操作（例如文件系统权限）时引发。</span><span class="yiyi-st" id="yiyi-264">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">EACCES</span></code>和<code class="docutils literal"><span class="pre">EPERM</span></code>。</span></p></dd></dl><dl class="exception"><dt id="ProcessLookupError"><span class="yiyi-st" id="yiyi-265"><em class="property">exception </em><code class="descname">ProcessLookupError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-266">在给定进程不存在时引发。</span><span class="yiyi-st" id="yiyi-267">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">ESRCH</span></code>。</span></p></dd></dl><dl class="exception"><dt id="TimeoutError"><span class="yiyi-st" id="yiyi-268"><em class="property">exception </em><code class="descname">TimeoutError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-269">在系统级别的系统函数超时时触发。</span><span class="yiyi-st" id="yiyi-270">对应于<code class="xref c c-data docutils literal"><span class="pre">errno</span></code> <code class="docutils literal"><span class="pre">ETIMEDOUT</span></code>。</span></p></dd></dl><div class="versionadded"><p><span class="yiyi-st" id="yiyi-271"><span class="versionmodified">版本3.3中的新功能：</span>添加了上述所有<a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>子类。</span></p></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-272">请参阅</span></p><p class="last"><span class="yiyi-st" id="yiyi-273"><span class="target" id="index-5"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3151"><strong>PEP 3151</strong></a>  - 重新修改操作系统和IO异常层次结构</span></p></div></div></div><div class="section" id="warnings"><h2><span class="yiyi-st" id="yiyi-274">5.3.</span><span class="yiyi-st" id="yiyi-275">警告</span></h2><p><span class="yiyi-st" id="yiyi-276">以下例外情况用作警告类别：有关详细信息，请参阅<a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a>模块。</span></p><dl class="exception"><dt id="Warning"><span class="yiyi-st" id="yiyi-277"><em class="property">exception </em><code class="descname">Warning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-278">警告类别基类。</span></p></dd></dl><dl class="exception"><dt id="UserWarning"><span class="yiyi-st" id="yiyi-279"><em class="property">exception </em><code class="descname">UserWarning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-280">用户代码生成警告基类。</span></p></dd></dl><dl class="exception"><dt id="DeprecationWarning"><span class="yiyi-st" id="yiyi-281"><em class="property">exception </em><code class="descname">DeprecationWarning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-282">弃用特性警告基类。</span></p></dd></dl><dl class="exception"><dt id="PendingDeprecationWarning"><span class="yiyi-st" id="yiyi-283"><em class="property">exception</em><code class="descname">PendingDeprecationWarning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-284">将来会被弃用特性的警告基类。</span></p></dd></dl><dl class="exception"><dt id="SyntaxWarning"><span class="yiyi-st" id="yiyi-285"><em class="property">exception </em><code class="descname">SyntaxWarning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-286">有关可疑语法的警告的基类。</span></p></dd></dl><dl class="exception"><dt id="RuntimeWarning"><span class="yiyi-st" id="yiyi-287"><em class="property">exception </em><code class="descname">RuntimeWarning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-288">可疑 Runtime 行为警告基类。</span></p></dd></dl><dl class="exception"><dt id="FutureWarning"><span class="yiyi-st" id="yiyi-289"><em class="property">exception </em><code class="descname">FutureWarning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-290">将来会改变语义结构的警告基类。</span></p></dd></dl><dl class="exception"><dt id="ImportWarning"><span class="yiyi-st" id="yiyi-291"><em class="property">exception </em><code class="descname">ImportWarning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-292">可能弄错模块导入警告基类。</span></p></dd></dl><dl class="exception"><dt id="UnicodeWarning"><span class="yiyi-st" id="yiyi-293"><em class="property">exception </em><code class="descname">UnicodeWarning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-294">Unicode 相关的警告基类。</span></p></dd></dl><dl class="exception"><dt id="BytesWarning"><span class="yiyi-st" id="yiyi-295"><em class="property">exception </em><code class="descname">BytesWarning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-296">与<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>和<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>相关的警告的基类。</span></p></dd></dl><dl class="exception"><dt id="ResourceWarning"><span class="yiyi-st" id="yiyi-297"><em class="property">exception </em><code class="descname">ResourceWarning</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-298">与资源使用相关的警告的基类。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-299"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="exception-hierarchy"><h2><span class="yiyi-st" id="yiyi-300">5.4.</span><span class="yiyi-st" id="yiyi-301">异常层次</span></h2><p><span class="yiyi-st" id="yiyi-302">内建异常的类层次结构是：</span></p><pre><code class="language-python"><span></span><span class="ne">BaseException</span>
 <span class="o">+--</span> <span class="ne">SystemExit</span>
 <span class="o">+--</span> <span class="ne">KeyboardInterrupt</span>
 <span class="o">+--</span> <span class="ne">GeneratorExit</span>
 <span class="o">+--</span> <span class="ne">Exception</span>
      <span class="o">+--</span> <span class="ne">StopIteration</span>
      <span class="o">+--</span> <span class="n">StopAsyncIteration</span>
      <span class="o">+--</span> <span class="ne">ArithmeticError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">FloatingPointError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">OverflowError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">ZeroDivisionError</span>
      <span class="o">+--</span> <span class="ne">AssertionError</span>
      <span class="o">+--</span> <span class="ne">AttributeError</span>
      <span class="o">+--</span> <span class="ne">BufferError</span>
      <span class="o">+--</span> <span class="ne">EOFError</span>
      <span class="o">+--</span> <span class="ne">ImportError</span>
      <span class="o">+--</span> <span class="ne">LookupError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">IndexError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">KeyError</span>
      <span class="o">+--</span> <span class="ne">MemoryError</span>
      <span class="o">+--</span> <span class="ne">NameError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">UnboundLocalError</span>
      <span class="o">+--</span> <span class="ne">OSError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">BlockingIOError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">ChildProcessError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">ConnectionError</span>
      <span class="o">|</span>    <span class="o">|</span>    <span class="o">+--</span> <span class="ne">BrokenPipeError</span>
      <span class="o">|</span>    <span class="o">|</span>    <span class="o">+--</span> <span class="ne">ConnectionAbortedError</span>
      <span class="o">|</span>    <span class="o">|</span>    <span class="o">+--</span> <span class="ne">ConnectionRefusedError</span>
      <span class="o">|</span>    <span class="o">|</span>    <span class="o">+--</span> <span class="ne">ConnectionResetError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">FileExistsError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">FileNotFoundError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">InterruptedError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">IsADirectoryError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">NotADirectoryError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">PermissionError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">ProcessLookupError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">TimeoutError</span>
      <span class="o">+--</span> <span class="ne">ReferenceError</span>
      <span class="o">+--</span> <span class="ne">RuntimeError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">NotImplementedError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="n">RecursionError</span>
      <span class="o">+--</span> <span class="ne">SyntaxError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">IndentationError</span>
      <span class="o">|</span>         <span class="o">+--</span> <span class="ne">TabError</span>
      <span class="o">+--</span> <span class="ne">SystemError</span>
      <span class="o">+--</span> <span class="ne">TypeError</span>
      <span class="o">+--</span> <span class="ne">ValueError</span>
      <span class="o">|</span>    <span class="o">+--</span> <span class="ne">UnicodeError</span>
      <span class="o">|</span>         <span class="o">+--</span> <span class="ne">UnicodeDecodeError</span>
      <span class="o">|</span>         <span class="o">+--</span> <span class="ne">UnicodeEncodeError</span>
      <span class="o">|</span>         <span class="o">+--</span> <span class="ne">UnicodeTranslateError</span>
      <span class="o">+--</span> <span class="ne">Warning</span>
           <span class="o">+--</span> <span class="ne">DeprecationWarning</span>
           <span class="o">+--</span> <span class="ne">PendingDeprecationWarning</span>
           <span class="o">+--</span> <span class="ne">RuntimeWarning</span>
           <span class="o">+--</span> <span class="ne">SyntaxWarning</span>
           <span class="o">+--</span> <span class="ne">UserWarning</span>
           <span class="o">+--</span> <span class="ne">FutureWarning</span>
           <span class="o">+--</span> <span class="ne">ImportWarning</span>
           <span class="o">+--</span> <span class="ne">UnicodeWarning</span>
           <span class="o">+--</span> <span class="ne">BytesWarning</span>
           <span class="o">+--</span> <span class="ne">ResourceWarning</span>
</code></pre></div></div></div>