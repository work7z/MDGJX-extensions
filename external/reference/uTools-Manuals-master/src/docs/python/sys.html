<div class="body" role="main"><div class="section" id="module-sys"><h1><span class="yiyi-st" id="yiyi-10">29.1. <a class="reference internal" href="#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a> — 与系统相关的参数和函数</span></h1><p><span class="yiyi-st" id="yiyi-11">本模块提供了访问由解释器使用和维护的一些变量和与解释器强烈交互的函数。</span><span class="yiyi-st" id="yiyi-12">它始终可用。</span></p><dl class="data"><dt id="sys.abiflags"><span class="yiyi-st" id="yiyi-13"> <code class="descclassname">sys.</code><code class="descname">abiflags</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-14">在使用标准<code class="docutils literal"><span class="pre">configure</span></code>脚本构建Python的POSIX系统上，它包含由<span class="target" id="index-0"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3149"><strong>PEP 3149</strong></a>指定的ABI标志。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-15"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="sys.argv"><span class="yiyi-st" id="yiyi-16"> <code class="descclassname">sys.</code><code class="descname">argv</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-17">传递给Python脚本的命令行参数列表。</span><span class="yiyi-st" id="yiyi-18"><code class="docutils literal"><span class="pre">argv[0]</span></code>是脚本名称（与操作系统有关，无论这是否是完整的路径名）。</span><span class="yiyi-st" id="yiyi-19">If the command was executed using the <a class="reference internal" href="tarfile.html#cmdoption-c"><code class="xref std std-option docutils literal"><span class="pre">-c</span></code></a> command line option to the interpreter, <code class="docutils literal"><span class="pre">argv[0]</span></code> is set to the string <code class="docutils literal"><span class="pre">'-c'</span></code>. </span><span class="yiyi-st" id="yiyi-20">If no script name was passed to the Python interpreter, <code class="docutils literal"><span class="pre">argv[0]</span></code> is the empty string.</span></p><p><span class="yiyi-st" id="yiyi-21">要循环访问标准输入或命令行上给出的文件列表，请参阅<a class="reference internal" href="fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal"><span class="pre">fileinput</span></code></a>模块。</span></p></dd></dl><dl class="data"><dt id="sys.base_exec_prefix"><span class="yiyi-st" id="yiyi-22"> <code class="descclassname">sys.</code><code class="descname">base_exec_prefix</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-23">在Python启动过程中，在<code class="docutils literal"><span class="pre">site.py</span></code>运行之前设置为与<a class="reference internal" href="#sys.exec_prefix" title="sys.exec_prefix"><code class="xref py py-data docutils literal"><span class="pre">exec_prefix</span></code></a>相同的值。</span><span class="yiyi-st" id="yiyi-24">如果不在<a class="reference internal" href="venv.html#venv-def"><span>virtual environment</span></a>中运行，则值将保持不变；如果<code class="docutils literal"><span class="pre">site.py</span></code>发现虚拟环境正在使用，则<a class="reference internal" href="#sys.prefix" title="sys.prefix"><code class="xref py py-data docutils literal"><span class="pre">prefix</span></code></a>和<a class="reference internal" href="#sys.exec_prefix" title="sys.exec_prefix"><code class="xref py py-data docutils literal"><span class="pre">exec_prefix</span></code></a>的值将更改为指向虚拟环境，而<a class="reference internal" href="#sys.base_prefix" title="sys.base_prefix"><code class="xref py py-data docutils literal"><span class="pre">base_prefix</span></code></a>和<a class="reference internal" href="#sys.base_exec_prefix" title="sys.base_exec_prefix"><code class="xref py py-data docutils literal"><span class="pre">base_exec_prefix</span></code></a>将保持指向基本Python安装（虚拟环境的创建源）。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-25"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="sys.base_prefix"><span class="yiyi-st" id="yiyi-26"> <code class="descclassname">sys.</code><code class="descname">base_prefix</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-27">在Python启动过程中，在<code class="docutils literal"><span class="pre">site.py</span></code>运行之前设置为与<a class="reference internal" href="#sys.prefix" title="sys.prefix"><code class="xref py py-data docutils literal"><span class="pre">prefix</span></code></a>相同的值。</span><span class="yiyi-st" id="yiyi-28">如果不在<a class="reference internal" href="venv.html#venv-def"><span>virtual environment</span></a>中运行，则值将保持不变；如果<code class="docutils literal"><span class="pre">site.py</span></code>发现虚拟环境正在使用，则<a class="reference internal" href="#sys.prefix" title="sys.prefix"><code class="xref py py-data docutils literal"><span class="pre">prefix</span></code></a>和<a class="reference internal" href="#sys.exec_prefix" title="sys.exec_prefix"><code class="xref py py-data docutils literal"><span class="pre">exec_prefix</span></code></a>的值将更改为指向虚拟环境，而<a class="reference internal" href="#sys.base_prefix" title="sys.base_prefix"><code class="xref py py-data docutils literal"><span class="pre">base_prefix</span></code></a>和<a class="reference internal" href="#sys.base_exec_prefix" title="sys.base_exec_prefix"><code class="xref py py-data docutils literal"><span class="pre">base_exec_prefix</span></code></a>将保持指向基本Python安装（虚拟环境的创建源）。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-29"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="sys.byteorder"><span class="yiyi-st" id="yiyi-30"> <code class="descclassname">sys.</code><code class="descname">byteorder</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-31">本地字节顺序的指示符。</span><span class="yiyi-st" id="yiyi-32">这将在big-endian（最重要的字节在前）平台上具有值<code class="docutils literal"><span class="pre">'big'</span></code>，而在little-endian（最低有效字节在先）上具有<code class="docutils literal"><span class="pre">'little'</span></code>平台。</span></p></dd></dl><dl class="data"><dt id="sys.builtin_module_names"><span class="yiyi-st" id="yiyi-33"> <code class="descclassname">sys.</code><code class="descname">builtin_module_names</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-34">一个字符串元组，给出了编译到这个Python解释器中的所有模块的名称。</span><span class="yiyi-st" id="yiyi-35">（该信息不能以其他方式提供 -  <code class="docutils literal"><span class="pre">modules.keys()</span></code>仅列出导入的模块。）</span></p></dd></dl><dl class="function"><dt id="sys.call_tracing"><span class="yiyi-st" id="yiyi-36"> <code class="descclassname">sys.</code><code class="descname">call_tracing</code><span class="sig-paren">(</span><em>func</em>, <em>args</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-37">在跟踪启用时调用<code class="docutils literal"><span class="pre">func(*args)</span></code>。</span><span class="yiyi-st" id="yiyi-38">跟踪状态被保存，并在之后恢复。</span><span class="yiyi-st" id="yiyi-39">这旨在从检查点的调试器调用，以递归调试其他代码。</span></p></dd></dl><dl class="data"><dt id="sys.copyright"><span class="yiyi-st" id="yiyi-40"> <code class="descclassname">sys.</code><code class="descname">copyright</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-41">包含与Python解释器相关的版权的字符串。</span></p></dd></dl><dl class="function"><dt id="sys._clear_type_cache"><span class="yiyi-st" id="yiyi-42"> <code class="descclassname">sys.</code><code class="descname">_clear_type_cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-43">清除内部类型缓存。</span><span class="yiyi-st" id="yiyi-44">The type cache is used to speed up attribute and method lookups.</span><span class="yiyi-st" id="yiyi-45">Use the function <em>only</em> to drop unnecessary references during reference leak debugging.</span></p><p><span class="yiyi-st" id="yiyi-46">This function should be used for internal and specialized purposes only.</span></p></dd></dl><dl class="function"><dt id="sys._current_frames"><span class="yiyi-st" id="yiyi-47"> <code class="descclassname">sys.</code><code class="descname">_current_frames</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-48">返回一个字典，该函数被调用时，将每个线程的标识符映射到当前在该线程中处于活动状态的最上面的堆栈帧。</span><span class="yiyi-st" id="yiyi-49">请注意，<a class="reference internal" href="traceback.html#module-traceback" title="traceback: Print or retrieve a stack traceback."><code class="xref py py-mod docutils literal"><span class="pre">traceback</span></code></a>模块中的函数可以构建给定这种帧的调用堆栈。</span></p><p><span class="yiyi-st" id="yiyi-50">这对于调试死锁非常有用：该函数不需要死锁线程的合作，只要这些线程的调用堆栈保持死锁状态，它们就会被冻结。</span><span class="yiyi-st" id="yiyi-51">在调用代码检查帧时，为非死锁线程返回的帧可能与该线程的当前活动无关。</span></p><p><span class="yiyi-st" id="yiyi-52">This function should be used for internal and specialized purposes only.</span></p></dd></dl><dl class="function"><dt id="sys._debugmallocstats"><span class="yiyi-st" id="yiyi-53"> <code class="descclassname">sys.</code><code class="descname">_debugmallocstats</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-54">打印低级别信息以了解CPython内存分配器的状态。</span></p><p><span class="yiyi-st" id="yiyi-55">如果Python配置了-with-pydebug，它还会执行一些昂贵的内部一致性检查。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-56"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-57"><strong>CPython implementation detail:</strong> This function is specific to CPython. </span><span class="yiyi-st" id="yiyi-58">确切的输出格式在这里没有定义，并且可能会改变。</span></p></div></dd></dl><dl class="data"><dt id="sys.dllhandle"><span class="yiyi-st" id="yiyi-59"> <code class="descclassname">sys.</code><code class="descname">dllhandle</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-60">整数指定Python DLL的句柄。</span><span class="yiyi-st" id="yiyi-61">可用性：Windows。</span></p></dd></dl><dl class="function"><dt id="sys.displayhook"><span class="yiyi-st" id="yiyi-62"> <code class="descclassname">sys.</code><code class="descname">displayhook</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-63">如果<em>值</em>不是<code class="docutils literal"><span class="pre">None</span></code>，则此函数将<code class="docutils literal"><span class="pre">repr(value)</span></code>打印到<code class="docutils literal"><span class="pre">sys.stdout</span></code>，并保存<em>值</em>在<code class="docutils literal"><span class="pre">builtins._</span></code>中。</span><span class="yiyi-st" id="yiyi-64">If <code class="docutils literal"><span class="pre">repr(value)</span></code> is not encodable to <code class="docutils literal"><span class="pre">sys.stdout.encoding</span></code> with <code class="docutils literal"><span class="pre">sys.stdout.errors</span></code> error handler (which is probably <code class="docutils literal"><span class="pre">'strict'</span></code>), encode it to <code class="docutils literal"><span class="pre">sys.stdout.encoding</span></code> with <code class="docutils literal"><span class="pre">'backslashreplace'</span></code> error handler.</span></p><p><span class="yiyi-st" id="yiyi-65"><code class="docutils literal"><span class="pre">sys.displayhook</span></code> is called on the result of evaluating an <a class="reference internal" href="../glossary.html#term-expression"><span class="xref std std-term">expression</span></a> entered in an interactive Python session. </span><span class="yiyi-st" id="yiyi-66">这些值的显示可以通过为<code class="docutils literal"><span class="pre">sys.displayhook</span></code>分配另一个参数来定制。</span></p><p><span class="yiyi-st" id="yiyi-67">伪代码：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">displayhook</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="c1"># Set '_' to None to avoid recursion</span>
    <span class="n">builtins</span><span class="o">.</span><span class="n">_</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">text</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
        <span class="nb">bytes</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="s1">'backslashreplace'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="s1">'buffer'</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="s1">'strict'</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
    <span class="n">builtins</span><span class="o">.</span><span class="n">_</span> <span class="o">=</span> <span class="n">value</span>
</code></pre><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-68"><span class="versionmodified">在版本3.2中更改：</span>在<a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeEncodeError</span></code></a>上使用<code class="docutils literal"><span class="pre">'backslashreplace'</span></code>错误处理程序。</span></p></div></dd></dl><dl class="data"><dt id="sys.dont_write_bytecode"><span class="yiyi-st" id="yiyi-69"> <code class="descclassname">sys.</code><code class="descname">dont_write_bytecode</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-70">如果这是真的，Python将不会尝试在导入源模块时编写<code class="docutils literal"><span class="pre">.pyc</span></code>文件。</span><span class="yiyi-st" id="yiyi-71">This value is initially set to <code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code> depending on the <a class="reference internal" href="../using/cmdline.html#cmdoption-B"><code class="xref std std-option docutils literal"><span class="pre">-B</span></code></a> command line option and the <span class="target" id="index-1"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> environment variable, but you can set it yourself to control bytecode file generation.</span></p></dd></dl><dl class="function"><dt id="sys.excepthook"><span class="yiyi-st" id="yiyi-72"> <code class="descclassname">sys.</code><code class="descname">excepthook</code><span class="sig-paren">(</span><em>type</em>, <em>value</em>, <em>traceback</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-73">这个函数打印出一个给定的回溯和例外情况给<code class="docutils literal"><span class="pre">sys.stderr</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-74">当引发异常并且未被捕获时，解释器使用三个参数调用<code class="docutils literal"><span class="pre">sys.excepthook</span></code>，异常类，异常实例和一个追踪对象。</span><span class="yiyi-st" id="yiyi-75">在交互式会话中，这恰好在控制返回提示之前发生；在一个Python程序中，这个就在程序退出之前发生。</span><span class="yiyi-st" id="yiyi-76">可以通过为<code class="docutils literal"><span class="pre">sys.excepthook</span></code>分配另一个三参数函数来自定义这些顶级异常的处理。</span></p></dd></dl><dl class="data"><dt id="sys.__displayhook__"><span class="yiyi-st" id="yiyi-77"> <code class="descclassname">sys.</code><code class="descname">__displayhook__</code></span></dt><dt id="sys.__excepthook__"><span class="yiyi-st" id="yiyi-78"> <code class="descclassname">sys.</code><code class="descname">__excepthook__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-79">这些对象在程序开始时包含<code class="docutils literal"><span class="pre">displayhook</span></code>和<code class="docutils literal"><span class="pre">excepthook</span></code>的原始值。</span><span class="yiyi-st" id="yiyi-80">它们被保存起来，以便在发生被破坏的对象替换时，可以恢复<code class="docutils literal"><span class="pre">displayhook</span></code>和<code class="docutils literal"><span class="pre">excepthook</span></code>。</span></p></dd></dl><dl class="function"><dt id="sys.exc_info"><span class="yiyi-st" id="yiyi-81"> <code class="descclassname">sys.</code><code class="descname">exc_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-82">这个函数返回一个包含三个值的元组，该元组提供有关当前正在处理的异常的信息。</span><span class="yiyi-st" id="yiyi-83">返回的信息既针对当前线程也针对当前堆栈帧。</span><span class="yiyi-st" id="yiyi-84">如果当前堆栈帧没有处理异常，则从调用堆栈帧或其调用者那里获取信息，直到找到处理异常的堆栈帧为止。</span><span class="yiyi-st" id="yiyi-85">这里，“处理异常”定义为“执行except子句”。对于任何堆栈帧，只能访问有关当前处理的异常的信息。</span></p><p id="index-2"><span class="yiyi-st" id="yiyi-86">如果堆栈中的任何位置没有异常处理，则返回包含三个<code class="docutils literal"><span class="pre">None</span></code>值的元组。</span><span class="yiyi-st" id="yiyi-87">否则，返回的值是<code class="docutils literal"><span class="pre">（type，</span> <span class="pre">value，</span> <span class="pre">traceback）</span></code>。</span><span class="yiyi-st" id="yiyi-88">Their meaning is: <em>type</em> gets the type of the exception being handled (a subclass of <a class="reference internal" href="exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a>); <em>value</em> gets the exception instance (an instance of the exception type); <em>traceback</em> gets a traceback object (see the Reference Manual) which encapsulates the call stack at the point where the exception originally occurred.</span></p></dd></dl><dl class="data"><dt id="sys.exec_prefix"><span class="yiyi-st" id="yiyi-89"> <code class="descclassname">sys.</code><code class="descname">exec_prefix</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">一个字符串，其中给出了特定于站点的目录前缀，其中安装了与平台相关的Python文件；默认情况下，这也是<code class="docutils literal"><span class="pre">'/usr/local'</span></code>。</span><span class="yiyi-st" id="yiyi-91">这可以在构建时使用<strong class="program">configure</strong>脚本的<code class="docutils literal"><span class="pre">--exec-prefix</span></code>参数进行设置。</span><span class="yiyi-st" id="yiyi-92">具体而言，所有配置文件（例如</span><span class="yiyi-st" id="yiyi-93">the <code class="file docutils literal"><span class="pre">pyconfig.h</span></code> header file) are installed in the directory <code class="file docutils literal"><em><span class="pre">exec_prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/config</span></code>, and shared library modules are installed in <code class="file docutils literal"><em><span class="pre">exec_prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/lib-dynload</span></code>, where <em>X.Y</em> is the version number of Python, for example <code class="docutils literal"><span class="pre">3.2</span></code>.</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-94">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-95">如果<a class="reference internal" href="venv.html#venv-def"><span>virtual environment</span></a>有效，则此值将在<code class="docutils literal"><span class="pre">site.py</span></code>中更改为指向虚拟环境。</span><span class="yiyi-st" id="yiyi-96">通过<a class="reference internal" href="#sys.base_exec_prefix" title="sys.base_exec_prefix"><code class="xref py py-data docutils literal"><span class="pre">base_exec_prefix</span></code></a>，Python安装的值仍然可用。</span></p></div></dd></dl><dl class="data"><dt id="sys.executable"><span class="yiyi-st" id="yiyi-97"> <code class="descclassname">sys.</code><code class="descname">executable</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-98">一个字符串，给出Python解释器的可执行二进制文件的绝对路径，在这种情况下是合理的。</span><span class="yiyi-st" id="yiyi-99">If Python is unable to retrieve the real path to its executable, <a class="reference internal" href="#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal"><span class="pre">sys.executable</span></code></a> will be an empty string or <code class="docutils literal"><span class="pre">None</span></code>.</span></p></dd></dl><dl class="function"><dt id="sys.exit"><span class="yiyi-st" id="yiyi-100"> <code class="descclassname">sys.</code><code class="descname">exit</code><span class="sig-paren">(</span><span class="optional">[</span><em>arg</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-101">从Python退出。</span><span class="yiyi-st" id="yiyi-102">这是通过引发<a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal"><span class="pre">SystemExit</span></code></a>异常实现的，因此可以使用由<a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>语句的finally子句指定的清理操作，并且可以在外层拦截退出尝试。</span></p><p><span class="yiyi-st" id="yiyi-103">可选参数<em>arg</em>可以是一个给出退出状态（默认为零）的整数或其他类型的对象。</span><span class="yiyi-st" id="yiyi-104">如果它是一个整数，零被认为是“成功终止”，并且任何非零值被shell等认为是“异常终止”。</span><span class="yiyi-st" id="yiyi-105">大多数系统要求它在0-127范围内，否则会产生未定义的结果。</span><span class="yiyi-st" id="yiyi-106">一些系统具有为特定退出代码分配特定含义的惯例，但这些通常是欠发达的； Unix程序通常使用2作为命令行语法错误，1使用其他类型的错误。</span><span class="yiyi-st" id="yiyi-107">如果传递另一种类型的对象，则<code class="docutils literal"><span class="pre">None</span></code>相当于传递零，并且任何其他对象都被打印到<a class="reference internal" href="#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">stderr</span></code></a>并导致退出代码为1。</span><span class="yiyi-st" id="yiyi-108">特别是，<code class="docutils literal"><span class="pre">sys.exit（“some</span> <span class="pre">error</span> <span class="pre">message”）</span></code>是退出程序的快速方法发生错误。</span></p><p><span class="yiyi-st" id="yiyi-109">由于<a class="reference internal" href="constants.html#exit" title="exit"><code class="xref py py-func docutils literal"><span class="pre">exit()</span></code></a>最终“唯一”引发了一个异常，它只会在从主线程调用时退出进程，并且异常不会被拦截。</span></p></dd></dl><dl class="data"><dt id="sys.flags"><span class="yiyi-st" id="yiyi-110"> <code class="descclassname">sys.</code><code class="descname">flags</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-111"><a class="reference internal" href="../glossary.html#term-struct-sequence"><span class="xref std std-term">struct sequence</span></a> <em>flags</em>暴露了命令行标志的状态。</span><span class="yiyi-st" id="yiyi-112">属性是只读的。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-113">属性</span></th><th class="head"><span class="yiyi-st" id="yiyi-114">旗</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-115"><code class="xref py py-const docutils literal"><span class="pre">debug</span></code></span></td><td><span class="yiyi-st" id="yiyi-116"><a class="reference internal" href="../using/cmdline.html#cmdoption-d"><code class="xref std std-option docutils literal"><span class="pre">-d</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-117"><a class="reference internal" href="inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-const docutils literal"><span class="pre">inspect</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-118"><a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal"><span class="pre">-i</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-119"><code class="xref py py-const docutils literal"><span class="pre">interactive</span></code></span></td><td><span class="yiyi-st" id="yiyi-120"><a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal"><span class="pre">-i</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-121"><code class="xref py py-const docutils literal"><span class="pre">optimize</span></code></span></td><td><span class="yiyi-st" id="yiyi-122"><a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal"><span class="pre">-O</span></code></a>或<a class="reference internal" href="../using/cmdline.html#cmdoption-OO"><code class="xref std std-option docutils literal"><span class="pre">-OO</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-123"><a class="reference internal" href="#sys.dont_write_bytecode" title="sys.dont_write_bytecode"><code class="xref py py-const docutils literal"><span class="pre">dont_write_bytecode</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-124"><a class="reference internal" href="../using/cmdline.html#cmdoption-B"><code class="xref std std-option docutils literal"><span class="pre">-B</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-125"><code class="xref py py-const docutils literal"><span class="pre">no_user_site</span></code></span></td><td><span class="yiyi-st" id="yiyi-126"><a class="reference internal" href="../using/cmdline.html#cmdoption-s"><code class="xref std std-option docutils literal"><span class="pre">-s</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-127"><code class="xref py py-const docutils literal"><span class="pre">no_site</span></code></span></td><td><span class="yiyi-st" id="yiyi-128"><a class="reference internal" href="../using/cmdline.html#cmdoption-S"><code class="xref std std-option docutils literal"><span class="pre">-S</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-129"><code class="xref py py-const docutils literal"><span class="pre">ignore_environment</span></code></span></td><td><span class="yiyi-st" id="yiyi-130"><a class="reference internal" href="../using/cmdline.html#cmdoption-E"><code class="xref std std-option docutils literal"><span class="pre">-E</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-131"><code class="xref py py-const docutils literal"><span class="pre">verbose</span></code></span></td><td><span class="yiyi-st" id="yiyi-132"><a class="reference internal" href="tarfile.html#cmdoption-v"><code class="xref std std-option docutils literal"><span class="pre">-v</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-133"><code class="xref py py-const docutils literal"><span class="pre">bytes_warning</span></code></span></td><td><span class="yiyi-st" id="yiyi-134"><a class="reference internal" href="../using/cmdline.html#cmdoption-b"><code class="xref std std-option docutils literal"><span class="pre">-b</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-135"><code class="xref py py-const docutils literal"><span class="pre">quiet</span></code></span></td><td><span class="yiyi-st" id="yiyi-136"><a class="reference internal" href="../using/cmdline.html#cmdoption-q"><code class="xref std std-option docutils literal"><span class="pre">-q</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-137"><code class="xref py py-const docutils literal"><span class="pre">hash_randomization</span></code></span></td><td><span class="yiyi-st" id="yiyi-138"><a class="reference internal" href="../using/cmdline.html#cmdoption-R"><code class="xref std std-option docutils literal"><span class="pre">-R</span></code></a></span></td></tr></tbody></table><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-139"><span class="versionmodified">在版本3.2中更改：</span>为新的<a class="reference internal" href="../using/cmdline.html#cmdoption-q"><code class="xref std std-option docutils literal"><span class="pre">-q</span></code></a>标志添加了<code class="docutils literal"><span class="pre">quiet</span></code>属性。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-140"><span class="versionmodified">版本3.2.3中的新功能：</span> <code class="docutils literal"><span class="pre">hash_randomization</span></code>属性。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-141"><span class="versionmodified">在版本3.3中更改：</span>删除了过时的<code class="docutils literal"><span class="pre">division_warning</span></code>属性。</span></p></div></dd></dl><dl class="data"><dt id="sys.float_info"><span class="yiyi-st" id="yiyi-142"> <code class="descclassname">sys.</code><code class="descname">float_info</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-143">包含关于浮点类型信息的<a class="reference internal" href="../glossary.html#term-struct-sequence"><span class="xref std std-term">struct sequence</span></a>。</span><span class="yiyi-st" id="yiyi-144">它包含有关精度和内部表示的低级信息。</span><span class="yiyi-st" id="yiyi-145">这些值对应于'C'编程语言的标准头文件<code class="file docutils literal"><span class="pre">float.h</span></code>中定义的各种浮点常量；有关详细信息，请参见1999 ISO / IEC C标准<a class="reference internal" href="#c99" id="id1">[C99]</a>，'浮点类型的特性'的5.2.4.2.2节。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-146">属性</span></th><th class="head"><span class="yiyi-st" id="yiyi-147">float.h宏</span></th><th class="head"><span class="yiyi-st" id="yiyi-148">说明</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-149"><code class="xref py py-const docutils literal"><span class="pre">epsilon</span></code></span></td><td><span class="yiyi-st" id="yiyi-150">DBL_EPSILON</span></td><td><span class="yiyi-st" id="yiyi-151">1和大于1的最小值之间的差值可以表示为浮点数</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-152"><code class="xref py py-const docutils literal"><span class="pre">dig</span></code></span></td><td><span class="yiyi-st" id="yiyi-153">DBL_DIG</span></td><td><span class="yiyi-st" id="yiyi-154">浮点数可以忠实地表示的最大小数位数；见下文</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-155"><code class="xref py py-const docutils literal"><span class="pre">mant_dig</span></code></span></td><td><span class="yiyi-st" id="yiyi-156">DBL_MANT_DIG</span></td><td><span class="yiyi-st" id="yiyi-157">float precision：float的有效位数中的base- <code class="docutils literal"><span class="pre">radix</span></code>数字的个数</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-158"><a class="reference internal" href="functions.html#max" title="max"><code class="xref py py-const docutils literal"><span class="pre">max</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-159">DBL_MAX</span></td><td><span class="yiyi-st" id="yiyi-160">最大可表示的有限浮点数</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-161"><code class="xref py py-const docutils literal"><span class="pre">max_exp</span></code></span></td><td><span class="yiyi-st" id="yiyi-162">DBL_MAX_EXP</span></td><td><span class="yiyi-st" id="yiyi-163">maximum integer e such that <code class="docutils literal"><span class="pre">radix**(e-1)</span></code> is a representable finite float</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-164"><code class="xref py py-const docutils literal"><span class="pre">max_10_exp</span></code></span></td><td><span class="yiyi-st" id="yiyi-165">DBL_MAX_10_EXP</span></td><td><span class="yiyi-st" id="yiyi-166">maximum integer e such that <code class="docutils literal"><span class="pre">10**e</span></code> is in the range of representable finite floats</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-167"><a class="reference internal" href="functions.html#min" title="min"><code class="xref py py-const docutils literal"><span class="pre">min</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-168">DBL_MIN</span></td><td><span class="yiyi-st" id="yiyi-169">最小正归一化浮点数</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-170"><code class="xref py py-const docutils literal"><span class="pre">min_exp</span></code></span></td><td><span class="yiyi-st" id="yiyi-171">DBL_MIN_EXP</span></td><td><span class="yiyi-st" id="yiyi-172">最小整数e使得<code class="docutils literal"><span class="pre">radix**(e-1)</span></code>是归一化的浮点数</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-173"><code class="xref py py-const docutils literal"><span class="pre">min_10_exp</span></code></span></td><td><span class="yiyi-st" id="yiyi-174">DBL_MIN_10_EXP</span></td><td><span class="yiyi-st" id="yiyi-175">最小整数e使得<code class="docutils literal"><span class="pre">10**e</span></code>是标准化的浮点数</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-176"><code class="xref py py-const docutils literal"><span class="pre">radix</span></code></span></td><td><span class="yiyi-st" id="yiyi-177">FLT_RADIX</span></td><td><span class="yiyi-st" id="yiyi-178">指数表示的基数</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-179"><code class="xref py py-const docutils literal"><span class="pre">rounds</span></code></span></td><td><span class="yiyi-st" id="yiyi-180">FLT_ROUNDS</span></td><td><span class="yiyi-st" id="yiyi-181">整数常量表示用于算术运算的舍入模式。</span><span class="yiyi-st" id="yiyi-182">这反映了解释器启动时系统FLT_ROUNDS宏的价值。</span><span class="yiyi-st" id="yiyi-183">有关可能值及其含义的解释，请参阅C99标准的5.2.4.2.2节。</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-184">属性<code class="xref py py-attr docutils literal"><span class="pre">sys.float_info.dig</span></code>需要进一步说明。</span><span class="yiyi-st" id="yiyi-185">如果<code class="docutils literal"><span class="pre">s</span></code>是表示至多<code class="xref py py-attr docutils literal"><span class="pre">sys.float_info.dig</span></code>有效数字的十进制数字的任何字符串，则将<code class="docutils literal"><span class="pre">s</span></code>转换为float并返回将恢复表示相同十进制值的字符串：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">dig</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">'3.14159265358979'</span>    <span class="c1"># decimal string with 15 significant digits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s1">'.15g'</span><span class="p">)</span>  <span class="c1"># convert to float and back -&gt; same value</span>
<span class="go">'3.14159265358979'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-186">但对于大于<code class="xref py py-attr docutils literal"><span class="pre">sys.float_info.dig</span></code>有效数字的字符串，情况并非总是如此：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">'9876543211234567'</span>    <span class="c1"># 16 significant digits is too many!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s1">'.16g'</span><span class="p">)</span>  <span class="c1"># conversion changes value</span>
<span class="go">'9876543211234568'</span>
</code></pre></dd></dl><dl class="data"><dt id="sys.float_repr_style"><span class="yiyi-st" id="yiyi-187"> <code class="descclassname">sys.</code><code class="descname">float_repr_style</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-188">一个字符串，指示<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>函数如何为浮点操作。</span><span class="yiyi-st" id="yiyi-189">If the string has value <code class="docutils literal"><span class="pre">'short'</span></code> then for a finite float <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">repr(x)</span></code> aims to produce a short string with the property that <code class="docutils literal"><span class="pre">float(repr(x))</span> <span class="pre">==</span> <span class="pre">x</span></code>. </span><span class="yiyi-st" id="yiyi-190">这是Python 3.1和更高版本中的常见行为。</span><span class="yiyi-st" id="yiyi-191">Otherwise, <code class="docutils literal"><span class="pre">float_repr_style</span></code> has value <code class="docutils literal"><span class="pre">'legacy'</span></code> and <code class="docutils literal"><span class="pre">repr(x)</span></code> behaves in the same way as it did in versions of Python prior to 3.1.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-192"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="sys.getallocatedblocks"><span class="yiyi-st" id="yiyi-193"> <code class="descclassname">sys.</code><code class="descname">getallocatedblocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-194">不管大小如何，都返回当前由解释器分配的内存块数量。</span><span class="yiyi-st" id="yiyi-195">此功能主要用于跟踪和调试内存泄漏。</span><span class="yiyi-st" id="yiyi-196">由于解释器的内部缓存，结果可能因呼叫而异；您可能需要调用<a class="reference internal" href="#sys._clear_type_cache" title="sys._clear_type_cache"><code class="xref py py-func docutils literal"><span class="pre">_clear_type_cache()</span></code></a>和<a class="reference internal" href="gc.html#gc.collect" title="gc.collect"><code class="xref py py-func docutils literal"><span class="pre">gc.collect()</span></code></a>以获得更多可预测的结果。</span></p><p><span class="yiyi-st" id="yiyi-197">If a Python build or implementation cannot reasonably compute this information, <a class="reference internal" href="#sys.getallocatedblocks" title="sys.getallocatedblocks"><code class="xref py py-func docutils literal"><span class="pre">getallocatedblocks()</span></code></a> is allowed to return 0 instead.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-198"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="sys.getcheckinterval"><span class="yiyi-st" id="yiyi-199"> <code class="descclassname">sys.</code><code class="descname">getcheckinterval</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-200">返回解释器的“检查间隔”；请参阅<a class="reference internal" href="#sys.setcheckinterval" title="sys.setcheckinterval"><code class="xref py py-func docutils literal"><span class="pre">setcheckinterval()</span></code></a>。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-201"><span class="versionmodified">从版本3.2开始弃用：</span>改为使用<a class="reference internal" href="#sys.getswitchinterval" title="sys.getswitchinterval"><code class="xref py py-func docutils literal"><span class="pre">getswitchinterval()</span></code></a>。</span></p></div></dd></dl><dl class="function"><dt id="sys.getdefaultencoding"><span class="yiyi-st" id="yiyi-202"> <code class="descclassname">sys.</code><code class="descname">getdefaultencoding</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-203">返回Unicode实现使用的当前默认字符串编码的名称。</span></p></dd></dl><dl class="function"><dt id="sys.getdlopenflags"><span class="yiyi-st" id="yiyi-204"> <code class="descclassname">sys.</code><code class="descname">getdlopenflags</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-205">返回用于<code class="xref c c-func docutils literal"><span class="pre">dlopen()</span></code>调用的标志的当前值。</span><span class="yiyi-st" id="yiyi-206">Symbolic names for the flag values can be found in the <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> module (<code class="docutils literal"><span class="pre">RTLD_xxx</span></code> constants, e.g. </span><span class="yiyi-st" id="yiyi-207"><a class="reference internal" href="os.html#os.RTLD_LAZY" title="os.RTLD_LAZY"><code class="xref py py-data docutils literal"><span class="pre">os.RTLD_LAZY</span></code></a></span><span class="yiyi-st" id="yiyi-208">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="sys.getfilesystemencoding"><span class="yiyi-st" id="yiyi-209"> <code class="descclassname">sys.</code><code class="descname">getfilesystemencoding</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-210">返回用于将Unicode文件名转换为系统文件名的编码名称。</span><span class="yiyi-st" id="yiyi-211">结果值取决于操作系统：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-212">在Mac OS X上，编码是<code class="docutils literal"><span class="pre">'utf-8'</span></code>。</span></li><li><span class="yiyi-st" id="yiyi-213">在Unix上，根据nl_langinfo（CODESET）的结果，编码是用户的偏好。</span></li><li><span class="yiyi-st" id="yiyi-214">在Windows NT +上，文件名本身是Unicode，因此不执行转换。</span><span class="yiyi-st" id="yiyi-215"><a class="reference internal" href="#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal"><span class="pre">getfilesystemencoding()</span></code></a> still returns <code class="docutils literal"><span class="pre">'mbcs'</span></code>, as this is the encoding that applications should use when they explicitly want to convert Unicode strings to byte strings that are equivalent when used as file names.</span></li><li><span class="yiyi-st" id="yiyi-216">在Windows 9x上，编码是<code class="docutils literal"><span class="pre">'mbcs'</span></code>。</span></li></ul><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-217"><span class="versionmodified">在版本3.2中更改：</span> <a class="reference internal" href="#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal"><span class="pre">getfilesystemencoding()</span></code></a>结果不能再<code class="docutils literal"><span class="pre">None</span></code>。</span></p></div></dd></dl><dl class="function"><dt id="sys.getrefcount"><span class="yiyi-st" id="yiyi-218"> <code class="descclassname">sys.</code><code class="descname">getrefcount</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-219">返回<em>对象</em>的引用计数。</span><span class="yiyi-st" id="yiyi-220">返回的计数通常比您预期的要高，因为它包含（临时）引用作为<a class="reference internal" href="#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal"><span class="pre">getrefcount()</span></code></a>的参数。</span></p></dd></dl><dl class="function"><dt id="sys.getrecursionlimit"><span class="yiyi-st" id="yiyi-221"> <code class="descclassname">sys.</code><code class="descname">getrecursionlimit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-222">返回递归限制的当前值，即Python解释器堆栈的最大深度。</span><span class="yiyi-st" id="yiyi-223">此限制可防止无限递归导致C堆栈溢出并导致Python崩溃。</span><span class="yiyi-st" id="yiyi-224">它可以由<a class="reference internal" href="#sys.setrecursionlimit" title="sys.setrecursionlimit"><code class="xref py py-func docutils literal"><span class="pre">setrecursionlimit()</span></code></a>设置。</span></p></dd></dl><dl class="function"><dt id="sys.getsizeof"><span class="yiyi-st" id="yiyi-225"> <code class="descclassname">sys.</code><code class="descname">getsizeof</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-226">以字节为单位返回对象的大小。</span><span class="yiyi-st" id="yiyi-227">该对象可以是任何类型的对象。</span><span class="yiyi-st" id="yiyi-228">所有内置对象都会返回正确的结果，但这不一定适用于第三方扩展，因为它是特定于实现的。</span></p><p><span class="yiyi-st" id="yiyi-229">只考虑直接归因于该对象的内存消耗，而不考虑其引用的对象的内存消耗。</span></p><p><span class="yiyi-st" id="yiyi-230">如果给定，如果对象不提供检索大小的方法，则将返回<em>默认</em>。</span><span class="yiyi-st" id="yiyi-231">否则会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-232"><a class="reference internal" href="#sys.getsizeof" title="sys.getsizeof"><code class="xref py py-func docutils literal"><span class="pre">getsizeof()</span></code></a>调用对象的<code class="docutils literal"><span class="pre">__sizeof__</span></code>方法，如果对象由垃圾收集器管理，则会添加额外的垃圾回收器开销。</span></p><p><span class="yiyi-st" id="yiyi-233">递归地使用<a class="reference internal" href="#sys.getsizeof" title="sys.getsizeof"><code class="xref py py-func docutils literal"><span class="pre">getsizeof()</span></code></a>的示例参见<a class="reference external" href="https://code.activestate.com/recipes/577504">递归sizeof recipe</a>以查找容器及其所有内容的大小。</span></p></dd></dl><dl class="function"><dt id="sys.getswitchinterval"><span class="yiyi-st" id="yiyi-234"> <code class="descclassname">sys.</code><code class="descname">getswitchinterval</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-235">返回解释器的“线程切换间隔”；请参阅<a class="reference internal" href="#sys.setswitchinterval" title="sys.setswitchinterval"><code class="xref py py-func docutils literal"><span class="pre">setswitchinterval()</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-236"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="sys._getframe"><span class="yiyi-st" id="yiyi-237"> <code class="descclassname">sys.</code><code class="descname">_getframe</code><span class="sig-paren">(</span><span class="optional">[</span><em>depth</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-238">从调用堆栈中返回一个框架对象。</span><span class="yiyi-st" id="yiyi-239">如果给出了可选的整数<em>depth</em>，则将多个调用的帧对象返回到堆栈顶部以下。</span><span class="yiyi-st" id="yiyi-240">如果这比调用堆栈更深，则引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span><span class="yiyi-st" id="yiyi-241"><em>depth</em>的默认值为零，返回调用堆栈顶部的帧。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-242"><strong>CPython implementation detail:</strong> This function should be used for internal and specialized purposes only. </span><span class="yiyi-st" id="yiyi-243">不能保证在Python的所有实现中都存在。</span></p></div></dd></dl><dl class="function"><dt id="sys.getprofile"><span class="yiyi-st" id="yiyi-244"> <code class="descclassname">sys.</code><code class="descname">getprofile</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p id="index-3"><span class="yiyi-st" id="yiyi-245">Get the profiler function as set by <a class="reference internal" href="#sys.setprofile" title="sys.setprofile"><code class="xref py py-func docutils literal"><span class="pre">setprofile()</span></code></a>.</span></p></dd></dl><dl class="function"><dt id="sys.gettrace"><span class="yiyi-st" id="yiyi-246"> <code class="descclassname">sys.</code><code class="descname">gettrace</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p id="index-4"><span class="yiyi-st" id="yiyi-247">获取由<a class="reference internal" href="#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal"><span class="pre">settrace()</span></code></a>设置的跟踪函数。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-248"><strong>CPython实现细节</strong> <a class="reference internal" href="#sys.gettrace" title="sys.gettrace"><code class="xref py py-func docutils literal"><span class="pre">gettrace()</span></code></a>函数仅用于实现调试器，分析器，覆盖工具等。</span><span class="yiyi-st" id="yiyi-249">它的行为是实现平台的一部分，而不是语言定义的一部分，因此可能不适用于所有Python实现。</span></p></div></dd></dl><dl class="function"><dt id="sys.getwindowsversion"><span class="yiyi-st" id="yiyi-250"> <code class="descclassname">sys.</code><code class="descname">getwindowsversion</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-251">返回描述当前正在运行的Windows版本的命名元组。</span><span class="yiyi-st" id="yiyi-252">The named elements are <em>major</em>, <em>minor</em>, <em>build</em>, <em>platform</em>, <em>service_pack</em>, <em>service_pack_minor</em>, <em>service_pack_major</em>, <em>suite_mask</em>, and <em>product_type</em>. </span><span class="yiyi-st" id="yiyi-253"><em>service_pack</em>包含一个字符串，而其他所有值都是整数。</span><span class="yiyi-st" id="yiyi-254">组件也可以按名称访问，所以<code class="docutils literal"><span class="pre">sys.getwindowsversion()[0]</span></code>等同于<code class="docutils literal"><span class="pre">sys.getwindowsversion().major</span></code>。</span><span class="yiyi-st" id="yiyi-255">为了与先前版本兼容，只有前5个元素可通过索引检索。</span></p><p><span class="yiyi-st" id="yiyi-256"><em>平台</em>可能是下列其中一个值：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-257">不变</span></th><th class="head"><span class="yiyi-st" id="yiyi-258">平台</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-259"><code class="xref py py-const docutils literal"><span class="pre">0</span> <span class="pre">（VER_PLATFORM_WIN32s）</span></code></span></td><td><span class="yiyi-st" id="yiyi-260">Windows 3.1上的Win32s</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-261"><code class="xref py py-const docutils literal"><span class="pre">1</span> <span class="pre">（VER_PLATFORM_WIN32_WINDOWS）</span></code></span></td><td><span class="yiyi-st" id="yiyi-262">Windows 95/98 / ME</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-263"><code class="xref py py-const docutils literal"><span class="pre">2</span> <span class="pre">（VER_PLATFORM_WIN32_NT）</span></code></span></td><td><span class="yiyi-st" id="yiyi-264">Windows NT / 2000 / XP / x64</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-265"><code class="xref py py-const docutils literal"><span class="pre">3</span> <span class="pre">（VER_PLATFORM_WIN32_CE）</span></code></span></td><td><span class="yiyi-st" id="yiyi-266">Windows CE</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-267"><em>product_type</em>可能是以下值之一：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-268">不变</span></th><th class="head"><span class="yiyi-st" id="yiyi-269">含义</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-270"><code class="xref py py-const docutils literal"><span class="pre">1</span> <span class="pre">（VER_NT_WORKSTATION）</span></code></span></td><td><span class="yiyi-st" id="yiyi-271">该系统是一个工作站。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-272"><code class="xref py py-const docutils literal"><span class="pre">2</span> <span class="pre">（VER_NT_DOMAIN_CONTROLLER）</span></code></span></td><td><span class="yiyi-st" id="yiyi-273">该系统是一个域控制器。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-274"><code class="xref py py-const docutils literal"><span class="pre">3</span> <span class="pre">（VER_NT_SERVER）</span></code></span></td><td><span class="yiyi-st" id="yiyi-275">该系统是一个服务器，但不是域控制器。</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-276">此函数包装Win32 <code class="xref c c-func docutils literal"><span class="pre">GetVersionEx()</span></code>函数；有关这些字段的更多信息，请参阅<code class="xref c c-func docutils literal"><span class="pre">OSVERSIONINFOEX()</span></code>上的Microsoft文档。</span></p><p><span class="yiyi-st" id="yiyi-277">可用性：Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-278"><span class="versionmodified">版本3.2中的变化：</span>变成一个命名元组，并添加<em>service_pack_minor</em>、<em>service_pack_major</em>、 <em>suite_mask</em>和<em>product_type</em>。</span></p></div></dd></dl><dl class="function"><dt id="sys.get_coroutine_wrapper"><span class="yiyi-st" id="yiyi-279"> <code class="descclassname">sys.</code><code class="descname">get_coroutine_wrapper</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-280">返回<code class="docutils literal"><span class="pre">None</span></code>，或由<a class="reference internal" href="#sys.set_coroutine_wrapper" title="sys.set_coroutine_wrapper"><code class="xref py py-func docutils literal"><span class="pre">set_coroutine_wrapper()</span></code></a>设置的包装器。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-281"><span class="versionmodified">版本3.5中的新功能：</span>了解更多详情，请参阅<span class="target" id="index-5"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-282">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-283">此功能暂时添加（详情请参阅<span class="target" id="index-6"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0411"><strong>PEP 411</strong></a>）。</span><span class="yiyi-st" id="yiyi-284">仅用于调试目的。</span></p></div></dd></dl><dl class="data"><dt id="sys.hash_info"><span class="yiyi-st" id="yiyi-285"> <code class="descclassname">sys.</code><code class="descname">hash_info</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-286">给出数字散列实现参数的<a class="reference internal" href="../glossary.html#term-struct-sequence"><span class="xref std std-term">struct sequence</span></a>。</span><span class="yiyi-st" id="yiyi-287">有关数字类型散列的更多详细信息，请参阅<a class="reference internal" href="stdtypes.html#numeric-hash"><span>Hashing of numeric types</span></a>。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-288">属性</span></th><th class="head"><span class="yiyi-st" id="yiyi-289">说明</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-290"><code class="xref py py-const docutils literal"><span class="pre">width</span></code></span></td><td><span class="yiyi-st" id="yiyi-291">用于散列值的位宽</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-292"><code class="xref py py-const docutils literal"><span class="pre">modulus</span></code></span></td><td><span class="yiyi-st" id="yiyi-293">用于数字哈希方案的素数模数P.</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-294"><code class="xref py py-const docutils literal"><span class="pre">inf</span></code></span></td><td><span class="yiyi-st" id="yiyi-295">哈希值返回正无穷大</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-296"><code class="xref py py-const docutils literal"><span class="pre">nan</span></code></span></td><td><span class="yiyi-st" id="yiyi-297">哈希值返回一个南</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-298"><code class="xref py py-const docutils literal"><span class="pre">imag</span></code></span></td><td><span class="yiyi-st" id="yiyi-299">乘数用于复数的虚部</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-300"><code class="xref py py-const docutils literal"><span class="pre">algorithm</span></code></span></td><td><span class="yiyi-st" id="yiyi-301">str，字节和内存视图散列算法的名称</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-302"><code class="xref py py-const docutils literal"><span class="pre">hash_bits</span></code></span></td><td><span class="yiyi-st" id="yiyi-303">哈希算法的内部输出大小</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-304"><code class="xref py py-const docutils literal"><span class="pre">seed_bits</span></code></span></td><td><span class="yiyi-st" id="yiyi-305">散列算法的种子密钥的大小</span></td></tr></tbody></table><div class="versionadded"><p><span class="yiyi-st" id="yiyi-306"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-307"><span class="versionmodified">在版本3.4中改变：</span>添加了<em>算法</em>，<em>hash_bits</em>和<em>seed_bits</em></span></p></div></dd></dl><dl class="data"><dt id="sys.hexversion"><span class="yiyi-st" id="yiyi-308"> <code class="descclassname">sys.</code><code class="descname">hexversion</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-309">版本号编码为单个整数。</span><span class="yiyi-st" id="yiyi-310">每个版本都有保证，包括适当支持非生产版本。</span><span class="yiyi-st" id="yiyi-311">例如，要测试Python解释器的版本是否至少为1.5.2，请使用：</span></p><pre><code class="language-python"><span></span><span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">hexversion</span> <span class="o">&gt;=</span> <span class="mh">0x010502F0</span><span class="p">:</span>
    <span class="c1"># use some advanced feature</span>
    <span class="o">...</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># use an alternative implementation or warn the user</span>
    <span class="o">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-312">这被称为<code class="docutils literal"><span class="pre">hexversion</span></code>，因为只有当它传递给内置的<a class="reference internal" href="functions.html#hex" title="hex"><code class="xref py py-func docutils literal"><span class="pre">hex()</span></code></a>函数时才会看起来很有意义。</span><span class="yiyi-st" id="yiyi-313"><a class="reference internal" href="../glossary.html#term-struct-sequence"><span class="xref std std-term">struct sequence</span></a> <a class="reference internal" href="#sys.version_info" title="sys.version_info"><code class="xref py py-data docutils literal"><span class="pre">sys.version_info</span></code></a>可用于对相同信息进行更人性化的编码。</span></p><p><span class="yiyi-st" id="yiyi-314">在<a class="reference internal" href="../c-api/apiabiversion.html#apiabiversion"><span>API and ABI Versioning</span></a>中可以找到<code class="docutils literal"><span class="pre">hexversion</span></code>的更多详细信息。</span></p></dd></dl><dl class="data"><dt id="sys.implementation"><span class="yiyi-st" id="yiyi-315"> <code class="descclassname">sys.</code><code class="descname">implementation</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-316">包含有关当前正在运行的Python解释器的实现信息的对象。</span><span class="yiyi-st" id="yiyi-317">所有Python实现中都需要以下属性。</span></p><p><span class="yiyi-st" id="yiyi-318"><em>name</em>是实现的标识符，例如</span><span class="yiyi-st" id="yiyi-319"><code class="docutils literal"><span class="pre">'cpython'</span></code></span><span class="yiyi-st" id="yiyi-320">实际的字符串由Python实现定义，但保证为小写。</span></p><p><span class="yiyi-st" id="yiyi-321"><em>version</em>是一个命名元组，格式与<a class="reference internal" href="#sys.version_info" title="sys.version_info"><code class="xref py py-data docutils literal"><span class="pre">sys.version_info</span></code></a>相同。</span><span class="yiyi-st" id="yiyi-322">它代表Python <em>实现</em>的版本。</span><span class="yiyi-st" id="yiyi-323">这与当前正在运行的解释器符合的特定版本的Python <em>语言</em>有明确的含义，<code class="docutils literal"><span class="pre">sys.version_info</span></code>表示。</span><span class="yiyi-st" id="yiyi-324">For example, for PyPy 1.8 <code class="docutils literal"><span class="pre">sys.implementation.version</span></code> might be <code class="docutils literal"><span class="pre">sys.version_info(1,</span> <span class="pre">8,</span> <span class="pre">0,</span> <span class="pre">'final',</span> <span class="pre">0)</span></code>, whereas <code class="docutils literal"><span class="pre">sys.version_info</span></code> would be <code class="docutils literal"><span class="pre">sys.version_info(2,</span> <span class="pre">7,</span> <span class="pre">2,</span> <span class="pre">'final',</span> <span class="pre">0)</span></code>. </span><span class="yiyi-st" id="yiyi-325">对于CPython，它们具有相同的价值，因为它是参考实现。</span></p><p><span class="yiyi-st" id="yiyi-326"><em>hexversion</em>是十六进制格式的实现版本，如<a class="reference internal" href="#sys.hexversion" title="sys.hexversion"><code class="xref py py-data docutils literal"><span class="pre">sys.hexversion</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-327"><em>cache_tag</em>是导入机制在缓存模块的文件名中使用的标签。</span><span class="yiyi-st" id="yiyi-328">按照惯例，它将是实现名称和版本的组合，如<code class="docutils literal"><span class="pre">'cpython-33'</span></code>。</span><span class="yiyi-st" id="yiyi-329">但是，如果合适，Python实现可能会使用其他值。</span><span class="yiyi-st" id="yiyi-330">如果<code class="docutils literal"><span class="pre">cache_tag</span></code>设置为<code class="docutils literal"><span class="pre">None</span></code>，则表示应禁用模块缓存。</span></p><p><span class="yiyi-st" id="yiyi-331"><a class="reference internal" href="#sys.implementation" title="sys.implementation"><code class="xref py py-data docutils literal"><span class="pre">sys.implementation</span></code></a>可能包含特定于Python实现的其他属性。</span><span class="yiyi-st" id="yiyi-332">这些非标准属性必须以下划线开头，这里不再描述。</span><span class="yiyi-st" id="yiyi-333">Regardless of its contents, <a class="reference internal" href="#sys.implementation" title="sys.implementation"><code class="xref py py-data docutils literal"><span class="pre">sys.implementation</span></code></a> will not change during a run of the interpreter, nor between implementation versions. </span><span class="yiyi-st" id="yiyi-334">（然而，它可能会在Python语言版本之间改变。）</span><span class="yiyi-st" id="yiyi-335">有关更多信息，请参见<span class="target" id="index-7"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0421"><strong>PEP 421</strong></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-336"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="sys.int_info"><span class="yiyi-st" id="yiyi-337"> <code class="descclassname">sys.</code><code class="descname">int_info</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-338">一个<a class="reference internal" href="../glossary.html#term-struct-sequence"><span class="xref std std-term">struct sequence</span></a>，它包含关于Python内部整数表示的信息。</span><span class="yiyi-st" id="yiyi-339">属性是只读的。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-340">属性</span></th><th class="head"><span class="yiyi-st" id="yiyi-341">说明</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-342"><code class="xref py py-const docutils literal"><span class="pre">bits_per_digit</span></code></span></td><td><span class="yiyi-st" id="yiyi-343">每位数字中保存的位数。</span><span class="yiyi-st" id="yiyi-344">Python整数存储在内部<code class="docutils literal"><span class="pre">2**int_info.bits_per_digit</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-345"><code class="xref py py-const docutils literal"><span class="pre">sizeof_digit</span></code></span></td><td><span class="yiyi-st" id="yiyi-346">用于表示数字的C类型的字节大小</span></td></tr></tbody></table><div class="versionadded"><p><span class="yiyi-st" id="yiyi-347"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="sys.__interactivehook__"><span class="yiyi-st" id="yiyi-348"> <code class="descclassname">sys.</code><code class="descname">__interactivehook__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-349">当该属性存在时，当解释器以<a class="reference internal" href="../tutorial/interpreter.html#tut-interactive"><span>interactive mode</span></a>启动时，它的值会自动调用（不带参数）。</span><span class="yiyi-st" id="yiyi-350">这是在读取<span class="target" id="index-8"></span> <a class="reference internal" href="../using/cmdline.html#envvar-PYTHONSTARTUP"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONSTARTUP</span></code></a>文件之后完成的，以便您可以在此处设置此钩子。</span><span class="yiyi-st" id="yiyi-351"><a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal"><span class="pre">site</span></code></a>模块<a class="reference internal" href="site.html#rlcompleter-config"><span>sets this</span></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-352"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="sys.intern"><span class="yiyi-st" id="yiyi-353"> <code class="descclassname">sys.</code><code class="descname">intern</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-354">在“interned”字符串表中输入<em>字符串</em>，并返回字符串 -  <em>字符串</em>本身或副本。</span><span class="yiyi-st" id="yiyi-355">实习字符串对于在字典查找中获得一些性能很有用 - 如果字典中的密钥被实施并且查找密钥被实施，则可以通过指针比较而不是字符串比较来完成关键比较（哈希后）。</span><span class="yiyi-st" id="yiyi-356">通常情况下，Python程序中使用的名称会自动实现，并且用于保存模块，类或实例属性的字典具有实际的密钥。</span></p><p><span class="yiyi-st" id="yiyi-357">Interned字符串不是不朽的；你必须保持对<a class="reference internal" href="#sys.intern" title="sys.intern"><code class="xref py py-func docutils literal"><span class="pre">intern()</span></code></a>的返回值的引用，才能从中受益。</span></p></dd></dl><dl class="function"><dt id="sys.is_finalizing"><span class="yiyi-st" id="yiyi-358"> <code class="descclassname">sys.</code><code class="descname">is_finalizing</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-359">如果Python解释器<a class="reference internal" href="../glossary.html#term-interpreter-shutdown"><span class="xref std std-term">shutting down</span></a>，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>，否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-360"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="sys.last_type"><span class="yiyi-st" id="yiyi-361"> <code class="descclassname">sys.</code><code class="descname">last_type</code></span></dt><dt id="sys.last_value"><span class="yiyi-st" id="yiyi-362"> <code class="descclassname">sys.</code><code class="descname">last_value</code></span></dt><dt id="sys.last_traceback"><span class="yiyi-st" id="yiyi-363"> <code class="descclassname">sys.</code><code class="descname">last_traceback</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-364">这三个变量并不总是被定义的；它们在未处理异常时设置，并且解释器打印错误消息和堆栈回溯。</span><span class="yiyi-st" id="yiyi-365">它们的预期用途是允许交互式用户导入调试器模块并进行事后调试，而不必重新执行导致错误的命令。</span><span class="yiyi-st" id="yiyi-366">(Typical use is <code class="docutils literal"><span class="pre">import</span> <span class="pre">pdb;</span> <span class="pre">pdb.pm()</span></code> to enter the post-mortem debugger; see <a class="reference internal" href="pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal"><span class="pre">pdb</span></code></a> module for more information.)</span></p><p><span class="yiyi-st" id="yiyi-367">变量的含义与上面<a class="reference internal" href="#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">exc_info()</span></code></a>中返回值的含义相同。</span></p></dd></dl><dl class="data"><dt id="sys.maxsize"><span class="yiyi-st" id="yiyi-368"> <code class="descclassname">sys.</code><code class="descname">maxsize</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-369">一个给出最大值的整数是一个<code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code>类型的变量。</span><span class="yiyi-st" id="yiyi-370">在32位平台上通常是<code class="docutils literal"><span class="pre">2 ** 31</span> <span class="pre"> - </span> <span class="pre">1</span></code>和<code class="docutils literal"><span class="pre">2 ** 63</span> <span class="pre"> - </span> <span class="pre">1</span></code>在64位平台上。</span></p></dd></dl><dl class="data"><dt id="sys.maxunicode"><span class="yiyi-st" id="yiyi-371"> <code class="descclassname">sys.</code><code class="descname">maxunicode</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-372">一个给出最大Unicode码点值的整数，即</span><span class="yiyi-st" id="yiyi-373"><code class="docutils literal"><span class="pre">1114111</span></code>（<code class="docutils literal"><span class="pre">0x10FFFF</span></code>，十六进制）。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-374"><span class="versionmodified">Changed in version 3.3: </span>Before <span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a>, <code class="docutils literal"><span class="pre">sys.maxunicode</span></code> used to be either <code class="docutils literal"><span class="pre">0xFFFF</span></code> or <code class="docutils literal"><span class="pre">0x10FFFF</span></code>, depending on the configuration option that specified whether Unicode characters were stored as UCS-2 or UCS-4.</span></p></div></dd></dl><dl class="data"><dt id="sys.meta_path"><span class="yiyi-st" id="yiyi-375"> <code class="descclassname">sys.</code><code class="descname">meta_path</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-376">调用其<a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>方法的<a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a>对象的列表，以查看其中一个对象是否可以找到要导入的模块。</span><span class="yiyi-st" id="yiyi-377">至少调用正在导入的模块的绝对名称来调用<a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>方法。</span><span class="yiyi-st" id="yiyi-378">如果要导入的模块包含在包中，则父包的<a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal"><span class="pre">__path__</span></code></a>属性将作为第二个参数传入。</span><span class="yiyi-st" id="yiyi-379">如果找不到模块，该方法将返回<a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">module spec</span></a>或<code class="docutils literal"><span class="pre">None</span></code>。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-380">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-381"><a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.MetaPathFinder</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-382">抽象基类定义<a class="reference internal" href="#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">meta_path</span></code></a>上的查找器对象的接口。</span></dd><dt><span class="yiyi-st" id="yiyi-383"><a class="reference internal" href="importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal"><span class="pre">importlib.machinery.ModuleSpec</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-384">The concrete class which <a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> should return instances of.</span></dd></dl></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-385"><span class="versionmodified">版本3.4中改变：</span> <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">Module specs</span></a>是在Python 3.4中由<span class="target" id="index-10"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a>引入的。</span><span class="yiyi-st" id="yiyi-386">早期版本的Python寻找一种名为<a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder.find_module" title="importlib.abc.MetaPathFinder.find_module"><code class="xref py py-meth docutils literal"><span class="pre">find_module()</span></code></a>的方法。</span><span class="yiyi-st" id="yiyi-387">如果<a class="reference internal" href="#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">meta_path</span></code></a>条目没有<a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>方法，这仍然称为后备。</span></p></div></dd></dl><dl class="data"><dt id="sys.modules"><span class="yiyi-st" id="yiyi-388"> <code class="descclassname">sys.</code><code class="descname">modules</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-389">这是一个将模块名称映射到已经加载的模块的字典。</span><span class="yiyi-st" id="yiyi-390">这可以被操纵来强制重新加载模块和其他技巧。</span><span class="yiyi-st" id="yiyi-391">但是，替换字典并不一定按预期工作，并且从字典中删除基本项目可能会导致Python失败。</span></p></dd></dl><dl class="data"><dt id="sys.path"><span class="yiyi-st" id="yiyi-392"> <code class="descclassname">sys.</code><code class="descname">path</code></span></dt><dd><p id="index-11"><span class="yiyi-st" id="yiyi-393">指定模块搜索路径的字符串列表。</span><span class="yiyi-st" id="yiyi-394">从环境变量<span class="target" id="index-12"></span> <a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></code></a>初始化，加上依赖于安装的缺省值。</span></p><p><span class="yiyi-st" id="yiyi-395">正如在程序启动时初始化的那样，这个列表的第一个项目<code class="docutils literal"><span class="pre">path[0]</span></code>是包含用于调用Python解释器的脚本的目录。</span><span class="yiyi-st" id="yiyi-396">如果脚本目录不可用（例如，</span><span class="yiyi-st" id="yiyi-397">如果解释器是交互式调用的，或者脚本是从标准输入读取的），那么<code class="docutils literal"><span class="pre">path[0]</span></code>是空字符串，它指示Python首先在当前目录中搜索模块。</span><span class="yiyi-st" id="yiyi-398">请注意，由于<span class="target" id="index-13"></span> <a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></code></a>插入的条目之前，脚本目录被插入<em>中。</em></span></p><p><span class="yiyi-st" id="yiyi-399">一个程序可以根据自己的目的自由修改这个列表。</span><span class="yiyi-st" id="yiyi-400">只有字符串和字节应该添加到<a class="reference internal" href="#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a>；导入时忽略所有其他数据类型。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-401">也可以看看</span></p><p class="last"><span class="yiyi-st" id="yiyi-402">模块<a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal"><span class="pre">site</span></code></a>这描述了如何使用.pth文件来扩展<a class="reference internal" href="#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a>。</span></p></div></dd></dl><dl class="data"><dt id="sys.path_hooks"><span class="yiyi-st" id="yiyi-403"> <code class="descclassname">sys.</code><code class="descname">path_hooks</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-404">可以使用路径参数尝试为路径创建<a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a>的可调用列表。</span><span class="yiyi-st" id="yiyi-405">如果可以创建查找器，它将由可调用对象返回，否则引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-406">最初在<span class="target" id="index-14"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>中指定。</span></p></dd></dl><dl class="data"><dt id="sys.path_importer_cache"><span class="yiyi-st" id="yiyi-407"> <code class="descclassname">sys.</code><code class="descname">path_importer_cache</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-408">作为<a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a>对象缓存的字典。</span><span class="yiyi-st" id="yiyi-409">键是已经传递给<a class="reference internal" href="#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a>的路径，值是找到的查找器。</span><span class="yiyi-st" id="yiyi-410">如果一个路径是一个有效的文件系统路径，但是在<a class="reference internal" href="#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a>上没有找到finder，则存储<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-411">最初在<span class="target" id="index-15"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>中指定。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-412"><span class="versionmodified">Changed in version 3.3: </span><code class="docutils literal"><span class="pre">None</span></code> is stored instead of <a class="reference internal" href="imp.html#imp.NullImporter" title="imp.NullImporter"><code class="xref py py-class docutils literal"><span class="pre">imp.NullImporter</span></code></a> when no finder is found.</span></p></div></dd></dl><dl class="data"><dt id="sys.platform"><span class="yiyi-st" id="yiyi-413"> <code class="descclassname">sys.</code><code class="descname">platform</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-414">例如，该字符串包含一个平台标识符，可用于将特定于平台的组件附加到<a class="reference internal" href="#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-415">For Unix systems, except on Linux, this is the lowercased OS name as returned by <code class="docutils literal"><span class="pre">uname</span> <span class="pre">-s</span></code> with the first part of the version as returned by <code class="docutils literal"><span class="pre">uname</span> <span class="pre">-r</span></code> appended, e.g. </span><span class="yiyi-st" id="yiyi-416"><code class="docutils literal"><span class="pre">'sunos5'</span></code>或<code class="docutils literal"><span class="pre">'freebsd8'</span></code>，<em>在构建Python时</em>。</span><span class="yiyi-st" id="yiyi-417">除非您想测试特定的系统版本，否则建议使用以下习惯用法：</span></p><pre><code class="language-python"><span></span><span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'freebsd'</span><span class="p">):</span>
    <span class="c1"># FreeBSD-specific code here...</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'linux'</span><span class="p">):</span>
    <span class="c1"># Linux-specific code here...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-418">对于其他系统，其值为：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-419">系统</span></th><th class="head"><span class="yiyi-st" id="yiyi-420"><code class="docutils literal"><span class="pre">platform</span></code>值</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-421">Linux的</span></td><td><span class="yiyi-st" id="yiyi-422"><code class="docutils literal"><span class="pre">'linux'</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-423">视窗</span></td><td><span class="yiyi-st" id="yiyi-424"><code class="docutils literal"><span class="pre">'win32'</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-425">在Windows / Cygwin的</span></td><td><span class="yiyi-st" id="yiyi-426"><code class="docutils literal"><span class="pre">'cygwin'</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-427">Mac OS X</span></td><td><span class="yiyi-st" id="yiyi-428"><code class="docutils literal"><span class="pre">'darwin'</span></code></span></td></tr></tbody></table><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-429"><span class="versionmodified">在版本3.3中更改：</span>在Linux上，<a class="reference internal" href="#sys.platform" title="sys.platform"><code class="xref py py-attr docutils literal"><span class="pre">sys.platform</span></code></a>不再包含主要版本。</span><span class="yiyi-st" id="yiyi-430">它始终是<code class="docutils literal"><span class="pre">'linux'</span></code>，而不是<code class="docutils literal"><span class="pre">'linux2'</span></code>或<code class="docutils literal"><span class="pre">'linux3'</span></code>。</span><span class="yiyi-st" id="yiyi-431">由于较早的Python版本包含版本号，因此建议始终使用上面提供的<code class="docutils literal"><span class="pre">startswith</span></code>成语。</span></p></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-432">也可以看看</span></p><p><span class="yiyi-st" id="yiyi-433"><a class="reference internal" href="os.html#os.name" title="os.name"><code class="xref py py-attr docutils literal"><span class="pre">os.name</span></code></a>具有较粗的粒度。</span><span class="yiyi-st" id="yiyi-434"><a class="reference internal" href="os.html#os.uname" title="os.uname"><code class="xref py py-func docutils literal"><span class="pre">os.uname()</span></code></a>给出系统相关的版本信息。</span></p><p class="last"><span class="yiyi-st" id="yiyi-435"><a class="reference internal" href="platform.html#module-platform" title="platform: Retrieves as much platform identifying data as possible."><code class="xref py py-mod docutils literal"><span class="pre">platform</span></code></a>模块提供了有关系统身份的详细检查。</span></p></div></dd></dl><dl class="data"><dt id="sys.prefix"><span class="yiyi-st" id="yiyi-436"> <code class="descclassname">sys.</code><code class="descname">prefix</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-437">一个字符串，它给出了特定于站点的目录前缀，其中安装了与平台无关的Python文件；默认情况下，这是字符串<code class="docutils literal"><span class="pre">'/usr/local'</span></code>。</span><span class="yiyi-st" id="yiyi-438">这可以在构建时使用<strong class="program">configure</strong>脚本的<code class="docutils literal"><span class="pre">--prefix</span></code>参数进行设置。</span><span class="yiyi-st" id="yiyi-439">The main collection of Python library modules is installed in the directory <code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em></code> while the platform independent header files (all except <code class="file docutils literal"><span class="pre">pyconfig.h</span></code>) are stored in <code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/include/python</span><em><span class="pre">X.Y</span></em></code>, where <em>X.Y</em> is the version number of Python, for example <code class="docutils literal"><span class="pre">3.2</span></code>.</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-440">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-441">如果<a class="reference internal" href="venv.html#venv-def"><span>virtual environment</span></a>有效，则此值将在<code class="docutils literal"><span class="pre">site.py</span></code>中更改为指向虚拟环境。</span><span class="yiyi-st" id="yiyi-442">通过<a class="reference internal" href="#sys.base_prefix" title="sys.base_prefix"><code class="xref py py-data docutils literal"><span class="pre">base_prefix</span></code></a>，Python安装的值仍然可用。</span></p></div></dd></dl><dl class="data"><dt id="sys.ps1"><span class="yiyi-st" id="yiyi-443"> <code class="descclassname">sys.</code><code class="descname">ps1</code></span></dt><dt id="sys.ps2"><span class="yiyi-st" id="yiyi-444"> <code class="descclassname">sys.</code><code class="descname">ps2</code></span></dt><dd><p id="index-16"><span class="yiyi-st" id="yiyi-445">指定解释器的主要和次要提示的字符串。</span><span class="yiyi-st" id="yiyi-446">这些仅在解释器处于交互模式时才被定义。</span><span class="yiyi-st" id="yiyi-447">它们的初始值在这种情况下是<code class="docutils literal"><span class="pre">'＆gt；＆gt；＆gt；</span> <span class="pre">'</span></code>和<code class="docutils literal"><span class="pre">'...  t4 &gt; <span class="pre">'</span></span></code>。</span><span class="yiyi-st" id="yiyi-448">如果非字符串对象被分配给任何一个变量，则每次解释器准备读取新的交互式命令时，都会重新评估它的<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>；这可以用来实现动态提示。</span></p></dd></dl><dl class="function"><dt id="sys.setcheckinterval"><span class="yiyi-st" id="yiyi-449"> <code class="descclassname">sys.</code><code class="descname">setcheckinterval</code><span class="sig-paren">(</span><em>interval</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-450">设置解释器的“检查间隔”。</span><span class="yiyi-st" id="yiyi-451">此整数值决定解释器检查周期性事件的频率，例如线程切换和信号处理程序。</span><span class="yiyi-st" id="yiyi-452">缺省值是<code class="docutils literal"><span class="pre">100</span></code>，这意味着检查每100个Python虚拟指令执行一次。</span><span class="yiyi-st" id="yiyi-453">将其设置为更大的值可能会增加使用线程的程序的性能。</span><span class="yiyi-st" id="yiyi-454">将其设置为值<code class="docutils literal"><span class="pre">&lt;=</span></code> 0会检查每条虚拟指令，从而最大限度地提高响应性和开销。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-455"><span class="versionmodified">从版本3.2开始弃用：</span>由于线程切换和异步任务的内部逻辑已被重写，此函数不再有效果。</span><span class="yiyi-st" id="yiyi-456">改为使用<a class="reference internal" href="#sys.setswitchinterval" title="sys.setswitchinterval"><code class="xref py py-func docutils literal"><span class="pre">setswitchinterval()</span></code></a>。</span></p></div></dd></dl><dl class="function"><dt id="sys.setdlopenflags"><span class="yiyi-st" id="yiyi-457"> <code class="descclassname">sys.</code><code class="descname">setdlopenflags</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-458">设置解释器用于<code class="xref c c-func docutils literal"><span class="pre">dlopen()</span></code>调用的标志，例如当解释器加载扩展模块时。</span><span class="yiyi-st" id="yiyi-459">除此之外，如果调用<code class="docutils literal"><span class="pre">sys.setdlopenflags(0)</span></code>，这将在导入模块时启用对符号的惰性解析。</span><span class="yiyi-st" id="yiyi-460">要通过扩展模块共享符号，请调用<code class="docutils literal"><span class="pre">sys.setdlopenflags(os.RTLD_GLOBAL)</span></code>。</span><span class="yiyi-st" id="yiyi-461">Symbolic names for the flag values can be found in the <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> module (<code class="docutils literal"><span class="pre">RTLD_xxx</span></code> constants, e.g. </span><span class="yiyi-st" id="yiyi-462"><a class="reference internal" href="os.html#os.RTLD_LAZY" title="os.RTLD_LAZY"><code class="xref py py-data docutils literal"><span class="pre">os.RTLD_LAZY</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-463">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="sys.setprofile"><span class="yiyi-st" id="yiyi-464"> <code class="descclassname">sys.</code><code class="descname">setprofile</code><span class="sig-paren">(</span><em>profilefunc</em><span class="sig-paren">)</span></span></dt><dd><p id="index-17"><span class="yiyi-st" id="yiyi-465">设置系统的配置文件功能，它允许您在Py​​thon中实现Python源代码分析器。</span><span class="yiyi-st" id="yiyi-466">有关Python分析器的更多信息，请参阅<a class="reference internal" href="profile.html#profile"><span>The Python Profilers</span></a>一章。</span><span class="yiyi-st" id="yiyi-467">系统的配置文件函数与系统的跟踪函数类似（参见<a class="reference internal" href="#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal"><span class="pre">settrace()</span></code></a>），但不会为每个已执行的代码行调用（仅在调用和返回时调用，但返回事件是即使在设定例外情况下也会报告）。</span><span class="yiyi-st" id="yiyi-468">该函数是线程特定的，但探查器没有办法知道线程之间的上下文切换，所以在多线程的情况下使用它是没有意义的。</span><span class="yiyi-st" id="yiyi-469">而且，它的返回值没有使用，所以它可以简单地返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="function"><dt id="sys.setrecursionlimit"><span class="yiyi-st" id="yiyi-470"> <code class="descclassname">sys.</code><code class="descname">setrecursionlimit</code><span class="sig-paren">(</span><em>limit</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-471">将Python解释器堆栈的最大深度设置为<em>limit</em>。</span><span class="yiyi-st" id="yiyi-472">此限制可防止无限递归导致C堆栈溢出并导致Python崩溃。</span></p><p><span class="yiyi-st" id="yiyi-473">尽可能高的限制取决于平台。</span><span class="yiyi-st" id="yiyi-474">当用户需要深度递归的程序和支持更高限制的平台时，用户可能需要设置更高的限制。</span><span class="yiyi-st" id="yiyi-475">这应该谨慎处理，因为太高的限制可能会导致崩溃。</span></p><p><span class="yiyi-st" id="yiyi-476">如果当前递归深度的新限制过低，则会引发<a class="reference internal" href="exceptions.html#RecursionError" title="RecursionError"><code class="xref py py-exc docutils literal"><span class="pre">RecursionError</span></code></a>异常。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-477"><span class="versionmodified">在版本3.5.1中更改：</span>如果当前递归深度的新限制太低，现在会引发<a class="reference internal" href="exceptions.html#RecursionError" title="RecursionError"><code class="xref py py-exc docutils literal"><span class="pre">RecursionError</span></code></a>异常。</span></p></div></dd></dl><dl class="function"><dt id="sys.setswitchinterval"><span class="yiyi-st" id="yiyi-478"> <code class="descclassname">sys.</code><code class="descname">setswitchinterval</code><span class="sig-paren">(</span><em>interval</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-479">设置解释器的线程切换间隔（以秒为单位）。</span><span class="yiyi-st" id="yiyi-480">这个浮点值决定了分配给并发运行的Python线程的“时间片”的理想持续时间。</span><span class="yiyi-st" id="yiyi-481">请注意，实际值可能更高，特别是如果使用长时间运行的内部函数或方法。</span><span class="yiyi-st" id="yiyi-482">另外，在时间间隔结束时哪个线程将被调度，这是操作系统的决定。</span><span class="yiyi-st" id="yiyi-483">解释器没有自己的调度器。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-484"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="sys.settrace"><span class="yiyi-st" id="yiyi-485"> <code class="descclassname">sys.</code><code class="descname">settrace</code><span class="sig-paren">(</span><em>tracefunc</em><span class="sig-paren">)</span></span></dt><dd><p id="index-18"><span class="yiyi-st" id="yiyi-486">设置系统的跟踪功能，它允许你在Python中实现一个Python源代码调试器。</span><span class="yiyi-st" id="yiyi-487">该函数是特定于线程的；为了支持多线程的调试器，必须使用<a class="reference internal" href="#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal"><span class="pre">settrace()</span></code></a>注册正在调试的每个线程。</span></p><p><span class="yiyi-st" id="yiyi-488">跟踪函数应该有三个参数：<em>frame</em>，<em>event</em>和<em>arg</em>。</span><span class="yiyi-st" id="yiyi-489"><em>frame</em>是当前的堆栈帧。</span><span class="yiyi-st" id="yiyi-490"><em>事件</em>是一个字符串：<code class="docutils literal"><span class="pre">'call'</span></code>，<code class="docutils literal"><span class="pre">'line'</span></code>，<code class="docutils literal"><span class="pre">'return'</span></code>，<code class="docutils literal"><span class="pre">'exception'</span></code>，<code class="docutils literal"><span class="pre">'c_call'</span></code>，<code class="docutils literal"><span class="pre">'c_return'</span></code>或<code class="docutils literal"><span class="pre">'c_exception'</span></code>。</span><span class="yiyi-st" id="yiyi-491"><em>arg</em>取决于事件类型。</span></p><p><span class="yiyi-st" id="yiyi-492">无论何时输入新的本地作用域，都会调用跟踪函数（将<em>event</em>设置为<code class="docutils literal"><span class="pre">'call'</span></code>）；它应该返回一个本地跟踪函数的引用来使用该范围，或者如果不应该跟踪范围，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-493">局部跟踪函数应该返回一个对自身的引用（或者在该范围内进一步跟踪的另一个函数），或者<code class="docutils literal"><span class="pre">None</span></code>关闭该范围内的跟踪。</span></p><p><span class="yiyi-st" id="yiyi-494">这些事件具有以下含义：</span></p><dl class="docutils"><dt><span class="yiyi-st" id="yiyi-495"><code class="docutils literal"><span class="pre">'call'</span></code></span></dt><dd><span class="yiyi-st" id="yiyi-496">一个函数被调用（或其他一些代码块输入）。</span><span class="yiyi-st" id="yiyi-497">全局跟踪功能被调用； <em>arg</em>是<code class="docutils literal"><span class="pre">None</span></code>；返回值指定本地跟踪功能。</span></dd><dt><span class="yiyi-st" id="yiyi-498"><code class="docutils literal"><span class="pre">'line'</span></code></span></dt><dd><span class="yiyi-st" id="yiyi-499">解释器即将执行一行新的代码或重新执行循环的条件。</span><span class="yiyi-st" id="yiyi-500">局部跟踪功能被调用； <em>arg</em>是<code class="docutils literal"><span class="pre">None</span></code>；返回值指定新的本地跟踪功能。</span><span class="yiyi-st" id="yiyi-501">请参阅<code class="file docutils literal"><span class="pre">Objects/lnotab_notes.txt</span></code>了解其工作原理的详细说明。</span></dd><dt><span class="yiyi-st" id="yiyi-502"><code class="docutils literal"><span class="pre">'return'</span></code></span></dt><dd><span class="yiyi-st" id="yiyi-503">函数（或其他代码块）即将返回。</span><span class="yiyi-st" id="yiyi-504">局部跟踪功能被调用； <em>如果事件是由引发的异常引起的，则arg</em>是将返回的值，或<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-505">跟踪函数的返回值被忽略。</span></dd><dt><span class="yiyi-st" id="yiyi-506"><code class="docutils literal"><span class="pre">'exception'</span></code></span></dt><dd><span class="yiyi-st" id="yiyi-507">发生异常。</span><span class="yiyi-st" id="yiyi-508">局部跟踪功能被调用； <em>arg</em>是元组<code class="docutils literal"><span class="pre">（异常，</span> <span class="pre">值，</span> <span class="pre">回溯）</span></code>返回值指定新的本地跟踪功能。</span></dd><dt><span class="yiyi-st" id="yiyi-509"><code class="docutils literal"><span class="pre">'c_call'</span></code></span></dt><dd><span class="yiyi-st" id="yiyi-510">C函数即将被调用。</span><span class="yiyi-st" id="yiyi-511">这可能是一个扩展功能或内置。</span><span class="yiyi-st" id="yiyi-512"><em>arg</em>是C函数对象。</span></dd><dt><span class="yiyi-st" id="yiyi-513"><code class="docutils literal"><span class="pre">'c_return'</span></code></span></dt><dd><span class="yiyi-st" id="yiyi-514">一个C函数已经返回。</span><span class="yiyi-st" id="yiyi-515"><em>arg</em>是C函数对象。</span></dd><dt><span class="yiyi-st" id="yiyi-516"><code class="docutils literal"><span class="pre">'c_exception'</span></code></span></dt><dd><span class="yiyi-st" id="yiyi-517">C函数引发了一个异常。</span><span class="yiyi-st" id="yiyi-518"><em>arg</em>是C函数对象。</span></dd></dl><p><span class="yiyi-st" id="yiyi-519">请注意，随着异常传播到调用者链中，每个级别都会生成一个<code class="docutils literal"><span class="pre">'exception'</span></code>事件。</span></p><p><span class="yiyi-st" id="yiyi-520">有关代码和框架对象的详细信息，请参阅<a class="reference internal" href="../reference/datamodel.html#types"><span>The standard type hierarchy</span></a>。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-521"><strong>CPython实现细节</strong> <a class="reference internal" href="#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal"><span class="pre">settrace()</span></code></a>函数仅用于实现调试器，分析器，覆盖工具等。</span><span class="yiyi-st" id="yiyi-522">它的行为是实现平台的一部分，而不是语言定义的一部分，因此可能不适用于所有Python实现。</span></p></div></dd></dl><dl class="function"><dt id="sys.settscdump"><span class="yiyi-st" id="yiyi-523"> <code class="descclassname">sys.</code><code class="descname">settscdump</code><span class="sig-paren">(</span><em>on_flag</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-524">如果<em>on_flag</em>为真，则使用Pentium时间戳计数器激活VM测量结果的转储。</span><span class="yiyi-st" id="yiyi-525">如果<em>on_flag</em>关闭，则停用这些转储。</span><span class="yiyi-st" id="yiyi-526">该功能仅在Python编译时使用<code class="docutils literal"><span class="pre">--with-tsc</span></code>才可用。</span><span class="yiyi-st" id="yiyi-527">要理解此转储的输出，请阅读Python源代码中的<code class="file docutils literal"><span class="pre">Python/ceval.c</span></code>。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-528"><strong>CPython implementation detail:</strong> This function is intimately bound to CPython implementation details and thus not likely to be implemented elsewhere.</span></p></div></dd></dl><dl class="function"><dt id="sys.set_coroutine_wrapper"><span class="yiyi-st" id="yiyi-529"> <code class="descclassname">sys.</code><code class="descname">set_coroutine_wrapper</code><span class="sig-paren">(</span><em>wrapper</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-530">Allows intercepting creation of <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> objects (only ones that are created by an <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a> function; generators decorated with <a class="reference internal" href="types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal"><span class="pre">types.coroutine()</span></code></a> or <a class="reference internal" href="asyncio-task.html#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal"><span class="pre">asyncio.coroutine()</span></code></a> will not be intercepted).</span></p><p><span class="yiyi-st" id="yiyi-531"><em>包装</em>参数必须是：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-532">一个可接受一个参数的调用（一个协程对象）；</span></li><li><span class="yiyi-st" id="yiyi-533"><code class="docutils literal"><span class="pre">None</span></code>，重置包装。</span></li></ul><p><span class="yiyi-st" id="yiyi-534">如果调用两次，则新包装将替换前一个。</span><span class="yiyi-st" id="yiyi-535">该函数是特定于线程的。</span></p><p><span class="yiyi-st" id="yiyi-536"><em>wrapper</em>可调用不能直接或间接定义新的协程：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">coro</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">coro</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">coro</span>
    <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">set_coroutine_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="c1"># The following line will fail with a RuntimeError, because</span>
<span class="c1"># ``wrapper`` creates a ``wrap(coro)`` coroutine:</span>
<span class="n">foo</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-537">另见<a class="reference internal" href="#sys.get_coroutine_wrapper" title="sys.get_coroutine_wrapper"><code class="xref py py-func docutils literal"><span class="pre">get_coroutine_wrapper()</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-538"><span class="versionmodified">版本3.5中的新功能：</span>了解更多详情，请参阅<span class="target" id="index-19"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-539">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-540">此功能暂时添加（详情请参阅<span class="target" id="index-20"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0411"><strong>PEP 411</strong></a>）。</span><span class="yiyi-st" id="yiyi-541">仅用于调试目的。</span></p></div></dd></dl><dl class="data"><dt id="sys.stdin"><span class="yiyi-st" id="yiyi-542"> <code class="descclassname">sys.</code><code class="descname">stdin</code></span></dt><dt id="sys.stdout"><span class="yiyi-st" id="yiyi-543"> <code class="descclassname">sys.</code><code class="descname">stdout</code></span></dt><dt id="sys.stderr"><span class="yiyi-st" id="yiyi-544"> <code class="descclassname">sys.</code><code class="descname">stderr</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-545">解释器用于标准输入，输出和错误的<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">File objects</span></a>：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-546"><code class="docutils literal"><span class="pre">stdin</span></code>用于所有交互式输入（包括对<a class="reference internal" href="functions.html#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a>的调用）；</span></li><li><span class="yiyi-st" id="yiyi-547"><code class="docutils literal"><span class="pre">stdout</span></code>用于<a class="reference internal" href="functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a>和<a class="reference internal" href="../glossary.html#term-expression"><span class="xref std std-term">expression</span></a>语句的输出以及<a class="reference internal" href="functions.html#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a>的提示。</span></li><li><span class="yiyi-st" id="yiyi-548">解释器自己的提示和错误消息转到<code class="docutils literal"><span class="pre">stderr</span></code>。</span></li></ul><p><span class="yiyi-st" id="yiyi-549">这些流是<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>函数返回的常规<a class="reference internal" href="../glossary.html#term-text-file"><span class="xref std std-term">text files</span></a>。</span><span class="yiyi-st" id="yiyi-550">他们的参数选择如下：</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-551">字符编码是平台相关的。</span><span class="yiyi-st" id="yiyi-552">在Windows下，如果流是交互式的（也就是说，如果它的<code class="xref py py-meth docutils literal"><span class="pre">isatty()</span></code>方法返回<code class="docutils literal"><span class="pre">True</span></code>），则使用控制台代码页，否则使用ANSI代码页。</span><span class="yiyi-st" id="yiyi-553">在其他平台下，使用区域设置编码（请参阅<a class="reference internal" href="locale.html#locale.getpreferredencoding" title="locale.getpreferredencoding"><code class="xref py py-meth docutils literal"><span class="pre">locale.getpreferredencoding()</span></code></a>）。</span></p><p><span class="yiyi-st" id="yiyi-554">但是，在所有平台下，您可以在启动Python之前通过设置<span class="target" id="index-21"></span> <a class="reference internal" href="../using/cmdline.html#envvar-PYTHONIOENCODING"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONIOENCODING</span></code></a>环境变量来覆盖此值。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-555">交互时，标准流是行缓冲的。</span><span class="yiyi-st" id="yiyi-556">否则，它们像常规文本文件一样被块缓冲。</span><span class="yiyi-st" id="yiyi-557">您可以使用<a class="reference internal" href="../using/cmdline.html#cmdoption-u"><code class="xref std std-option docutils literal"><span class="pre">-u</span></code></a>命令行选项覆盖此值。</span></p></li></ul><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-558">注意</span></p><p><span class="yiyi-st" id="yiyi-559">要向标准流写入或读取二进制数据，请使用基础二进制<a class="reference internal" href="io.html#io.TextIOBase.buffer" title="io.TextIOBase.buffer"><code class="xref py py-data docutils literal"><span class="pre">buffer</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-560">例如，要将字节写入<a class="reference internal" href="#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">stdout</span></code></a>，请使用<code class="docutils literal"><span class="pre">sys.stdout.buffer.write(b'abc')</span></code>。</span></p><p class="last"><span class="yiyi-st" id="yiyi-561">但是，如果您正在编写一个库（并且不控制其代码将在哪个上下文中执行），请注意，标准流可能会替换为类似文件的对象，如<a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a>不支持<code class="xref py py-attr docutils literal"><span class="pre">buffer</span></code>属性。</span></p></div></dd></dl><dl class="data"><dt id="sys.__stdin__"><span class="yiyi-st" id="yiyi-562"> <code class="descclassname">sys.</code><code class="descname">__stdin__</code></span></dt><dt id="sys.__stdout__"><span class="yiyi-st" id="yiyi-563"> <code class="descclassname">sys.</code><code class="descname">__stdout__</code></span></dt><dt id="sys.__stderr__"><span class="yiyi-st" id="yiyi-564"> <code class="descclassname">sys.</code><code class="descname">__stderr__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-565">这些对象在程序开始时包含<code class="docutils literal"><span class="pre">stdin</span></code>，<code class="docutils literal"><span class="pre">stderr</span></code>和<code class="docutils literal"><span class="pre">stdout</span></code>的原始值。</span><span class="yiyi-st" id="yiyi-566">它们在定稿过程中使用，无论<code class="docutils literal"><span class="pre">sys.std*</span></code>对象是否被重定向，都可以用于打印到实际的标准流。</span></p><p><span class="yiyi-st" id="yiyi-567">它也可用于将实际文件恢复到已知工作文件对象，以防被已损坏的对象覆盖。</span><span class="yiyi-st" id="yiyi-568">但是，执行此操作的首选方法是在替换之前显式保存前一个流，然后恢复保存的对象。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-569">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-570">Under some conditions <code class="docutils literal"><span class="pre">stdin</span></code>, <code class="docutils literal"><span class="pre">stdout</span></code> and <code class="docutils literal"><span class="pre">stderr</span></code> as well as the original values <code class="docutils literal"><span class="pre">__stdin__</span></code>, <code class="docutils literal"><span class="pre">__stdout__</span></code> and <code class="docutils literal"><span class="pre">__stderr__</span></code> can be None. </span><span class="yiyi-st" id="yiyi-571">对于未连接到控制台的Windows GUI应用程序以及以<strong class="program">pythonw</strong>开头的Python应用程序，通常情况如此。</span></p></div></dd></dl><dl class="data"><dt id="sys.thread_info"><span class="yiyi-st" id="yiyi-572"> <code class="descclassname">sys.</code><code class="descname">thread_info</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-573">包含关于线程实现的信息的<a class="reference internal" href="../glossary.html#term-struct-sequence"><span class="xref std std-term">struct sequence</span></a>。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-574">属性</span></th><th class="head"><span class="yiyi-st" id="yiyi-575">说明</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-576"><code class="xref py py-const docutils literal"><span class="pre">name</span></code></span></td><td><p class="first"><span class="yiyi-st" id="yiyi-577">线程实现的名称：</span></p><span class="yiyi-st" id="yiyi-578"> <blockquote class="last"> <div><ul class="simple"> <li><code class="docutils literal"><span class="pre">'nt'</span></code>: Windows threads</li> <li><code class="docutils literal"><span class="pre">'pthread'</span></code>: POSIX threads</li> <li><code class="docutils literal"><span class="pre">'solaris'</span></code>: Solaris threads</li> </ul> </div></blockquote></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-579"><code class="xref py py-const docutils literal"><span class="pre">lock</span></code></span></td><td><p class="first"><span class="yiyi-st" id="yiyi-580">锁执行的名称：</span></p><span class="yiyi-st" id="yiyi-581"> <blockquote class="last"> <div><ul class="simple"> <li><code class="docutils literal"><span class="pre">'semaphore'</span></code>: a lock uses a semaphore</li> <li><code class="docutils literal"><span class="pre">'mutex+cond'</span></code>: a lock uses a mutex and a condition variable</li> <li><code class="docutils literal"><span class="pre">None</span></code> if this information is unknown</li> </ul> </div></blockquote></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-582"><a class="reference internal" href="#sys.version" title="sys.version"><code class="xref py py-const docutils literal"><span class="pre">version</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-583">线程库的名称和版本。</span><span class="yiyi-st" id="yiyi-584">它是一个字符串，或者<code class="docutils literal"><span class="pre">None</span></code>，如果这些信息是未知的。</span></td></tr></tbody></table><div class="versionadded"><p><span class="yiyi-st" id="yiyi-585"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="sys.tracebacklimit"><span class="yiyi-st" id="yiyi-586"> <code class="descclassname">sys.</code><code class="descname">tracebacklimit</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-587">当此变量设置为整数值时，它确定发生未处理的异常时打印的追溯信息的最大级别数。</span><span class="yiyi-st" id="yiyi-588">默认值是<code class="docutils literal"><span class="pre">1000</span></code>。</span><span class="yiyi-st" id="yiyi-589">当设置为<code class="docutils literal"><span class="pre">0</span></code>或更低时，所有回溯信息被抑制，并且只打印异常类型和值。</span></p></dd></dl><dl class="data"><dt id="sys.version"><span class="yiyi-st" id="yiyi-590"> <code class="descclassname">sys.</code><code class="descname">version</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-591">一个字符串，其中包含Python解释器的版本号以及所使用的内部版本号和编译器的附加信息。</span><span class="yiyi-st" id="yiyi-592">交互式解释器启动时显示该字符串。</span><span class="yiyi-st" id="yiyi-593">不要将版本信息提取出来，而应使用<a class="reference internal" href="#sys.version_info" title="sys.version_info"><code class="xref py py-data docutils literal"><span class="pre">version_info</span></code></a>和<a class="reference internal" href="platform.html#module-platform" title="platform: Retrieves as much platform identifying data as possible."><code class="xref py py-mod docutils literal"><span class="pre">platform</span></code></a>模块提供的功能。</span></p></dd></dl><dl class="data"><dt id="sys.api_version"><span class="yiyi-st" id="yiyi-594"> <code class="descclassname">sys.</code><code class="descname">api_version</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-595">此解释器的C API版本。</span><span class="yiyi-st" id="yiyi-596">在调试Python和扩展模块之间的版本冲突时，程序员可能会觉得这很有用。</span></p></dd></dl><dl class="data"><dt id="sys.version_info"><span class="yiyi-st" id="yiyi-597"> <code class="descclassname">sys.</code><code class="descname">version_info</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-598">一个包含版本号五个组成部分的元组：<em>major</em>、<em>minor</em>、<em>micro</em>、<em>releaselevel</em>和<em>serial</em>。</span><span class="yiyi-st" id="yiyi-599">除<em>releaselevel</em>以外的所有值均为整数；发布级别是<code class="docutils literal"><span class="pre">'alpha'</span></code>，<code class="docutils literal"><span class="pre">'beta'</span></code>，<code class="docutils literal"><span class="pre">'candidate'</span></code>或<code class="docutils literal"><span class="pre">'final'</span></code>。</span><span class="yiyi-st" id="yiyi-600">The <code class="docutils literal"><span class="pre">version_info</span></code> value corresponding to the Python version 2.0 is <code class="docutils literal"><span class="pre">(2,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">'final',</span> <span class="pre">0)</span></code>. </span><span class="yiyi-st" id="yiyi-601">组件也可以通过名称访问，所以<code class="docutils literal"><span class="pre">sys.version_info[0]</span></code>等同于<code class="docutils literal"><span class="pre">sys.version_info.major</span></code>等等。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-602"><span class="versionmodified">在版本3.1中更改：</span>添加了命名的组件属性。</span></p></div></dd></dl><dl class="data"><dt id="sys.warnoptions"><span class="yiyi-st" id="yiyi-603"> <code class="descclassname">sys.</code><code class="descname">warnoptions</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-604">这是警告框架的实施细节；不要修改这个值。</span><span class="yiyi-st" id="yiyi-605">有关警告框架的更多信息，请参阅<a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a>模块。</span></p></dd></dl><dl class="data"><dt id="sys.winver"><span class="yiyi-st" id="yiyi-606"> <code class="descclassname">sys.</code><code class="descname">winver</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-607">用于在Windows平台上形成注册表项的版本号。</span><span class="yiyi-st" id="yiyi-608">这将作为字符串资源1000存储在Python DLL中。</span><span class="yiyi-st" id="yiyi-609">该值通常是<a class="reference internal" href="#sys.version" title="sys.version"><code class="xref py py-const docutils literal"><span class="pre">version</span></code></a>的前三个字符。</span><span class="yiyi-st" id="yiyi-610">它在<a class="reference internal" href="#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a>模块中用于提供信息；修改此值不会影响Python使用的注册表项。</span><span class="yiyi-st" id="yiyi-611">可用性：Windows。</span></p></dd></dl><dl class="data"><dt id="sys._xoptions"><span class="yiyi-st" id="yiyi-612"> <code class="descclassname">sys.</code><code class="descname">_xoptions</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-613">通过<a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal"><span class="pre">-X</span></code></a>命令行选项传递的各种实现特定标志的字典。</span><span class="yiyi-st" id="yiyi-614">如果显式给出选项名称或将其映射到它们的值，或者将它们映射到<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>。</span><span class="yiyi-st" id="yiyi-615">例：</span></p><div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> ./python -Xa<span class="o">=</span>b -Xc
<span class="go">Python 3.2a3+ (py3k, Oct 16 2010, 20:14:50)</span>
<span class="go">[GCC 4.4.3] on linux2</span>
<span class="go">Type "help", "copyright", "credits" or "license" for more information.</span>
<span class="gp">&gt;</span>&gt;&gt; import sys
<span class="gp">&gt;</span>&gt;&gt; sys._xoptions
<span class="go">{'a': 'b', 'c': True}</span>
</pre></div></div><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-616"><strong>CPython implementation detail:</strong> This is a CPython-specific way of accessing options passed through <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal"><span class="pre">-X</span></code></a>. </span><span class="yiyi-st" id="yiyi-617">其他实现可以通过其他方式导出它们，或根本不导入它们。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-618"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><p class="rubric"><span class="yiyi-st" id="yiyi-619">引文</span></p><table class="docutils citation" frame="void" id="c99" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-620"><a class="fn-backref" href="#id1">[C99]</a></span></td><td><span class="yiyi-st" id="yiyi-621">ISO/IEC 9899:1999. </span><span class="yiyi-st" id="yiyi-622">“编程语言-C”这个标准的公共草案可以在<a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf</a>上找到。</span></td></tr></tbody></table></div></div>