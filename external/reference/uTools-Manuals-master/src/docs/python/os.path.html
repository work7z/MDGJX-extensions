<div class="body" role="main"><div class="section" id="module-os.path"><h1><span class="yiyi-st" id="yiyi-10">11.2. <a class="reference internal" href="#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a> — 路径操作</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/posixpath.py">Lib/posixpath.py</a> (for POSIX), <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/ntpath.py">Lib/ntpath.py</a> (for Windows NT), and <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/macpath.py">Lib/macpath.py</a> (for Macintosh)</span></p><p><span class="yiyi-st" id="yiyi-12">这个模块实现了一些有关操作路径的函数。</span><span class="yiyi-st" id="yiyi-13">如果需要读取或写入文件请参见<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>, 如果要访问文件系统请参见 <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> 模块.</span><span class="yiyi-st" id="yiyi-14">路径参数可以作为字符串或字节传递。</span><span class="yiyi-st" id="yiyi-15">鼓励应用程序将文件名称表示为（Unicode）字符串。</span><span class="yiyi-st" id="yiyi-16">不幸的是，一些文件的名称可能不可以在 Unix 上表示为字符串，所以需要在 Unix 上支持任意文件的名称的应用程序应使用字节对象来表示路径名称。</span><span class="yiyi-st" id="yiyi-17">反之亦然，使用字节对象不能表示所有在 Windows 上文件的名称 （在标准 <code class="docutils literal"><span class="pre">mbcs</span></code> 编码），因此 Windows 应用程序应使用字符串对象来访问所有文件。</span></p><p><span class="yiyi-st" id="yiyi-18">与unix shell不同的 是，Python 不做任何 <em>自动</em> 路径扩展。</span><span class="yiyi-st" id="yiyi-19">当应用程序希望shell-like路径扩展，可以显式调用函数，如 <a class="reference internal" href="#os.path.expanduser" title="os.path.expanduser"><code class="xref py py-func docutils literal"><span class="pre">expanduser()</span></code></a> 和 <a class="reference internal" href="#os.path.expandvars" title="os.path.expandvars"><code class="xref py py-func docutils literal"><span class="pre">expandvars()</span></code></a>。</span><span class="yiyi-st" id="yiyi-20">（请参阅 <a class="reference internal" href="glob.html#module-glob" title="glob: Unix shell style pathname pattern expansion."><code class="xref py py-mod docutils literal"><span class="pre">glob</span></code></a> 模块）。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-21">请参见</span></p><p class="last"><span class="yiyi-st" id="yiyi-22"><a class="reference internal" href="pathlib.html#module-pathlib" title="pathlib: Object-oriented filesystem paths"><code class="xref py py-mod docutils literal"><span class="pre">pathlib</span></code></a> 模块提供更高级别的路径对象。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-23">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-24">所有的这些功能接受仅以字节或只有字符串对象作为其参数。</span><span class="yiyi-st" id="yiyi-25">如果返回路径或文件的名称，则结果为相同类型的对象。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-26">注意</span></p><p><span class="yiyi-st" id="yiyi-27">由于不同的操作系统有不同的路径名称约定，标准库中有几个版本的这个模块。</span><span class="yiyi-st" id="yiyi-28">运行 Python得到的<a class="reference internal" href="#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a> 模块始终是适用于操作系统得路径模块，并因此可用于本地路径。</span><span class="yiyi-st" id="yiyi-29">然而，您也可以导入并使用单独的模块，如果你想要操作 <em>总是</em> 在一种不同格式的路径。</span><span class="yiyi-st" id="yiyi-30">他们都有相同的接口︰</span></p><ul class="last simple"><li><span class="yiyi-st" id="yiyi-31"><code class="xref py py-mod docutils literal"><span class="pre">posixpath</span></code>用于UNIX样式路径</span></li><li><span class="yiyi-st" id="yiyi-32"><code class="xref py py-mod docutils literal"><span class="pre">ntpath</span></code>用于Windows路径</span></li><li><span class="yiyi-st" id="yiyi-33"><a class="reference internal" href="macpath.html#module-macpath" title="macpath: Mac OS 9 path manipulation functions."><code class="xref py py-mod docutils literal"><span class="pre">macpath</span></code></a>用于旧式MacOS路径</span></li></ul></div><dl class="function"><dt id="os.path.abspath"><span class="yiyi-st" id="yiyi-34"> <code class="descclassname">os.path.</code><code class="descname">abspath</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-35">返回一个标准的绝对路径名 <em>path</em>.</span><span class="yiyi-st" id="yiyi-36">在大多数平台上，该函数等效于调用 <a class="reference internal" href="#os.path.normpath" title="os.path.normpath"><code class="xref py py-func docutils literal"><span class="pre">normpath()</span></code></a>函数， 如下所示: <code class="docutils literal"><span class="pre">normpath(join(os.getcwd(),</span> <span class="pre">path))</span></code>.</span></p></dd></dl><dl class="function"><dt id="os.path.basename"><span class="yiyi-st" id="yiyi-37"><code class="descclassname">os.path.</code><code class="descname">basename</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-38">返回路径名<em>path</em>的最后一级的名称。</span><span class="yiyi-st" id="yiyi-39">它为将<em>path</em>参数传递给<a class="reference internal" href="#os.path.split" title="os.path.split"><code class="xref py py-func docutils literal"><span class="pre">split()</span></code></a>函数返回的元组对的第二个元素。</span><span class="yiyi-st" id="yiyi-40">请注意，这个函数的结果不同于Unix的<strong class="program">basename</strong>程序；对于<code class="docutils literal"><span class="pre">'/foo/bar/'</span></code>，Unix的<strong class="program">basename</strong>返回<code class="docutils literal"><span class="pre">'bar'</span></code>，而<a class="reference internal" href="#os.path.basename" title="os.path.basename"><code class="xref py py-func docutils literal"><span class="pre">basename()</span></code></a>函数返回空字符串（<code class="docutils literal"><span class="pre">''</span></code>）。</span></p></dd></dl><dl class="function"><dt id="os.path.commonpath"><span class="yiyi-st" id="yiyi-41"><code class="descclassname">os.path.</code><code class="descname">commonpath</code><span class="sig-paren">(</span><em>paths</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-42">返回 <em>paths</em>参数中，所有路径序列中共有的最长的路径.</span><span class="yiyi-st" id="yiyi-43">如果 <em>paths</em> 即包含绝对路径又包含相对路径,或者 <em>paths</em> 为空将抛出ValueError.</span><span class="yiyi-st" id="yiyi-44">不同于 <a class="reference internal" href="#os.path.commonprefix" title="os.path.commonprefix"><code class="xref py py-func docutils literal"><span class="pre">commonprefix()</span></code></a>函数, commonpath()返回一个有效的路径.</span></p><p><span class="yiyi-st" id="yiyi-45">可用性：Unix，Windows</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-46"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.path.commonprefix"><span class="yiyi-st" id="yiyi-47"><code class="descclassname">os.path.</code><code class="descname">commonprefix</code><span class="sig-paren">(</span><em>list</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-48">返回<em>列表</em>中所有路径的前缀的最长路径前缀（逐个字符）。</span><span class="yiyi-st" id="yiyi-49">如果<em>列表</em>为空，则返回空字符串（<code class="docutils literal"><span class="pre">''</span></code>）。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-50">注意</span></p><p><span class="yiyi-st" id="yiyi-51">此函数可能返回无效路径，因为它一次处理一个字符。</span><span class="yiyi-st" id="yiyi-52">要获取有效路径，请参阅<a class="reference internal" href="#os.path.commonpath" title="os.path.commonpath"><code class="xref py py-func docutils literal"><span class="pre">commonpath()</span></code></a>。</span></p><div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">commonprefix</span><span class="p">([</span><span class="s1">'/usr/lib'</span><span class="p">,</span> <span class="s1">'/usr/local/lib'</span><span class="p">])</span>
<span class="go">'/usr/l'</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">commonpath</span><span class="p">([</span><span class="s1">'/usr/lib'</span><span class="p">,</span> <span class="s1">'/usr/local/lib'</span><span class="p">])</span>
<span class="go">'/usr'</span>
</pre></div></div></div></dd></dl><dl class="function"><dt id="os.path.dirname"><span class="yiyi-st" id="yiyi-53"><code class="descclassname">os.path.</code><code class="descname">dirname</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-54">返回 <em>path</em>中的目录名.</span><span class="yiyi-st" id="yiyi-55">实际上是通过将<em>path</em>参数传递个 <a class="reference internal" href="#os.path.split" title="os.path.split"><code class="xref py py-func docutils literal"><span class="pre">split()</span></code></a>函数得到的返回值的第一个元素.</span></p></dd></dl><dl class="function"><dt id="os.path.exists"><span class="yiyi-st" id="yiyi-56"><code class="descclassname">os.path.</code><code class="descname">exists</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-57">如果<em>路径</em>指向现有路径或打开的文件描述器，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-58">如果是损坏的符号链接，则返回<code class="docutils literal"><span class="pre">False</span></code>.</span><span class="yiyi-st" id="yiyi-59">在某些平台上，如果未授予在所请求的文件上执行<a class="reference internal" href="os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>的权限，此函数可能会返回<code class="docutils literal"><span class="pre">False</span></code>，即使<em>路径</em>物理上确实是存在的。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-60"><span class="versionmodified">版本 3.3 中的更改︰</span>现在，<em>path</em> 可以是一个整数︰ 返回 <code class="docutils literal"><span class="pre">True</span></code> 如果它是一个打开的文件描述符，否则为<code class="docutils literal"><span class="pre">False</span></code>。</span></p></div></dd></dl><dl class="function"><dt id="os.path.lexists"><span class="yiyi-st" id="yiyi-61"><code class="descclassname">os.path.</code><code class="descname">lexists</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-62">如果 <em>path</em> 指向现有的路径，则返回 <code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-63">破碎的符号链接将返回 <code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-64">在缺少<a class="reference internal" href="os.html#os.lstat" title="os.lstat"><code class="xref py py-func docutils literal"><span class="pre">os.lstat()</span></code></a>的平台上等效于<a class="reference internal" href="#os.path.exists" title="os.path.exists"><code class="xref py py-func docutils literal"><span class="pre">exists()</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="os.path.expanduser"><span class="yiyi-st" id="yiyi-65"><code class="descclassname">os.path.</code><code class="descname">expanduser</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-66">在Unix和Windows上，将参数中原始的<code class="docutils literal"><span class="pre">~</span></code>或<code class="docutils literal"><span class="pre">~user</span></code>部分用<em>user</em>主目录替换。</span></p><p id="index-1"><span class="yiyi-st" id="yiyi-67">在Unix上，如果设置了环境变量<span class="target" id="index-2"></span><code class="xref std std-envvar docutils literal"><span class="pre">HOME</span></code>，则用它替换原始的<code class="docutils literal"><span class="pre">~</span></code>；否则通过内建模块<a class="reference internal" href="pwd.html#module-pwd" title="pwd: The password database (getpwnam() and friends). (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">pwd</span></code></a>在password目录中查找当前用户的主目录。</span><span class="yiyi-st" id="yiyi-68">原始的<code class="docutils literal"><span class="pre">~user</span></code>直接在password目录中查找。</span></p><p><span class="yiyi-st" id="yiyi-69">在Windows上，如果设置了<span class="target" id="index-3"></span><code class="xref std std-envvar docutils literal"><span class="pre">HOME</span></code>和<span class="target" id="index-4"></span><code class="xref std std-envvar docutils literal"><span class="pre">USERPROFILE</span></code>，则使用它们；否则组合使用<span class="target" id="index-5"></span><code class="xref std std-envvar docutils literal"><span class="pre">HOMEPATH</span></code>和<span class="target" id="index-6"></span><code class="xref std std-envvar docutils literal"><span class="pre">HOMEDRIVE</span></code>。</span><span class="yiyi-st" id="yiyi-70">通过从上面得到的创建的用户路径剥离最后一个目录组件来处理初始<code class="docutils literal"><span class="pre">~user</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-71">如果扩展失败或者参数path不是以~打头，则返回path不变。</span></p></dd></dl><dl class="function"><dt id="os.path.expandvars"><span class="yiyi-st" id="yiyi-72"><code class="descclassname">os.path.</code><code class="descname">expandvars</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-73">返回参数，其中的环境变量被扩展。</span><span class="yiyi-st" id="yiyi-74">形式<code class="docutils literal"><span class="pre">$name</span></code>或<code class="docutils literal"><span class="pre">${name}</span></code>的子字符串由环境变量<em>name</em>的值替换。</span><span class="yiyi-st" id="yiyi-75">如果格式不正确或者引用了不存在的变量，则不进行替换（或者扩展）。</span></p><p><span class="yiyi-st" id="yiyi-76">在Windows上，除了<code class="docutils literal"><span class="pre">$name</span></code>和<code class="docutils literal"><span class="pre">${name}</span></code>之外，还支持<code class="docutils literal"><span class="pre">%name%</span></code>扩展。</span></p></dd></dl><dl class="function"><dt id="os.path.getatime"><span class="yiyi-st" id="yiyi-77"><code class="descclassname">os.path.</code><code class="descname">getatime</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-78">返回 <em>path</em>的上次访问时间.</span><span class="yiyi-st" id="yiyi-79">返回值是一个数字，表示自纪元以来的秒数（参见<a class="reference internal" href="time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal"><span class="pre">time</span></code></a>模块）。</span><span class="yiyi-st" id="yiyi-80">如果文件不存在或无法访问，则引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-81">如果<a class="reference internal" href="os.html#os.stat_float_times" title="os.stat_float_times"><code class="xref py py-func docutils literal"><span class="pre">os.stat_float_times()</span></code></a>返回<code class="docutils literal"><span class="pre">True</span></code>，则结果为浮点数。</span></p></dd></dl><dl class="function"><dt id="os.path.getmtime"><span class="yiyi-st" id="yiyi-82"><code class="descclassname">os.path.</code><code class="descname">getmtime</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">返回<em>path</em>的最后修改时间。</span><span class="yiyi-st" id="yiyi-84">返回值是一个数字，表示自纪元以来的秒数（参见<a class="reference internal" href="time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal"><span class="pre">time</span></code></a>模块）。</span><span class="yiyi-st" id="yiyi-85">如果文件不存在或无法访问，则引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-86">如果<a class="reference internal" href="os.html#os.stat_float_times" title="os.stat_float_times"><code class="xref py py-func docutils literal"><span class="pre">os.stat_float_times()</span></code></a>返回<code class="docutils literal"><span class="pre">True</span></code>，则结果为浮点数。</span></p></dd></dl><dl class="function"><dt id="os.path.getctime"><span class="yiyi-st" id="yiyi-87"><code class="descclassname">os.path.</code><code class="descname">getctime</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-88">返回系统的ctime，在某些系统（如Unix）上是最后元数据更改的时间，在其他系统（如Windows）上，是<em>路径</em>的创建时间。</span><span class="yiyi-st" id="yiyi-89">返回值是一个数字，表示自纪元以来的秒数（参见<a class="reference internal" href="time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal"><span class="pre">时间</span></code></a>模块）。</span><span class="yiyi-st" id="yiyi-90">如果文件不存在或无法访问，则引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="os.path.getsize"><span class="yiyi-st" id="yiyi-91"><code class="descclassname">os.path.</code><code class="descname">getsize</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-92">返回<em>path</em>的大小，以字节为单位。</span><span class="yiyi-st" id="yiyi-93">如果文件不存在或无法访问，则引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="os.path.isabs"><span class="yiyi-st" id="yiyi-94"> <code class="descclassname">os.path.</code><code class="descname">isabs</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-95">如果<em>路径</em>是绝对路径名，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-96">在Unix上，这表示路径以/开始；在Windows上，这表示路径以\开始（在去掉可能的盘符后，如C:）。</span></p></dd></dl><dl class="function"><dt id="os.path.isfile"><span class="yiyi-st" id="yiyi-97"><code class="descclassname">os.path.</code><code class="descname">isfile</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-98">如果<em>路径</em>是现有的常规文件，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-99">这遵循符号链接(软链接)，因此<a class="reference internal" href="#os.path.islink" title="os.path.islink"><code class="xref py py-func docutils literal"><span class="pre">islink()</span></code></a>和<a class="reference internal" href="#os.path.isfile" title="os.path.isfile"><code class="xref py py-func docutils literal"><span class="pre">isfile()</span></code></a>对于同一路径可以为true。</span></p></dd></dl><dl class="function"><dt id="os.path.isdir"><span class="yiyi-st" id="yiyi-100"><code class="descclassname">os.path.</code><code class="descname">isdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-101">如果<em>文件</em>是目录，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-102">这遵循符号链接，因此<a class="reference internal" href="#os.path.islink" title="os.path.islink"><code class="xref py py-func docutils literal"><span class="pre">islink()</span></code></a>和<a class="reference internal" href="#os.path.isdir" title="os.path.isdir"><code class="xref py py-func docutils literal"><span class="pre">isdir()</span></code></a>对于同一路径可以为true。</span></p></dd></dl><dl class="function"><dt id="os.path.islink"><span class="yiyi-st" id="yiyi-103"><code class="descclassname">os.path.</code><code class="descname">islink</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">如果<em>路径</em>指的是符号链接的目录条目，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-105">始终<code class="docutils literal"><span class="pre">False</span></code>如果Python运行时不支持符号链接。</span></p></dd></dl><dl class="function"><dt id="os.path.ismount"><span class="yiyi-st" id="yiyi-106"><code class="descclassname">os.path.</code><code class="descname">ismount</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">如果路径名<em>路径</em>是<em class="dfn">安装点</em>，则返回<code class="docutils literal"><span class="pre">True</span></code></span><span class="yiyi-st" id="yiyi-108">在POSIX上，函数检查<em>路径</em>的父节点，<code class="file docutils literal"><span class="pre">path/..</span></code>是否与<em>路径</em>不在同一个设备上，或者<code class="file docutils literal"><span class="pre">path/..</span></code>和<em>path</em>指向同一设备上的同一个i-node  - 这应该检测所有Unix和POSIX变体的挂载点。</span><span class="yiyi-st" id="yiyi-109">在Windows上，驱动器号根和共享UNC始终是安装点，并且调用任何其他路径<code class="docutils literal"><span class="pre">GetVolumePathName</span></code>以查看它是否与输入路径不同。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-110"><span class="versionmodified">版本3.4中的新功能：</span>支持在Windows上检测非根安装点。</span></p></div></dd></dl><dl class="function"><dt id="os.path.join"><span class="yiyi-st" id="yiyi-111"><code class="descclassname">os.path.</code><code class="descname">join</code><span class="sig-paren">(</span><em>path</em>, <em>*paths</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-112">将一个或多个路径正确地连接起来。</span><span class="yiyi-st" id="yiyi-113">返回值是<em>路径</em>和<em>*路径</em>的任何成员与每个非空的后面紧跟一个目录分隔符（<code class="docutils literal"><span class="pre">os.sep</span></code>）的连接部分，除了最后一个，意味着结果将只在分隔符结束，如果最后一部分为空。</span><span class="yiyi-st" id="yiyi-114">如果组件是绝对路径，则所有先前组件都将被丢弃，并且从绝对路径组件继续加入。</span></p><p><span class="yiyi-st" id="yiyi-115">在Windows上，遇到绝对路径组件（例如，<code class="docutils literal"><span class="pre">r'\foo'</span></code>）时，不会重置驱动器盘符。</span><span class="yiyi-st" id="yiyi-116">如果组件包含驱动器号，则所有以前的组件都将被丢弃，并且驱动器号被重置。</span><span class="yiyi-st" id="yiyi-117">请注意，由于每个驱动器都有一个当前目录，因此<code class="docutils literal"><span class="pre">os.path.join（“c：”，</span> <span class="pre">“foo”）</span> 驱动器<code class="file docutils literal"><span class="pre">C:</span></code>（<code class="file docutils literal"><span class="pre">c:foo</span></code>）上的当前目录的路径，而不是<code class="file docutils literal"><span class="pre">c:\foo</span></code>。</code></span></p></dd></dl><dl class="function"><dt id="os.path.normcase"><span class="yiyi-st" id="yiyi-118"><code class="descclassname">os.path.</code><code class="descname">normcase</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-119">标准化路径名的大小写。</span><span class="yiyi-st" id="yiyi-120">在Unix和Mac OS X上，这会返回路径不变；在不区分大小写的文件系统上，它将路径转换为小写。</span><span class="yiyi-st" id="yiyi-121">在Windows上，还会将斜线转换成反斜线。</span><span class="yiyi-st" id="yiyi-122">如果<em>路径</em>的类型不是<code class="docutils literal"><span class="pre">str</span></code>或<code class="docutils literal"><span class="pre">bytes</span></code>，则引发TypeError。</span></p></dd></dl><dl class="function"><dt id="os.path.normpath"><span class="yiyi-st" id="yiyi-123"><code class="descclassname">os.path.</code><code class="descname">normpath</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-124">通过折叠冗余分隔符和上级引用来归一化路径名，以使<code class="docutils literal"><span class="pre">A//B</span></code>，<code class="docutils literal"><span class="pre">A/B/</span></code>，<code class="docutils literal"><span class="pre">A/./B</span></code>和<code class="docutils literal"><span class="pre">A/foo/../B</span></code>都变为<code class="docutils literal"><span class="pre">A/B</span></code>。</span><span class="yiyi-st" id="yiyi-125">该字符串操作可能改变包含符号链接的路径的含义。</span><span class="yiyi-st" id="yiyi-126">在Windows上，还会将斜线转换成反斜线。</span><span class="yiyi-st" id="yiyi-127">要规范化情况，请使用<a class="reference internal" href="#os.path.normcase" title="os.path.normcase"><code class="xref py py-func docutils literal"><span class="pre">normcase()</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="os.path.realpath"><span class="yiyi-st" id="yiyi-128"><code class="descclassname">os.path.</code><code class="descname">realpath</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-129">返回指定的文件名的规范名字，并消除路径中遇到的任何符号链接（如果操作系统支持的话）。</span></p></dd></dl><dl class="function"><dt id="os.path.relpath"><span class="yiyi-st" id="yiyi-130"><code class="descclassname">os.path.</code><code class="descname">relpath</code><span class="sig-paren">(</span><em>path</em>, <em>start=os.curdir</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-131">返回自当前目录或者可选的<em>start</em> 目录的 <em>path</em>相对文件路径。</span><span class="yiyi-st" id="yiyi-132">这是一个路径计算：不访问文件系统以确认<em>路径</em>或<em>开始</em>的存在或本质。</span></p><p><span class="yiyi-st" id="yiyi-133"><em>开始</em>默认为<a class="reference internal" href="os.html#os.curdir" title="os.curdir"><code class="xref py py-attr docutils literal"><span class="pre">os.curdir</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-134">可用性：Unix，Windows。</span></p></dd></dl><dl class="function"><dt id="os.path.samefile"><span class="yiyi-st" id="yiyi-135"><code class="descclassname">os.path.</code><code class="descname">samefile</code><span class="sig-paren">(</span><em>path1</em>, <em>path2</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-136">如果两个路径名参数都指向相同的文件或目录，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-137">这由设备号和i节点号决定，如果对任一路径名的<a class="reference internal" href="os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>调用失败，则引发异常。</span></p><p><span class="yiyi-st" id="yiyi-138">可用性：Unix，Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-139"><span class="versionmodified">在版本3.2中更改：</span>添加了Windows支持。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-140"><span class="versionmodified">在版本3.4中更改：</span> Windows现在使用与所有其他平台相同的实现。</span></p></div></dd></dl><dl class="function"><dt id="os.path.sameopenfile"><span class="yiyi-st" id="yiyi-141"><code class="descclassname">os.path.</code><code class="descname">sameopenfile</code><span class="sig-paren">(</span><em>fp1</em>, <em>fp2</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-142">如果文件描述器<em>fp1</em>和<em>fp2</em>指向同一文件，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-143">可用性：Unix，Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-144"><span class="versionmodified">在版本3.2中更改：</span>添加了Windows支持。</span></p></div></dd></dl><dl class="function"><dt id="os.path.samestat"><span class="yiyi-st" id="yiyi-145"><code class="descclassname">os.path.</code><code class="descname">samestat</code><span class="sig-paren">(</span><em>stat1</em>, <em>stat2</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-146">如果统计数据元组<em>stat1</em>和<em>stat2</em>指向同一文件，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-147">这些结构可能已由<a class="reference internal" href="os.html#os.fstat" title="os.fstat"><code class="xref py py-func docutils literal"><span class="pre">os.fstat()</span></code></a>，<a class="reference internal" href="os.html#os.lstat" title="os.lstat"><code class="xref py py-func docutils literal"><span class="pre">os.lstat()</span></code></a>或<a class="reference internal" href="os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>返回。</span><span class="yiyi-st" id="yiyi-148">此函数实现<a class="reference internal" href="#os.path.samefile" title="os.path.samefile"><code class="xref py py-func docutils literal"><span class="pre">samefile()</span></code></a>和<a class="reference internal" href="#os.path.sameopenfile" title="os.path.sameopenfile"><code class="xref py py-func docutils literal"><span class="pre">sameopenfile()</span></code></a>使用的基础比较。</span></p><p><span class="yiyi-st" id="yiyi-149">可用性：Unix，Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-150"><span class="versionmodified">在版本3.4中更改：</span>添加了Windows支持。</span></p></div></dd></dl><dl class="function"><dt id="os.path.split"><span class="yiyi-st" id="yiyi-151"> <code class="descclassname">os.path.</code><code class="descname">split</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-152">将路径名<em>path</em>拆分为一个元组对<code class="docutils literal"><span class="pre">(head,</span> <span class="pre">tail)</span></code>，其中<em>tail</em>是路径名的最后一个部分，<em>head</em>是前面的所有内容。</span><span class="yiyi-st" id="yiyi-153"><em>tail</em>部分不会包含斜杠；如果<em>path</em>以斜线结尾，则<em>tail</em>将为空。</span><span class="yiyi-st" id="yiyi-154">如果<em>path</em>中没有斜线，<em>head</em>将为空。</span><span class="yiyi-st" id="yiyi-155">如果<em>path</em>为空，<em>head</em> 和 <em>tail</em>两个都将为空。</span><span class="yiyi-st" id="yiyi-156">尾部的斜线会从<em>head</em>中去除掉，除非它是根目录（只包含一个或多个斜线的目录）。</span><span class="yiyi-st" id="yiyi-157">在所有情况下，<code class="docutils literal"><span class="pre">join(head,</span> <span class="pre">tail)</span></code>返回与<em>path</em>相同位置的路径（但是字符串可能不同）。</span><span class="yiyi-st" id="yiyi-158">另请参阅函数<a class="reference internal" href="#os.path.dirname" title="os.path.dirname"><code class="xref py py-func docutils literal"><span class="pre">dirname()</span></code></a>和<a class="reference internal" href="#os.path.basename" title="os.path.basename"><code class="xref py py-func docutils literal"><span class="pre">basename()</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="os.path.splitdrive"><span class="yiyi-st" id="yiyi-159"><code class="descclassname">os.path.</code><code class="descname">splitdrive</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-160">将路径名<em>路径</em>拆分为<code class="docutils literal"><span class="pre">（drive，</span> <span class="pre">tail）</span></code>其中<em>drive</em>为挂载点或空字符串。</span><span class="yiyi-st" id="yiyi-161">在没有使用驱动器描述符的系统上，<em>drive</em> 将永远是空字符串。</span><span class="yiyi-st" id="yiyi-162">在所有情况下，<code class="docutils literal"><span class="pre">驱动</span> <span class="pre">+</span> <span class="pre">尾</span></code>将与<em>路径</em>相同。</span></p><p><span class="yiyi-st" id="yiyi-163">在Windows上，将路径名分割到驱动器/ UNC共享点和相对路径。</span></p><p><span class="yiyi-st" id="yiyi-164">如果路径包含驱动器号，驱动器将包含直到并包括冒号的所有内容。</span><span class="yiyi-st" id="yiyi-165">例如</span><span class="yiyi-st" id="yiyi-166"><code class="docutils literal"><span class="pre">splitdrive("c:/dir")</span></code>返回<code class="docutils literal"><span class="pre">（“c：”，</span> <span class="pre">“/ dir”）</span> </code></span></p><p><span class="yiyi-st" id="yiyi-167">如果路径包含UNC路径，则驱动器将包含主机名和共享（最多但不包括第四个分隔符）。</span><span class="yiyi-st" id="yiyi-168">例如</span><span class="yiyi-st" id="yiyi-169"><code class="docutils literal"><span class="pre">splitdrive("//host/computer/dir")</span></code>返回<code class="docutils literal"><span class="pre">（“// host / computer”，</span> <span class="pre">“/ dir”） t4 &gt;</span></code></span></p></dd></dl><dl class="function"><dt id="os.path.splitext"><span class="yiyi-st" id="yiyi-170"><code class="descclassname">os.path.</code><code class="descname">splitext</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-171">Split the pathname <em>path</em> into a pair <code class="docutils literal"><span class="pre">(root,</span> <span class="pre">ext)</span></code> such that <code class="docutils literal"><span class="pre">root</span> <span class="pre">+</span> <span class="pre">ext</span> <span class="pre">==</span> <span class="pre">path</span></code>, and <em>ext</em> is empty or begins with a period and contains at most one period. </span><span class="yiyi-st" id="yiyi-172">忽略basename前面的点号；<code class="docutils literal"><span class="pre">splitext('.cshrc')</span></code>返回<code class="docutils literal"><span class="pre">('.cshrc',</span> <span class="pre">'')</span></code>。</span></p></dd></dl><dl class="function"><dt id="os.path.splitunc"><span class="yiyi-st" id="yiyi-173"><code class="descclassname">os.path.</code><code class="descname">splitunc</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><div class="deprecated"><p><span class="yiyi-st" id="yiyi-174"><span class="versionmodified">自3.1版起已弃用：</span>改用<em>splitdrive</em>。</span></p></div><p><span class="yiyi-st" id="yiyi-175">将路径名<em>路径</em>拆分为<code class="docutils literal"><span class="pre">（unc，</span> <span class="pre">rest）</span></code>，以便<em>unc</em>是UNC挂载点（如<code class="docutils literal"><span class="pre">r'\\host\mount'</span></code>）（如果存在）和<em>rest</em>路径的其余部分（如<code class="docutils literal"><span class="pre">r'\path\file.ext'</span></code></span><span class="yiyi-st" id="yiyi-176">对于包含驱动器字母的路径，<em>unc</em>将永远是空字符串。</span></p><p><span class="yiyi-st" id="yiyi-177">可用性：Windows。</span></p></dd></dl><dl class="data"><dt id="os.path.supports_unicode_filenames"><span class="yiyi-st" id="yiyi-178"><code class="descclassname">os.path.</code><code class="descname">supports_unicode_filenames</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-179"><code class="docutils literal"><span class="pre">True</span></code>如果任意Unicode字符串可以用作文件名（在文件系统限制的限制之内）。</span></p></dd></dl></div></div>