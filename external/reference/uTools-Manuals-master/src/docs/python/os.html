<div class="body" role="main"><div class="section" id="module-os"><h1><span class="yiyi-st" id="yiyi-10">16.1. <a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> — 操作系统的各种接口</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/os.py">Lib/os.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">这个模快提供了一个便携的方式去使用操作系统的相关功能。</span><span class="yiyi-st" id="yiyi-13">如果你只是想要读取或写入文件请参阅 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>，如果你想要操作路径，请参阅 <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a> 模块，如果你想要在命令行上读取所有文件中的所有行，请参阅 <a class="reference internal" href="fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal"><span class="pre">fileinput</span></code></a> 模块。</span><span class="yiyi-st" id="yiyi-14">需要创建临时文件和目录，请参阅 <a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a> 模块。需要高级的文件和目录处理请参见 <a class="reference internal" href="shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal"><span class="pre">shutil</span></code></a> 模块。</span></p><p><span class="yiyi-st" id="yiyi-15">注意这些功能的可用性︰</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-16">Python的所有内置操作系统相关模块的设计都是这样的，只要具有相同的功能，它就使用相同的接口；例如，函数<code class="docutils literal"><span class="pre">os.stat(path)</span></code>以相同的格式返回有关<em>path</em>的统计信息（恰好源于POSIX接口）。</span></li><li><span class="yiyi-st" id="yiyi-17">通过<a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a>模块也可以使用特定操作系统特有的扩展，但使用它们当然会对可移植性构成威胁。</span></li><li><span class="yiyi-st" id="yiyi-18">所有接受路径或文件名的函数接受字节和字符串对象，并且如果返回路径或文件名，则会生成相同类型的对象。</span></li><li><span class="yiyi-st" id="yiyi-19">“可用性：Unix”说明意味着这个函数通常在Unix系统上找到。</span><span class="yiyi-st" id="yiyi-20">它没有在特定的操作系统上声称它的存在。</span></li><li><span class="yiyi-st" id="yiyi-21">如果没有单独说明，那么声称“可用性：Unix”的所有功能都支持在基于Unix核心的Mac OS X上。</span></li></ul><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-22">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-23">在无效或无法访问的文件名和路径或具有正确类型但操作系统不接受的其他参数的情况下，此模块中的所有函数都会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></div><dl class="exception"><dt id="os.error"><span class="yiyi-st" id="yiyi-24"> <em class="property">exception </em><code class="descclassname">os.</code><code class="descname">error</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-25">内置 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> 异常的别名.</span></p></dd></dl><dl class="data"><dt id="os.name"><span class="yiyi-st" id="yiyi-26"> <code class="descclassname">os.</code><code class="descname">name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-27">导入的操作系统相关模块的名称。</span><span class="yiyi-st" id="yiyi-28">以下名称已被注册：<code class="docutils literal"><span class="pre">'posix'</span></code>，<code class="docutils literal"><span class="pre">'nt'</span></code>，<code class="docutils literal"><span class="pre">'ce'</span></code>，<code class="docutils literal"><span class="pre">'java'</span></code></span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-29">也可以看看</span></p><p><span class="yiyi-st" id="yiyi-30"><a class="reference internal" href="sys.html#sys.platform" title="sys.platform"><code class="xref py py-attr docutils literal"><span class="pre">sys.platform</span></code></a>具有更精细的粒度。</span><span class="yiyi-st" id="yiyi-31"><a class="reference internal" href="#os.uname" title="os.uname"><code class="xref py py-func docutils literal"><span class="pre">os.uname()</span></code></a>给出系统相关的版本信息。</span></p><p class="last"><span class="yiyi-st" id="yiyi-32"><a class="reference internal" href="platform.html#module-platform" title="platform: Retrieves as much platform identifying data as possible."><code class="xref py py-mod docutils literal"><span class="pre">platform</span></code></a>模块提供了有关系统身份的详细检查。</span></p></div></dd></dl><div class="section" id="file-names-command-line-arguments-and-environment-variables"><h2><span class="yiyi-st" id="yiyi-33">16.1.1. </span><span class="yiyi-st" id="yiyi-34">文件名称，命令行参数和环境变量</span></h2><p><span class="yiyi-st" id="yiyi-35">在 Python中 文件名称、 命令行参数和环境变量使用字符串类型来表示。</span><span class="yiyi-st" id="yiyi-36">在某些系统上，将它们传递给操作系统之前解码这些字符串并从字节是必要。</span><span class="yiyi-st" id="yiyi-37">Python 使用文件系统 编码执行此转换（见 <a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal"><span class="pre">sys.getfilesystemencoding()</span></code></a>）。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-38"><span class="versionmodified">版本 3.1 中的更改︰</span>在某些系统上，使用文件系统编码的转换可能失败。</span><span class="yiyi-st" id="yiyi-39">在这种情况下，Python 使用 <a class="reference internal" href="codecs.html#surrogateescape"><span>surrogateescape 编码的错误处理程序</span></a>，这意味着 undecodable 字节的解码使用 Unicode 字符 U + DCxx替代，和这些都再次在编码中转换为原始字节。</span></p></div><p><span class="yiyi-st" id="yiyi-40">文件系统编码必须保证成功解码 128 以下的所有字节。</span><span class="yiyi-st" id="yiyi-41">如果文件系统编码不能提供这种保证，API 函数可能raise UnicodeErrors。</span></p></div><div class="section" id="process-parameters"><h2><span class="yiyi-st" id="yiyi-42">16.1.2. </span><span class="yiyi-st" id="yiyi-43">进程参数 </span></h2><p><span class="yiyi-st" id="yiyi-44">这些函数和数据的项目提供当前进程和用户的信息以及操作。</span></p><dl class="function"><dt id="os.ctermid"><span class="yiyi-st" id="yiyi-45"> <code class="descclassname">os.</code><code class="descname">ctermid</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-46">返回与进程的控制终端对应的文件名。</span></p><p><span class="yiyi-st" id="yiyi-47">可用性：Unix。</span></p></dd></dl><dl class="data"><dt id="os.environ"><span class="yiyi-st" id="yiyi-48"> <code class="descclassname">os.</code><code class="descname">environ</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-49">表示字符串环境的<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>对象。</span><span class="yiyi-st" id="yiyi-50">例如，<code class="docutils literal"><span class="pre">environ['HOME']</span></code>是主目录（在某些平台上）的路径名，相当于C中的<code class="docutils literal"><span class="pre">getenv("HOME")</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-51">该映射是在导入<a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a>模块时首次捕获的，通常在Python启动期间作为处理<code class="file docutils literal"><span class="pre">site.py</span></code>的一部分。</span><span class="yiyi-st" id="yiyi-52">除了通过直接修改<code class="docutils literal"><span class="pre">os.environ</span></code>所做的更改之外，在此时间之后对环境所做的更改不会反映在<code class="docutils literal"><span class="pre">os.environ</span></code>中。</span></p><p><span class="yiyi-st" id="yiyi-53">如果平台支持<a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>函数，则此映射可用于修改环境以及查询环境。</span><span class="yiyi-st" id="yiyi-54"><a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a> will be called automatically when the mapping is modified.</span></p><p><span class="yiyi-st" id="yiyi-55">在Unix上，键和值使用<a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal"><span class="pre">sys.getfilesystemencoding()</span></code></a>和<code class="docutils literal"><span class="pre">'surrogateescape'</span></code>错误处理程序。</span><span class="yiyi-st" id="yiyi-56">如果您想使用不同的编码，请使用<a class="reference internal" href="#os.environb" title="os.environb"><code class="xref py py-data docutils literal"><span class="pre">environb</span></code></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-57">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-58">直接调用<a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>不会改变<code class="docutils literal"><span class="pre">os.environ</span></code>，所以最好修改<code class="docutils literal"><span class="pre">os.environ</span></code>。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-59">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-60">在某些平台上，包括FreeBSD和Mac OS X，设置<code class="docutils literal"><span class="pre">environ</span></code>可能导致内存泄漏。</span><span class="yiyi-st" id="yiyi-61">请参阅<code class="xref c c-func docutils literal"><span class="pre">putenv()</span></code>的系统文档。</span></p></div><p><span class="yiyi-st" id="yiyi-62">如果未提供<a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>，则可以将此映射的修改副本传递给适当的流程创建功能，以使子流程使用修改后的环境。</span></p><p><span class="yiyi-st" id="yiyi-63">如果平台支持<a class="reference internal" href="#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">unsetenv()</span></code></a>函数，则可以删除此映射中的项目以取消设置环境变量。</span><span class="yiyi-st" id="yiyi-64"><a class="reference internal" href="#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">unsetenv()</span></code></a> will be called automatically when an item is deleted from <code class="docutils literal"><span class="pre">os.environ</span></code>, and when one of the <code class="xref py py-meth docutils literal"><span class="pre">pop()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> methods is called.</span></p></dd></dl><dl class="data"><dt id="os.environb"><span class="yiyi-st" id="yiyi-65"> <code class="descclassname">os.</code><code class="descname">environb</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-66">字节版本的<a class="reference internal" href="#os.environ" title="os.environ"><code class="xref py py-data docutils literal"><span class="pre">environ</span></code></a>：表示环境为字节字符串的<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>对象。</span><span class="yiyi-st" id="yiyi-67"><a class="reference internal" href="#os.environ" title="os.environ"><code class="xref py py-data docutils literal"><span class="pre">environ</span></code></a>和<a class="reference internal" href="#os.environb" title="os.environb"><code class="xref py py-data docutils literal"><span class="pre">environb</span></code></a>是同步的（修改<a class="reference internal" href="#os.environb" title="os.environb"><code class="xref py py-data docutils literal"><span class="pre">environb</span></code></a>更新<a class="reference internal" href="#os.environ" title="os.environ"><code class="xref py py-data docutils literal"><span class="pre">environ</span></code></a>，反之亦然）。</span></p><p><span class="yiyi-st" id="yiyi-68"><a class="reference internal" href="#os.environb" title="os.environb"><code class="xref py py-data docutils literal"><span class="pre">environb</span></code></a>仅在<a class="reference internal" href="#os.supports_bytes_environ" title="os.supports_bytes_environ"><code class="xref py py-data docutils literal"><span class="pre">supports_bytes_environ</span></code></a>为True时可用。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-69"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt><span class="yiyi-st" id="yiyi-70"><code class="descclassname">os.</code><code class="descname">chdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-71"><code class="descclassname">os.</code><code class="descname">fchdir</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-72"><code class="descclassname">os.</code><code class="descname">getcwd</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-73">这些功能在<a class="reference internal" href="#os-file-dir"><span>文件和目录</span></a>中进行了说明。</span></p></dd></dl><dl class="function"><dt id="os.fsencode"><span class="yiyi-st" id="yiyi-74"> <code class="descclassname">os.</code><code class="descname">fsencode</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-75">在Windows上使用<code class="docutils literal"><span class="pre">'surrogateescape'</span></code>错误处理程序或<code class="docutils literal"><span class="pre">'strict'</span></code>编码<em>文件名</em>返回<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>不变。</span></p><p><span class="yiyi-st" id="yiyi-76"><a class="reference internal" href="#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal"><span class="pre">fsdecode()</span></code></a> is the reverse function.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-77"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.fsdecode"><span class="yiyi-st" id="yiyi-78"> <code class="descclassname">os.</code><code class="descname">fsdecode</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-79">在Windows上使用<code class="docutils literal"><span class="pre">'surrogateescape'</span></code>错误处理程序或<code class="docutils literal"><span class="pre">'strict'</span></code>对文件系统进行解码<em>filename</em>返回<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>不变。</span></p><p><span class="yiyi-st" id="yiyi-80"><a class="reference internal" href="#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal"><span class="pre">fsencode()</span></code></a> is the reverse function.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-81"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.getenv"><span class="yiyi-st" id="yiyi-82"> <code class="descclassname">os.</code><code class="descname">getenv</code><span class="sig-paren">(</span><em>key</em>, <em>default=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">如果它存在，则返回环境变量<em>键</em>的值；如果不存在，则返回<em>默认值</em>。</span><span class="yiyi-st" id="yiyi-84"><em>键</em>，<em>默认</em>，结果是str。</span></p><p><span class="yiyi-st" id="yiyi-85">在Unix上，键和值用<a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal"><span class="pre">sys.getfilesystemencoding()</span></code></a>和<code class="docutils literal"><span class="pre">'surrogateescape'</span></code>错误处理程序解码。</span><span class="yiyi-st" id="yiyi-86">如果您想使用不同的编码，请使用<a class="reference internal" href="#os.getenvb" title="os.getenvb"><code class="xref py py-func docutils literal"><span class="pre">os.getenvb()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-87">可用性：最受欢迎的Unix，Windows。</span></p></dd></dl><dl class="function"><dt id="os.getenvb"><span class="yiyi-st" id="yiyi-88"> <code class="descclassname">os.</code><code class="descname">getenvb</code><span class="sig-paren">(</span><em>key</em>, <em>default=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-89">如果它存在，则返回环境变量<em>键</em>的值；如果不存在，则返回<em>默认值</em>。</span><span class="yiyi-st" id="yiyi-90"><em>键</em>，<em>默认</em>，结果是字节。</span></p><p><span class="yiyi-st" id="yiyi-91">可用性：大多数Unix的口味。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-92"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.get_exec_path"><span class="yiyi-st" id="yiyi-93"> <code class="descclassname">os.</code><code class="descname">get_exec_path</code><span class="sig-paren">(</span><em>env=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">在启动进程时，返回将搜索命名可执行文件的目录列表，类似于shell。</span><span class="yiyi-st" id="yiyi-95"><em>env</em>, when specified, should be an environment variable dictionary to lookup the PATH in. </span><span class="yiyi-st" id="yiyi-96">默认情况下，当<em>env</em>为None时，使用<a class="reference internal" href="#os.environ" title="os.environ"><code class="xref py py-data docutils literal"><span class="pre">environ</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-97"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.getegid"><span class="yiyi-st" id="yiyi-98"> <code class="descclassname">os.</code><code class="descname">getegid</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-99">返回当前进程的有效组标识。</span><span class="yiyi-st" id="yiyi-100">这对应于当前进程中正在执行的文件上的“set id”位。</span></p><p><span class="yiyi-st" id="yiyi-101">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.geteuid"><span class="yiyi-st" id="yiyi-102"> <code class="descclassname">os.</code><code class="descname">geteuid</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p id="index-0"><span class="yiyi-st" id="yiyi-103">返回当前进程的有效用户标识。</span></p><p><span class="yiyi-st" id="yiyi-104">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.getgid"><span class="yiyi-st" id="yiyi-105"> <code class="descclassname">os.</code><code class="descname">getgid</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p id="index-1"><span class="yiyi-st" id="yiyi-106">返回当前进程的实际组ID。</span></p><p><span class="yiyi-st" id="yiyi-107">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.getgrouplist"><span class="yiyi-st" id="yiyi-108"> <code class="descclassname">os.</code><code class="descname">getgrouplist</code><span class="sig-paren">(</span><em>user</em>, <em>group</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-109">返回<em>user</em>所属的组ID的列表。</span><span class="yiyi-st" id="yiyi-110">如果<em>组</em>不在列表中，则包含它；通常，<em>组</em>被指定为<em>user</em>的密码记录中的组ID字段。</span></p><p><span class="yiyi-st" id="yiyi-111">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-112"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.getgroups"><span class="yiyi-st" id="yiyi-113"> <code class="descclassname">os.</code><code class="descname">getgroups</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-114">返回与当前进程关联的补充组标识的列表。</span></p><p><span class="yiyi-st" id="yiyi-115">可用性：UNIX。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-116">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-117">在Mac OS X上，<a class="reference internal" href="#os.getgroups" title="os.getgroups"><code class="xref py py-func docutils literal"><span class="pre">getgroups()</span></code></a>行为与其他Unix平台稍有不同。</span><span class="yiyi-st" id="yiyi-118">If the Python interpreter was built with a deployment target of <code class="xref py py-const docutils literal"><span class="pre">10.5</span></code> or earlier, <a class="reference internal" href="#os.getgroups" title="os.getgroups"><code class="xref py py-func docutils literal"><span class="pre">getgroups()</span></code></a> returns the list of effective group ids associated with the current user process; this list is limited to a system-defined number of entries, typically 16, and may be modified by calls to <a class="reference internal" href="#os.setgroups" title="os.setgroups"><code class="xref py py-func docutils literal"><span class="pre">setgroups()</span></code></a> if suitably privileged. </span><span class="yiyi-st" id="yiyi-119">如果使用大于<code class="xref py py-const docutils literal"><span class="pre">10.5</span></code>的部署目标构建，则<a class="reference internal" href="#os.getgroups" title="os.getgroups"><code class="xref py py-func docutils literal"><span class="pre">getgroups()</span></code></a>返回与进程的有效用户标识关联的用户的当前组访问列表；组访问列表可能会在进程的整个生命周期中改变，它不会受到对<a class="reference internal" href="#os.setgroups" title="os.setgroups"><code class="xref py py-func docutils literal"><span class="pre">setgroups()</span></code></a>的调用的影响，并且其长度不限于16。</span><span class="yiyi-st" id="yiyi-120">部署目标值<code class="xref py py-const docutils literal"><span class="pre">MACOSX_DEPLOYMENT_TARGET</span></code>可以通过<a class="reference internal" href="sysconfig.html#sysconfig.get_config_var" title="sysconfig.get_config_var"><code class="xref py py-func docutils literal"><span class="pre">sysconfig.get_config_var()</span></code></a>获取。</span></p></div></dd></dl><dl class="function"><dt id="os.getlogin"><span class="yiyi-st" id="yiyi-121"> <code class="descclassname">os.</code><code class="descname">getlogin</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-122">Return the name of the user logged in on the controlling terminal of the process.</span><span class="yiyi-st" id="yiyi-123">For most purposes, it is more useful to use the environment variables <span class="target" id="index-2"></span><code class="xref std std-envvar docutils literal"><span class="pre">LOGNAME</span></code> or <span class="target" id="index-3"></span><code class="xref std std-envvar docutils literal"><span class="pre">USERNAME</span></code> to find out who the user is, or <code class="docutils literal"><span class="pre">pwd.getpwuid(os.getuid())[0]</span></code> to get the login name of the current real user id.</span></p><p><span class="yiyi-st" id="yiyi-124">可用性：Unix，Windows。</span></p></dd></dl><dl class="function"><dt id="os.getpgid"><span class="yiyi-st" id="yiyi-125"> <code class="descclassname">os.</code><code class="descname">getpgid</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-126">用进程id <em>pid</em>返回进程的进程组ID。</span><span class="yiyi-st" id="yiyi-127">如果<em>pid</em>为0，则返回当前进程的进程组标识。</span></p><p><span class="yiyi-st" id="yiyi-128">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.getpgrp"><span class="yiyi-st" id="yiyi-129"> <code class="descclassname">os.</code><code class="descname">getpgrp</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p id="index-4"><span class="yiyi-st" id="yiyi-130">返回当前进程组的ID。</span></p><p><span class="yiyi-st" id="yiyi-131">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.getpid"><span class="yiyi-st" id="yiyi-132"> <code class="descclassname">os.</code><code class="descname">getpid</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p id="index-5"><span class="yiyi-st" id="yiyi-133">返回当前进程id。</span></p></dd></dl><dl class="function"><dt id="os.getppid"><span class="yiyi-st" id="yiyi-134"> <code class="descclassname">os.</code><code class="descname">getppid</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p id="index-6"><span class="yiyi-st" id="yiyi-135">返回父进程的进程ID。</span><span class="yiyi-st" id="yiyi-136">当父进程退出时，在Unix上返回的id是init进程（1）之一，在Windows上它仍然是同一个id，它可能已被另一个进程重用。</span></p><p><span class="yiyi-st" id="yiyi-137">可用性：Unix，Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-138"><span class="versionmodified">在版本3.2中更改：</span>增加了对Windows的支持。</span></p></div></dd></dl><dl class="function"><dt id="os.getpriority"><span class="yiyi-st" id="yiyi-139"> <code class="descclassname">os.</code><code class="descname">getpriority</code><span class="sig-paren">(</span><em>which</em>, <em>who</em><span class="sig-paren">)</span></span></dt><dd><p id="index-7"><span class="yiyi-st" id="yiyi-140">获取计划调度优先级。</span><span class="yiyi-st" id="yiyi-141"><em>其中</em>是<a class="reference internal" href="#os.PRIO_PROCESS" title="os.PRIO_PROCESS"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PROCESS</span></code></a>，<a class="reference internal" href="#os.PRIO_PGRP" title="os.PRIO_PGRP"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PGRP</span></code></a>或<a class="reference internal" href="#os.PRIO_USER" title="os.PRIO_USER"><code class="xref py py-const docutils literal"><span class="pre">PRIO_USER</span></code></a>，<em>who</em>之一的值<em>（<a class="reference internal" href="#os.PRIO_PROCESS" title="os.PRIO_PROCESS"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PROCESS</span></code></a>的进程标识符，<a class="reference internal" href="#os.PRIO_PGRP" title="os.PRIO_PGRP"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PGRP</span></code></a>的进程组标识符，以及<a class="reference internal" href="#os.PRIO_USER" title="os.PRIO_USER"><code class="xref py py-const docutils literal"><span class="pre">PRIO_USER</span></code></a></em></span><span class="yiyi-st" id="yiyi-142"><em>who</em>表示（分别）调用进程，调用进程的进程组或调用进程的实际用户标识的零值。</span></p><p><span class="yiyi-st" id="yiyi-143">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-144"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="os.PRIO_PROCESS"><span class="yiyi-st" id="yiyi-145"> <code class="descclassname">os.</code><code class="descname">PRIO_PROCESS</code></span></dt><dt id="os.PRIO_PGRP"><span class="yiyi-st" id="yiyi-146"> <code class="descclassname">os.</code><code class="descname">PRIO_PGRP</code></span></dt><dt id="os.PRIO_USER"><span class="yiyi-st" id="yiyi-147"> <code class="descclassname">os.</code><code class="descname">PRIO_USER</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-148"><a class="reference internal" href="#os.getpriority" title="os.getpriority"><code class="xref py py-func docutils literal"><span class="pre">getpriority()</span></code></a>和<a class="reference internal" href="#os.setpriority" title="os.setpriority"><code class="xref py py-func docutils literal"><span class="pre">setpriority()</span></code></a>函数的参数。</span></p><p><span class="yiyi-st" id="yiyi-149">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-150"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.getresuid"><span class="yiyi-st" id="yiyi-151"> <code class="descclassname">os.</code><code class="descname">getresuid</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-152">返回一个元组（ruid，euid，suid），表示当前进程的真实，有效和保存的用户id。</span></p><p><span class="yiyi-st" id="yiyi-153">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-154"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.getresgid"><span class="yiyi-st" id="yiyi-155"> <code class="descclassname">os.</code><code class="descname">getresgid</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156">返回一个元组（rgid，egid，sgid），表示当前进程的真实，有效和保存的组ID。</span></p><p><span class="yiyi-st" id="yiyi-157">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-158"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.getuid"><span class="yiyi-st" id="yiyi-159"> <code class="descclassname">os.</code><code class="descname">getuid</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p id="index-8"><span class="yiyi-st" id="yiyi-160">返回当前进程的真实用户ID。</span></p><p><span class="yiyi-st" id="yiyi-161">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.initgroups"><span class="yiyi-st" id="yiyi-162"> <code class="descclassname">os.</code><code class="descname">initgroups</code><span class="sig-paren">(</span><em>username</em>, <em>gid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-163">调用系统initgroups()初始化组访问列表，其中包含指定用户名所属的所有组以及指定的组ID。</span></p><p><span class="yiyi-st" id="yiyi-164">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-165"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.putenv"><span class="yiyi-st" id="yiyi-166"> <code class="descclassname">os.</code><code class="descname">putenv</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span></span></dt><dd><p id="index-9"><span class="yiyi-st" id="yiyi-167">将名为<em>key</em>的环境变量设置为字符串<em>值</em>。</span><span class="yiyi-st" id="yiyi-168">Such changes to the environment affect subprocesses started with <a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-func docutils literal"><span class="pre">os.system()</span></code></a>, <a class="reference internal" href="#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">popen()</span></code></a> or <a class="reference internal" href="#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">fork()</span></code></a> and <a class="reference internal" href="#os.execv" title="os.execv"><code class="xref py py-func docutils literal"><span class="pre">execv()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-169">可用性：最受欢迎的Unix，Windows。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-170">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-171">在某些平台上，包括FreeBSD和Mac OS X，设置<code class="docutils literal"><span class="pre">environ</span></code>可能导致内存泄漏。</span><span class="yiyi-st" id="yiyi-172">请参阅putenv的系统文档。</span></p></div><p><span class="yiyi-st" id="yiyi-173">当支持<a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>时，<code class="docutils literal"><span class="pre">os.environ</span></code>中的项目分配会自动转换为对<a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>的相应调用。但是，对<a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>的调用不会更新<code class="docutils literal"><span class="pre">os.environ</span></code>，因此实际上最好将其分配给<code class="docutils literal"><span class="pre">os.environ</span></code>的项目。</span></p></dd></dl><dl class="function"><dt id="os.setegid"><span class="yiyi-st" id="yiyi-174"> <code class="descclassname">os.</code><code class="descname">setegid</code><span class="sig-paren">(</span><em>egid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-175">设置当前进程的有效组ID。</span></p><p><span class="yiyi-st" id="yiyi-176">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.seteuid"><span class="yiyi-st" id="yiyi-177"> <code class="descclassname">os.</code><code class="descname">seteuid</code><span class="sig-paren">(</span><em>euid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-178">设置当前进程的有效用户标识。</span></p><p><span class="yiyi-st" id="yiyi-179">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.setgid"><span class="yiyi-st" id="yiyi-180"> <code class="descclassname">os.</code><code class="descname">setgid</code><span class="sig-paren">(</span><em>gid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-181">设置当前进程的组ID。</span></p><p><span class="yiyi-st" id="yiyi-182">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.setgroups"><span class="yiyi-st" id="yiyi-183"> <code class="descclassname">os.</code><code class="descname">setgroups</code><span class="sig-paren">(</span><em>groups</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-184">将与当前进程关联的补充组标识列表设置为<em>组</em>。</span><span class="yiyi-st" id="yiyi-185"><em>组</em>必须是一个序列，并且每个元素必须是标识组的整数。</span><span class="yiyi-st" id="yiyi-186">此操作通常仅适用于超级用户。</span></p><p><span class="yiyi-st" id="yiyi-187">可用性：UNIX。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-188">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-189">在Mac OS X上，<em>组</em>的长度不得超过系统定义的最大有效组标识数，通常为16。</span><span class="yiyi-st" id="yiyi-190">有关通过调用setgroups()可能不会返回相同组列表的情况，请参阅<a class="reference internal" href="#os.getgroups" title="os.getgroups"><code class="xref py py-func docutils literal"><span class="pre">getgroups()</span></code></a>的文档。</span></p></div></dd></dl><dl class="function"><dt id="os.setpgrp"><span class="yiyi-st" id="yiyi-191"> <code class="descclassname">os.</code><code class="descname">setpgrp</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-192">根据所实现的版本，调用系统调用<code class="xref c c-func docutils literal"><span class="pre">setpgrp()</span></code>或<code class="docutils literal"><span class="pre">setpgrp（0，</span> <span class="pre">0）</span></code>任何）。</span><span class="yiyi-st" id="yiyi-193">有关语义的信息，请参阅Unix手册。</span></p><p><span class="yiyi-st" id="yiyi-194">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.setpgid"><span class="yiyi-st" id="yiyi-195"> <code class="descclassname">os.</code><code class="descname">setpgid</code><span class="sig-paren">(</span><em>pid</em>, <em>pgrp</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-196">调用系统调用<code class="xref c c-func docutils literal"><span class="pre">setpgid()</span></code>将id为<em>pid</em>的进程的进程组id设置为id为<em>pgrp</em>的进程组。</span><span class="yiyi-st" id="yiyi-197">有关语义的信息，请参阅Unix手册。</span></p><p><span class="yiyi-st" id="yiyi-198">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.setpriority"><span class="yiyi-st" id="yiyi-199"> <code class="descclassname">os.</code><code class="descname">setpriority</code><span class="sig-paren">(</span><em>which</em>, <em>who</em>, <em>priority</em><span class="sig-paren">)</span></span></dt><dd><p id="index-10"><span class="yiyi-st" id="yiyi-200">设置节目安排优先级。</span><span class="yiyi-st" id="yiyi-201"><em>其中</em>是<a class="reference internal" href="#os.PRIO_PROCESS" title="os.PRIO_PROCESS"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PROCESS</span></code></a>，<a class="reference internal" href="#os.PRIO_PGRP" title="os.PRIO_PGRP"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PGRP</span></code></a>或<a class="reference internal" href="#os.PRIO_USER" title="os.PRIO_USER"><code class="xref py py-const docutils literal"><span class="pre">PRIO_USER</span></code></a>，<em>who</em>之一的值<em>（<a class="reference internal" href="#os.PRIO_PROCESS" title="os.PRIO_PROCESS"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PROCESS</span></code></a>的进程标识符，<a class="reference internal" href="#os.PRIO_PGRP" title="os.PRIO_PGRP"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PGRP</span></code></a>的进程组标识符，以及<a class="reference internal" href="#os.PRIO_USER" title="os.PRIO_USER"><code class="xref py py-const docutils literal"><span class="pre">PRIO_USER</span></code></a></em></span><span class="yiyi-st" id="yiyi-202"><em>who</em>表示（分别）调用进程，调用进程的进程组或调用进程的实际用户标识的零值。</span><span class="yiyi-st" id="yiyi-203"><em>priority</em>是一个范围在-20到19之间的值。</span><span class="yiyi-st" id="yiyi-204">默认优先级是0；低优先级会导致更有利的调度。</span></p><p><span class="yiyi-st" id="yiyi-205">可用性：Unix</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-206"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.setregid"><span class="yiyi-st" id="yiyi-207"> <code class="descclassname">os.</code><code class="descname">setregid</code><span class="sig-paren">(</span><em>rgid</em>, <em>egid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-208">设置当前进程的真实和有效的组ID。</span></p><p><span class="yiyi-st" id="yiyi-209">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.setresgid"><span class="yiyi-st" id="yiyi-210"> <code class="descclassname">os.</code><code class="descname">setresgid</code><span class="sig-paren">(</span><em>rgid</em>, <em>egid</em>, <em>sgid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-211">设置当前进程的真实，有效和保存的组ID。</span></p><p><span class="yiyi-st" id="yiyi-212">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-213"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.setresuid"><span class="yiyi-st" id="yiyi-214"> <code class="descclassname">os.</code><code class="descname">setresuid</code><span class="sig-paren">(</span><em>ruid</em>, <em>euid</em>, <em>suid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-215">设置当前进程的真实，有效和保存的用户标识。</span></p><p><span class="yiyi-st" id="yiyi-216">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-217"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.setreuid"><span class="yiyi-st" id="yiyi-218"> <code class="descclassname">os.</code><code class="descname">setreuid</code><span class="sig-paren">(</span><em>ruid</em>, <em>euid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-219">设置当前进程的真实和有效的用户ID。</span></p><p><span class="yiyi-st" id="yiyi-220">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.getsid"><span class="yiyi-st" id="yiyi-221"> <code class="descclassname">os.</code><code class="descname">getsid</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-222">调用系统调用<code class="xref c c-func docutils literal"><span class="pre">getsid()</span></code>。</span><span class="yiyi-st" id="yiyi-223">有关语义的信息，请参阅Unix手册。</span></p><p><span class="yiyi-st" id="yiyi-224">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.setsid"><span class="yiyi-st" id="yiyi-225"> <code class="descclassname">os.</code><code class="descname">setsid</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-226">调用系统调用<code class="xref c c-func docutils literal"><span class="pre">setsid()</span></code>。</span><span class="yiyi-st" id="yiyi-227">有关语义的信息，请参阅Unix手册。</span></p><p><span class="yiyi-st" id="yiyi-228">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.setuid"><span class="yiyi-st" id="yiyi-229"> <code class="descclassname">os.</code><code class="descname">setuid</code><span class="sig-paren">(</span><em>uid</em><span class="sig-paren">)</span></span></dt><dd><p id="index-11"><span class="yiyi-st" id="yiyi-230">设置当前进程的用户标识。</span></p><p><span class="yiyi-st" id="yiyi-231">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.strerror"><span class="yiyi-st" id="yiyi-232"> <code class="descclassname">os.</code><code class="descname">strerror</code><span class="sig-paren">(</span><em>code</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-233">返回<em>代码</em>中与错误代码对应的错误消息。</span><span class="yiyi-st" id="yiyi-234">在给定未知错误号时，在<code class="xref c c-func docutils literal"><span class="pre">strerror()</span></code>返回<code class="docutils literal"><span class="pre">NULL</span></code>的平台上，引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p></dd></dl><dl class="data"><dt id="os.supports_bytes_environ"><span class="yiyi-st" id="yiyi-235"> <code class="descclassname">os.</code><code class="descname">supports_bytes_environ</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-236"><code class="docutils literal"><span class="pre">True</span></code></span><span class="yiyi-st" id="yiyi-237"><code class="docutils literal"><span class="pre">False</span></code>在Windows上）。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-238"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.umask"><span class="yiyi-st" id="yiyi-239"> <code class="descclassname">os.</code><code class="descname">umask</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-240">设置当前的数字umask并返回先前的umask。</span></p></dd></dl><dl class="function"><dt id="os.uname"><span class="yiyi-st" id="yiyi-241"> <code class="descclassname">os.</code><code class="descname">uname</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p id="index-12"><span class="yiyi-st" id="yiyi-242">返回标识当前操作系统的信息。</span><span class="yiyi-st" id="yiyi-243">返回值是一个具有五个属性的对象：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-244"><code class="xref py py-attr docutils literal"><span class="pre">sysname</span></code>  - 操作系统名称</span></li><li><span class="yiyi-st" id="yiyi-245"><code class="xref py py-attr docutils literal"><span class="pre">nodename</span></code>  - 网络上机器的名称（实施定义）</span></li><li><span class="yiyi-st" id="yiyi-246"><code class="xref py py-attr docutils literal"><span class="pre">release</span></code>  - 操作系统版本</span></li><li><span class="yiyi-st" id="yiyi-247"><code class="xref py py-attr docutils literal"><span class="pre">version</span></code>  - 操作系统版本</span></li><li><span class="yiyi-st" id="yiyi-248"><code class="xref py py-attr docutils literal"><span class="pre">machine</span></code> - hardware identifier</span></li></ul><p><span class="yiyi-st" id="yiyi-249">For backwards compatibility, this object is also iterable, behaving like a five-tuple containing <code class="xref py py-attr docutils literal"><span class="pre">sysname</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nodename</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">release</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">version</span></code>, and <code class="xref py py-attr docutils literal"><span class="pre">machine</span></code> in that order.</span></p><p><span class="yiyi-st" id="yiyi-250">某些系统将<code class="xref py py-attr docutils literal"><span class="pre">nodename</span></code>截断为8个字符或导致组件；获取主机名的更好方法是<a class="reference internal" href="socket.html#socket.gethostname" title="socket.gethostname"><code class="xref py py-func docutils literal"><span class="pre">socket.gethostname()</span></code></a>甚至是<code class="docutils literal"><span class="pre">socket.gethostbyaddr(socket.gethostname())</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-251">可用性：最近的Unix版本。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-252"><span class="versionmodified">在版本3.3中改变：</span>返回类型从一个元组改变为一个具有命名属性的元组对象。</span></p></div></dd></dl><dl class="function"><dt id="os.unsetenv"><span class="yiyi-st" id="yiyi-253"> <code class="descclassname">os.</code><code class="descname">unsetenv</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span></span></dt><dd><p id="index-13"><span class="yiyi-st" id="yiyi-254">取消设置（删除）名为<em>键</em>的环境变量。</span><span class="yiyi-st" id="yiyi-255">Such changes to the environment affect subprocesses started with <a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-func docutils literal"><span class="pre">os.system()</span></code></a>, <a class="reference internal" href="#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">popen()</span></code></a> or <a class="reference internal" href="#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">fork()</span></code></a> and <a class="reference internal" href="#os.execv" title="os.execv"><code class="xref py py-func docutils literal"><span class="pre">execv()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-256">当支持<a class="reference internal" href="#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">unsetenv()</span></code></a>时，删除<code class="docutils literal"><span class="pre">os.environ</span></code>中的项目会自动转换为对<a class="reference internal" href="#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">unsetenv()</span></code></a>的相应调用。但是，对<a class="reference internal" href="#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">unsetenv()</span></code></a>的调用不会更新<code class="docutils literal"><span class="pre">os.environ</span></code>，因此实际上最好删除<code class="docutils literal"><span class="pre">os.environ</span></code>的项目。</span></p><p><span class="yiyi-st" id="yiyi-257">可用性：最受欢迎的Unix，Windows。</span></p></dd></dl></div><div class="section" id="file-object-creation"><h2><span class="yiyi-st" id="yiyi-258">16.1.3. </span><span class="yiyi-st" id="yiyi-259">文件对象创建</span></h2><p><span class="yiyi-st" id="yiyi-260">此函数创建新的<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">文件对象</span></a>。</span><span class="yiyi-st" id="yiyi-261">（参见<a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>用于打开文件描述符。）</span></p><dl class="function"><dt id="os.fdopen"><span class="yiyi-st" id="yiyi-262"> <code class="descclassname">os.</code><code class="descname">fdopen</code><span class="sig-paren">(</span><em>fd</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-263">返回连接到文件描述符<em>fd</em>的打开文件对象。</span><span class="yiyi-st" id="yiyi-264">这是<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>内置函数的别名，并接受相同的参数。</span><span class="yiyi-st" id="yiyi-265">唯一的区别是，<a class="reference internal" href="#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">fdopen()</span></code></a>的第一个参数必须始终为整数。</span></p></dd></dl></div><div class="section" id="file-descriptor-operations"><h2><span class="yiyi-st" id="yiyi-266">16.1.4. </span><span class="yiyi-st" id="yiyi-267">文件描述符操作</span></h2><p><span class="yiyi-st" id="yiyi-268">这些函数对使用文件描述符引用的I / O流进行操作。</span></p><p><span class="yiyi-st" id="yiyi-269">文件描述符是对应于当前进程打开的文件的小整数。</span><span class="yiyi-st" id="yiyi-270">例如，标准输入通常是文件描述符0，标准输出是1，标准错误是2。</span><span class="yiyi-st" id="yiyi-271">然后，由进程打开的其他文件将被分配3,4,5等等。</span><span class="yiyi-st" id="yiyi-272">名称“文件描述符”有点欺骗性；在Unix平台上，套接字和管道也被文件描述符引用。</span></p><p><span class="yiyi-st" id="yiyi-273">必要时，可以使用<a class="reference internal" href="io.html#io.IOBase.fileno" title="io.IOBase.fileno"><code class="xref py py-meth docutils literal"><span class="pre">fileno()</span></code></a>方法获取与<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>关联的文件描述符。</span><span class="yiyi-st" id="yiyi-274">Note that using the file descriptor directly will bypass the file object methods, ignoring aspects such as internal buffering of data.</span></p><dl class="function"><dt id="os.close"><span class="yiyi-st" id="yiyi-275"> <code class="descclassname">os.</code><code class="descname">close</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-276">关闭文件描述符<em>fd</em>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-277">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-278">此函数用于低级I / O，并且必须应用于由<a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>或<a class="reference internal" href="#os.pipe" title="os.pipe"><code class="xref py py-func docutils literal"><span class="pre">pipe()</span></code></a>返回的文件描述符。</span><span class="yiyi-st" id="yiyi-279">To close a “file object” returned by the built-in function <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> or by <a class="reference internal" href="#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">popen()</span></code></a> or <a class="reference internal" href="#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">fdopen()</span></code></a>, use its <a class="reference internal" href="io.html#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> method.</span></p></div></dd></dl><dl class="function"><dt id="os.closerange"><span class="yiyi-st" id="yiyi-280"> <code class="descclassname">os.</code><code class="descname">closerange</code><span class="sig-paren">(</span><em>fd_low</em>, <em>fd_high</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-281">将所有文件描述符从<em>fd_low</em>（包括）关闭到<em>fd_high</em>（不包括），忽略错误。</span><span class="yiyi-st" id="yiyi-282">相当于（但快得多）：</span></p><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fd_low</span><span class="p">,</span> <span class="n">fd_high</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="k">pass</span>
</code></pre></dd></dl><dl class="function"><dt id="os.device_encoding"><span class="yiyi-st" id="yiyi-283"> <code class="descclassname">os.</code><code class="descname">device_encoding</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-284">如果连接到终端，则返回描述与<em>fd</em>关联的设备的编码的字符串；否则返回<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="os.dup"><span class="yiyi-st" id="yiyi-285"> <code class="descclassname">os.</code><code class="descname">dup</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-286">返回文件描述符<em>fd</em>的副本。</span><span class="yiyi-st" id="yiyi-287">新的文件描述符是<a class="reference internal" href="#fd-inheritance"><span>non-inheritable</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-288">在Windows上，当复制标准流（0：stdin，1：stdout，2：stderr）时，新文件描述符是<a class="reference internal" href="#fd-inheritance"><span>inheritable</span></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-289"><span class="versionmodified">在版本3.4中更改：</span>新的文件描述符现在是不可继承的。</span></p></div></dd></dl><dl class="function"><dt id="os.dup2"><span class="yiyi-st" id="yiyi-290"> <code class="descclassname">os.</code><code class="descname">dup2</code><span class="sig-paren">(</span><em>fd</em>, <em>fd2</em>, <em>inheritable=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-291">复制文件描述符<em>fd</em>到<em>fd2</em>，必要时关闭后者。</span><span class="yiyi-st" id="yiyi-292">默认情况下，文件描述符<em>fd2</em>为<a class="reference internal" href="#fd-inheritance"><span>inheritable</span></a>，如果<em>可继承</em>为<code class="docutils literal"><span class="pre">False</span></code>，则不可继承。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-293"><span class="versionmodified">Changed in version 3.4: </span>Add the optional <em>inheritable</em> parameter.</span></p></div></dd></dl><dl class="function"><dt id="os.fchmod"><span class="yiyi-st" id="yiyi-294"> <code class="descclassname">os.</code><code class="descname">fchmod</code><span class="sig-paren">(</span><em>fd</em>, <em>mode</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-295">将由<em>fd</em>给出的文件模式更改为数字<em>模式</em>。</span><span class="yiyi-st" id="yiyi-296">有关<em>mode</em>的可能值，请参阅<a class="reference internal" href="#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal"><span class="pre">chmod()</span></code></a>的文档。</span><span class="yiyi-st" id="yiyi-297">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.chmod（fd，</span> <span class="pre">mode）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-298">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.fchown"><span class="yiyi-st" id="yiyi-299"> <code class="descclassname">os.</code><code class="descname">fchown</code><span class="sig-paren">(</span><em>fd</em>, <em>uid</em>, <em>gid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-300">将由<em>fd</em>给出的文件的所有者和组标识更改为数字<em>uid</em>和<em>gid</em>。</span><span class="yiyi-st" id="yiyi-301">要使其中一个ID保持不变，请将其设置为-1。</span><span class="yiyi-st" id="yiyi-302">参见<a class="reference internal" href="#os.chown" title="os.chown"><code class="xref py py-func docutils literal"><span class="pre">chown()</span></code></a>。</span><span class="yiyi-st" id="yiyi-303">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.chown（fd，</span> <span class="pre">uid，</span> <span class="pre">gid）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-304">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.fdatasync"><span class="yiyi-st" id="yiyi-305"> <code class="descclassname">os.</code><code class="descname">fdatasync</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-306">用filedescriptor <em>fd</em>强制将文件写入磁盘。</span><span class="yiyi-st" id="yiyi-307">不强制更新元数据。</span></p><p><span class="yiyi-st" id="yiyi-308">可用性：UNIX。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-309">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-310">此功能在MacOS上不可用。</span></p></div></dd></dl><dl class="function"><dt id="os.fpathconf"><span class="yiyi-st" id="yiyi-311"> <code class="descclassname">os.</code><code class="descname">fpathconf</code><span class="sig-paren">(</span><em>fd</em>, <em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-312">返回与打开文件相关的系统配置信息。</span><span class="yiyi-st" id="yiyi-313"><em>name</em>指定要检索的配置值；它可能是一个字符串，它是定义的系统值的名称；这些名称在许多标准（POSIX.1，Unix 95，Unix 98等）中都有详细说明。</span><span class="yiyi-st" id="yiyi-314">一些平台也定义了其他名称。</span><span class="yiyi-st" id="yiyi-315">主机操作系统已知的名称在<code class="docutils literal"><span class="pre">pathconf_names</span></code>字典中给出。</span><span class="yiyi-st" id="yiyi-316">对于不包含在该映射中的配置变量，也接受传递<em>name</em>的整数。</span></p><p><span class="yiyi-st" id="yiyi-317">如果<em>name</em>是一个字符串且未知，则引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span><span class="yiyi-st" id="yiyi-318">If a specific value for <em>name</em> is not supported by the host system, even if it is included in <code class="docutils literal"><span class="pre">pathconf_names</span></code>, an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> is raised with <a class="reference internal" href="errno.html#errno.EINVAL" title="errno.EINVAL"><code class="xref py py-const docutils literal"><span class="pre">errno.EINVAL</span></code></a> for the error number.</span></p><p><span class="yiyi-st" id="yiyi-319">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.pathconf（fd，</span> <span class="pre">name）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-320">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.fstat"><span class="yiyi-st" id="yiyi-321"> <code class="descclassname">os.</code><code class="descname">fstat</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-322">获取文件描述符<em>fd</em>的状态。</span><span class="yiyi-st" id="yiyi-323">返回一个<a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a>对象。</span></p><p><span class="yiyi-st" id="yiyi-324">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.stat(fd)</span></code>。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-325">也可以看看</span></p><p class="last"><span class="yiyi-st" id="yiyi-326"><a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a>函数。</span></p></div></dd></dl><dl class="function"><dt id="os.fstatvfs"><span class="yiyi-st" id="yiyi-327"> <code class="descclassname">os.</code><code class="descname">fstatvfs</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-328">返回包含与文件描述符<em>fd</em>关联的文件的文件系统的信息，如<a class="reference internal" href="#os.statvfs" title="os.statvfs"><code class="xref py py-func docutils literal"><span class="pre">statvfs()</span></code></a>。</span><span class="yiyi-st" id="yiyi-329">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.statvfs(fd)</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-330">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.fsync"><span class="yiyi-st" id="yiyi-331"> <code class="descclassname">os.</code><code class="descname">fsync</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-332">用filedescriptor <em>fd</em>强制将文件写入磁盘。</span><span class="yiyi-st" id="yiyi-333">在Unix上，这会调用本地的<code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>函数；在Windows上，MS <code class="xref c c-func docutils literal"><span class="pre">_commit()</span></code>函数。</span></p><p><span class="yiyi-st" id="yiyi-334">如果你从缓冲的Python <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> <em>f</em>开始，首先执行<code class="docutils literal"><span class="pre">f.flush()</span></code>，然后执行<code class="docutils literal"><span class="pre">os.fsync(f.fileno())</span></code>，以确保与<em>f</em>关联的所有内部缓冲区都写入磁盘。</span></p><p><span class="yiyi-st" id="yiyi-335">可用性：Unix，Windows。</span></p></dd></dl><dl class="function"><dt id="os.ftruncate"><span class="yiyi-st" id="yiyi-336"> <code class="descclassname">os.</code><code class="descname">ftruncate</code><span class="sig-paren">(</span><em>fd</em>, <em>length</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-337">截断与文件描述符<em>fd</em>相对应的文件，以便它的大小最多为<em>长度</em>个字节。</span><span class="yiyi-st" id="yiyi-338">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.truncate（fd，</span> <span class="pre">length）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-339">可用性：Unix，Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-340"><span class="versionmodified">版本3.5中已更改：</span>添加了对Windows的支持</span></p></div></dd></dl><dl class="function"><dt id="os.get_blocking"><span class="yiyi-st" id="yiyi-341"> <code class="descclassname">os.</code><code class="descname">get_blocking</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-342">获取文件描述符的阻塞模式：<code class="docutils literal"><span class="pre">False</span></code>如果<a class="reference internal" href="#os.O_NONBLOCK" title="os.O_NONBLOCK"><code class="xref py py-data docutils literal"><span class="pre">O_NONBLOCK</span></code></a>标志被设置，<code class="docutils literal"><span class="pre">True</span></code>如果标志被清除。</span></p><p><span class="yiyi-st" id="yiyi-343">另见<a class="reference internal" href="#os.set_blocking" title="os.set_blocking"><code class="xref py py-func docutils literal"><span class="pre">set_blocking()</span></code></a>和<a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.setblocking()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-344">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-345"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.isatty"><span class="yiyi-st" id="yiyi-346"> <code class="descclassname">os.</code><code class="descname">isatty</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-347">如果文件描述符<em>fd</em>打开并连接到类似tty（-like）的设备，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="function"><dt id="os.lockf"><span class="yiyi-st" id="yiyi-348"> <code class="descclassname">os.</code><code class="descname">lockf</code><span class="sig-paren">(</span><em>fd</em>, <em>cmd</em>, <em>len</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-349">在打开的文件描述符上应用，测试或移除POSIX锁。</span><span class="yiyi-st" id="yiyi-350"><em>fd</em>是一个打开的文件描述符。</span><span class="yiyi-st" id="yiyi-351"><em>cmd</em>指定要使用的命令 -  <a class="reference internal" href="#os.F_LOCK" title="os.F_LOCK"><code class="xref py py-data docutils literal"><span class="pre">F_LOCK</span></code></a>，<a class="reference internal" href="#os.F_TLOCK" title="os.F_TLOCK"><code class="xref py py-data docutils literal"><span class="pre">F_TLOCK</span></code></a>，<a class="reference internal" href="#os.F_ULOCK" title="os.F_ULOCK"><code class="xref py py-data docutils literal"><span class="pre">F_ULOCK</span></code></a>或<a class="reference internal" href="#os.F_TEST" title="os.F_TEST"><code class="xref py py-data docutils literal"><span class="pre">F_TEST</span></code></a></span><span class="yiyi-st" id="yiyi-352"><em>len</em>指定要锁定的文件部分。</span></p><p><span class="yiyi-st" id="yiyi-353">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-354"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="os.F_LOCK"><span class="yiyi-st" id="yiyi-355"> <code class="descclassname">os.</code><code class="descname">F_LOCK</code></span></dt><dt id="os.F_TLOCK"><span class="yiyi-st" id="yiyi-356"> <code class="descclassname">os.</code><code class="descname">F_TLOCK</code></span></dt><dt id="os.F_ULOCK"><span class="yiyi-st" id="yiyi-357"> <code class="descclassname">os.</code><code class="descname">F_ULOCK</code></span></dt><dt id="os.F_TEST"><span class="yiyi-st" id="yiyi-358"> <code class="descclassname">os.</code><code class="descname">F_TEST</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-359">指定<a class="reference internal" href="#os.lockf" title="os.lockf"><code class="xref py py-func docutils literal"><span class="pre">lockf()</span></code></a>执行什么操作的标志。</span></p><p><span class="yiyi-st" id="yiyi-360">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-361"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.lseek"><span class="yiyi-st" id="yiyi-362"> <code class="descclassname">os.</code><code class="descname">lseek</code><span class="sig-paren">(</span><em>fd</em>, <em>pos</em>, <em>how</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-363">Set the current position of file descriptor <em>fd</em> to position <em>pos</em>, modified by <em>how</em>: <a class="reference internal" href="#os.SEEK_SET" title="os.SEEK_SET"><code class="xref py py-const docutils literal"><span class="pre">SEEK_SET</span></code></a> or <code class="docutils literal"><span class="pre">0</span></code> to set the position relative to the beginning of the file; <a class="reference internal" href="#os.SEEK_CUR" title="os.SEEK_CUR"><code class="xref py py-const docutils literal"><span class="pre">SEEK_CUR</span></code></a> or <code class="docutils literal"><span class="pre">1</span></code> to set it relative to the current position; <a class="reference internal" href="#os.SEEK_END" title="os.SEEK_END"><code class="xref py py-const docutils literal"><span class="pre">SEEK_END</span></code></a> or <code class="docutils literal"><span class="pre">2</span></code> to set it relative to the end of the file. </span><span class="yiyi-st" id="yiyi-364">从头开始，以字节为单位返回新的光标位置。</span></p></dd></dl><dl class="data"><dt id="os.SEEK_SET"><span class="yiyi-st" id="yiyi-365"> <code class="descclassname">os.</code><code class="descname">SEEK_SET</code></span></dt><dt id="os.SEEK_CUR"><span class="yiyi-st" id="yiyi-366"> <code class="descclassname">os.</code><code class="descname">SEEK_CUR</code></span></dt><dt id="os.SEEK_END"><span class="yiyi-st" id="yiyi-367"> <code class="descclassname">os.</code><code class="descname">SEEK_END</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-368"><a class="reference internal" href="#os.lseek" title="os.lseek"><code class="xref py py-func docutils literal"><span class="pre">lseek()</span></code></a>函数的参数。</span><span class="yiyi-st" id="yiyi-369">它们的值分别为0,1和2。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-370"><span class="versionmodified">版本3.3中的新功能：</span>某些操作系统可能支持其他值，例如<code class="xref py py-data docutils literal"><span class="pre">os.SEEK_HOLE</span></code>或<code class="xref py py-data docutils literal"><span class="pre">os.SEEK_DATA</span></code>。</span></p></div></dd></dl><dl class="function"><dt id="os.open"><span class="yiyi-st" id="yiyi-371"> <code class="descclassname">os.</code><code class="descname">open</code><span class="sig-paren">(</span><em>path</em>, <em>flags</em>, <em>mode=0o777</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-372">根据<em>flags</em>打开文件<em>path</em>，并根据<em>mode</em>设置不同的标志。</span><span class="yiyi-st" id="yiyi-373">当计算<em>模式</em>时，当前的umask值首先被屏蔽掉。</span><span class="yiyi-st" id="yiyi-374">返回新打开的文件的文件描述符。</span><span class="yiyi-st" id="yiyi-375">新的文件描述符是<a class="reference internal" href="#fd-inheritance"><span>non-inheritable</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-376">有关标志和模式值的说明，请参阅C运行时文档；标志常量（如<a class="reference internal" href="#os.O_RDONLY" title="os.O_RDONLY"><code class="xref py py-const docutils literal"><span class="pre">O_RDONLY</span></code></a>和<a class="reference internal" href="#os.O_WRONLY" title="os.O_WRONLY"><code class="xref py py-const docutils literal"><span class="pre">O_WRONLY</span></code></a>）在<a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a>模块中定义。</span><span class="yiyi-st" id="yiyi-377">特别是，在Windows上，需要使用<a class="reference internal" href="#os.O_BINARY" title="os.O_BINARY"><code class="xref py py-const docutils literal"><span class="pre">O_BINARY</span></code></a>以二进制模式打开文件。</span></p><p><span class="yiyi-st" id="yiyi-378">该函数可以使用<em>dir_fd</em>参数支持<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>的路径。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-379"><span class="versionmodified">在版本3.4中更改：</span>新的文件描述符现在是不可继承的。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-380">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-381">此功能适用于低级别的I / O。</span><span class="yiyi-st" id="yiyi-382">对于正常使用，使用内置函数<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>，该函数返回<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>，其中<code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">write()</span></code>方法（还有更多）。</span><span class="yiyi-st" id="yiyi-383">要将文件描述符包装到文件对象中，请使用<a class="reference internal" href="#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">fdopen()</span></code></a>。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-384"><span class="versionmodified">3.3版本中的新功能：</span> <em>dir_fd</em>参数。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-385"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-14"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-386">以下常量是<a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>函数的<em>flags</em>参数的选项。</span><span class="yiyi-st" id="yiyi-387">它们可以使用按位或运算符<code class="docutils literal"><span class="pre">|</span></code>进行组合。</span><span class="yiyi-st" id="yiyi-388">其中一些不适用于所有平台。</span><span class="yiyi-st" id="yiyi-389">有关它们的可用性和使用情况的描述，请参阅Unix上的<em class="manpage">open（2）</em>手册页或Windows上的<a class="reference external" href="https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx">MSDN</a>。</span></p><dl class="data"><dt id="os.O_RDONLY"><span class="yiyi-st" id="yiyi-390"> <code class="descclassname">os.</code><code class="descname">O_RDONLY</code></span></dt><dt id="os.O_WRONLY"><span class="yiyi-st" id="yiyi-391"> <code class="descclassname">os.</code><code class="descname">O_WRONLY</code></span></dt><dt id="os.O_RDWR"><span class="yiyi-st" id="yiyi-392"> <code class="descclassname">os.</code><code class="descname">O_RDWR</code></span></dt><dt id="os.O_APPEND"><span class="yiyi-st" id="yiyi-393"> <code class="descclassname">os.</code><code class="descname">O_APPEND</code></span></dt><dt id="os.O_CREAT"><span class="yiyi-st" id="yiyi-394"> <code class="descclassname">os.</code><code class="descname">O_CREAT</code></span></dt><dt id="os.O_EXCL"><span class="yiyi-st" id="yiyi-395"> <code class="descclassname">os.</code><code class="descname">O_EXCL</code></span></dt><dt id="os.O_TRUNC"><span class="yiyi-st" id="yiyi-396"> <code class="descclassname">os.</code><code class="descname">O_TRUNC</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-397">这些常量在Unix和Windows上可用。</span></p></dd></dl><dl class="data"><dt id="os.O_DSYNC"><span class="yiyi-st" id="yiyi-398"> <code class="descclassname">os.</code><code class="descname">O_DSYNC</code></span></dt><dt id="os.O_RSYNC"><span class="yiyi-st" id="yiyi-399"> <code class="descclassname">os.</code><code class="descname">O_RSYNC</code></span></dt><dt id="os.O_SYNC"><span class="yiyi-st" id="yiyi-400"> <code class="descclassname">os.</code><code class="descname">O_SYNC</code></span></dt><dt id="os.O_NDELAY"><span class="yiyi-st" id="yiyi-401"> <code class="descclassname">os.</code><code class="descname">O_NDELAY</code></span></dt><dt id="os.O_NONBLOCK"><span class="yiyi-st" id="yiyi-402"> <code class="descclassname">os.</code><code class="descname">O_NONBLOCK</code></span></dt><dt id="os.O_NOCTTY"><span class="yiyi-st" id="yiyi-403"> <code class="descclassname">os.</code><code class="descname">O_NOCTTY</code></span></dt><dt id="os.O_SHLOCK"><span class="yiyi-st" id="yiyi-404"> <code class="descclassname">os.</code><code class="descname">O_SHLOCK</code></span></dt><dt id="os.O_EXLOCK"><span class="yiyi-st" id="yiyi-405"> <code class="descclassname">os.</code><code class="descname">O_EXLOCK</code></span></dt><dt id="os.O_CLOEXEC"><span class="yiyi-st" id="yiyi-406"> <code class="descclassname">os.</code><code class="descname">O_CLOEXEC</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-407">这些常量仅在Unix上可用。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-408"><span class="versionmodified">在版本3.3中更改：</span>添加<a class="reference internal" href="#os.O_CLOEXEC" title="os.O_CLOEXEC"><code class="xref py py-data docutils literal"><span class="pre">O_CLOEXEC</span></code></a>常量。</span></p></div></dd></dl><dl class="data"><dt id="os.O_BINARY"><span class="yiyi-st" id="yiyi-409"> <code class="descclassname">os.</code><code class="descname">O_BINARY</code></span></dt><dt id="os.O_NOINHERIT"><span class="yiyi-st" id="yiyi-410"> <code class="descclassname">os.</code><code class="descname">O_NOINHERIT</code></span></dt><dt id="os.O_SHORT_LIVED"><span class="yiyi-st" id="yiyi-411"> <code class="descclassname">os.</code><code class="descname">O_SHORT_LIVED</code></span></dt><dt id="os.O_TEMPORARY"><span class="yiyi-st" id="yiyi-412"> <code class="descclassname">os.</code><code class="descname">O_TEMPORARY</code></span></dt><dt id="os.O_RANDOM"><span class="yiyi-st" id="yiyi-413"> <code class="descclassname">os.</code><code class="descname">O_RANDOM</code></span></dt><dt id="os.O_SEQUENTIAL"><span class="yiyi-st" id="yiyi-414"> <code class="descclassname">os.</code><code class="descname">O_SEQUENTIAL</code></span></dt><dt id="os.O_TEXT"><span class="yiyi-st" id="yiyi-415"> <code class="descclassname">os.</code><code class="descname">O_TEXT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-416">这些常量仅在Windows上可用。</span></p></dd></dl><dl class="data"><dt id="os.O_ASYNC"><span class="yiyi-st" id="yiyi-417"> <code class="descclassname">os.</code><code class="descname">O_ASYNC</code></span></dt><dt id="os.O_DIRECT"><span class="yiyi-st" id="yiyi-418"> <code class="descclassname">os.</code><code class="descname">O_DIRECT</code></span></dt><dt id="os.O_DIRECTORY"><span class="yiyi-st" id="yiyi-419"> <code class="descclassname">os.</code><code class="descname">O_DIRECTORY</code></span></dt><dt id="os.O_NOFOLLOW"><span class="yiyi-st" id="yiyi-420"> <code class="descclassname">os.</code><code class="descname">O_NOFOLLOW</code></span></dt><dt id="os.O_NOATIME"><span class="yiyi-st" id="yiyi-421"> <code class="descclassname">os.</code><code class="descname">O_NOATIME</code></span></dt><dt id="os.O_PATH"><span class="yiyi-st" id="yiyi-422"> <code class="descclassname">os.</code><code class="descname">O_PATH</code></span></dt><dt id="os.O_TMPFILE"><span class="yiyi-st" id="yiyi-423"> <code class="descclassname">os.</code><code class="descname">O_TMPFILE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-424">这些常量是GNU扩展，如果它们没有被C库定义则不存在。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-425"><span class="versionmodified">Changed in version 3.4: </span>Add <a class="reference internal" href="#os.O_PATH" title="os.O_PATH"><code class="xref py py-data docutils literal"><span class="pre">O_PATH</span></code></a> on systems that support it. </span><span class="yiyi-st" id="yiyi-426">添加<a class="reference internal" href="#os.O_TMPFILE" title="os.O_TMPFILE"><code class="xref py py-data docutils literal"><span class="pre">O_TMPFILE</span></code></a>，仅适用于Linux Kernel 3.11或更新版本。</span></p></div></dd></dl><dl class="function"><dt id="os.openpty"><span class="yiyi-st" id="yiyi-427"> <code class="descclassname">os.</code><code class="descname">openpty</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p id="index-15"><span class="yiyi-st" id="yiyi-428">打开一个新的伪终端对。</span><span class="yiyi-st" id="yiyi-429">分别为pty和tty返回一对文件描述符<code class="docutils literal"><span class="pre">（master，</span> <span class="pre">slave）</span></code>。</span><span class="yiyi-st" id="yiyi-430">新的文件描述符是<a class="reference internal" href="#fd-inheritance"><span>non-inheritable</span></a>。</span><span class="yiyi-st" id="yiyi-431">对于（稍微）更便携的方法，请使用<a class="reference internal" href="pty.html#module-pty" title="pty: Pseudo-Terminal Handling for Linux. (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">pty</span></code></a>模块。</span></p><p><span class="yiyi-st" id="yiyi-432">可用性：一些Unix的味道。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-433"><span class="versionmodified">在版本3.4中更改：</span>新的文件描述符现在是不可继承的。</span></p></div></dd></dl><dl class="function"><dt id="os.pipe"><span class="yiyi-st" id="yiyi-434"> <code class="descclassname">os.</code><code class="descname">pipe</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-435">创建一个管道。</span><span class="yiyi-st" id="yiyi-436">分别返回可用于读写的一对文件描述符<code class="docutils literal"><span class="pre">（r，</span> <span class="pre">w）</span></code>。</span><span class="yiyi-st" id="yiyi-437">新的文件描述符是<a class="reference internal" href="#fd-inheritance"><span>non-inheritable</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-438">可用性：Unix，Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-439"><span class="versionmodified">在版本3.4中更改：</span>新的文件描述符现在是不可继承的。</span></p></div></dd></dl><dl class="function"><dt id="os.pipe2"><span class="yiyi-st" id="yiyi-440"> <code class="descclassname">os.</code><code class="descname">pipe2</code><span class="sig-paren">(</span><em>flags</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-441">使用<em>flags</em>自动设置一个管道。</span><span class="yiyi-st" id="yiyi-442"><em>flags</em>可以通过OR这些值中的一个或多个来构造：<a class="reference internal" href="#os.O_NONBLOCK" title="os.O_NONBLOCK"><code class="xref py py-data docutils literal"><span class="pre">O_NONBLOCK</span></code></a>，<a class="reference internal" href="#os.O_CLOEXEC" title="os.O_CLOEXEC"><code class="xref py py-data docutils literal"><span class="pre">O_CLOEXEC</span></code></a>。</span><span class="yiyi-st" id="yiyi-443">分别返回可用于读写的一对文件描述符<code class="docutils literal"><span class="pre">（r，</span> <span class="pre">w）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-444">可用性：一些Unix的味道。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-445"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.posix_fallocate"><span class="yiyi-st" id="yiyi-446"> <code class="descclassname">os.</code><code class="descname">posix_fallocate</code><span class="sig-paren">(</span><em>fd</em>, <em>offset</em>, <em>len</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-447">确保为<em>fd</em>指定的文件分配足够的磁盘空间，该文件从<em>offset</em>开始并继续处理<em>len</em>字节。</span></p><p><span class="yiyi-st" id="yiyi-448">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-449"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.posix_fadvise"><span class="yiyi-st" id="yiyi-450"> <code class="descclassname">os.</code><code class="descname">posix_fadvise</code><span class="sig-paren">(</span><em>fd</em>, <em>offset</em>, <em>len</em>, <em>advice</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-451">宣布打算以特定模式访问数据，从而允许内核进行优化。</span><span class="yiyi-st" id="yiyi-452">该建议适用于由<em>fd</em>从<em>offset</em>开始并继续<em>len</em>字节指定的文件区域。</span><span class="yiyi-st" id="yiyi-453"><em>advice</em> is one of <a class="reference internal" href="#os.POSIX_FADV_NORMAL" title="os.POSIX_FADV_NORMAL"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_NORMAL</span></code></a>, <a class="reference internal" href="#os.POSIX_FADV_SEQUENTIAL" title="os.POSIX_FADV_SEQUENTIAL"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_SEQUENTIAL</span></code></a>, <a class="reference internal" href="#os.POSIX_FADV_RANDOM" title="os.POSIX_FADV_RANDOM"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_RANDOM</span></code></a>, <a class="reference internal" href="#os.POSIX_FADV_NOREUSE" title="os.POSIX_FADV_NOREUSE"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_NOREUSE</span></code></a>, <a class="reference internal" href="#os.POSIX_FADV_WILLNEED" title="os.POSIX_FADV_WILLNEED"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_WILLNEED</span></code></a> or <a class="reference internal" href="#os.POSIX_FADV_DONTNEED" title="os.POSIX_FADV_DONTNEED"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_DONTNEED</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-454">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-455"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="os.POSIX_FADV_NORMAL"><span class="yiyi-st" id="yiyi-456"> <code class="descclassname">os.</code><code class="descname">POSIX_FADV_NORMAL</code></span></dt><dt id="os.POSIX_FADV_SEQUENTIAL"><span class="yiyi-st" id="yiyi-457"> <code class="descclassname">os.</code><code class="descname">POSIX_FADV_SEQUENTIAL</code></span></dt><dt id="os.POSIX_FADV_RANDOM"><span class="yiyi-st" id="yiyi-458"> <code class="descclassname">os.</code><code class="descname">POSIX_FADV_RANDOM</code></span></dt><dt id="os.POSIX_FADV_NOREUSE"><span class="yiyi-st" id="yiyi-459"> <code class="descclassname">os.</code><code class="descname">POSIX_FADV_NOREUSE</code></span></dt><dt id="os.POSIX_FADV_WILLNEED"><span class="yiyi-st" id="yiyi-460"> <code class="descclassname">os.</code><code class="descname">POSIX_FADV_WILLNEED</code></span></dt><dt id="os.POSIX_FADV_DONTNEED"><span class="yiyi-st" id="yiyi-461"> <code class="descclassname">os.</code><code class="descname">POSIX_FADV_DONTNEED</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-462">可以在<a class="reference internal" href="#os.posix_fadvise" title="os.posix_fadvise"><code class="xref py py-func docutils literal"><span class="pre">posix_fadvise()</span></code></a>的<em>advice</em>中使用的标志指定可能使用的访问模式。</span></p><p><span class="yiyi-st" id="yiyi-463">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-464"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.pread"><span class="yiyi-st" id="yiyi-465"> <code class="descclassname">os.</code><code class="descname">pread</code><span class="sig-paren">(</span><em>fd</em>, <em>buffersize</em>, <em>offset</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-466">从文件描述符<em>fd</em>中读取<em>offset</em>位置处的文件描述符。</span><span class="yiyi-st" id="yiyi-467">它将读取<em>buffersize</em>字节数。</span><span class="yiyi-st" id="yiyi-468">文件偏移保持不变。</span></p><p><span class="yiyi-st" id="yiyi-469">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-470"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.pwrite"><span class="yiyi-st" id="yiyi-471"> <code class="descclassname">os.</code><code class="descname">pwrite</code><span class="sig-paren">(</span><em>fd</em>, <em>str</em>, <em>offset</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-472">将<em>bytestring</em>从<em>offset</em>写入文件描述符<em>fd</em>，使文件偏移保持不变。</span></p><p><span class="yiyi-st" id="yiyi-473">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-474"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.read"><span class="yiyi-st" id="yiyi-475"> <code class="descclassname">os.</code><code class="descname">read</code><span class="sig-paren">(</span><em>fd</em>, <em>n</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-476">从文件描述符<em>fd</em>中最多读取<em>n</em>个字节。</span><span class="yiyi-st" id="yiyi-477">返回包含读取字节的字节串。</span><span class="yiyi-st" id="yiyi-478">如果已经到达由<em>fd</em>引用的文件末尾，则返回空字节对象。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-479">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-480">此函数用于低级I / O，并且必须应用于由<a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>或<a class="reference internal" href="#os.pipe" title="os.pipe"><code class="xref py py-func docutils literal"><span class="pre">pipe()</span></code></a>返回的文件描述符。</span><span class="yiyi-st" id="yiyi-481">To read a “file object” returned by the built-in function <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> or by <a class="reference internal" href="#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">popen()</span></code></a> or <a class="reference internal" href="#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">fdopen()</span></code></a>, or <a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal"><span class="pre">sys.stdin</span></code></a>, use its <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code> methods.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-482"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-16"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="function"><dt id="os.sendfile"><span class="yiyi-st" id="yiyi-483"> <code class="descclassname">os.</code><code class="descname">sendfile</code><span class="sig-paren">(</span><em>out</em>, <em>in</em>, <em>offset</em>, <em>count</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-484"> <code class="descclassname">os.</code><code class="descname">sendfile</code><span class="sig-paren">(</span><em>out</em>, <em>in</em>, <em>offset</em>, <em>count</em>, <span class="optional">[</span><em>headers</em>, <span class="optional">]</span><span class="optional">[</span><em>trailers</em>, <span class="optional">]</span><em>flags=0</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-485">从<em>offset</em>开始，将<em>count</em>字节从中的文件描述符<em>复制到文件描述符<em>out</em>。</em></span><span class="yiyi-st" id="yiyi-486">返回发送的字节数。</span><span class="yiyi-st" id="yiyi-487">EOF到达时返回0。</span></p><p><span class="yiyi-st" id="yiyi-488">定义<a class="reference internal" href="#os.sendfile" title="os.sendfile"><code class="xref py py-func docutils literal"><span class="pre">sendfile()</span></code></a>的所有平台都支持第一个函数表示法。</span></p><p><span class="yiyi-st" id="yiyi-489">On Linux, if <em>offset</em> is given as <code class="docutils literal"><span class="pre">None</span></code>, the bytes are read from the current position of <em>in</em> and the position of <em>in</em> is updated.</span></p><p><span class="yiyi-st" id="yiyi-490">第二种情况可能在Mac OS X和FreeBSD上使用，其中<em>头</em>和<em>尾&gt;</em>是任意序列的缓冲区，在<em>t2&gt;写入。</em></span><span class="yiyi-st" id="yiyi-491">它返回与第一种情况相同的结果。</span></p><p><span class="yiyi-st" id="yiyi-492">On Mac OS X and FreeBSD, a value of 0 for <em>count</em> specifies to send until the end of <em>in</em> is reached.</span></p><p><span class="yiyi-st" id="yiyi-493">所有平台都支持套接字作为<em>out</em>文件描述符，并且一些平台允许其他类型（例如，</span><span class="yiyi-st" id="yiyi-494">普通文件，管道）。</span></p><p><span class="yiyi-st" id="yiyi-495">跨平台应用程序不应该使用<em>头</em>，<em>尾部</em>和<em>标记</em>参数。</span></p><p><span class="yiyi-st" id="yiyi-496">可用性：UNIX。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-497">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-498">对于<a class="reference internal" href="#os.sendfile" title="os.sendfile"><code class="xref py py-func docutils literal"><span class="pre">sendfile()</span></code></a>的更高级别包装，请参阅<a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.sendfile()</span></code></a>。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-499"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.set_blocking"><span class="yiyi-st" id="yiyi-500"> <code class="descclassname">os.</code><code class="descname">set_blocking</code><span class="sig-paren">(</span><em>fd</em>, <em>blocking</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-501">设置指定文件描述符的阻止模式。</span><span class="yiyi-st" id="yiyi-502">如果阻塞<code class="docutils literal"><span class="pre">False</span></code>，则设置<a class="reference internal" href="#os.O_NONBLOCK" title="os.O_NONBLOCK"><code class="xref py py-data docutils literal"><span class="pre">O_NONBLOCK</span></code></a>标志，否则清除该标志。</span></p><p><span class="yiyi-st" id="yiyi-503">另见<a class="reference internal" href="#os.get_blocking" title="os.get_blocking"><code class="xref py py-func docutils literal"><span class="pre">get_blocking()</span></code></a>和<a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.setblocking()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-504">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-505"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="os.SF_NODISKIO"><span class="yiyi-st" id="yiyi-506"> <code class="descclassname">os.</code><code class="descname">SF_NODISKIO</code></span></dt><dt id="os.SF_MNOWAIT"><span class="yiyi-st" id="yiyi-507"> <code class="descclassname">os.</code><code class="descname">SF_MNOWAIT</code></span></dt><dt id="os.SF_SYNC"><span class="yiyi-st" id="yiyi-508"> <code class="descclassname">os.</code><code class="descname">SF_SYNC</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-509"><a class="reference internal" href="#os.sendfile" title="os.sendfile"><code class="xref py py-func docutils literal"><span class="pre">sendfile()</span></code></a>函数的参数，如果实现支持它们的话。</span></p><p><span class="yiyi-st" id="yiyi-510">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-511"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.readv"><span class="yiyi-st" id="yiyi-512"> <code class="descclassname">os.</code><code class="descname">readv</code><span class="sig-paren">(</span><em>fd</em>, <em>buffers</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-513">从文件描述符<em>fd</em>中读入多个可变的<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a> <em>缓冲区</em>。</span><span class="yiyi-st" id="yiyi-514"><a class="reference internal" href="#os.readv" title="os.readv"><code class="xref py py-func docutils literal"><span class="pre">readv()</span></code></a> will transfer data into each buffer until it is full and then move on to the next buffer in the sequence to hold the rest of the data. </span><span class="yiyi-st" id="yiyi-515"><a class="reference internal" href="#os.readv" title="os.readv"><code class="xref py py-func docutils literal"><span class="pre">readv()</span></code></a> returns the total number of bytes read (which may be less than the total capacity of all the objects).</span></p><p><span class="yiyi-st" id="yiyi-516">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-517"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.tcgetpgrp"><span class="yiyi-st" id="yiyi-518"> <code class="descclassname">os.</code><code class="descname">tcgetpgrp</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-519">返回由<em>fd</em>（由<a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>返回的打开文件描述符）给出的与终端关联的进程组。</span></p><p><span class="yiyi-st" id="yiyi-520">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.tcsetpgrp"><span class="yiyi-st" id="yiyi-521"> <code class="descclassname">os.</code><code class="descname">tcsetpgrp</code><span class="sig-paren">(</span><em>fd</em>, <em>pg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-522">将与由<em>fd</em>（由<a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>）返回的打开文件描述符给出的终端关联的进程组设置为<em>pg</em>。</span></p><p><span class="yiyi-st" id="yiyi-523">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.ttyname"><span class="yiyi-st" id="yiyi-524"> <code class="descclassname">os.</code><code class="descname">ttyname</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-525">返回一个字符串，它指定与文件描述符<em>fd</em>关联的终端设备。</span><span class="yiyi-st" id="yiyi-526">如果<em>fd</em>未与终端设备关联，则会引发异常。</span></p><p><span class="yiyi-st" id="yiyi-527">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.write"><span class="yiyi-st" id="yiyi-528"> <code class="descclassname">os.</code><code class="descname">write</code><span class="sig-paren">(</span><em>fd</em>, <em>str</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-529">将<em>str</em>中的字节串写入文件描述符<em>fd</em>。</span><span class="yiyi-st" id="yiyi-530">返回实际写入的字节数。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-531">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-532">此函数用于低级I / O，并且必须应用于由<a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>或<a class="reference internal" href="#os.pipe" title="os.pipe"><code class="xref py py-func docutils literal"><span class="pre">pipe()</span></code></a>返回的文件描述符。</span><span class="yiyi-st" id="yiyi-533">To write a “file object” returned by the built-in function <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> or by <a class="reference internal" href="#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">popen()</span></code></a> or <a class="reference internal" href="#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">fdopen()</span></code></a>, or <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a> or <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a>, use its <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> method.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-534"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-17"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="function"><dt id="os.writev"><span class="yiyi-st" id="yiyi-535"> <code class="descclassname">os.</code><code class="descname">writev</code><span class="sig-paren">(</span><em>fd</em>, <em>buffers</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-536">将<em>buffers</em>的内容写入文件描述符<em>fd</em>。</span><span class="yiyi-st" id="yiyi-537"><em>buffers</em>必须是<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>的序列。</span><span class="yiyi-st" id="yiyi-538">缓冲区按阵列顺序处理。</span><span class="yiyi-st" id="yiyi-539">第一个缓冲区的全部内容在进入第二个之前写入，依此类推。</span><span class="yiyi-st" id="yiyi-540">操作系统可以对可以使用的缓冲区数量设置限制（sysconf()值SC_IOV_MAX）。</span></p><p><span class="yiyi-st" id="yiyi-541"><a class="reference internal" href="#os.writev" title="os.writev"><code class="xref py py-func docutils literal"><span class="pre">writev()</span></code></a> writes the contents of each object to the file descriptor and returns the total number of bytes written.</span></p><p><span class="yiyi-st" id="yiyi-542">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-543"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><div class="section" id="querying-the-size-of-a-terminal"><h3><span class="yiyi-st" id="yiyi-544">16.1.4.1. </span><span class="yiyi-st" id="yiyi-545">查询终端的大小</span></h3><div class="versionadded"><p><span class="yiyi-st" id="yiyi-546"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><dl class="function"><dt id="os.get_terminal_size"><span class="yiyi-st" id="yiyi-547"> <code class="descclassname">os.</code><code class="descname">get_terminal_size</code><span class="sig-paren">(</span><em>fd=STDOUT_FILENO</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-548">以<code class="docutils literal"><span class="pre">（列，</span> <span class="pre">行）</span></code>，<a class="reference internal" href="#os.terminal_size" title="os.terminal_size"><code class="xref py py-class docutils literal"><span class="pre">terminal_size</span></code></a>类型的元组的形式返回终端窗口的大小。</span></p><p><span class="yiyi-st" id="yiyi-549">可选参数<code class="docutils literal"><span class="pre">fd</span></code>（默认<code class="docutils literal"><span class="pre">STDOUT_FILENO</span></code>或标准输出）指定应查询哪个文件描述符。</span></p><p><span class="yiyi-st" id="yiyi-550">如果文件描述符未连接到终端，则引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-551"><a class="reference internal" href="shutil.html#shutil.get_terminal_size" title="shutil.get_terminal_size"><code class="xref py py-func docutils literal"><span class="pre">shutil.get_terminal_size()</span></code></a> is the high-level function which should normally be used, <code class="docutils literal"><span class="pre">os.get_terminal_size</span></code> is the low-level implementation.</span></p><p><span class="yiyi-st" id="yiyi-552">可用性：Unix，Windows。</span></p></dd></dl><dl class="class"><dt id="os.terminal_size"><span class="yiyi-st" id="yiyi-553"> <em class="property">class </em><code class="descclassname">os.</code><code class="descname">terminal_size</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-554">元组的子类，保存终端窗口大小的<code class="docutils literal"><span class="pre">（列，</span> <span class="pre">行）</span></code>。</span></p><dl class="attribute"><dt id="os.terminal_size.columns"><span class="yiyi-st" id="yiyi-555"> <code class="descname">columns</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-556">终端窗口的宽度，以字符为单位。</span></p></dd></dl><dl class="attribute"><dt id="os.terminal_size.lines"><span class="yiyi-st" id="yiyi-557"> <code class="descname">lines</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-558">终端窗口的高度，以字符表示。</span></p></dd></dl></dd></dl></div><div class="section" id="inheritance-of-file-descriptors"><h3><span class="yiyi-st" id="yiyi-559">16.1.4.2. </span><span class="yiyi-st" id="yiyi-560">文件描述符的继承</span></h3><div class="versionadded"><p><span class="yiyi-st" id="yiyi-561"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div><p><span class="yiyi-st" id="yiyi-562">文件描述符具有“可继承”标志，该标志指示文件描述符是否可以被子进程继承。</span><span class="yiyi-st" id="yiyi-563">从Python 3.4开始，由Python创建的文件描述符在默认情况下是非可继承的。</span></p><p><span class="yiyi-st" id="yiyi-564">在UNIX上，执行新程序时，子进程中的非可继承文件描述符被关闭，其他文件描述符被继承。</span></p><p><span class="yiyi-st" id="yiyi-565">在Windows上，除了标准流（文件描述符0,1和2：stdin，stdout和stderr）外，子进程中的非可继承句柄和文件描述符都是关闭的，它们始终是继承的。</span><span class="yiyi-st" id="yiyi-566">使用<a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a>函数，所有可继承的句柄和所有可继承的文件描述符都被继承。</span><span class="yiyi-st" id="yiyi-567">使用<a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a>模块，除标准流以外的所有文件描述符都会关闭，并且只有在<em>close_fds</em>参数为<code class="docutils literal"><span class="pre">False</span></code>时才继承可继承的句柄。</span></p><dl class="function"><dt id="os.get_inheritable"><span class="yiyi-st" id="yiyi-568"> <code class="descclassname">os.</code><code class="descname">get_inheritable</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-569">获取指定文件描述符的“可继承”标志（布尔值）。</span></p></dd></dl><dl class="function"><dt id="os.set_inheritable"><span class="yiyi-st" id="yiyi-570"> <code class="descclassname">os.</code><code class="descname">set_inheritable</code><span class="sig-paren">(</span><em>fd</em>, <em>inheritable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-571">设置指定文件描述符的“可继承”标志。</span></p></dd></dl><dl class="function"><dt id="os.get_handle_inheritable"><span class="yiyi-st" id="yiyi-572"> <code class="descclassname">os.</code><code class="descname">get_handle_inheritable</code><span class="sig-paren">(</span><em>handle</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-573">获取指定句柄的“可继承”标志（布尔值）。</span></p><p><span class="yiyi-st" id="yiyi-574">可用性：Windows。</span></p></dd></dl><dl class="function"><dt id="os.set_handle_inheritable"><span class="yiyi-st" id="yiyi-575"> <code class="descclassname">os.</code><code class="descname">set_handle_inheritable</code><span class="sig-paren">(</span><em>handle</em>, <em>inheritable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-576">设置指定句柄的“可继承”标志。</span></p><p><span class="yiyi-st" id="yiyi-577">可用性：Windows。</span></p></dd></dl></div></div><div class="section" id="files-and-directories"><h2><span class="yiyi-st" id="yiyi-578">16.1.5. </span><span class="yiyi-st" id="yiyi-579">文件和目录</span></h2><p><span class="yiyi-st" id="yiyi-580">在一些Unix平台上，许多这些功能都支持以下一个或多个功能：</span></p><ul id="path-fd"><li><p class="first"><span class="yiyi-st" id="yiyi-581"><strong>指定文件描述符：</strong>对于某些函数，<em>path</em>参数不仅可以是一个给出路径名的字符串，也可以是一个文件描述符。</span><span class="yiyi-st" id="yiyi-582">然后该函数将对描述符引用的文件进行操作。</span><span class="yiyi-st" id="yiyi-583">（对于POSIX系统，Python将调用该函数的<code class="docutils literal"><span class="pre">f...</span></code>版本。）</span></p><p><span class="yiyi-st" id="yiyi-584">您可以使用<a class="reference internal" href="#os.supports_fd" title="os.supports_fd"><code class="xref py py-data docutils literal"><span class="pre">os.supports_fd</span></code></a>检查<em>path</em>是否可以在您的平台上指定为文件描述符。</span><span class="yiyi-st" id="yiyi-585">如果不可用，使用它将引发一个<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-586">如果该函数还支持<em>dir_fd</em>或<em>follow_symlinks</em>参数，则在将<em>path</em>作为文件描述符时指定其中的一个是错误的。</span></p></li></ul><ul id="dir-fd"><li><p class="first"><span class="yiyi-st" id="yiyi-587"><strong>相对于目录描述符的路径：</strong>如果<em>dir_fd</em>不是<code class="docutils literal"><span class="pre">None</span></code>，它应该是一个指向目录的文件描述符，以及要操作的路径应该是相对的；路径将是相对于该目录。</span><span class="yiyi-st" id="yiyi-588">如果路径是绝对路径，则忽略<em>dir_fd</em>。</span><span class="yiyi-st" id="yiyi-589">（对于POSIX系统，Python将在函数的版本处调用<code class="docutils literal"><span class="pre">...at</span></code>或<code class="docutils literal"><span class="pre">f...at</span></code></span></p><p><span class="yiyi-st" id="yiyi-590">您可以使用<a class="reference internal" href="#os.supports_dir_fd" title="os.supports_dir_fd"><code class="xref py py-data docutils literal"><span class="pre">os.supports_dir_fd</span></code></a>检查您的平台上是否支持<em>dir_fd</em>。</span><span class="yiyi-st" id="yiyi-591">如果不可用，使用它将引发一个<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p></li></ul><ul id="follow-symlinks"><li><p class="first"><span class="yiyi-st" id="yiyi-592"><strong>不遵循符号链接：</strong>如果<em>follow_symlinks</em>为<code class="docutils literal"><span class="pre">False</span></code>，并且要操作的路径的最后一个元素是符号链接，则该函数将在符号链接本身，而不是链接指向的文件。</span><span class="yiyi-st" id="yiyi-593">（对于POSIX系统，Python将调用该函数的<code class="docutils literal"><span class="pre">l...</span></code>版本。）</span></p><p><span class="yiyi-st" id="yiyi-594">您可以使用<a class="reference internal" href="#os.supports_follow_symlinks" title="os.supports_follow_symlinks"><code class="xref py py-data docutils literal"><span class="pre">os.supports_follow_symlinks</span></code></a>检查您的平台是否支持<em>follow_symlinks</em>。</span><span class="yiyi-st" id="yiyi-595">如果不可用，使用它将引发一个<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p></li></ul><dl class="function"><dt id="os.access"><span class="yiyi-st" id="yiyi-596"> <code class="descclassname">os.</code><code class="descname">access</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em>, <em>*</em>, <em>dir_fd=None</em>, <em>effective_ids=False</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-597">使用real uid / gid来测试对<em>路径</em>的访问。</span><span class="yiyi-st" id="yiyi-598">请注意，大多数操作将使用有效的uid / gid，因此可以在suid / sgid环境中使用此例程来测试调用用户是否具有对<em>路径</em>的指定访问权限。</span><span class="yiyi-st" id="yiyi-599"><em>mode</em> should be <a class="reference internal" href="#os.F_OK" title="os.F_OK"><code class="xref py py-const docutils literal"><span class="pre">F_OK</span></code></a> to test the existence of <em>path</em>, or it can be the inclusive OR of one or more of <a class="reference internal" href="#os.R_OK" title="os.R_OK"><code class="xref py py-const docutils literal"><span class="pre">R_OK</span></code></a>, <a class="reference internal" href="#os.W_OK" title="os.W_OK"><code class="xref py py-const docutils literal"><span class="pre">W_OK</span></code></a>, and <a class="reference internal" href="#os.X_OK" title="os.X_OK"><code class="xref py py-const docutils literal"><span class="pre">X_OK</span></code></a> to test permissions. </span><span class="yiyi-st" id="yiyi-600">如果允许访问，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>，否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span><span class="yiyi-st" id="yiyi-601">有关更多信息，请参阅Unix手册页<em class="manpage">access（2）</em>。</span></p><p><span class="yiyi-st" id="yiyi-602">该函数可以支持指定<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>和<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>的路径。</span></p><p><span class="yiyi-st" id="yiyi-603">If <em>effective_ids</em> is <code class="docutils literal"><span class="pre">True</span></code>, <a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">access()</span></code></a> will perform its access checks using the effective uid/gid instead of the real uid/gid. </span><span class="yiyi-st" id="yiyi-604">您的平台可能不支持<em>effective_ids</em>；你可以使用<a class="reference internal" href="#os.supports_effective_ids" title="os.supports_effective_ids"><code class="xref py py-data docutils literal"><span class="pre">os.supports_effective_ids</span></code></a>检查它是否可用。</span><span class="yiyi-st" id="yiyi-605">如果不可用，使用它将引发一个<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-606">注意</span></p><p><span class="yiyi-st" id="yiyi-607">使用<a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">access()</span></code></a>检查用户是否有权例如</span><span class="yiyi-st" id="yiyi-608">在使用<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>创建安全漏洞之前打开一个文件，因为用户可能会利用检查和打开文件之间的短时间间隔来操作它。</span><span class="yiyi-st" id="yiyi-609">最好使用<a class="reference internal" href="../glossary.html#term-eafp"><span class="xref std std-term">EAFP</span></a>技术。</span><span class="yiyi-st" id="yiyi-610">例如：</span></p><pre><code class="language-python"><span></span><span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="s2">"myfile"</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"myfile"</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="k">return</span> <span class="s2">"some default data"</span>
</code></pre><p><span class="yiyi-st" id="yiyi-611">写得更好：</span></p><div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"myfile"</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">PermissionError</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">"some default data"</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">fp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div></div></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-612">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-613">即使<a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">access()</span></code></a>表明它们会成功，I / O操作可能会失败，特别是对于可能具有超出通常POSIX权限位模型的权限语义的网络文件系统上的操作。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-614"><span class="versionmodified">在版本3.3中更改：</span>添加了<em>dir_fd</em>，<em>effective_ids</em>和<em>follow_symlinks</em>参数。</span></p></div></dd></dl><dl class="data"><dt id="os.F_OK"><span class="yiyi-st" id="yiyi-615"> <code class="descclassname">os.</code><code class="descname">F_OK</code></span></dt><dt id="os.R_OK"><span class="yiyi-st" id="yiyi-616"> <code class="descclassname">os.</code><code class="descname">R_OK</code></span></dt><dt id="os.W_OK"><span class="yiyi-st" id="yiyi-617"> <code class="descclassname">os.</code><code class="descname">W_OK</code></span></dt><dt id="os.X_OK"><span class="yiyi-st" id="yiyi-618"> <code class="descclassname">os.</code><code class="descname">X_OK</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-619">作为<a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">access()</span></code></a>的<em>mode</em>参数传递的值分别用于测试<em>path</em>的存在性，可读性，可写性和可执行性。</span></p></dd></dl><dl class="function"><dt id="os.chdir"><span class="yiyi-st" id="yiyi-620"> <code class="descclassname">os.</code><code class="descname">chdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p id="index-18"><span class="yiyi-st" id="yiyi-621">将当前工作目录更改为<em>路径</em>。</span></p><p><span class="yiyi-st" id="yiyi-622">该函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>。</span><span class="yiyi-st" id="yiyi-623">描述符必须引用打开的目录，而不是打开的文件。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-624"><span class="versionmodified">3.3版新增功能：</span>增加了在某些平台上将<em>路径</em>指定为文件描述符的支持。</span></p></div></dd></dl><dl class="function"><dt id="os.chflags"><span class="yiyi-st" id="yiyi-625"> <code class="descclassname">os.</code><code class="descname">chflags</code><span class="sig-paren">(</span><em>path</em>, <em>flags</em>, <em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-626">将<em>路径</em>的标志设置为数字<em>标志</em>。</span><span class="yiyi-st" id="yiyi-627"><em>flags</em>可以采用以下值（按照<a class="reference internal" href="stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a>模块中的定义）的组合（按位或）：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-628"><a class="reference internal" href="stat.html#stat.UF_NODUMP" title="stat.UF_NODUMP"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_NODUMP</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-629"><a class="reference internal" href="stat.html#stat.UF_IMMUTABLE" title="stat.UF_IMMUTABLE"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_IMMUTABLE</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-630"><a class="reference internal" href="stat.html#stat.UF_APPEND" title="stat.UF_APPEND"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_APPEND</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-631"><a class="reference internal" href="stat.html#stat.UF_OPAQUE" title="stat.UF_OPAQUE"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_OPAQUE</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-632"><a class="reference internal" href="stat.html#stat.UF_NOUNLINK" title="stat.UF_NOUNLINK"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_NOUNLINK</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-633"><a class="reference internal" href="stat.html#stat.UF_COMPRESSED" title="stat.UF_COMPRESSED"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_COMPRESSED</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-634"><a class="reference internal" href="stat.html#stat.UF_HIDDEN" title="stat.UF_HIDDEN"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_HIDDEN</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-635"><a class="reference internal" href="stat.html#stat.SF_ARCHIVED" title="stat.SF_ARCHIVED"><code class="xref py py-data docutils literal"><span class="pre">stat.SF_ARCHIVED</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-636"><a class="reference internal" href="stat.html#stat.SF_IMMUTABLE" title="stat.SF_IMMUTABLE"><code class="xref py py-data docutils literal"><span class="pre">stat.SF_IMMUTABLE</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-637"><a class="reference internal" href="stat.html#stat.SF_APPEND" title="stat.SF_APPEND"><code class="xref py py-data docutils literal"><span class="pre">stat.SF_APPEND</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-638"><a class="reference internal" href="stat.html#stat.SF_NOUNLINK" title="stat.SF_NOUNLINK"><code class="xref py py-data docutils literal"><span class="pre">stat.SF_NOUNLINK</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-639"><a class="reference internal" href="stat.html#stat.SF_SNAPSHOT" title="stat.SF_SNAPSHOT"><code class="xref py py-data docutils literal"><span class="pre">stat.SF_SNAPSHOT</span></code></a></span></li></ul><p><span class="yiyi-st" id="yiyi-640">该功能可以支持<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-641">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-642"><span class="versionmodified">版本3.3新增：</span> <em>follow_symlinks</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.chmod"><span class="yiyi-st" id="yiyi-643"> <code class="descclassname">os.</code><code class="descname">chmod</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em>, <em>*</em>, <em>dir_fd=None</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-644">将<em>路径</em>的模式更改为数字<em>模式</em>。</span><span class="yiyi-st" id="yiyi-645"><em>mode</em>可以采用以下值之一（如<a class="reference internal" href="stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a>模块中定义的）或它们的按位或运算组合：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-646"><a class="reference internal" href="stat.html#stat.S_ISUID" title="stat.S_ISUID"><code class="xref py py-data docutils literal"><span class="pre">stat.S_ISUID</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-647"><a class="reference internal" href="stat.html#stat.S_ISGID" title="stat.S_ISGID"><code class="xref py py-data docutils literal"><span class="pre">stat.S_ISGID</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-648"><a class="reference internal" href="stat.html#stat.S_ENFMT" title="stat.S_ENFMT"><code class="xref py py-data docutils literal"><span class="pre">stat.S_ENFMT</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-649"><a class="reference internal" href="stat.html#stat.S_ISVTX" title="stat.S_ISVTX"><code class="xref py py-data docutils literal"><span class="pre">stat.S_ISVTX</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-650"><a class="reference internal" href="stat.html#stat.S_IREAD" title="stat.S_IREAD"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IREAD</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-651"><a class="reference internal" href="stat.html#stat.S_IWRITE" title="stat.S_IWRITE"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IWRITE</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-652"><a class="reference internal" href="stat.html#stat.S_IEXEC" title="stat.S_IEXEC"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IEXEC</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-653"><a class="reference internal" href="stat.html#stat.S_IRWXU" title="stat.S_IRWXU"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IRWXU</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-654"><a class="reference internal" href="stat.html#stat.S_IRUSR" title="stat.S_IRUSR"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IRUSR</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-655"><a class="reference internal" href="stat.html#stat.S_IWUSR" title="stat.S_IWUSR"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IWUSR</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-656"><a class="reference internal" href="stat.html#stat.S_IXUSR" title="stat.S_IXUSR"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IXUSR</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-657"><a class="reference internal" href="stat.html#stat.S_IRWXG" title="stat.S_IRWXG"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IRWXG</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-658"><a class="reference internal" href="stat.html#stat.S_IRGRP" title="stat.S_IRGRP"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IRGRP</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-659"><a class="reference internal" href="stat.html#stat.S_IWGRP" title="stat.S_IWGRP"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IWGRP</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-660"><a class="reference internal" href="stat.html#stat.S_IXGRP" title="stat.S_IXGRP"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IXGRP</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-661"><a class="reference internal" href="stat.html#stat.S_IRWXO" title="stat.S_IRWXO"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IRWXO</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-662"><a class="reference internal" href="stat.html#stat.S_IROTH" title="stat.S_IROTH"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IROTH</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-663"><a class="reference internal" href="stat.html#stat.S_IWOTH" title="stat.S_IWOTH"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IWOTH</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-664"><a class="reference internal" href="stat.html#stat.S_IXOTH" title="stat.S_IXOTH"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IXOTH</span></code></a></span></li></ul><p><span class="yiyi-st" id="yiyi-665">该函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>，<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>的路径和<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>的路径。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-666">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-667">尽管Windows支持<a class="reference internal" href="#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal"><span class="pre">chmod()</span></code></a>，但您只能使用它设置文件的只读标志（通过<code class="docutils literal"><span class="pre">stat.S_IWRITE</span></code>和<code class="docutils literal"><span class="pre">stat.S_IREAD</span></code>常量或相应的整数值）。</span><span class="yiyi-st" id="yiyi-668">所有其他位都被忽略。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-669"><span class="versionmodified">版本3.3新增：</span>新增了对指定<em>path</em>作为开放文件描述符，以及<em>dir_fd</em>和<em>follow_symlinks</em>参数的支持。</span></p></div></dd></dl><dl class="function"><dt id="os.chown"><span class="yiyi-st" id="yiyi-670"> <code class="descclassname">os.</code><code class="descname">chown</code><span class="sig-paren">(</span><em>path</em>, <em>uid</em>, <em>gid</em>, <em>*</em>, <em>dir_fd=None</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-671">将<em>path</em>的所有者和组标识更改为数字<em>uid</em>和<em>gid</em>。</span><span class="yiyi-st" id="yiyi-672">要使其中一个ID保持不变，请将其设置为-1。</span></p><p><span class="yiyi-st" id="yiyi-673">该函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>，<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>的路径和<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>的路径。</span></p><p><span class="yiyi-st" id="yiyi-674">请参阅<a class="reference internal" href="shutil.html#shutil.chown" title="shutil.chown"><code class="xref py py-func docutils literal"><span class="pre">shutil.chown()</span></code></a>以获取除数字ID之外还接受名称的更高级别函数。</span></p><p><span class="yiyi-st" id="yiyi-675">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-676"><span class="versionmodified">3.3版新增：</span>新增支持为<em>路径</em>和<em>dir_fd</em>和<em>follow_symlinks</em>参数指定打开的文件描述符。</span></p></div></dd></dl><dl class="function"><dt id="os.chroot"><span class="yiyi-st" id="yiyi-677"> <code class="descclassname">os.</code><code class="descname">chroot</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-678">将当前进程的根目录更改为<em>路径</em>。</span></p><p><span class="yiyi-st" id="yiyi-679">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.fchdir"><span class="yiyi-st" id="yiyi-680"> <code class="descclassname">os.</code><code class="descname">fchdir</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-681">将当前工作目录更改为由文件描述符<em>fd</em>表示的目录。</span><span class="yiyi-st" id="yiyi-682">描述符必须引用打开的目录，而不是打开的文件。</span><span class="yiyi-st" id="yiyi-683">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.chdir(fd)</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-684">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.getcwd"><span class="yiyi-st" id="yiyi-685"> <code class="descclassname">os.</code><code class="descname">getcwd</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-686">返回表示当前工作目录的字符串。</span></p></dd></dl><dl class="function"><dt id="os.getcwdb"><span class="yiyi-st" id="yiyi-687"> <code class="descclassname">os.</code><code class="descname">getcwdb</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-688">返回表示当前工作目录的字符串。</span></p></dd></dl><dl class="function"><dt id="os.lchflags"><span class="yiyi-st" id="yiyi-689"> <code class="descclassname">os.</code><code class="descname">lchflags</code><span class="sig-paren">(</span><em>path</em>, <em>flags</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-690">将<em>path</em>的标志设置为数字<em>标志</em>，如<a class="reference internal" href="#os.chflags" title="os.chflags"><code class="xref py py-func docutils literal"><span class="pre">chflags()</span></code></a>，但不要遵循符号链接。</span><span class="yiyi-st" id="yiyi-691">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.chflags（path，</span> <span class="pre">flags，</span> <span class="pre">follow_symlinks = False）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-692">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.lchmod"><span class="yiyi-st" id="yiyi-693"> <code class="descclassname">os.</code><code class="descname">lchmod</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-694">将<em>路径</em>的模式更改为数字<em>模式</em>。</span><span class="yiyi-st" id="yiyi-695">如果path是符号链接，则会影响符号链接而不是目标。</span><span class="yiyi-st" id="yiyi-696">有关<em>mode</em>的可能值，请参阅<a class="reference internal" href="#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal"><span class="pre">chmod()</span></code></a>的文档。</span><span class="yiyi-st" id="yiyi-697">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.chmod（path，</span> <span class="pre">mode，</span> <span class="pre">follow_symlinks = False）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-698">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.lchown"><span class="yiyi-st" id="yiyi-699"> <code class="descclassname">os.</code><code class="descname">lchown</code><span class="sig-paren">(</span><em>path</em>, <em>uid</em>, <em>gid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-700">将<em>path</em>的所有者和组标识更改为数字<em>uid</em>和<em>gid</em>。</span><span class="yiyi-st" id="yiyi-701">此功能不会遵循符号链接。</span><span class="yiyi-st" id="yiyi-702">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.chown（path，</span> <span class="pre">uid，</span> <span class="pre">gid，</span> <span class="pre">follow_symlinks = False）  T4&gt;  T0&gt;。</span></code></span></p><p><span class="yiyi-st" id="yiyi-703">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.link"><span class="yiyi-st" id="yiyi-704"> <code class="descclassname">os.</code><code class="descname">link</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em>, <em>*</em>, <em>src_dir_fd=None</em>, <em>dst_dir_fd=None</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-705">Create a hard link pointing to <em>src</em> named <em>dst</em>.</span></p><p><span class="yiyi-st" id="yiyi-706">该函数可以支持指定<em>src_dir_fd</em>和/或<em>dst_dir_fd</em>来提供<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>的路径，<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a> 。</span></p><p><span class="yiyi-st" id="yiyi-707">可用性：Unix，Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-708"><span class="versionmodified">在版本3.2中更改：</span>添加了Windows支持。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-709"><span class="versionmodified">版本3.3新增：</span>添加了<em>src_dir_fd</em>，<em>dst_dir_fd</em>和<em>follow_symlinks</em>个参数。</span></p></div></dd></dl><dl class="function"><dt id="os.listdir"><span class="yiyi-st" id="yiyi-710"> <code class="descclassname">os.</code><code class="descname">listdir</code><span class="sig-paren">(</span><em>path='.'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-711">返回一个list，包含给定<em>path</em> 目录下所有条目的名字。</span><span class="yiyi-st" id="yiyi-712">该list是任意顺序，不包括特殊条目<code class="docutils literal"><span class="pre">'.'</span></code></span><span class="yiyi-st" id="yiyi-713">以及<code class="docutils literal"><span class="pre">'..'</span></code>，即使它们存在于目录中。</span></p><p><span class="yiyi-st" id="yiyi-714"><em>path</em>可以是<code class="docutils literal"><span class="pre">str</span></code>类型或<code class="docutils literal"><span class="pre">bytes</span></code>类型。</span><span class="yiyi-st" id="yiyi-715">如果<em>path</em>的类型为<code class="docutils literal"><span class="pre">bytes</span></code>，则返回的文件名也将为<code class="docutils literal"><span class="pre">bytes</span></code>类型；否则，它们的类型为<code class="docutils literal"><span class="pre">str</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-716">此函数还可以支持<a class="reference internal" href="#path-fd"><span>指定一个文件描述器（file descriptor）</span></a>；该文件描述器必须引用一个目录。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-717">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-718">要将<code class="docutils literal"><span class="pre">str</span></code>文件名编码为<code class="docutils literal"><span class="pre">bytes</span></code>，请使用<a class="reference internal" href="#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal"><span class="pre">fsencode()</span></code></a>。</span></p></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-719">也可以看看</span></p><p class="last"><span class="yiyi-st" id="yiyi-720"><a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>函数返回目录条目以及文件属性信息，为许多常见用例提供更好的性能。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-721"><span class="versionmodified">在版本3.2中更改：</span> <em>路径</em>参数变为可选。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-722"><span class="versionmodified">版本3.3新增：</span>增加了为<em>路径</em>指定打开的文件描述符的支持。</span></p></div></dd></dl><dl class="function"><dt id="os.lstat"><span class="yiyi-st" id="yiyi-723"> <code class="descclassname">os.</code><code class="descname">lstat</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-724">在给定路径上执行与<code class="xref c c-func docutils literal"><span class="pre">lstat()</span></code>系统调用等价的操作。</span><span class="yiyi-st" id="yiyi-725">类似于<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a>，但不符合符号链接。</span><span class="yiyi-st" id="yiyi-726">返回一个<a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a>对象。</span></p><p><span class="yiyi-st" id="yiyi-727">在不支持符号链接的平台上，这是<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a>的别名。</span></p><p><span class="yiyi-st" id="yiyi-728">从Python 3.3开始，这相当于<code class="docutils literal"><span class="pre">os.stat（path，</span> <span class="pre">dir_fd = dir_fd，</span> <span class="pre">follow_symlinks = False）</span>  t0 &gt;。</code></span></p><p><span class="yiyi-st" id="yiyi-729">该函数还可以支持<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-730">也可以看看</span></p><p class="last"><span class="yiyi-st" id="yiyi-731"><a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a>函数。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-732"><span class="versionmodified">在版本3.2中更改：</span>添加了对Windows 6.0（Vista）符号链接的支持。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-733"><span class="versionmodified">在版本3.3中更改：</span>添加了<em>dir_fd</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.mkdir"><span class="yiyi-st" id="yiyi-734"> <code class="descclassname">os.</code><code class="descname">mkdir</code><span class="sig-paren">(</span><em>path</em>, <em>mode=0o777</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-735">创建一个名称为<em>path</em>的目录，模式为<em>mode</em>。</span></p><p><span class="yiyi-st" id="yiyi-736">如果该目录已经存在，则引发<a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a>。</span></p><p id="mkdir-modebits"><span class="yiyi-st" id="yiyi-737">在模型系统上，<em>mode</em>会被忽略。</span><span class="yiyi-st" id="yiyi-738">在使用它的地方，当前的umask值首先被屏蔽掉。</span><span class="yiyi-st" id="yiyi-739">如果除了最后9位（即，</span><span class="yiyi-st" id="yiyi-740"><em>mode</em>的八进制表示的最后3位）被设置，它们的含义是平台相关的。</span><span class="yiyi-st" id="yiyi-741">在某些平台上，它们被忽略，你应该明确地调用<a class="reference internal" href="#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal"><span class="pre">chmod()</span></code></a>来设置它们。</span></p><p><span class="yiyi-st" id="yiyi-742">该函数还可以支持<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-743">也可以创建临时目录；请参阅<a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a>模块的<a class="reference internal" href="tempfile.html#tempfile.mkdtemp" title="tempfile.mkdtemp"><code class="xref py py-func docutils literal"><span class="pre">tempfile.mkdtemp()</span></code></a>函数。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-744"><span class="versionmodified">3.3版本中的新功能：</span> <em>dir_fd</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.makedirs"><span class="yiyi-st" id="yiyi-745"> <code class="descclassname">os.</code><code class="descname">makedirs</code><span class="sig-paren">(</span><em>name</em>, <em>mode=0o777</em>, <em>exist_ok=False</em><span class="sig-paren">)</span></span></dt><dd><p id="index-19"><span class="yiyi-st" id="yiyi-746">递归创建目录的函数。</span><span class="yiyi-st" id="yiyi-747">类似<a class="reference internal" href="#os.mkdir" title="os.mkdir"><code class="xref py py-func docutils literal"><span class="pre">mkdir()</span></code></a>，但是会生成所有中间目录以及叶子目录。</span></p><p><span class="yiyi-st" id="yiyi-748"><em>mode</em>参数将传递到<a class="reference internal" href="#os.mkdir" title="os.mkdir"><code class="xref py py-func docutils literal"><span class="pre">mkdir()</span></code></a>；关于它的解释，请参阅<a class="reference internal" href="#mkdir-modebits"><span>mkdir()的描述</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-749">如果<em>exists_ok</em>为<code class="docutils literal"><span class="pre">False</span></code>（默认值），则如果目标目录已存在，则会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-750">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-751">如果要创建的路径元素包含<a class="reference internal" href="#os.pardir" title="os.pardir"><code class="xref py py-data docutils literal"><span class="pre">pardir</span></code></a>，<a class="reference internal" href="#os.makedirs" title="os.makedirs"><code class="xref py py-func docutils literal"><span class="pre">makedirs()</span></code></a>将变得混乱（例如，</span><span class="yiyi-st" id="yiyi-752">UNIX系统上的“..”）。</span></p></div><p><span class="yiyi-st" id="yiyi-753">此函数可以正确处理UNC路径。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-754"><span class="versionmodified">版本3.2中的新功能：</span> <em>exist_ok</em>参数。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-755"><span class="versionmodified">版本3.4.1中的变化：</span>在Python 3.4.1之前，如果<em>exists_ok</em>为<code class="docutils literal"><span class="pre">True</span></code>并且目录已经存在，如果<em>mode</em>与现有目录的模式不匹配<a class="reference internal" href="#os.makedirs" title="os.makedirs"><code class="xref py py-func docutils literal"><span class="pre">makedirs()</span></code></a>仍然会引发错误。</span><span class="yiyi-st" id="yiyi-756">由于这种行为不可能安全地实现，所以它在Python 3.4.1中被删除。</span><span class="yiyi-st" id="yiyi-757">参见<a class="reference external" href="https://bugs.python.org/issue21082">问题21082</a>。</span></p></div></dd></dl><dl class="function"><dt id="os.mkfifo"><span class="yiyi-st" id="yiyi-758"> <code class="descclassname">os.</code><code class="descname">mkfifo</code><span class="sig-paren">(</span><em>path</em>, <em>mode=0o666</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-759">使用数字模式<em>模式</em>创建名为<em>path</em>的FIFO（命名管道）。</span><span class="yiyi-st" id="yiyi-760">首先将当前的umask值从模式中屏蔽掉。</span></p><p><span class="yiyi-st" id="yiyi-761">该函数还可以支持<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-762">FIFO是可以像普通文件一样访问的管道。</span><span class="yiyi-st" id="yiyi-763">FIFO存在直到它们被删除（例如<a class="reference internal" href="#os.unlink" title="os.unlink"><code class="xref py py-func docutils literal"><span class="pre">os.unlink()</span></code></a>）。</span><span class="yiyi-st" id="yiyi-764">通常，FIFO被用作“客户端”和“服务器”类型进程之间的交会点：服务器打开FIFO进行读取，客户端打开它进行写入。</span><span class="yiyi-st" id="yiyi-765">请注意，<a class="reference internal" href="#os.mkfifo" title="os.mkfifo"><code class="xref py py-func docutils literal"><span class="pre">mkfifo()</span></code></a>不会打开FIFO  - 它只是创建集合点。</span></p><p><span class="yiyi-st" id="yiyi-766">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-767"><span class="versionmodified">3.3版本中的新功能：</span> <em>dir_fd</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.mknod"><span class="yiyi-st" id="yiyi-768"> <code class="descclassname">os.</code><code class="descname">mknod</code><span class="sig-paren">(</span><em>path</em>, <em>mode=0o600</em>, <em>device=0</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-769">创建一个名为<em>path</em>的文件系统节点（文件，设备专用文件或命名管道）。</span><span class="yiyi-st" id="yiyi-770"><em>mode</em> specifies both the permissions to use and the type of node to be created, being combined (bitwise OR) with one of <code class="docutils literal"><span class="pre">stat.S_IFREG</span></code>, <code class="docutils literal"><span class="pre">stat.S_IFCHR</span></code>, <code class="docutils literal"><span class="pre">stat.S_IFBLK</span></code>, and <code class="docutils literal"><span class="pre">stat.S_IFIFO</span></code> (those constants are available in <a class="reference internal" href="stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a>). </span><span class="yiyi-st" id="yiyi-771">对于<code class="docutils literal"><span class="pre">stat.S_IFCHR</span></code>和<code class="docutils literal"><span class="pre">stat.S_IFBLK</span></code>，<em>设备</em>定义新创建的设备专用文件（可能使用<a class="reference internal" href="#os.makedev" title="os.makedev"><code class="xref py py-func docutils literal"><span class="pre">os.makedev()</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-772">该函数还可以支持<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-773"><span class="versionmodified">3.3版本中的新功能：</span> <em>dir_fd</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.major"><span class="yiyi-st" id="yiyi-774"> <code class="descclassname">os.</code><code class="descname">major</code><span class="sig-paren">(</span><em>device</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-775">从原始设备编号（通常是<code class="xref c c-type docutils literal"><span class="pre">stat</span></code>中的<code class="xref py py-attr docutils literal"><span class="pre">st_dev</span></code>或<code class="xref py py-attr docutils literal"><span class="pre">st_rdev</span></code>字段）中提取设备主编号。</span></p></dd></dl><dl class="function"><dt id="os.minor"><span class="yiyi-st" id="yiyi-776"> <code class="descclassname">os.</code><code class="descname">minor</code><span class="sig-paren">(</span><em>device</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-777">从原始设备编号（通常是<code class="xref c c-type docutils literal"><span class="pre">stat</span></code>中的<code class="xref py py-attr docutils literal"><span class="pre">st_dev</span></code>或<code class="xref py py-attr docutils literal"><span class="pre">st_rdev</span></code>字段）中提取设备次要编号。</span></p></dd></dl><dl class="function"><dt id="os.makedev"><span class="yiyi-st" id="yiyi-778"> <code class="descclassname">os.</code><code class="descname">makedev</code><span class="sig-paren">(</span><em>major</em>, <em>minor</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-779">从主要和次要设备编号构成原始设备编号。</span></p></dd></dl><dl class="function"><dt id="os.pathconf"><span class="yiyi-st" id="yiyi-780"> <code class="descclassname">os.</code><code class="descname">pathconf</code><span class="sig-paren">(</span><em>path</em>, <em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-781">返回与指定文件相关的系统配置信息。</span><span class="yiyi-st" id="yiyi-782"><em>name</em>指定要检索的配置值；它可能是一个字符串，它是定义的系统值的名称；这些名称在许多标准（POSIX.1，Unix 95，Unix 98等）中都有详细说明。</span><span class="yiyi-st" id="yiyi-783">一些平台也定义了其他名称。</span><span class="yiyi-st" id="yiyi-784">主机操作系统已知的名称在<code class="docutils literal"><span class="pre">pathconf_names</span></code>字典中给出。</span><span class="yiyi-st" id="yiyi-785">对于不包含在该映射中的配置变量，也接受传递<em>name</em>的整数。</span></p><p><span class="yiyi-st" id="yiyi-786">如果<em>name</em>是一个字符串且未知，则引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span><span class="yiyi-st" id="yiyi-787">If a specific value for <em>name</em> is not supported by the host system, even if it is included in <code class="docutils literal"><span class="pre">pathconf_names</span></code>, an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> is raised with <a class="reference internal" href="errno.html#errno.EINVAL" title="errno.EINVAL"><code class="xref py py-const docutils literal"><span class="pre">errno.EINVAL</span></code></a> for the error number.</span></p><p><span class="yiyi-st" id="yiyi-788">该函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-789">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.pathconf_names"><span class="yiyi-st" id="yiyi-790"> <code class="descclassname">os.</code><code class="descname">pathconf_names</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-791">将由<a class="reference internal" href="#os.pathconf" title="os.pathconf"><code class="xref py py-func docutils literal"><span class="pre">pathconf()</span></code></a>和<a class="reference internal" href="#os.fpathconf" title="os.fpathconf"><code class="xref py py-func docutils literal"><span class="pre">fpathconf()</span></code></a>接受的字典映射名称转换为主机操作系统为这些名称定义的整数值。</span><span class="yiyi-st" id="yiyi-792">这可以用来确定系统已知的一组名称。</span></p><p><span class="yiyi-st" id="yiyi-793">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.readlink"><span class="yiyi-st" id="yiyi-794"> <code class="descclassname">os.</code><code class="descname">readlink</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-795">返回表示符号链接指向的路径的字符串。</span><span class="yiyi-st" id="yiyi-796">The result may be either an absolute or relative pathname; if it is relative, it may be converted to an absolute pathname using <code class="docutils literal"><span class="pre">os.path.join(os.path.dirname(path),</span> <span class="pre">result)</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-797">如果<em>路径</em>是一个字符串对象，则结果也将是一个字符串对象，并且该调用可能会引发UnicodeDecodeError。</span><span class="yiyi-st" id="yiyi-798">如果<em>路径</em>是一个字节对象，则结果将是一个字节对象。</span></p><p><span class="yiyi-st" id="yiyi-799">该函数还可以支持<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-800">可用性：Unix，Windows</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-801"><span class="versionmodified">在版本3.2中更改：</span>添加了对Windows 6.0（Vista）符号链接的支持。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-802"><span class="versionmodified">3.3版本中的新功能：</span> <em>dir_fd</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.remove"><span class="yiyi-st" id="yiyi-803"> <code class="descclassname">os.</code><code class="descname">remove</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-804">删除（删除）文件<em>路径</em>。</span><span class="yiyi-st" id="yiyi-805">如果<em>path</em>是目录，则引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span><span class="yiyi-st" id="yiyi-806">使用<a class="reference internal" href="#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal"><span class="pre">rmdir()</span></code></a>删除目录。</span></p><p><span class="yiyi-st" id="yiyi-807">该函数可以支持<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>的路径。</span></p><p><span class="yiyi-st" id="yiyi-808">在Windows上，尝试删除正在使用的文件会导致引发异常；在Unix上，目录条目被删除，但分配给该文件的存储不可用，直到原始文件不再被使用。</span></p><p><span class="yiyi-st" id="yiyi-809">这个函数在语义上与<a class="reference internal" href="#os.unlink" title="os.unlink"><code class="xref py py-func docutils literal"><span class="pre">unlink()</span></code></a>相同。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-810"><span class="versionmodified">3.3版本中的新功能：</span> <em>dir_fd</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.removedirs"><span class="yiyi-st" id="yiyi-811"> <code class="descclassname">os.</code><code class="descname">removedirs</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p id="index-20"><span class="yiyi-st" id="yiyi-812">递归地删除目录。</span><span class="yiyi-st" id="yiyi-813">Works like <a class="reference internal" href="#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal"><span class="pre">rmdir()</span></code></a> except that, if the leaf directory is successfully removed, <a class="reference internal" href="#os.removedirs" title="os.removedirs"><code class="xref py py-func docutils literal"><span class="pre">removedirs()</span></code></a> tries to successively remove every parent directory mentioned in <em>path</em> until an error is raised (which is ignored, because it generally means that a parent directory is not empty). </span><span class="yiyi-st" id="yiyi-814">例如，<code class="docutils literal"><span class="pre">os.removedirs('foo/bar/baz')</span></code>将首先删除目录<code class="docutils literal"><span class="pre">'foo/bar/baz'</span></code>，然后删除<code class="docutils literal"><span class="pre">'foo/bar'</span></code>和<code class="docutils literal"><span class="pre">'foo'</span></code>，如果它们是空的。</span><span class="yiyi-st" id="yiyi-815">如果无法成功删除叶子目录，则引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="os.rename"><span class="yiyi-st" id="yiyi-816"> <code class="descclassname">os.</code><code class="descname">rename</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em>, <em>*</em>, <em>src_dir_fd=None</em>, <em>dst_dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-817">将文件或目录<em>src</em>重命名为<em>dst</em>。</span><span class="yiyi-st" id="yiyi-818">如果<em>dst</em>是目录，则会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span><span class="yiyi-st" id="yiyi-819">在Unix上，如果<em>dst</em>存在并且是一个文件，如果用户有权限，它将以静默方式替换。</span><span class="yiyi-st" id="yiyi-820">如果<em>src</em>和<em>dst</em>位于不同的文件系统上，则操作可能会在某些Unix版本中失败。</span><span class="yiyi-st" id="yiyi-821">如果成功，该重命名将是一个原子操作（这是POSIX 的要求）。</span><span class="yiyi-st" id="yiyi-822">在Windows中，如果<em>dst</em>已经存在，即使它是一个文件，也会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-823">该函数可以支持指定<em>src_dir_fd</em>和/或<em>dst_dir_fd</em>来提供相对于目录描述符的<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a></span></p><p><span class="yiyi-st" id="yiyi-824">如果您想要跨目标覆盖目标，请使用<a class="reference internal" href="#os.replace" title="os.replace"><code class="xref py py-func docutils literal"><span class="pre">replace()</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-825"><span class="versionmodified">版本3.3新增：</span> <em>src_dir_fd</em>和<em>dst_dir_fd</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.renames"><span class="yiyi-st" id="yiyi-826"> <code class="descclassname">os.</code><code class="descname">renames</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-827">重命名函数递归处理目录或文件，</span><span class="yiyi-st" id="yiyi-828">像<a class="reference internal" href="#os.rename" title="os.rename"><code class="xref py py-func docutils literal"><span class="pre">rename()</span></code></a>一样工作，除了首先尝试创建新路径名所需的任何中间目录之外。</span><span class="yiyi-st" id="yiyi-829">重命名后，使用<a class="reference internal" href="#os.removedirs" title="os.removedirs"><code class="xref py py-func docutils literal"><span class="pre">removedirs()</span></code></a>删除与旧名称的最右边路径段相对应的目录。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-830">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-831">如果您缺少删除叶子目录或文件所需的权限，则此功能可能会失败，并生成新的目录结构。</span></p></div></dd></dl><dl class="function"><dt id="os.replace"><span class="yiyi-st" id="yiyi-832"> <code class="descclassname">os.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em>, <em>*</em>, <em>src_dir_fd=None</em>, <em>dst_dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-833">将文件或目录<em>src</em>重命名为<em>dst</em>。</span><span class="yiyi-st" id="yiyi-834">如果<em>dst</em>是目录，则会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span><span class="yiyi-st" id="yiyi-835">如果<em>dst</em>存在并且是文件，则在用户具有权限时将被替换为无提示。</span><span class="yiyi-st" id="yiyi-836">如果<em>src</em>和<em>dst</em>位于不同的文件系统上，操作可能会失败。</span><span class="yiyi-st" id="yiyi-837">如果成功，该重命名将是一个原子操作（这是POSIX 的要求）。</span></p><p><span class="yiyi-st" id="yiyi-838">该函数可以支持指定<em>src_dir_fd</em>和/或<em>dst_dir_fd</em>来提供相对于目录描述符的<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a></span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-839"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.rmdir"><span class="yiyi-st" id="yiyi-840"> <code class="descclassname">os.</code><code class="descname">rmdir</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-841">删除（删除）目录<em>路径</em>。</span><span class="yiyi-st" id="yiyi-842">仅当目录为空时才起作用，否则引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span><span class="yiyi-st" id="yiyi-843">为了移除整个目录树，可以使用<a class="reference internal" href="shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal"><span class="pre">shutil.rmtree()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-844">该函数可以支持<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>的路径。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-845"><span class="versionmodified">版本3.3新增：</span> <em>dir_fd</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.scandir"><span class="yiyi-st" id="yiyi-846"> <code class="descclassname">os.</code><code class="descname">scandir</code><span class="sig-paren">(</span><em>path='.'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-847">返回与<em>path</em>给出的目录条目对应的<a class="reference internal" href="#os.DirEntry" title="os.DirEntry"><code class="xref py py-class docutils literal"><span class="pre">DirEntry</span></code></a>对象的迭代器。</span><span class="yiyi-st" id="yiyi-848">这些条目以任意顺序产生，特殊条目<code class="docutils literal"><span class="pre">'.'</span></code></span><span class="yiyi-st" id="yiyi-849">和<code class="docutils literal"><span class="pre">'..'</span></code>不包括在内。</span></p><p><span class="yiyi-st" id="yiyi-850">因为<a class="reference internal" href="#os.DirEntry" title="os.DirEntry"><code class="xref py py-class docutils literal"><span class="pre">DirEntry</span></code></a>对象，使用<a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>而不是<a class="reference internal" href="#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal"><span class="pre">listdir()</span></code></a>可以显着提高代码的性能，该代码还需要文件类型或文件属性信息如果操作系统在扫描目录时提供此信息，则会公开这些信息。</span><span class="yiyi-st" id="yiyi-851">All <a class="reference internal" href="#os.DirEntry" title="os.DirEntry"><code class="xref py py-class docutils literal"><span class="pre">DirEntry</span></code></a> methods may perform a system call, but <a class="reference internal" href="#os.DirEntry.is_dir" title="os.DirEntry.is_dir"><code class="xref py py-func docutils literal"><span class="pre">is_dir()</span></code></a> and <a class="reference internal" href="#os.DirEntry.is_file" title="os.DirEntry.is_file"><code class="xref py py-func docutils literal"><span class="pre">is_file()</span></code></a> usually only require a system call for symbolic links; <a class="reference internal" href="#os.DirEntry.stat" title="os.DirEntry.stat"><code class="xref py py-func docutils literal"><span class="pre">DirEntry.stat()</span></code></a> always requires a system call on Unix but only requires one for symbolic links on Windows.</span></p><p><span class="yiyi-st" id="yiyi-852">在Unix上，<em>path</em>可以是<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>或<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>（使用<a class="reference internal" href="#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal"><span class="pre">fsencode()</span></code></a>和<a class="reference internal" href="#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal"><span class="pre">fsdecode()</span></code></a>来对<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>路径进行编码和解码）。</span><span class="yiyi-st" id="yiyi-853">在Windows上，<em>path</em>必须是<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>类型。</span><span class="yiyi-st" id="yiyi-854">在两个系统上，每个<a class="reference internal" href="#os.DirEntry" title="os.DirEntry"><code class="xref py py-class docutils literal"><span class="pre">DirEntry</span></code></a>的<a class="reference internal" href="#os.DirEntry.name" title="os.DirEntry.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a>和<a class="reference internal" href="#os.DirEntry.path" title="os.DirEntry.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a>属性的类型将与<em>路径 t9 &gt;。</em></span></p><p><span class="yiyi-st" id="yiyi-855">以下示例显示了使用<a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>显示给定<em>路径</em>中不以<code class="docutils literal"><span class="pre">'.'</span></code>开头。</span><span class="yiyi-st" id="yiyi-856"><code class="docutils literal"><span class="pre">entry.is_file()</span></code>调用通常不会进行额外的系统调用：</span></p><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span> <span class="ow">and</span> <span class="n">entry</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
       <span class="nb">print</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-857">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-858">在基于Unix的系统上，<a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>使用系统的<a class="reference external" href="http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html">opendir()</a>和<a class="reference external" href="http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html">readdir()</a>函数。</span><span class="yiyi-st" id="yiyi-859">在Windows上，它使用Win32 <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85).aspx">FindFirstFileW</a>和<a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85).aspx">FindNextFileW</a>函数。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-860"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="class"><dt id="os.DirEntry"><span class="yiyi-st" id="yiyi-861"> <em class="property">class </em><code class="descclassname">os.</code><code class="descname">DirEntry</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-862">由<a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>生成的对象，以公开目录条目的文件路径和其他文件属性。</span></p><p><span class="yiyi-st" id="yiyi-863"><a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> will provide as much of this information as possible without making additional system calls. </span><span class="yiyi-st" id="yiyi-864">When a <code class="docutils literal"><span class="pre">stat()</span></code> or <code class="docutils literal"><span class="pre">lstat()</span></code> system call is made, the <code class="docutils literal"><span class="pre">DirEntry</span></code> object will cache the result.</span></p><p><span class="yiyi-st" id="yiyi-865"><code class="docutils literal"><span class="pre">DirEntry</span></code> instances are not intended to be stored in long-lived data structures; if you know the file metadata has changed or if a long time has elapsed since calling <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>, call <code class="docutils literal"><span class="pre">os.stat(entry.path)</span></code> to fetch up-to-date information.</span></p><p><span class="yiyi-st" id="yiyi-866">因为<code class="docutils literal"><span class="pre">DirEntry</span></code>方法可以进行操作系统调用，所以它们也可能会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span><span class="yiyi-st" id="yiyi-867">如果您需要对错误进行非常细致的控制，则可以在调用其中一个<code class="docutils literal"><span class="pre">DirEntry</span></code>方法时适当地捕获<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>并进行处理。</span></p><p><span class="yiyi-st" id="yiyi-868"><code class="docutils literal"><span class="pre">DirEntry</span></code>实例上的属性和方法如下所示：</span></p><dl class="attribute"><dt id="os.DirEntry.name"><span class="yiyi-st" id="yiyi-869"> <code class="descname">name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-870">条目的基本文件名，相对于<a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>路径</em>参数。</span></p><p><span class="yiyi-st" id="yiyi-871"><a class="reference internal" href="#os.name" title="os.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a>属性与<a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>属性的类型相同（<code class="docutils literal"><span class="pre">str</span></code>或<code class="docutils literal"><span class="pre">bytes</span></code>路径</em>参数。</span><span class="yiyi-st" id="yiyi-872">使用<a class="reference internal" href="#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal"><span class="pre">fsdecode()</span></code></a>来解码字节文件名。</span></p></dd></dl><dl class="attribute"><dt id="os.DirEntry.path"><span class="yiyi-st" id="yiyi-873"> <code class="descname">path</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-874">The entry’s full path name: equivalent to <code class="docutils literal"><span class="pre">os.path.join(scandir_path,</span> <span class="pre">entry.name)</span></code> where <em>scandir_path</em> is the <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>path</em> argument. </span><span class="yiyi-st" id="yiyi-875">如果<a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>路径</em>参数是绝对路径，则路径是绝对路径。</span></p><p><span class="yiyi-st" id="yiyi-876"><a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a>属性与<a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>属性的类型相同（<code class="docutils literal"><span class="pre">str</span></code>或<code class="docutils literal"><span class="pre">bytes</span></code>路径</em>参数。</span><span class="yiyi-st" id="yiyi-877">使用<a class="reference internal" href="#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal"><span class="pre">fsdecode()</span></code></a>来解码字节文件名。</span></p></dd></dl><dl class="method"><dt id="os.DirEntry.inode"><span class="yiyi-st" id="yiyi-878"> <code class="descname">inode</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-879">返回条目的inode号码。</span></p><p><span class="yiyi-st" id="yiyi-880">结果缓存在<code class="docutils literal"><span class="pre">DirEntry</span></code>对象上。</span><span class="yiyi-st" id="yiyi-881">使用<code class="docutils literal"><span class="pre">os.stat（entry.path，</span> <span class="pre">follow_symlinks = False）.st_ino</span></code>来获取最新信息。</span></p><p><span class="yiyi-st" id="yiyi-882">在第一个未缓存的调用中，系统调用在Windows上需要，而在Unix上不需要。</span></p></dd></dl><dl class="method"><dt id="os.DirEntry.is_dir"><span class="yiyi-st" id="yiyi-883"> <code class="descname">is_dir</code><span class="sig-paren">(</span><em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-884">如果此条目是指向目录的目录或符号链接，则返回<code class="docutils literal"><span class="pre">True</span></code>如果条目是或指向任何其他类型的文件，或者它不再存在，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-885">如果<em>follow_symlinks</em>为<code class="docutils literal"><span class="pre">False</span></code>，则仅当该条目是目录（没有符号链接时）才返回<code class="docutils literal"><span class="pre">True</span></code>；如果条目是任何其他类型的文件或者它不再存在，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-886">结果缓存在<code class="docutils literal"><span class="pre">DirEntry</span></code>对象上，其中有一个用于<em>follow_symlinks</em> <code class="docutils literal"><span class="pre">True</span></code>和<code class="docutils literal"><span class="pre">False</span></code>的单独缓存。</span><span class="yiyi-st" id="yiyi-887">与<a class="reference internal" href="stat.html#stat.S_ISDIR" title="stat.S_ISDIR"><code class="xref py py-func docutils literal"><span class="pre">stat.S_ISDIR()</span></code></a>一起调用<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>以获取最新信息。</span></p><p><span class="yiyi-st" id="yiyi-888">在第一个未缓存的呼叫中，大多数情况下不需要系统调用。</span><span class="yiyi-st" id="yiyi-889">具体而言，对于非符号链接，Windows或Unix都不需要系统调用，除了某些Unix文件系统（例如网络文件系统），它们返回<code class="docutils literal"><span class="pre">dirent.d_type</span> <span class="pre">== &lt; / t2&gt; <span class="pre">DT_UNKNOWN</span></span></code>。</span><span class="yiyi-st" id="yiyi-890">如果条目是符号链接，则除非<em>follow_symlinks</em>为<code class="docutils literal"><span class="pre">False</span></code>，否则系统调用将需要遵循符号链接。</span></p><p><span class="yiyi-st" id="yiyi-891">This method can raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>, such as <a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal"><span class="pre">PermissionError</span></code></a>, but <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">FileNotFoundError</span></code></a> is caught and not raised.</span></p></dd></dl><dl class="method"><dt id="os.DirEntry.is_file"><span class="yiyi-st" id="yiyi-892"> <code class="descname">is_file</code><span class="sig-paren">(</span><em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-893">如果此条目是指向文件的文件或符号链接，则返回<code class="docutils literal"><span class="pre">True</span></code>；如果条目是或指向一个目录或其他非文件条目，或者它不再存在，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-894">如果<em>follow_symlinks</em>为<code class="docutils literal"><span class="pre">False</span></code>，则仅当该条目是文件（不符合链接）时返回<code class="docutils literal"><span class="pre">True</span></code>。如果条目是目录或其他非文件条目，或者它不再存在，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-895">结果缓存在<code class="docutils literal"><span class="pre">DirEntry</span></code>对象上。</span><span class="yiyi-st" id="yiyi-896">缓存，系统调用以及引发的异常均按照<a class="reference internal" href="#os.DirEntry.is_dir" title="os.DirEntry.is_dir"><code class="xref py py-func docutils literal"><span class="pre">is_dir()</span></code></a>进行。</span></p></dd></dl><dl class="method"><dt id="os.DirEntry.is_symlink"><span class="yiyi-st" id="yiyi-897"> <code class="descname">is_symlink</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-898">如果这个条目是一个符号链接（即使破坏），则返回<code class="docutils literal"><span class="pre">True</span></code>；如果条目指向一个目录或任何类型的文件，或者它不再存在，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-899">结果缓存在<code class="docutils literal"><span class="pre">DirEntry</span></code>对象上。</span><span class="yiyi-st" id="yiyi-900">调用<a class="reference internal" href="os.path.html#os.path.islink" title="os.path.islink"><code class="xref py py-func docutils literal"><span class="pre">os.path.islink()</span></code></a>以获取最新信息。</span></p><p><span class="yiyi-st" id="yiyi-901">在第一个未缓存的呼叫中，大多数情况下不需要系统调用。</span><span class="yiyi-st" id="yiyi-902">具体而言，Windows或Unix都不需要系统调用，除了某些Unix文件系统（例如网络文件系统），它们返回<code class="docutils literal"><span class="pre">dirent.d_type</span> <span class="pre">==</span> <span class="pre"> DT_UNKNOWN  T3&gt;  T0&gt;。</span></code></span></p><p><span class="yiyi-st" id="yiyi-903">This method can raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>, such as <a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal"><span class="pre">PermissionError</span></code></a>, but <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">FileNotFoundError</span></code></a> is caught and not raised.</span></p></dd></dl><dl class="method"><dt id="os.DirEntry.stat"><span class="yiyi-st" id="yiyi-904"> <code class="descname">stat</code><span class="sig-paren">(</span><em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-905">为此条目返回一个<a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-906">该方法默认遵循符号链接；要统计符号链接，请添加<code class="docutils literal"><span class="pre">follow_symlinks=False</span></code>参数。</span></p><p><span class="yiyi-st" id="yiyi-907">在Unix上，这个方法总是需要一个系统调用。</span><span class="yiyi-st" id="yiyi-908">在Windows上，如果<em>follow_symlinks</em>为<code class="docutils literal"><span class="pre">True</span></code>，并且条目是符号链接，则它只需要系统调用。</span></p><p><span class="yiyi-st" id="yiyi-909">在Windows上，<a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a>的<code class="docutils literal"><span class="pre">st_ino</span></code>，<code class="docutils literal"><span class="pre">st_dev</span></code>和<code class="docutils literal"><span class="pre">st_nlink</span></code>属性始终设置为零。</span><span class="yiyi-st" id="yiyi-910">调用<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>以获取这些属性。</span></p><p><span class="yiyi-st" id="yiyi-911">结果缓存在<code class="docutils literal"><span class="pre">DirEntry</span></code>对象上，其中有一个用于<em>follow_symlinks</em> <code class="docutils literal"><span class="pre">True</span></code>和<code class="docutils literal"><span class="pre">False</span></code>的单独缓存。</span><span class="yiyi-st" id="yiyi-912">调用<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>来获取最新信息。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-913">请注意，<code class="docutils literal"><span class="pre">DirEntry</span></code>和<a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">pathlib.Path</span></code></a>的几个属性和方法之间存在很好的对应关系。</span><span class="yiyi-st" id="yiyi-914">In particular, the <code class="docutils literal"><span class="pre">name</span></code> attribute has the same meaning, as do the <code class="docutils literal"><span class="pre">is_dir()</span></code>, <code class="docutils literal"><span class="pre">is_file()</span></code>, <code class="docutils literal"><span class="pre">is_symlink()</span></code> and <code class="docutils literal"><span class="pre">stat()</span></code> methods.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-915"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.stat"><span class="yiyi-st" id="yiyi-916"> <code class="descclassname">os.</code><code class="descname">stat</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-917">获取文件或文件描述符的状态。</span><span class="yiyi-st" id="yiyi-918">在给定的路径上执行相同的<code class="xref c c-func docutils literal"><span class="pre">stat()</span></code>系统调用。</span><span class="yiyi-st" id="yiyi-919"><em>path</em>可以被指定为一个字符串或一个打开的文件描述符。</span><span class="yiyi-st" id="yiyi-920">返回一个<a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a>对象。</span></p><p><span class="yiyi-st" id="yiyi-921">这个函数通常遵循符号链接；统计符号链接添加参数<code class="docutils literal"><span class="pre">follow_symlinks=False</span></code>，或使用<a class="reference internal" href="#os.lstat" title="os.lstat"><code class="xref py py-func docutils literal"><span class="pre">lstat()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-922">此函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>和<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>。</span></p><p id="index-21"><span class="yiyi-st" id="yiyi-923">例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">statinfo</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="s1">'somefile.txt'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">statinfo</span>
<span class="go">os.stat_result(st_mode=33188, st_ino=7876932, st_dev=234881026,</span>
<span class="go">st_nlink=1, st_uid=501, st_gid=501, st_size=264, st_atime=1297230295,</span>
<span class="go">st_mtime=1297230027, st_ctime=1297230027)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">statinfo</span><span class="o">.</span><span class="n">st_size</span>
<span class="go">264</span>
</code></pre><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-924">也可以看看</span></p><p class="last"><span class="yiyi-st" id="yiyi-925"><a class="reference internal" href="#os.fstat" title="os.fstat"><code class="xref py py-func docutils literal"><span class="pre">fstat()</span></code></a>和<a class="reference internal" href="#os.lstat" title="os.lstat"><code class="xref py py-func docutils literal"><span class="pre">lstat()</span></code></a>函数。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-926"><span class="versionmodified">3.3版新增：</span>添加了<em>dir_fd</em>和<em>follow_symlinks</em>参数，指定了文件描述符而不是路径。</span></p></div></dd></dl><dl class="class"><dt id="os.stat_result"><span class="yiyi-st" id="yiyi-927"> <em class="property">class </em><code class="descclassname">os.</code><code class="descname">stat_result</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-928">对象的属性大致对应于<code class="xref c c-type docutils literal"><span class="pre">stat</span></code>结构的成员。</span><span class="yiyi-st" id="yiyi-929">它用于<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>，<a class="reference internal" href="#os.fstat" title="os.fstat"><code class="xref py py-func docutils literal"><span class="pre">os.fstat()</span></code></a>和<a class="reference internal" href="#os.lstat" title="os.lstat"><code class="xref py py-func docutils literal"><span class="pre">os.lstat()</span></code></a>的结果。</span></p><p><span class="yiyi-st" id="yiyi-930">属性：</span></p><dl class="attribute"><dt id="os.stat_result.st_mode"><span class="yiyi-st" id="yiyi-931"> <code class="descname">st_mode</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-932">文件模式：文件类型和文件模式位（权限）。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_ino"><span class="yiyi-st" id="yiyi-933"> <code class="descname">st_ino</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-934">inode 节点号。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_dev"><span class="yiyi-st" id="yiyi-935"> <code class="descname">st_dev</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-936">该文件所在设备的标识符。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_nlink"><span class="yiyi-st" id="yiyi-937"> <code class="descname">st_nlink</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-938">硬链接的数量。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_uid"><span class="yiyi-st" id="yiyi-939"> <code class="descname">st_uid</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-940">文件所有者的用户标识符。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_gid"><span class="yiyi-st" id="yiyi-941"> <code class="descname">st_gid</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-942">文件所有者的组标识符。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_size"><span class="yiyi-st" id="yiyi-943"> <code class="descname">st_size</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-944">文件大小（以字节为单位），如果是常规文件或符号链接。</span><span class="yiyi-st" id="yiyi-945">符号链接的大小是它所包含的路径名的长度，而不是终止的空字节。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-946">时间戳：</span></p><dl class="attribute"><dt id="os.stat_result.st_atime"><span class="yiyi-st" id="yiyi-947"> <code class="descname">st_atime</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-948">最近访问的时间以秒表示。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_mtime"><span class="yiyi-st" id="yiyi-949"> <code class="descname">st_mtime</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-950">最近的内容修改时间以秒表示。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_ctime"><span class="yiyi-st" id="yiyi-951"> <code class="descname">st_ctime</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-952">取决于平台：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-953">Unix上最新的元数据更改时间，</span></li><li><span class="yiyi-st" id="yiyi-954">在Windows上创建的时间，以秒表示。</span></li></ul></dd></dl><dl class="attribute"><dt id="os.stat_result.st_atime_ns"><span class="yiyi-st" id="yiyi-955"> <code class="descname">st_atime_ns</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-956">最近访问的时间以纳秒表示，以整数表示。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_mtime_ns"><span class="yiyi-st" id="yiyi-957"> <code class="descname">st_mtime_ns</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-958">最新内容修改的时间以纳秒表示，以整数表示。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_ctime_ns"><span class="yiyi-st" id="yiyi-959"> <code class="descname">st_ctime_ns</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-960">取决于平台：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-961">Unix上最新的元数据更改时间，</span></li><li><span class="yiyi-st" id="yiyi-962">在Windows上创建的时间，以纳秒为单位表示为整数。</span></li></ul></dd></dl><p><span class="yiyi-st" id="yiyi-963">另请参阅<a class="reference internal" href="#os.stat_float_times" title="os.stat_float_times"><code class="xref py py-func docutils literal"><span class="pre">stat_float_times()</span></code></a>函数。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-964">注意</span></p><p><span class="yiyi-st" id="yiyi-965"><a class="reference internal" href="#os.stat_result.st_atime" title="os.stat_result.st_atime"><code class="xref py py-attr docutils literal"><span class="pre">st_atime</span></code></a>，<a class="reference internal" href="#os.stat_result.st_mtime" title="os.stat_result.st_mtime"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime</span></code></a>和<a class="reference internal" href="#os.stat_result.st_ctime" title="os.stat_result.st_ctime"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime</span></code></a>属性的确切含义和解析度取决于操作系统和文件系统。</span><span class="yiyi-st" id="yiyi-966">例如，在使用FAT或FAT32文件系统的Windows系统上，<a class="reference internal" href="#os.stat_result.st_mtime" title="os.stat_result.st_mtime"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime</span></code></a>具有2秒的分辨率，<a class="reference internal" href="#os.stat_result.st_atime" title="os.stat_result.st_atime"><code class="xref py py-attr docutils literal"><span class="pre">st_atime</span></code></a>仅具有1天的分辨率。</span><span class="yiyi-st" id="yiyi-967">详细信息请参阅您的操作系统文档。</span></p><p class="last"><span class="yiyi-st" id="yiyi-968">Similarly, although <a class="reference internal" href="#os.stat_result.st_atime_ns" title="os.stat_result.st_atime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_atime_ns</span></code></a>, <a class="reference internal" href="#os.stat_result.st_mtime_ns" title="os.stat_result.st_mtime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime_ns</span></code></a>, and <a class="reference internal" href="#os.stat_result.st_ctime_ns" title="os.stat_result.st_ctime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime_ns</span></code></a> are always expressed in nanoseconds, many systems do not provide nanosecond precision. </span><span class="yiyi-st" id="yiyi-969">在提供纳秒级精度的系统上，用于存储<a class="reference internal" href="#os.stat_result.st_atime" title="os.stat_result.st_atime"><code class="xref py py-attr docutils literal"><span class="pre">st_atime</span></code></a>，<a class="reference internal" href="#os.stat_result.st_mtime" title="os.stat_result.st_mtime"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime</span></code></a>和<a class="reference internal" href="#os.stat_result.st_ctime" title="os.stat_result.st_ctime"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime</span></code></a>的浮点对象无法保留所有内容，因为这样稍微不准确。</span><span class="yiyi-st" id="yiyi-970">如果您需要准确的时间戳，则应始终使用<a class="reference internal" href="#os.stat_result.st_atime_ns" title="os.stat_result.st_atime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_atime_ns</span></code></a>，<a class="reference internal" href="#os.stat_result.st_mtime_ns" title="os.stat_result.st_mtime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime_ns</span></code></a>和<a class="reference internal" href="#os.stat_result.st_ctime_ns" title="os.stat_result.st_ctime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime_ns</span></code></a>。</span></p></div><p><span class="yiyi-st" id="yiyi-971">在某些Unix系统（如Linux）上，以下属性也可能可用：</span></p><dl class="attribute"><dt id="os.stat_result.st_blocks"><span class="yiyi-st" id="yiyi-972"> <code class="descname">st_blocks</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-973">为文件分配的512字节块的数量。</span><span class="yiyi-st" id="yiyi-974">当文件有空洞时，这可能小于<a class="reference internal" href="#os.stat_result.st_size" title="os.stat_result.st_size"><code class="xref py py-attr docutils literal"><span class="pre">st_size</span></code></a> / 512。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_blksize"><span class="yiyi-st" id="yiyi-975"> <code class="descname">st_blksize</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-976">对于高效的文件系统I / O，“首选”块大小。</span><span class="yiyi-st" id="yiyi-977">以较小的块写入文件可能会导致低效的读取 - 修改 - 重写。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_rdev"><span class="yiyi-st" id="yiyi-978"> <code class="descname">st_rdev</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-979">设备的类型，如果是inode设备。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_flags"><span class="yiyi-st" id="yiyi-980"> <code class="descname">st_flags</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-981">用户定义的文件标志。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-982">在其他Unix系统上（例如FreeBSD），下列属性可能是可用的（但只有在root尝试使用时才可以填写）：</span></p><dl class="attribute"><dt id="os.stat_result.st_gen"><span class="yiyi-st" id="yiyi-983"> <code class="descname">st_gen</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-984">文件生成号码。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_birthtime"><span class="yiyi-st" id="yiyi-985"> <code class="descname">st_birthtime</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-986">文件创建时间。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-987">在Mac OS系统上，以下属性也可能可用：</span></p><dl class="attribute"><dt id="os.stat_result.st_rsize"><span class="yiyi-st" id="yiyi-988"> <code class="descname">st_rsize</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-989">文件的实际大小。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_creator"><span class="yiyi-st" id="yiyi-990"> <code class="descname">st_creator</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-991">文件的创建者。</span></p></dd></dl><dl class="attribute"><dt id="os.stat_result.st_type"><span class="yiyi-st" id="yiyi-992"> <code class="descname">st_type</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-993">文件类型。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-994">在Windows系统上，以下属性也可用：</span></p><dl class="attribute"><dt id="os.stat_result.st_file_attributes"><span class="yiyi-st" id="yiyi-995"> <code class="descname">st_file_attributes</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-996">Windows文件属性：由<code class="xref c c-func docutils literal"><span class="pre">GetFileInformationByHandle()</span></code>返回的<code class="docutils literal"><span class="pre">BY_HANDLE_FILE_INFORMATION</span></code>结构的<code class="docutils literal"><span class="pre">dwFileAttributes</span></code>成员。</span><span class="yiyi-st" id="yiyi-997">请参阅<a class="reference internal" href="stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a>模块中的<code class="docutils literal"><span class="pre">FILE_ATTRIBUTE_*</span></code>常量。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-998">标准模块<a class="reference internal" href="stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a>定义了用于从<code class="xref c c-type docutils literal"><span class="pre">stat</span></code>结构中提取信息的函数和常量。</span><span class="yiyi-st" id="yiyi-999">（在Windows上，有些项目填充虚拟值。）</span></p><p><span class="yiyi-st" id="yiyi-1000">For backward compatibility, a <a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a> instance is also accessible as a tuple of at least 10 integers giving the most important (and portable) members of the <code class="xref c c-type docutils literal"><span class="pre">stat</span></code> structure, in the order <a class="reference internal" href="#os.stat_result.st_mode" title="os.stat_result.st_mode"><code class="xref py py-attr docutils literal"><span class="pre">st_mode</span></code></a>, <a class="reference internal" href="#os.stat_result.st_ino" title="os.stat_result.st_ino"><code class="xref py py-attr docutils literal"><span class="pre">st_ino</span></code></a>, <a class="reference internal" href="#os.stat_result.st_dev" title="os.stat_result.st_dev"><code class="xref py py-attr docutils literal"><span class="pre">st_dev</span></code></a>, <a class="reference internal" href="#os.stat_result.st_nlink" title="os.stat_result.st_nlink"><code class="xref py py-attr docutils literal"><span class="pre">st_nlink</span></code></a>, <a class="reference internal" href="#os.stat_result.st_uid" title="os.stat_result.st_uid"><code class="xref py py-attr docutils literal"><span class="pre">st_uid</span></code></a>, <a class="reference internal" href="#os.stat_result.st_gid" title="os.stat_result.st_gid"><code class="xref py py-attr docutils literal"><span class="pre">st_gid</span></code></a>, <a class="reference internal" href="#os.stat_result.st_size" title="os.stat_result.st_size"><code class="xref py py-attr docutils literal"><span class="pre">st_size</span></code></a>, <a class="reference internal" href="#os.stat_result.st_atime" title="os.stat_result.st_atime"><code class="xref py py-attr docutils literal"><span class="pre">st_atime</span></code></a>, <a class="reference internal" href="#os.stat_result.st_mtime" title="os.stat_result.st_mtime"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime</span></code></a>, <a class="reference internal" href="#os.stat_result.st_ctime" title="os.stat_result.st_ctime"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime</span></code></a>. </span><span class="yiyi-st" id="yiyi-1001">一些实现可能会在最后添加更多项目。</span><span class="yiyi-st" id="yiyi-1002">为了与旧Python版本兼容，访问<a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a>作为元组总是返回整数。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1003"><span class="versionmodified">版本3.3新增：</span>添加了<a class="reference internal" href="#os.stat_result.st_atime_ns" title="os.stat_result.st_atime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_atime_ns</span></code></a>，<a class="reference internal" href="#os.stat_result.st_mtime_ns" title="os.stat_result.st_mtime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime_ns</span></code></a>和<a class="reference internal" href="#os.stat_result.st_ctime_ns" title="os.stat_result.st_ctime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime_ns</span></code></a>个成员。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1004"><span class="versionmodified">版本3.5中的新功能</span>在Windows上添加了<a class="reference internal" href="#os.stat_result.st_file_attributes" title="os.stat_result.st_file_attributes"><code class="xref py py-attr docutils literal"><span class="pre">st_file_attributes</span></code></a>成员。</span></p></div></dd></dl><dl class="function"><dt id="os.stat_float_times"><span class="yiyi-st" id="yiyi-1005"> <code class="descclassname">os.</code><code class="descname">stat_float_times</code><span class="sig-paren">(</span><span class="optional">[</span><em>newvalue</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1006">确定<a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a>是否将时间戳记表示为浮动对象。</span><span class="yiyi-st" id="yiyi-1007">如果<em>newvalue</em>为<code class="docutils literal"><span class="pre">True</span></code>，未来对<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a>的调用将返回float，如果<code class="docutils literal"><span class="pre">False</span></code>，将来调用返回整数。</span><span class="yiyi-st" id="yiyi-1008">如果<em>newvalue</em>被省略，则返回当前设置。</span></p><p><span class="yiyi-st" id="yiyi-1009">为了与旧Python版本兼容，访问<a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a>作为元组总是返回整数。</span></p><p><span class="yiyi-st" id="yiyi-1010">Python现在默认返回浮点值。</span><span class="yiyi-st" id="yiyi-1011">无法正确使用浮点时间戳的应用程序可以使用此功能来恢复旧的行为。</span></p><p><span class="yiyi-st" id="yiyi-1012">时间戳的分辨率（即可能的最小分数）取决于系统。</span><span class="yiyi-st" id="yiyi-1013">有些系统仅支持第二种解决方案在这些系统上，分数将始终为零。</span></p><p><span class="yiyi-st" id="yiyi-1014">建议此设置仅在程序启动时在<em>__ main __</em>模块中更改；图书馆不应该改变这个设置。</span><span class="yiyi-st" id="yiyi-1015">如果应用程序使用工作不正确的库（如果处理了浮点时间戳记），则此应用程序应关闭此功能，直到库更正为止。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-1016"><span class="versionmodified">自版本3.3起已弃用。</span></span></p></div></dd></dl><dl class="function"><dt id="os.statvfs"><span class="yiyi-st" id="yiyi-1017"> <code class="descclassname">os.</code><code class="descname">statvfs</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1018">在给定路径上执行<code class="xref c c-func docutils literal"><span class="pre">statvfs()</span></code>系统调用。</span><span class="yiyi-st" id="yiyi-1019">The return value is an object whose attributes describe the filesystem on the given path, and correspond to the members of the <code class="xref c c-type docutils literal"><span class="pre">statvfs</span></code> structure, namely: <code class="xref py py-attr docutils literal"><span class="pre">f_bsize</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_frsize</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_blocks</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_bfree</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_bavail</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_files</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_ffree</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_favail</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_flag</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_namemax</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-1020">为<code class="xref py py-attr docutils literal"><span class="pre">f_flag</span></code>属性的位标记定义了两个模块级常量：如果设置了<code class="xref py py-const docutils literal"><span class="pre">ST_RDONLY</span></code>，文件系统以只读方式挂载，并且<code class="xref py py-const docutils literal"><span class="pre">ST_NOSUID</span></code></span></p><p><span class="yiyi-st" id="yiyi-1021">额外的模块级常量是为基于GNU / glibc的系统定义的。</span><span class="yiyi-st" id="yiyi-1022">These are <code class="xref py py-const docutils literal"><span class="pre">ST_NODEV</span></code> (disallow access to device special files), <code class="xref py py-const docutils literal"><span class="pre">ST_NOEXEC</span></code> (disallow program execution), <code class="xref py py-const docutils literal"><span class="pre">ST_SYNCHRONOUS</span></code> (writes are synced at once), <code class="xref py py-const docutils literal"><span class="pre">ST_MANDLOCK</span></code> (allow mandatory locks on an FS), <code class="xref py py-const docutils literal"><span class="pre">ST_WRITE</span></code> (write on file/directory/symlink), <code class="xref py py-const docutils literal"><span class="pre">ST_APPEND</span></code> (append-only file), <code class="xref py py-const docutils literal"><span class="pre">ST_IMMUTABLE</span></code> (immutable file), <code class="xref py py-const docutils literal"><span class="pre">ST_NOATIME</span></code> (do not update access times), <code class="xref py py-const docutils literal"><span class="pre">ST_NODIRATIME</span></code> (do not update directory access times), <code class="xref py py-const docutils literal"><span class="pre">ST_RELATIME</span></code> (update atime relative to mtime/ctime).</span></p><p><span class="yiyi-st" id="yiyi-1023">该函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1024"><span class="versionmodified">在版本3.2中更改：</span>添加了<code class="xref py py-const docutils literal"><span class="pre">ST_RDONLY</span></code>和<code class="xref py py-const docutils literal"><span class="pre">ST_NOSUID</span></code>常量。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1025"><span class="versionmodified">Changed in version 3.4: </span>The <code class="xref py py-const docutils literal"><span class="pre">ST_NODEV</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_NOEXEC</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_SYNCHRONOUS</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_MANDLOCK</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_WRITE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_APPEND</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_IMMUTABLE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_NOATIME</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_NODIRATIME</span></code>, and <code class="xref py py-const docutils literal"><span class="pre">ST_RELATIME</span></code> constants were added.</span></p></div><p><span class="yiyi-st" id="yiyi-1026">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1027"><span class="versionmodified">版本3.3新增：</span>增加了为<em>路径</em>指定打开的文件描述符的支持。</span></p></div></dd></dl><dl class="data"><dt id="os.supports_dir_fd"><span class="yiyi-st" id="yiyi-1028"> <code class="descclassname">os.</code><code class="descname">supports_dir_fd</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1029"><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">Set</span></code></a>对象指示<a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a>模块中的哪些函数允许使用它们的<em>dir_fd</em>参数。</span><span class="yiyi-st" id="yiyi-1030">不同的平台提供不同的功能，并且可能在另一个平台上工作的选项可能不受支持。</span><span class="yiyi-st" id="yiyi-1031">为了保持一致性，支持<em>dir_fd</em>的函数总是允许指定参数，但如果功能实际上不可用，则会引发异常。</span></p><p><span class="yiyi-st" id="yiyi-1032">要检查特定函数是否允许使用<em>dir_fd</em>参数，请使用<code class="docutils literal"><span class="pre">supports_dir_fd</span></code>中的运算符中的<code class="docutils literal"><span class="pre">in</span></code></span><span class="yiyi-st" id="yiyi-1033">作为示例，此表达式确定<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>的<em>dir_fd</em>参数是否本地可用：</span></p><pre><code class="language-python"><span></span><span class="n">os</span><span class="o">.</span><span class="n">stat</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">supports_dir_fd</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1034">目前<em>dir_fd</em>参数仅适用于Unix平台；他们都没有在Windows上工作。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1035"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="os.supports_effective_ids"><span class="yiyi-st" id="yiyi-1036"> <code class="descclassname">os.</code><code class="descname">supports_effective_ids</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1037">指示<a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a>模块中的哪些函数允许<a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">os.access()</span></code></a>使用<em>effective_ids</em>参数的<a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">Set</span></code></a> 。</span><span class="yiyi-st" id="yiyi-1038">如果本地平台支持它，则集合将包含<a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">os.access()</span></code></a>，否则它将为空。</span></p><p><span class="yiyi-st" id="yiyi-1039">要检查<a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">os.access()</span></code></a>是否可以使用<em>effective_ids</em>参数，请在<code class="docutils literal"><span class="pre">supports_effective_ids</span></code>的运算符中使用<code class="docutils literal"><span class="pre">in</span></code></span></p><pre><code class="language-python"><span></span><span class="n">os</span><span class="o">.</span><span class="n">access</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">supports_effective_ids</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1040">目前<em>effective_ids</em>仅适用于Unix平台；它不适用于Windows。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1041"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="os.supports_fd"><span class="yiyi-st" id="yiyi-1042"> <code class="descclassname">os.</code><code class="descname">supports_fd</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1043"><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">Set</span></code></a>对象指示<a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a>模块中的哪些函数允许将<em>路径</em>参数指定为打开的文件描述符。</span><span class="yiyi-st" id="yiyi-1044">不同的平台提供不同的功能，并且可能在另一个平台上工作的选项可能不受支持。</span><span class="yiyi-st" id="yiyi-1045">为了保持一致性，支持<em>fd</em>的函数总是允许指定参数，但如果功能实际上不可用，则会引发异常。</span></p><p><span class="yiyi-st" id="yiyi-1046">要检查特定函数是否允许为其<em>path</em>参数指定打开的文件描述符，请使用<code class="docutils literal"><span class="pre">supports_fd</span></code>中的运算符中的<code class="docutils literal"><span class="pre">in</span></code></span><span class="yiyi-st" id="yiyi-1047">作为一个例子，这个表达式决定了当你的本地平台调用时，<a class="reference internal" href="#os.chdir" title="os.chdir"><code class="xref py py-func docutils literal"><span class="pre">os.chdir()</span></code></a>是否接受打开的文件描述符：</span></p><pre><code class="language-python"><span></span><span class="n">os</span><span class="o">.</span><span class="n">chdir</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">supports_fd</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1048"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="os.supports_follow_symlinks"><span class="yiyi-st" id="yiyi-1049"> <code class="descclassname">os.</code><code class="descname">supports_follow_symlinks</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1050"><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">Set</span></code></a>对象指示<a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a>模块中的哪些函数允许使用它们的<em>follow_symlinks</em>参数。</span><span class="yiyi-st" id="yiyi-1051">不同的平台提供不同的功能，并且可能在另一个平台上工作的选项可能不受支持。</span><span class="yiyi-st" id="yiyi-1052">出于一致性的考虑，支持<em>follow_symlinks</em>的函数总是允许指定参数，但如果功能实际上不可用，则会引发异常。</span></p><p><span class="yiyi-st" id="yiyi-1053">要检查特定函数是否允许使用<em>follow_symlinks</em>参数，请使用<code class="docutils literal"><span class="pre">supports_follow_symlinks</span></code>中的运算符中的<code class="docutils literal"><span class="pre">in</span></code></span><span class="yiyi-st" id="yiyi-1054">作为一个例子，这个表达式确定<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>的<em>follow_symlinks</em>参数是否是本地可用的：</span></p><pre><code class="language-python"><span></span><span class="n">os</span><span class="o">.</span><span class="n">stat</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">supports_follow_symlinks</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1055"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.symlink"><span class="yiyi-st" id="yiyi-1056"> <code class="descclassname">os.</code><code class="descname">symlink</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em>, <em>target_is_directory=False</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1057">创建一个指向名为<em>dst</em>的<em>src</em>的符号链接。</span></p><p><span class="yiyi-st" id="yiyi-1058">在Windows上，符号链接表示文件或目录，并且不会动态变形为目标。</span><span class="yiyi-st" id="yiyi-1059">如果目标存在，则会创建符合链接的类型以匹配。</span><span class="yiyi-st" id="yiyi-1060">否则，如果<em>target_is_directory</em>为<code class="docutils literal"><span class="pre">True</span></code>或符号链接（默认），则符号链接将创建为目录。</span><span class="yiyi-st" id="yiyi-1061">在非Window平台上，<em>target_is_directory</em>被忽略。</span></p><p><span class="yiyi-st" id="yiyi-1062">在Windows 6.0（Vista）中引入了符号链接支持。</span><span class="yiyi-st" id="yiyi-1063"><a class="reference internal" href="#os.symlink" title="os.symlink"><code class="xref py py-func docutils literal"><span class="pre">symlink()</span></code></a> will raise a <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> on Windows versions earlier than 6.0.</span></p><p><span class="yiyi-st" id="yiyi-1064">该函数可以支持<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>的路径。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1065">注意</span></p><p><span class="yiyi-st" id="yiyi-1066">在Windows上，为了成功创建符号链接，需要<em>SeCreateSymbolicLinkPrivilege</em>。</span><span class="yiyi-st" id="yiyi-1067">此权限通常不授予常规用户，但可用于可将权限提升到管理员级别的帐户。</span><span class="yiyi-st" id="yiyi-1068">获得权限或以管理员身份运行应用程序是成功创建符号链接的方法。</span></p><p class="last"><span class="yiyi-st" id="yiyi-1069"><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> is raised when the function is called by an unprivileged user.</span></p></div><p><span class="yiyi-st" id="yiyi-1070">可用性：Unix，Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1071"><span class="versionmodified">在版本3.2中更改：</span>添加了对Windows 6.0（Vista）符号链接的支持。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1072"><span class="versionmodified">3.3版新增功能：</span>在非Windows平台上添加了<em>dir_fd</em>参数，现在允许<em>target_is_directory</em>。</span></p></div></dd></dl><dl class="function"><dt id="os.sync"><span class="yiyi-st" id="yiyi-1073"> <code class="descclassname">os.</code><code class="descname">sync</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1074">强制将所有内容写入磁盘。</span></p><p><span class="yiyi-st" id="yiyi-1075">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1076"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.truncate"><span class="yiyi-st" id="yiyi-1077"> <code class="descclassname">os.</code><code class="descname">truncate</code><span class="sig-paren">(</span><em>path</em>, <em>length</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1078">截断与<em>路径</em>对应的文件，以便它的大小至多为<em>长度</em>字节。</span></p><p><span class="yiyi-st" id="yiyi-1079">该函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-1080">可用性：Unix，Windows。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1081"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1082"><span class="versionmodified">版本3.5中已更改：</span>添加了对Windows的支持</span></p></div></dd></dl><dl class="function"><dt id="os.unlink"><span class="yiyi-st" id="yiyi-1083"> <code class="descclassname">os.</code><code class="descname">unlink</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1084">删除（删除）文件<em>路径</em>。</span><span class="yiyi-st" id="yiyi-1085">这个函数在语义上与<a class="reference internal" href="#os.remove" title="os.remove"><code class="xref py py-func docutils literal"><span class="pre">remove()</span></code></a>；相同。 <code class="docutils literal"><span class="pre">unlink</span></code>名称是其传统的Unix名称。</span><span class="yiyi-st" id="yiyi-1086">有关更多信息，请参阅<a class="reference internal" href="#os.remove" title="os.remove"><code class="xref py py-func docutils literal"><span class="pre">remove()</span></code></a>的文档。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1087"><span class="versionmodified">版本3.3新增：</span> <em>dir_fd</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.utime"><span class="yiyi-st" id="yiyi-1088"> <code class="descclassname">os.</code><code class="descname">utime</code><span class="sig-paren">(</span><em>path</em>, <em>times=None</em>, <em>*</em>, <span class="optional">[</span><em>ns</em>, <span class="optional">]</span><em>dir_fd=None</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1089">设置由<em>path</em>指定的文件的访问和修改时间。</span></p><p><span class="yiyi-st" id="yiyi-1090"><a class="reference internal" href="#os.utime" title="os.utime"><code class="xref py py-func docutils literal"><span class="pre">utime()</span></code></a>采用两个可选参数，<em>时间数</em>和<em>纳秒</em>。</span><span class="yiyi-st" id="yiyi-1091">这些指定了在<em>路径</em>上设置的时间，并按以下方式使用：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-1092">如果指定了<em>ns</em>，它必须是<code class="docutils literal"><span class="pre">（atime_ns，</span> <span class="pre">mtime_ns）</span></code>形式的2元组，其中每个成员是一个int表达纳秒。</span></li><li><span class="yiyi-st" id="yiyi-1093">如果<em>次</em>不是<code class="docutils literal"><span class="pre">None</span></code>，它必须是<code class="docutils literal"><span class="pre">形式的两元组（atime，</span> <span class="pre">mtime） t5&gt;</span></code>其中每个成员都是表示秒的int或float。</span></li><li><span class="yiyi-st" id="yiyi-1094">如果<em>次</em>为<code class="docutils literal"><span class="pre">None</span></code>且<em>未指定ns</em>，这相当于指定<code class="docutils literal"><span class="pre">ns =（atime_ns，</span> <code class="docutils literal">mtime_ns）</code>这两个时间都是当前时间。</code></span></li></ul><p><span class="yiyi-st" id="yiyi-1095">为<em>次</em>和<em>ns</em>指定元组是错误的。</span></p><p><span class="yiyi-st" id="yiyi-1096">是否可以为<em>路径</em>提供一个目录取决于操作系统是否将目录实现为文件（例如Windows不）。</span><span class="yiyi-st" id="yiyi-1097">请注意，您在此设置的确切时间可能不会由随后的<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a>调用返回，具体取决于操作系统记录访问和修改时间的分辨率；请参阅<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a>。</span><span class="yiyi-st" id="yiyi-1098">保留精确时间的最佳方法是将<a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>结果对象中的<em>st_atime_ns</em>和<em>st_mtime_ns</em>字段与<em>ns</em>参数到<cite>utime</cite>。</span></p><p><span class="yiyi-st" id="yiyi-1099">该函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>，<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>的路径和<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>的路径。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1100"><span class="versionmodified">3.3版新增：</span>增加了对指定<em>路径</em>和<em>dir_fd</em>，<em>follow_symlinks</em>的打开文件描述符的支持，和<em>ns</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="os.walk"><span class="yiyi-st" id="yiyi-1101"> <code class="descclassname">os.</code><code class="descname">walk</code><span class="sig-paren">(</span><em>top</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>followlinks=False</em><span class="sig-paren">)</span></span></dt><dd><p id="index-22"><span class="yiyi-st" id="yiyi-1102">遍历目录树，自顶向下或自底向上生成目录树下的文件名。</span><span class="yiyi-st" id="yiyi-1103">对根目录<em>top</em>（包括根目录<em>top</em>本身）中的每个目录，它都会yield一个3元元组<code class="docutils literal"><span class="pre">(dirpath,</span> <span class="pre">dirnames,</span> <span class="pre">filenames)</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1104"><em>dirpath</em>是一个字符串，为目录路径。</span><span class="yiyi-st" id="yiyi-1105"><em>dirnames</em>是<em>dirpath</em>中子目录的名称列表（不包括<code class="docutils literal"><span class="pre">'.'</span></code></span><span class="yiyi-st" id="yiyi-1106">和<code class="docutils literal"><span class="pre">'..'</span></code>)。</span><span class="yiyi-st" id="yiyi-1107"><em>文件名</em>是<em>dirpath</em>中非目录文件的名称列表。</span><span class="yiyi-st" id="yiyi-1108">注意，列表中的名称不包含路径部分。</span><span class="yiyi-st" id="yiyi-1109">要获得<em>dirpath</em> 中的文件或目录的完整路径(以 <em>top</em>开头), 请使用<code class="docutils literal"><span class="pre">os.path.join(dirpath,</span> <span class="pre">name)</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-1110">如果可选参数<em>topdown</em>为<code class="docutils literal"><span class="pre">True</span></code>或未指定，则在生成其任何子目录的三元组tuple之前生成其本身的三元组tuple。（简言之就是自上而下遍历）</span><span class="yiyi-st" id="yiyi-1111">如果<em>topdown</em>是<code class="docutils literal"><span class="pre">False</span></code>，则在生成所有子目录的三元组之后生成其本身的三元组（即自下而上生成）。</span><span class="yiyi-st" id="yiyi-1112">无论<em>topdown</em>的值如何，在生成目录及其子目录的元组之前，都会检索子目录列表。</span></p><p><span class="yiyi-st" id="yiyi-1113">当<em>topdown</em>为<code class="docutils literal"><span class="pre">True</span></code>时，调用者可以就地修改<em>dirnames</em>列表（也许使用<a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a> ），并且<a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>仅会递归到名称保留在<em>dirnames</em>中的子目录；这可以用来修剪搜索，强制访问的特定顺序，甚至可以通知<a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>关于调用者在恢复之前创建或重命名的目录<a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>再次。</span><span class="yiyi-st" id="yiyi-1114">当<em>topdown</em>为<code class="docutils literal"><span class="pre">False</span></code>时，修改<em>dirnames</em>对walk的行为没有影响，因为在自底向上模式下，<em>dirnames </em>在<em>dirpath</em>本身生成之前生成。</span></p><p><span class="yiyi-st" id="yiyi-1115">默认情况下，来自<a class="reference internal" href="#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal"><span class="pre">listdir()</span></code></a>的错误将被忽略。</span><span class="yiyi-st" id="yiyi-1116">如果指定了可选参数<em>onerror</em>，它应该是一个函数；it will be called with one argument, an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> instance.</span><span class="yiyi-st" id="yiyi-1117">它可以报告错误以继续步行，或者提出异常以中止步行。</span><span class="yiyi-st" id="yiyi-1118">请注意，文件名可用作异常对象的<code class="docutils literal"><span class="pre">filename</span></code>属性。</span></p><p><span class="yiyi-st" id="yiyi-1119">默认情况下，<a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>不会走向解析为目录的符号链接。</span><span class="yiyi-st" id="yiyi-1120">在支持它们的系统上，设置<em>followlinks</em>为<code class="docutils literal"><span class="pre">True</span></code>以访问由符号链接指向的目录。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1121">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1122">请注意，如果链接指向其自身的父目录，则将<em>followlinks</em>设置为<code class="docutils literal"><span class="pre">True</span></code>可导致无限递归。</span><span class="yiyi-st" id="yiyi-1123"><a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>不会跟踪它已经访问的目录。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1124">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1125">如果传递相对路径名，请不要在<a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>重新开始之间更改当前工作目录。</span><span class="yiyi-st" id="yiyi-1126"><a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>永远不会更改当前目录，并假定它的调用者也不会。</span></p></div><p><span class="yiyi-st" id="yiyi-1127">此示例显示非目录文件在起始目录下的每个目录中占用的字节数，但不显示在任何CVS子目录下：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">getsize</span>
<span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="s1">'python/Lib/email'</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">"consumes"</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">" "</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">getsize</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">" "</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"bytes in"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">),</span> <span class="s2">"non-directory files"</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">'CVS'</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
        <span class="n">dirs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">'CVS'</span><span class="p">)</span>  <span class="c1"># don't visit CVS directories</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1128">In the next example (simple implementation of <a class="reference internal" href="shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal"><span class="pre">shutil.rmtree()</span></code></a>), walking the tree bottom-up is essential, <a class="reference internal" href="#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal"><span class="pre">rmdir()</span></code></a> doesn’t allow deleting a directory before the directory is empty:</span></p><pre><code class="language-python"><span></span><span class="c1"># Delete everything reachable from the directory named in "top",</span>
<span class="c1"># assuming there are no symbolic links.</span>
<span class="c1"># CAUTION:  This is dangerous!  For example, if top == '/', it</span>
<span class="c1"># could delete all your disk files.</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">topdown</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
</code></pre><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1129"><span class="versionmodified">Changed in version 3.5: </span>This function now calls <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">os.scandir()</span></code></a> instead of <a class="reference internal" href="#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal"><span class="pre">os.listdir()</span></code></a>, making it faster by reducing the number of calls to <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>.</span></p></div></dd></dl><dl class="function"><dt id="os.fwalk"><span class="yiyi-st" id="yiyi-1130"> <code class="descclassname">os.</code><code class="descname">fwalk</code><span class="sig-paren">(</span><em>top='.'</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>*</em>, <em>follow_symlinks=False</em>, <em>dir_fd=None</em><span class="sig-paren">)</span></span></dt><dd><p id="index-23"><span class="yiyi-st" id="yiyi-1131">行为与<a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>非常类似，不同的是它产生一个4元组<code class="docutils literal"><span class="pre">(dirpath,</span> <span class="pre">dirnames,</span> <span class="pre">filenames,</span> <span class="pre">dirfd)</span></code>，并支持<code class="docutils literal"><span class="pre">dir_fd</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1132"><em>dirpath</em>, <em>dirnames</em> and <em>filenames</em> are identical to <a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a> output, and <em>dirfd</em> is a file descriptor referring to the directory <em>dirpath</em>.</span></p><p><span class="yiyi-st" id="yiyi-1133">该函数始终支持<a class="reference internal" href="#dir-fd"><span>paths relative to directory descriptors</span></a>和<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>的路径。</span><span class="yiyi-st" id="yiyi-1134">但请注意，与其他函数不同，<em>follow_symlinks</em>的<a class="reference internal" href="#os.fwalk" title="os.fwalk"><code class="xref py py-func docutils literal"><span class="pre">fwalk()</span></code></a>默认值为<code class="docutils literal"><span class="pre">False</span></code>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1135">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1136">由于<a class="reference internal" href="#os.fwalk" title="os.fwalk"><code class="xref py py-func docutils literal"><span class="pre">fwalk()</span></code></a>产生文件描述符，这些描述符只有在下一个迭代步骤之前才有效，所以你应该复制它们。</span><span class="yiyi-st" id="yiyi-1137">与<a class="reference internal" href="#os.dup" title="os.dup"><code class="xref py py-func docutils literal"><span class="pre">dup()</span></code></a>），如果你想保持更长的时间。</span></p></div><p><span class="yiyi-st" id="yiyi-1138">此示例显示非目录文件在起始目录下的每个目录中占用的字节数，但不显示在任何CVS子目录下：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">rootfd</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">fwalk</span><span class="p">(</span><span class="s1">'python/Lib/email'</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">"consumes"</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">""</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">rootfd</span><span class="p">)</span><span class="o">.</span><span class="n">st_size</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]),</span>
          <span class="n">end</span><span class="o">=</span><span class="s2">""</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"bytes in"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">),</span> <span class="s2">"non-directory files"</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">'CVS'</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
        <span class="n">dirs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">'CVS'</span><span class="p">)</span>  <span class="c1"># don't visit CVS directories</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1139">在下一个示例中，从下往上走树是至关重要的：<a class="reference internal" href="#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal"><span class="pre">rmdir()</span></code></a>不允许在目录为空之前删除目录：</span></p><pre><code class="language-python"><span></span><span class="c1"># Delete everything reachable from the directory named in "top",</span>
<span class="c1"># assuming there are no symbolic links.</span>
<span class="c1"># CAUTION:  This is dangerous!  For example, if top == '/', it</span>
<span class="c1"># could delete all your disk files.</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">rootfd</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">fwalk</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">topdown</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">rootfd</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">rootfd</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1140">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1141"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><div class="section" id="linux-extended-attributes"><h3><span class="yiyi-st" id="yiyi-1142">16.1.5.1. </span><span class="yiyi-st" id="yiyi-1143">Linux扩展属性</span></h3><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1144"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><p><span class="yiyi-st" id="yiyi-1145">这些功能仅在Linux上可用。</span></p><dl class="function"><dt id="os.getxattr"><span class="yiyi-st" id="yiyi-1146"> <code class="descclassname">os.</code><code class="descname">getxattr</code><span class="sig-paren">(</span><em>path</em>, <em>attribute</em>, <em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1147">为<em>路径</em>返回扩展文件系统属性<em>属性</em>的值。</span><span class="yiyi-st" id="yiyi-1148"><em>属性</em>可以是字节或字符串。</span><span class="yiyi-st" id="yiyi-1149">如果它是str，则用文件系统编码进行编码。</span></p><p><span class="yiyi-st" id="yiyi-1150">此函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>和<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>。</span></p></dd></dl><dl class="function"><dt id="os.listxattr"><span class="yiyi-st" id="yiyi-1151"> <code class="descclassname">os.</code><code class="descname">listxattr</code><span class="sig-paren">(</span><em>path=None</em>, <em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1152">返回<em>路径</em>上的扩展文件系统属性列表。</span><span class="yiyi-st" id="yiyi-1153">列表中的属性表示为用文件系统编码解码的字符串。</span><span class="yiyi-st" id="yiyi-1154">If <em>path</em> is <code class="docutils literal"><span class="pre">None</span></code>, <a class="reference internal" href="#os.listxattr" title="os.listxattr"><code class="xref py py-func docutils literal"><span class="pre">listxattr()</span></code></a> will examine the current directory.</span></p><p><span class="yiyi-st" id="yiyi-1155">此函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>和<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>。</span></p></dd></dl><dl class="function"><dt id="os.removexattr"><span class="yiyi-st" id="yiyi-1156"> <code class="descclassname">os.</code><code class="descname">removexattr</code><span class="sig-paren">(</span><em>path</em>, <em>attribute</em>, <em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1157">从<em>路径</em>中删除扩展文件系统属性<em>属性</em>。</span><span class="yiyi-st" id="yiyi-1158"><em>属性</em>应该是字节或str。</span><span class="yiyi-st" id="yiyi-1159">如果它是一个字符串，则用文件系统编码进行编码。</span></p><p><span class="yiyi-st" id="yiyi-1160">此函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>和<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>。</span></p></dd></dl><dl class="function"><dt id="os.setxattr"><span class="yiyi-st" id="yiyi-1161"> <code class="descclassname">os.</code><code class="descname">setxattr</code><span class="sig-paren">(</span><em>path</em>, <em>attribute</em>, <em>value</em>, <em>flags=0</em>, <em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1162">将<em>路径</em>上的扩展文件系统属性<em>属性</em>设置为<em>值</em>。</span><span class="yiyi-st" id="yiyi-1163"><em>属性</em>必须是没有嵌入式NUL的字节或字符串。</span><span class="yiyi-st" id="yiyi-1164">如果它是一个str，它将用文件系统编码进行编码。</span><span class="yiyi-st" id="yiyi-1165"><em>flags</em> may be <a class="reference internal" href="#os.XATTR_REPLACE" title="os.XATTR_REPLACE"><code class="xref py py-data docutils literal"><span class="pre">XATTR_REPLACE</span></code></a> or <a class="reference internal" href="#os.XATTR_CREATE" title="os.XATTR_CREATE"><code class="xref py py-data docutils literal"><span class="pre">XATTR_CREATE</span></code></a>. </span><span class="yiyi-st" id="yiyi-1166">If <a class="reference internal" href="#os.XATTR_REPLACE" title="os.XATTR_REPLACE"><code class="xref py py-data docutils literal"><span class="pre">XATTR_REPLACE</span></code></a> is given and the attribute does not exist, <code class="docutils literal"><span class="pre">EEXISTS</span></code> will be raised. </span><span class="yiyi-st" id="yiyi-1167">如果给出<a class="reference internal" href="#os.XATTR_CREATE" title="os.XATTR_CREATE"><code class="xref py py-data docutils literal"><span class="pre">XATTR_CREATE</span></code></a>并且该属性已经存在，那么该属性将不会被创建，并且会引发<code class="docutils literal"><span class="pre">ENODATA</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1168">此函数可以支持<a class="reference internal" href="#path-fd"><span>specifying a file descriptor</span></a>和<a class="reference internal" href="#follow-symlinks"><span>not following symlinks</span></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1169">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1170">Linux内核版本低于2.6.39的错误导致在某些文件系统上flags参数被忽略。</span></p></div></dd></dl><dl class="data"><dt id="os.XATTR_SIZE_MAX"><span class="yiyi-st" id="yiyi-1171"> <code class="descclassname">os.</code><code class="descname">XATTR_SIZE_MAX</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1172">扩展属性值的最大大小可以是。</span><span class="yiyi-st" id="yiyi-1173">目前，这是Linux上的64 KiB。</span></p></dd></dl><dl class="data"><dt id="os.XATTR_CREATE"><span class="yiyi-st" id="yiyi-1174"> <code class="descclassname">os.</code><code class="descname">XATTR_CREATE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1175">这是<a class="reference internal" href="#os.setxattr" title="os.setxattr"><code class="xref py py-func docutils literal"><span class="pre">setxattr()</span></code></a>中flags参数的可能值。</span><span class="yiyi-st" id="yiyi-1176">它表示操作必须创建一个属性。</span></p></dd></dl><dl class="data"><dt id="os.XATTR_REPLACE"><span class="yiyi-st" id="yiyi-1177"> <code class="descclassname">os.</code><code class="descname">XATTR_REPLACE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1178">这是<a class="reference internal" href="#os.setxattr" title="os.setxattr"><code class="xref py py-func docutils literal"><span class="pre">setxattr()</span></code></a>中flags参数的可能值。</span><span class="yiyi-st" id="yiyi-1179">它表示操作必须替换现有的属性。</span></p></dd></dl></div></div><div class="section" id="process-management"><h2><span class="yiyi-st" id="yiyi-1180">16.1.6. </span><span class="yiyi-st" id="yiyi-1181">流程管理</span></h2><p><span class="yiyi-st" id="yiyi-1182">这些功能可用于创建和管理进程。</span></p><p><span class="yiyi-st" id="yiyi-1183">各种<a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">exec*</span></code></a>函数为加载到进程中的新程序提供参数列表。</span><span class="yiyi-st" id="yiyi-1184">在每种情况下，这些参数中的第一个将作为自己的名称传递给新程序，而不是作为用户可能在命令行上输入的参数。</span><span class="yiyi-st" id="yiyi-1185">对于C程序员来说，这是传递给程序的<code class="xref c c-func docutils literal"><span class="pre">main()</span></code>的<code class="docutils literal"><span class="pre">argv[0]</span></code>。</span><span class="yiyi-st" id="yiyi-1186">For example, <code class="docutils literal"><span class="pre">os.execv('/bin/echo',</span> <span class="pre">['foo',</span> <span class="pre">'bar'])</span></code> will only print <code class="docutils literal"><span class="pre">bar</span></code> on standard output; <code class="docutils literal"><span class="pre">foo</span></code> will seem to be ignored.</span></p><dl class="function"><dt id="os.abort"><span class="yiyi-st" id="yiyi-1187"> <code class="descclassname">os.</code><code class="descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1188">生成一个<code class="xref py py-const docutils literal"><span class="pre">SIGABRT</span></code>信号给当前进程。</span><span class="yiyi-st" id="yiyi-1189">在Unix上，默认行为是产生核心转储；在Windows上，该进程立即返回<code class="docutils literal"><span class="pre">3</span></code>的退出码。</span><span class="yiyi-st" id="yiyi-1190">请注意，调用此函数不会使用<a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal"><span class="pre">signal.signal()</span></code></a>调用为<code class="xref py py-const docutils literal"><span class="pre">SIGABRT</span></code>注册的Python信号处理程序。</span></p></dd></dl><dl class="function"><dt id="os.execl"><span class="yiyi-st" id="yiyi-1191"> <code class="descclassname">os.</code><code class="descname">execl</code><span class="sig-paren">(</span><em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dt id="os.execle"><span class="yiyi-st" id="yiyi-1192"> <code class="descclassname">os.</code><code class="descname">execle</code><span class="sig-paren">(</span><em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>...</em>, <em>env</em><span class="sig-paren">)</span></span></dt><dt id="os.execlp"><span class="yiyi-st" id="yiyi-1193"> <code class="descclassname">os.</code><code class="descname">execlp</code><span class="sig-paren">(</span><em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dt id="os.execlpe"><span class="yiyi-st" id="yiyi-1194"> <code class="descclassname">os.</code><code class="descname">execlpe</code><span class="sig-paren">(</span><em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>...</em>, <em>env</em><span class="sig-paren">)</span></span></dt><dt id="os.execv"><span class="yiyi-st" id="yiyi-1195"> <code class="descclassname">os.</code><code class="descname">execv</code><span class="sig-paren">(</span><em>path</em>, <em>args</em><span class="sig-paren">)</span></span></dt><dt id="os.execve"><span class="yiyi-st" id="yiyi-1196"> <code class="descclassname">os.</code><code class="descname">execve</code><span class="sig-paren">(</span><em>path</em>, <em>args</em>, <em>env</em><span class="sig-paren">)</span></span></dt><dt id="os.execvp"><span class="yiyi-st" id="yiyi-1197"> <code class="descclassname">os.</code><code class="descname">execvp</code><span class="sig-paren">(</span><em>file</em>, <em>args</em><span class="sig-paren">)</span></span></dt><dt id="os.execvpe"><span class="yiyi-st" id="yiyi-1198"> <code class="descclassname">os.</code><code class="descname">execvpe</code><span class="sig-paren">(</span><em>file</em>, <em>args</em>, <em>env</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1199">这些功能都执行一个新程序，取代当前进程；他们不回来。</span><span class="yiyi-st" id="yiyi-1200">在Unix上，这组函数可以把一个新的可执行程序加载入当前的进程，并且进程保持process id不变。</span><span class="yiyi-st" id="yiyi-1201">错误将被报告为<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>异常。</span></p><p><span class="yiyi-st" id="yiyi-1202">当前进程中的程序会立即被替代。</span><span class="yiyi-st" id="yiyi-1203">Open file objects and descriptors are not flushed, so if there may be data buffered on these open files, you should flush them using <code class="xref py py-func docutils literal"><span class="pre">sys.stdout.flush()</span></code> or <a class="reference internal" href="#os.fsync" title="os.fsync"><code class="xref py py-func docutils literal"><span class="pre">os.fsync()</span></code></a> before calling an <a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">exec*</span></code></a> function.</span></p><p><span class="yiyi-st" id="yiyi-1204"><a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">exec*</span></code></a>函数的“l”和“v”变体在传递命令行参数方面有所不同。</span><span class="yiyi-st" id="yiyi-1205">如果在编写代码时参数的数量是固定的，则“l”变体可能是最容易使用的变体；各个参数只是成为<code class="xref py py-func docutils literal"><span class="pre">execl*()</span></code>函数的附加参数。</span><span class="yiyi-st" id="yiyi-1206">当参数的数量是可变的时，“v”变体是很好的，参数以列表或元组的形式作为<em>args</em>参数传递。</span><span class="yiyi-st" id="yiyi-1207">在任何一种情况下，子进程的参数都应以正在运行的命令的名称开始，但这不是强制执行的。</span></p><p><span class="yiyi-st" id="yiyi-1208">The variants which include a “p” near the end (<a class="reference internal" href="#os.execlp" title="os.execlp"><code class="xref py py-func docutils literal"><span class="pre">execlp()</span></code></a>, <a class="reference internal" href="#os.execlpe" title="os.execlpe"><code class="xref py py-func docutils literal"><span class="pre">execlpe()</span></code></a>, <a class="reference internal" href="#os.execvp" title="os.execvp"><code class="xref py py-func docutils literal"><span class="pre">execvp()</span></code></a>, and <a class="reference internal" href="#os.execvpe" title="os.execvpe"><code class="xref py py-func docutils literal"><span class="pre">execvpe()</span></code></a>) will use the <span class="target" id="index-24"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> environment variable to locate the program <em>file</em>. </span><span class="yiyi-st" id="yiyi-1209">当环境被替换时（使用下一段讨论的<a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">exec*e</span></code></a>变体之一），新环境被用作<span class="target" id="index-25"></span> <code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code>变量。</span><span class="yiyi-st" id="yiyi-1210">The other variants, <a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">execl()</span></code></a>, <a class="reference internal" href="#os.execle" title="os.execle"><code class="xref py py-func docutils literal"><span class="pre">execle()</span></code></a>, <a class="reference internal" href="#os.execv" title="os.execv"><code class="xref py py-func docutils literal"><span class="pre">execv()</span></code></a>, and <a class="reference internal" href="#os.execve" title="os.execve"><code class="xref py py-func docutils literal"><span class="pre">execve()</span></code></a>, will not use the <span class="target" id="index-26"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> variable to locate the executable; <em>path</em> must contain an appropriate absolute or relative path.</span></p><p><span class="yiyi-st" id="yiyi-1211">For <a class="reference internal" href="#os.execle" title="os.execle"><code class="xref py py-func docutils literal"><span class="pre">execle()</span></code></a>, <a class="reference internal" href="#os.execlpe" title="os.execlpe"><code class="xref py py-func docutils literal"><span class="pre">execlpe()</span></code></a>, <a class="reference internal" href="#os.execve" title="os.execve"><code class="xref py py-func docutils literal"><span class="pre">execve()</span></code></a>, and <a class="reference internal" href="#os.execvpe" title="os.execvpe"><code class="xref py py-func docutils literal"><span class="pre">execvpe()</span></code></a> (note that these all end in “e”), the <em>env</em> parameter must be a mapping which is used to define the environment variables for the new process (these are used instead of the current process’ environment); the functions <a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">execl()</span></code></a>, <a class="reference internal" href="#os.execlp" title="os.execlp"><code class="xref py py-func docutils literal"><span class="pre">execlp()</span></code></a>, <a class="reference internal" href="#os.execv" title="os.execv"><code class="xref py py-func docutils literal"><span class="pre">execv()</span></code></a>, and <a class="reference internal" href="#os.execvp" title="os.execvp"><code class="xref py py-func docutils literal"><span class="pre">execvp()</span></code></a> all cause the new process to inherit the environment of the current process.</span></p><p><span class="yiyi-st" id="yiyi-1212">对于某些平台上的<a class="reference internal" href="#os.execve" title="os.execve"><code class="xref py py-func docutils literal"><span class="pre">execve()</span></code></a>，<em>path</em>也可以指定为打开的文件描述符。</span><span class="yiyi-st" id="yiyi-1213">您的平台可能不支持此功能；您可以使用<a class="reference internal" href="#os.supports_fd" title="os.supports_fd"><code class="xref py py-data docutils literal"><span class="pre">os.supports_fd</span></code></a>检查它是否可用。</span><span class="yiyi-st" id="yiyi-1214">如果不可用，使用它将引发一个<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-1215">可用性：Unix，Windows。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1216"><span class="versionmodified">版本3.3新增：</span>新增支持为<a class="reference internal" href="#os.execve" title="os.execve"><code class="xref py py-func docutils literal"><span class="pre">execve()</span></code></a>指定<em>路径</em>的开放文件描述符。</span></p></div></dd></dl><dl class="function"><dt id="os._exit"><span class="yiyi-st" id="yiyi-1217"> <code class="descclassname">os.</code><code class="descname">_exit</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1218">状态<em>n</em>退出进程，无需调用清理处理程序，刷新stdio缓冲区等。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1219">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1220">标准的退出方式是<code class="docutils literal"><span class="pre">sys.exit(n)</span></code>。</span><span class="yiyi-st" id="yiyi-1221"><a class="reference internal" href="#os._exit" title="os._exit"><code class="xref py py-func docutils literal"><span class="pre">_exit()</span></code></a>通常只应在<a class="reference internal" href="#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">fork()</span></code></a>之后的子进程中使用。</span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-1222">以下退出代码已定义并可与<a class="reference internal" href="#os._exit" title="os._exit"><code class="xref py py-func docutils literal"><span class="pre">_exit()</span></code></a>一起使用，尽管它们不是必需的。</span><span class="yiyi-st" id="yiyi-1223">这些通常用于以Python编写的系统程序，例如邮件服务器的外部命令传递程序。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1224">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1225">其中一些可能不适用于所有的Unix平台，因为有一些变化。</span><span class="yiyi-st" id="yiyi-1226">这些常量被定义在底层平台所定义的位置。</span></p></div><dl class="data"><dt id="os.EX_OK"><span class="yiyi-st" id="yiyi-1227"> <code class="descclassname">os.</code><code class="descname">EX_OK</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1228">退出代码意味着没有发生错误。</span></p><p><span class="yiyi-st" id="yiyi-1229">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_USAGE"><span class="yiyi-st" id="yiyi-1230"> <code class="descclassname">os.</code><code class="descname">EX_USAGE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1231">退出代码意味着命令被错误地使用，例如给出错误的参数数量。</span></p><p><span class="yiyi-st" id="yiyi-1232">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_DATAERR"><span class="yiyi-st" id="yiyi-1233"> <code class="descclassname">os.</code><code class="descname">EX_DATAERR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1234">退出代码意味着输入数据不正确。</span></p><p><span class="yiyi-st" id="yiyi-1235">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_NOINPUT"><span class="yiyi-st" id="yiyi-1236"> <code class="descclassname">os.</code><code class="descname">EX_NOINPUT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1237">退出代码意味着输入文件不存在或不可读。</span></p><p><span class="yiyi-st" id="yiyi-1238">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_NOUSER"><span class="yiyi-st" id="yiyi-1239"> <code class="descclassname">os.</code><code class="descname">EX_NOUSER</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1240">退出代码，意味着指定的用户不存在。</span></p><p><span class="yiyi-st" id="yiyi-1241">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_NOHOST"><span class="yiyi-st" id="yiyi-1242"> <code class="descclassname">os.</code><code class="descname">EX_NOHOST</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1243">退出代码，意味着指定的主机不存在。</span></p><p><span class="yiyi-st" id="yiyi-1244">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_UNAVAILABLE"><span class="yiyi-st" id="yiyi-1245"> <code class="descclassname">os.</code><code class="descname">EX_UNAVAILABLE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1246">退出代码，这意味着所需的服务不可用。</span></p><p><span class="yiyi-st" id="yiyi-1247">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_SOFTWARE"><span class="yiyi-st" id="yiyi-1248"> <code class="descclassname">os.</code><code class="descname">EX_SOFTWARE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1249">退出代码意味着检测到内部软件错误。</span></p><p><span class="yiyi-st" id="yiyi-1250">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_OSERR"><span class="yiyi-st" id="yiyi-1251"> <code class="descclassname">os.</code><code class="descname">EX_OSERR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1252">退出代码意味着检测到操作系统错误，例如无法分叉或创建管道。</span></p><p><span class="yiyi-st" id="yiyi-1253">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_OSFILE"><span class="yiyi-st" id="yiyi-1254"> <code class="descclassname">os.</code><code class="descname">EX_OSFILE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1255">退出代码意味着某些系统文件不存在，无法打开或出现其他类型的错误。</span></p><p><span class="yiyi-st" id="yiyi-1256">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_CANTCREAT"><span class="yiyi-st" id="yiyi-1257"> <code class="descclassname">os.</code><code class="descname">EX_CANTCREAT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1258">退出代码意味着无法创建用户指定的输出文件。</span></p><p><span class="yiyi-st" id="yiyi-1259">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_IOERR"><span class="yiyi-st" id="yiyi-1260"> <code class="descclassname">os.</code><code class="descname">EX_IOERR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1261">退出代码意味着在某个文件上执行I / O时发生错误。</span></p><p><span class="yiyi-st" id="yiyi-1262">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_TEMPFAIL"><span class="yiyi-st" id="yiyi-1263"> <code class="descclassname">os.</code><code class="descname">EX_TEMPFAIL</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1264">退出代码意味着发生了临时故障。</span><span class="yiyi-st" id="yiyi-1265">这表示可能不是真正的错误，例如在重试操作期间无法建立的网络连接。</span></p><p><span class="yiyi-st" id="yiyi-1266">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_PROTOCOL"><span class="yiyi-st" id="yiyi-1267"> <code class="descclassname">os.</code><code class="descname">EX_PROTOCOL</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1268">退出代码意味着协议交换是非法的，无效的或不被理解的。</span></p><p><span class="yiyi-st" id="yiyi-1269">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_NOPERM"><span class="yiyi-st" id="yiyi-1270"> <code class="descclassname">os.</code><code class="descname">EX_NOPERM</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1271">退出代码意味着没有足够的权限执行操作（但不适用于文件系统问题）。</span></p><p><span class="yiyi-st" id="yiyi-1272">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_CONFIG"><span class="yiyi-st" id="yiyi-1273"> <code class="descclassname">os.</code><code class="descname">EX_CONFIG</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1274">退出代码意味着发生某种配置错误。</span></p><p><span class="yiyi-st" id="yiyi-1275">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.EX_NOTFOUND"><span class="yiyi-st" id="yiyi-1276"> <code class="descclassname">os.</code><code class="descname">EX_NOTFOUND</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1277">退出代码意味着类似“未找到条目”。</span></p><p><span class="yiyi-st" id="yiyi-1278">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.fork"><span class="yiyi-st" id="yiyi-1279"> <code class="descclassname">os.</code><code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1280">叉一个孩子的过程。</span><span class="yiyi-st" id="yiyi-1281">返回子节点中的<code class="docutils literal"><span class="pre">0</span></code>以及父节点中的子进程标识。</span><span class="yiyi-st" id="yiyi-1282">如果发生错误<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-1283">请注意，从线程使用fork()时，包括FreeBSD &lt;= 6.3和Cygwin在内的一些平台已知问题。</span></p><div class="admonition warning"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1284">警告</span></p><p class="last"><span class="yiyi-st" id="yiyi-1285">对于使用带fork()的SSL模块的应用程序，请参见<a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a>。</span></p></div><p><span class="yiyi-st" id="yiyi-1286">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.forkpty"><span class="yiyi-st" id="yiyi-1287"> <code class="descclassname">os.</code><code class="descname">forkpty</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1288">用一个新的伪终端作为孩子的控制终端，把一个子进程分叉开来。</span><span class="yiyi-st" id="yiyi-1289">返回一对<code class="docutils literal"><span class="pre">（pid，</span> <span class="pre">fd）</span></code>，其中<em>pid</em>为<code class="docutils literal"><span class="pre">0</span></code>孩子，父亲中的新孩子的进程ID，以及<em>fd</em>是伪终端主端的文件描述符。</span><span class="yiyi-st" id="yiyi-1290">对于更便携的方法，请使用<a class="reference internal" href="pty.html#module-pty" title="pty: Pseudo-Terminal Handling for Linux. (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">pty</span></code></a>模块。</span><span class="yiyi-st" id="yiyi-1291">如果发生错误<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-1292">可用性：一些Unix的味道。</span></p></dd></dl><dl class="function"><dt id="os.kill"><span class="yiyi-st" id="yiyi-1293"> <code class="descclassname">os.</code><code class="descname">kill</code><span class="sig-paren">(</span><em>pid</em>, <em>sig</em><span class="sig-paren">)</span></span></dt><dd><p id="index-27"><span class="yiyi-st" id="yiyi-1294">发送信号<em>sig</em>到进程<em>pid</em>。</span><span class="yiyi-st" id="yiyi-1295">主机平台上可用的特定信号的常数在<a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal"><span class="pre">signal</span></code></a>模块中定义。</span></p><p><span class="yiyi-st" id="yiyi-1296">Windows：<a class="reference internal" href="signal.html#signal.CTRL_C_EVENT" title="signal.CTRL_C_EVENT"><code class="xref py py-data docutils literal"><span class="pre">signal.CTRL_C_EVENT</span></code></a>和<a class="reference internal" href="signal.html#signal.CTRL_BREAK_EVENT" title="signal.CTRL_BREAK_EVENT"><code class="xref py py-data docutils literal"><span class="pre">signal.CTRL_BREAK_EVENT</span></code></a>信号是特殊信号，只能发送到共享公共控制台窗口的控制台进程，例如某些子进程。</span><span class="yiyi-st" id="yiyi-1297">对于<em>sig</em>的任何其他值都将导致进程无条件地被TerminateProcess API终止，并且退出代码将被设置为<em>sig</em>。</span><span class="yiyi-st" id="yiyi-1298">Windows版本的<a class="reference internal" href="#os.kill" title="os.kill"><code class="xref py py-func docutils literal"><span class="pre">kill()</span></code></a>还需要终止进程句柄。</span></p><p><span class="yiyi-st" id="yiyi-1299">另请参阅<a class="reference internal" href="signal.html#signal.pthread_kill" title="signal.pthread_kill"><code class="xref py py-func docutils literal"><span class="pre">signal.pthread_kill()</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1300"><span class="versionmodified">3.2版中的新功能：</span> Windows支持。</span></p></div></dd></dl><dl class="function"><dt id="os.killpg"><span class="yiyi-st" id="yiyi-1301"> <code class="descclassname">os.</code><code class="descname">killpg</code><span class="sig-paren">(</span><em>pgid</em>, <em>sig</em><span class="sig-paren">)</span></span></dt><dd><p id="index-28"><span class="yiyi-st" id="yiyi-1302">Send the signal <em>sig</em> to the process group <em>pgid</em>.</span></p><p><span class="yiyi-st" id="yiyi-1303">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.nice"><span class="yiyi-st" id="yiyi-1304"> <code class="descclassname">os.</code><code class="descname">nice</code><span class="sig-paren">(</span><em>increment</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1305">将<em>increment</em>添加到进程的“niceness”中。</span><span class="yiyi-st" id="yiyi-1306">回报新的美好。</span></p><p><span class="yiyi-st" id="yiyi-1307">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.plock"><span class="yiyi-st" id="yiyi-1308"> <code class="descclassname">os.</code><code class="descname">plock</code><span class="sig-paren">(</span><em>op</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1309">将程序段锁定到内存中。</span><span class="yiyi-st" id="yiyi-1310"><em>op</em>（在<code class="docutils literal"><span class="pre">&lt;sys/lock.h&gt;</span></code>中定义）的值确定哪些段被锁定。</span></p><p><span class="yiyi-st" id="yiyi-1311">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.popen"><span class="yiyi-st" id="yiyi-1312"> <code class="descclassname">os.</code><code class="descname">popen</code><span class="sig-paren">(</span><em>cmd</em>, <em>mode='r'</em>, <em>buffering=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1313">从命令<em>cmd</em>打开管道。</span><span class="yiyi-st" id="yiyi-1314">返回值是一个连接到管道的打开文件对象，根据<em>mode</em>是否为<code class="docutils literal"><span class="pre">'r'</span></code>（默认值）或<code class="docutils literal"><span class="pre">'w'</span></code></span><span class="yiyi-st" id="yiyi-1315"><em>buffering</em>参数的含义与内置的<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>函数的相应参数相同。</span><span class="yiyi-st" id="yiyi-1316">返回的文件对象读取或写入文本字符串而不是字节。</span></p><p><span class="yiyi-st" id="yiyi-1317">如果子进程成功退出，则<code class="docutils literal"><span class="pre">close</span></code>方法返回<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>，如果发生错误，则返回子进程的返回码。</span><span class="yiyi-st" id="yiyi-1318">在POSIX系统上，如果返回码是正值，它表示进程的返回值左移一个字节。</span><span class="yiyi-st" id="yiyi-1319">如果返回码是负数，则处理过程由返回码的取反值给出的信号终止。</span><span class="yiyi-st" id="yiyi-1320">（例如，如果子进程被终止，返回值可能是<code class="docutils literal"><span class="pre"> - </span> <span class="pre">signal.SIGKILL</span></code>。）</span><span class="yiyi-st" id="yiyi-1321">在Windows系统上，返回值包含子进程的带符号整数返回码。</span></p><p><span class="yiyi-st" id="yiyi-1322">这是通过使用<a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal"><span class="pre">subprocess.Popen</span></code></a>；请参阅该类的文档以获取更多有效的方式来管理和与子流程进行通信。</span></p></dd></dl><dl class="function"><dt id="os.spawnl"><span class="yiyi-st" id="yiyi-1323"> <code class="descclassname">os.</code><code class="descname">spawnl</code><span class="sig-paren">(</span><em>mode</em>, <em>path</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dt id="os.spawnle"><span class="yiyi-st" id="yiyi-1324"> <code class="descclassname">os.</code><code class="descname">spawnle</code><span class="sig-paren">(</span><em>mode</em>, <em>path</em>, <em>...</em>, <em>env</em><span class="sig-paren">)</span></span></dt><dt id="os.spawnlp"><span class="yiyi-st" id="yiyi-1325"> <code class="descclassname">os.</code><code class="descname">spawnlp</code><span class="sig-paren">(</span><em>mode</em>, <em>file</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dt id="os.spawnlpe"><span class="yiyi-st" id="yiyi-1326"> <code class="descclassname">os.</code><code class="descname">spawnlpe</code><span class="sig-paren">(</span><em>mode</em>, <em>file</em>, <em>...</em>, <em>env</em><span class="sig-paren">)</span></span></dt><dt id="os.spawnv"><span class="yiyi-st" id="yiyi-1327"> <code class="descclassname">os.</code><code class="descname">spawnv</code><span class="sig-paren">(</span><em>mode</em>, <em>path</em>, <em>args</em><span class="sig-paren">)</span></span></dt><dt id="os.spawnve"><span class="yiyi-st" id="yiyi-1328"> <code class="descclassname">os.</code><code class="descname">spawnve</code><span class="sig-paren">(</span><em>mode</em>, <em>path</em>, <em>args</em>, <em>env</em><span class="sig-paren">)</span></span></dt><dt id="os.spawnvp"><span class="yiyi-st" id="yiyi-1329"><code class="descclassname">os.</code><code class="descname">spawnvp</code><span class="sig-paren">(</span><em>mode</em>, <em>file</em>, <em>args</em><span class="sig-paren">)</span></span></dt><dt id="os.spawnvpe"><span class="yiyi-st" id="yiyi-1330"> <code class="descclassname">os.</code><code class="descname">spawnvpe</code><span class="sig-paren">(</span><em>mode</em>, <em>file</em>, <em>args</em>, <em>env</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1331">在新进程中执行程序<em>路径</em>。</span></p><p><span class="yiyi-st" id="yiyi-1332">（请注意，<a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a>模块为产生新进程和检索结果提供了更强大的功能；使用该模块优于使用这些功能。</span><span class="yiyi-st" id="yiyi-1333">特别检查<a class="reference internal" href="subprocess.html#subprocess-replacements"><span>Replacing Older Functions with the subprocess Module</span></a>部分替换旧功能。）</span></p><p><span class="yiyi-st" id="yiyi-1334">如果<em>mode</em>是<a class="reference internal" href="#os.P_NOWAIT" title="os.P_NOWAIT"><code class="xref py py-const docutils literal"><span class="pre">P_NOWAIT</span></code></a>，则此函数返回新进程的进程ID；如果<em>mode</em>是<a class="reference internal" href="#os.P_WAIT" title="os.P_WAIT"><code class="xref py py-const docutils literal"><span class="pre">P_WAIT</span></code></a>，则返回进程的退出代码（如果它正常退出）或<code class="docutils literal"><span class="pre">-signal</span></code>，其中<em>signal</em>杀死该进程的信号。</span><span class="yiyi-st" id="yiyi-1335">在Windows上，进程ID实际上是进程句柄，因此可以与<a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>函数一起使用。</span></p><p><span class="yiyi-st" id="yiyi-1336"><a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a>函数的“l”和“v”变体在传递命令行参数方面有所不同。</span><span class="yiyi-st" id="yiyi-1337">如果在编写代码时参数的数量是固定的，则“l”变体可能是最容易使用的变体；各个参数只是成为<code class="xref py py-func docutils literal"><span class="pre">spawnl*()</span></code>函数的附加参数。</span><span class="yiyi-st" id="yiyi-1338">当参数的数量是可变的时，“v”变体是很好的，参数以列表或元组的形式作为<em>args</em>参数传递。</span><span class="yiyi-st" id="yiyi-1339">无论哪种情况，子进程的参数都必须以正在运行的命令的名称开始。</span></p><p><span class="yiyi-st" id="yiyi-1340">The variants which include a second “p” near the end (<a class="reference internal" href="#os.spawnlp" title="os.spawnlp"><code class="xref py py-func docutils literal"><span class="pre">spawnlp()</span></code></a>, <a class="reference internal" href="#os.spawnlpe" title="os.spawnlpe"><code class="xref py py-func docutils literal"><span class="pre">spawnlpe()</span></code></a>, <a class="reference internal" href="#os.spawnvp" title="os.spawnvp"><code class="xref py py-func docutils literal"><span class="pre">spawnvp()</span></code></a>, and <a class="reference internal" href="#os.spawnvpe" title="os.spawnvpe"><code class="xref py py-func docutils literal"><span class="pre">spawnvpe()</span></code></a>) will use the <span class="target" id="index-29"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> environment variable to locate the program <em>file</em>. </span><span class="yiyi-st" id="yiyi-1341">当环境被替换时（使用下一段讨论的<a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*e</span></code></a>变体之一），新环境被用作<span class="target" id="index-30"></span> <code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code>变量。</span><span class="yiyi-st" id="yiyi-1342">The other variants, <a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawnl()</span></code></a>, <a class="reference internal" href="#os.spawnle" title="os.spawnle"><code class="xref py py-func docutils literal"><span class="pre">spawnle()</span></code></a>, <a class="reference internal" href="#os.spawnv" title="os.spawnv"><code class="xref py py-func docutils literal"><span class="pre">spawnv()</span></code></a>, and <a class="reference internal" href="#os.spawnve" title="os.spawnve"><code class="xref py py-func docutils literal"><span class="pre">spawnve()</span></code></a>, will not use the <span class="target" id="index-31"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> variable to locate the executable; <em>path</em> must contain an appropriate absolute or relative path.</span></p><p><span class="yiyi-st" id="yiyi-1343">For <a class="reference internal" href="#os.spawnle" title="os.spawnle"><code class="xref py py-func docutils literal"><span class="pre">spawnle()</span></code></a>, <a class="reference internal" href="#os.spawnlpe" title="os.spawnlpe"><code class="xref py py-func docutils literal"><span class="pre">spawnlpe()</span></code></a>, <a class="reference internal" href="#os.spawnve" title="os.spawnve"><code class="xref py py-func docutils literal"><span class="pre">spawnve()</span></code></a>, and <a class="reference internal" href="#os.spawnvpe" title="os.spawnvpe"><code class="xref py py-func docutils literal"><span class="pre">spawnvpe()</span></code></a> (note that these all end in “e”), the <em>env</em> parameter must be a mapping which is used to define the environment variables for the new process (they are used instead of the current process’ environment); the functions <a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawnl()</span></code></a>, <a class="reference internal" href="#os.spawnlp" title="os.spawnlp"><code class="xref py py-func docutils literal"><span class="pre">spawnlp()</span></code></a>, <a class="reference internal" href="#os.spawnv" title="os.spawnv"><code class="xref py py-func docutils literal"><span class="pre">spawnv()</span></code></a>, and <a class="reference internal" href="#os.spawnvp" title="os.spawnvp"><code class="xref py py-func docutils literal"><span class="pre">spawnvp()</span></code></a> all cause the new process to inherit the environment of the current process. </span><span class="yiyi-st" id="yiyi-1344">请注意，<em>env</em>字典中的键和值必须是字符串；无效的键或值将导致函数失败，返回值为<code class="docutils literal"><span class="pre">127</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1345">例如，以下对<a class="reference internal" href="#os.spawnlp" title="os.spawnlp"><code class="xref py py-func docutils literal"><span class="pre">spawnlp()</span></code></a>和<a class="reference internal" href="#os.spawnvpe" title="os.spawnvpe"><code class="xref py py-func docutils literal"><span class="pre">spawnvpe()</span></code></a>的调用是等效的：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">spawnlp</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">P_WAIT</span><span class="p">,</span> <span class="s1">'cp'</span><span class="p">,</span> <span class="s1">'cp'</span><span class="p">,</span> <span class="s1">'index.html'</span><span class="p">,</span> <span class="s1">'/dev/null'</span><span class="p">)</span>

<span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'cp'</span><span class="p">,</span> <span class="s1">'index.html'</span><span class="p">,</span> <span class="s1">'/dev/null'</span><span class="p">]</span>
<span class="n">os</span><span class="o">.</span><span class="n">spawnvpe</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">P_WAIT</span><span class="p">,</span> <span class="s1">'cp'</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1346">可用性：Unix，Windows。</span><span class="yiyi-st" id="yiyi-1347"><a class="reference internal" href="#os.spawnlp" title="os.spawnlp"><code class="xref py py-func docutils literal"><span class="pre">spawnlp()</span></code></a>, <a class="reference internal" href="#os.spawnlpe" title="os.spawnlpe"><code class="xref py py-func docutils literal"><span class="pre">spawnlpe()</span></code></a>, <a class="reference internal" href="#os.spawnvp" title="os.spawnvp"><code class="xref py py-func docutils literal"><span class="pre">spawnvp()</span></code></a> and <a class="reference internal" href="#os.spawnvpe" title="os.spawnvpe"><code class="xref py py-func docutils literal"><span class="pre">spawnvpe()</span></code></a> are not available on Windows. </span><span class="yiyi-st" id="yiyi-1348"><a class="reference internal" href="#os.spawnle" title="os.spawnle"><code class="xref py py-func docutils literal"><span class="pre">spawnle()</span></code></a> and <a class="reference internal" href="#os.spawnve" title="os.spawnve"><code class="xref py py-func docutils literal"><span class="pre">spawnve()</span></code></a> are not thread-safe on Windows; we advise you to use the <a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> module instead.</span></p></dd></dl><dl class="data"><dt id="os.P_NOWAIT"><span class="yiyi-st" id="yiyi-1349"> <code class="descclassname">os.</code><code class="descname">P_NOWAIT</code></span></dt><dt id="os.P_NOWAITO"><span class="yiyi-st" id="yiyi-1350"> <code class="descclassname">os.</code><code class="descname">P_NOWAITO</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1351"><a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a>系列函数的<em>mode</em>参数的可能值。</span><span class="yiyi-st" id="yiyi-1352">如果给出了这两个值中的任何一个，那么一旦创建新进程，<code class="xref py py-func docutils literal"><span class="pre">spawn*()</span></code>函数将返回，进程ID将作为返回值。</span></p><p><span class="yiyi-st" id="yiyi-1353">可用性：Unix，Windows。</span></p></dd></dl><dl class="data"><dt id="os.P_WAIT"><span class="yiyi-st" id="yiyi-1354"> <code class="descclassname">os.</code><code class="descname">P_WAIT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1355"><a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a>系列函数的<em>模式</em>参数的可能值。</span><span class="yiyi-st" id="yiyi-1356">如果这是以<em>mode</em>的形式给出的，那么<code class="xref py py-func docutils literal"><span class="pre">spawn*()</span></code>函数将不会返回，直到新进程运行完成并返回进程的退出代码成功或<code class="docutils literal"><span class="pre">-signal</span></code>，如果信号杀死进程。</span></p><p><span class="yiyi-st" id="yiyi-1357">可用性：Unix，Windows。</span></p></dd></dl><dl class="data"><dt id="os.P_DETACH"><span class="yiyi-st" id="yiyi-1358"> <code class="descclassname">os.</code><code class="descname">P_DETACH</code></span></dt><dt id="os.P_OVERLAY"><span class="yiyi-st" id="yiyi-1359"> <code class="descclassname">os.</code><code class="descname">P_OVERLAY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1360"><a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a>系列函数的<em>mode</em>参数的可能值。</span><span class="yiyi-st" id="yiyi-1361">这些便携式比上面列出的便携式更少。</span><span class="yiyi-st" id="yiyi-1362"><a class="reference internal" href="#os.P_DETACH" title="os.P_DETACH"><code class="xref py py-const docutils literal"><span class="pre">P_DETACH</span></code></a>类似于<a class="reference internal" href="#os.P_NOWAIT" title="os.P_NOWAIT"><code class="xref py py-const docutils literal"><span class="pre">P_NOWAIT</span></code></a>，但新进程从调用进程的控制台分离。</span><span class="yiyi-st" id="yiyi-1363">如果使用<a class="reference internal" href="#os.P_OVERLAY" title="os.P_OVERLAY"><code class="xref py py-const docutils literal"><span class="pre">P_OVERLAY</span></code></a>，则当前进程将被替换； <a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a>函数不会返回。</span></p><p><span class="yiyi-st" id="yiyi-1364">可用性：Windows。</span></p></dd></dl><dl class="function"><dt id="os.startfile"><span class="yiyi-st" id="yiyi-1365"> <code class="descclassname">os.</code><code class="descname">startfile</code><span class="sig-paren">(</span><em>path</em><span class="optional">[</span>, <em>operation</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1366">用相关的应用程序启动一个文件。</span></p><p><span class="yiyi-st" id="yiyi-1367">当没有指定<em>操作</em>或<code class="docutils literal"><span class="pre">'open'</span></code>时，这就像在Windows资源管理器中双击文件或将文件名作为参数指向<strong class="program">start </strong>来自交互式命令shell的命令：该文件与其扩展关联的任何应用程序（如果有的话）打开。</span></p><p><span class="yiyi-st" id="yiyi-1368">当给出另一个<em>操作</em>时，它必须是一个“命令动词”，指定应该对文件执行什么操作。</span><span class="yiyi-st" id="yiyi-1369">Microsoft记录的常见动词是<code class="docutils literal"><span class="pre">'print'</span></code>和<code class="docutils literal"><span class="pre">'edit'</span></code>（用于文件）以及<code class="docutils literal"><span class="pre">'explore'</span></code>和<code class="docutils literal"><span class="pre">'find'</span></code>（用于目录）。</span></p><p><span class="yiyi-st" id="yiyi-1370"><a class="reference internal" href="#os.startfile" title="os.startfile"><code class="xref py py-func docutils literal"><span class="pre">startfile()</span></code></a> returns as soon as the associated application is launched. </span><span class="yiyi-st" id="yiyi-1371">没有选项可以等待应用程序关闭，也无法检索应用程序的退出状态。</span><span class="yiyi-st" id="yiyi-1372"><em>路径</em>参数相对于当前目录。</span><span class="yiyi-st" id="yiyi-1373">如果你想使用绝对路径，确保第一个字符不是斜线（<code class="docutils literal"><span class="pre">'/'</span></code>）；底层Win32 <code class="xref c c-func docutils literal"><span class="pre">ShellExecute()</span></code>函数不起作用。</span><span class="yiyi-st" id="yiyi-1374">使用<a class="reference internal" href="os.path.html#os.path.normpath" title="os.path.normpath"><code class="xref py py-func docutils literal"><span class="pre">os.path.normpath()</span></code></a>函数确保路径为Win32正确编码。</span></p><p><span class="yiyi-st" id="yiyi-1375">为了减少解释器启动开销，Win32 <code class="xref c c-func docutils literal"><span class="pre">ShellExecute()</span></code>函数在第一次调用该函数之前不会被解析。</span><span class="yiyi-st" id="yiyi-1376">如果函数无法解析，则会引发<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-1377">可用性：Windows。</span></p></dd></dl><dl class="function"><dt id="os.system"><span class="yiyi-st" id="yiyi-1378"> <code class="descclassname">os.</code><code class="descname">system</code><span class="sig-paren">(</span><em>command</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1379">在子shell中执行命令（一个字符串）。</span><span class="yiyi-st" id="yiyi-1380">这是通过调用标准C函数<code class="xref c c-func docutils literal"><span class="pre">system()</span></code>来实现的，并且具有相同的限制。</span><span class="yiyi-st" id="yiyi-1381">对<a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal"><span class="pre">sys.stdin</span></code></a>等的更改</span><span class="yiyi-st" id="yiyi-1382">不会反映在执行命令的环境中。</span><span class="yiyi-st" id="yiyi-1383">如果<em>命令</em>产生任何输出，它将被发送到解释器标准输出流。</span></p><p><span class="yiyi-st" id="yiyi-1384">在Unix上，返回值是以<a class="reference internal" href="#os.wait" title="os.wait"><code class="xref py py-func docutils literal"><span class="pre">wait()</span></code></a>指定的格式编码的进程的退出状态。</span><span class="yiyi-st" id="yiyi-1385">请注意，POSIX没有指定C <code class="xref c c-func docutils literal"><span class="pre">system()</span></code>函数的返回值的含义，所以Python函数的返回值是依赖于系统的。</span></p><p><span class="yiyi-st" id="yiyi-1386">在Windows上，返回值是运行<em>命令</em>后由系统shell返回的值。</span><span class="yiyi-st" id="yiyi-1387">该shell由Windows环境变量<span class="target" id="index-32"></span> <code class="xref std std-envvar docutils literal"><span class="pre">COMSPEC</span></code>给出：它通常是<strong class="program">cmd.exe</strong>，它返回命令run的退出状态；在使用非本地shell的系统上，请查阅您的shell文档。</span></p><p><span class="yiyi-st" id="yiyi-1388"><a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a>模块为产生新流程和检索结果提供了更强大的功能；使用该模块优于使用此功能。</span><span class="yiyi-st" id="yiyi-1389">请参阅<a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a>文档中<a class="reference internal" href="subprocess.html#subprocess-replacements"><span>Replacing Older Functions with the subprocess Module</span></a>部分替换旧功能以获取一些有用的配方。</span></p><p><span class="yiyi-st" id="yiyi-1390">可用性：Unix，Windows。</span></p></dd></dl><dl class="function"><dt id="os.times"><span class="yiyi-st" id="yiyi-1391"> <code class="descclassname">os.</code><code class="descname">times</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1392">返回当前的全局流程时间。</span><span class="yiyi-st" id="yiyi-1393">返回值是一个具有五个属性的对象：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-1394"><code class="xref py py-attr docutils literal"><span class="pre">user</span></code>  - 用户时间</span></li><li><span class="yiyi-st" id="yiyi-1395"><a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-attr docutils literal"><span class="pre">system</span></code></a>  - 系统时间</span></li><li><span class="yiyi-st" id="yiyi-1396"><code class="xref py py-attr docutils literal"><span class="pre">children_user</span></code>  - 所有子进程的用户时间</span></li><li><span class="yiyi-st" id="yiyi-1397"><code class="xref py py-attr docutils literal"><span class="pre">children_system</span></code>  - 所有子进程的系统时间</span></li><li><span class="yiyi-st" id="yiyi-1398"><code class="xref py py-attr docutils literal"><span class="pre">elapsed</span></code>  - 自过去的固定点开始经过的实时时间</span></li></ul><p><span class="yiyi-st" id="yiyi-1399">为了向后兼容，这个对象的行为就像一个包含<code class="xref py py-attr docutils literal"><span class="pre">user</span></code>，<a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-attr docutils literal"><span class="pre">system</span></code></a>，<code class="xref py py-attr docutils literal"><span class="pre">children_user</span></code>，<code class="xref py py-attr docutils literal"><span class="pre">children_system</span></code>的五元组，和<code class="xref py py-attr docutils literal"><span class="pre">elapsed</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1400">请参阅Unix手册页<em class="manpage">次（2）</em>或相应的Windows平台API文档。</span><span class="yiyi-st" id="yiyi-1401">在Windows上，只有<code class="xref py py-attr docutils literal"><span class="pre">user</span></code>和<a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-attr docutils literal"><span class="pre">system</span></code></a>是已知的；其他属性为零。</span></p><p><span class="yiyi-st" id="yiyi-1402">可用性：Unix，Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1403"><span class="versionmodified">在版本3.3中改变：</span>返回类型从一个元组改变为一个具有命名属性的元组对象。</span></p></div></dd></dl><dl class="function"><dt id="os.wait"><span class="yiyi-st" id="yiyi-1404"> <code class="descclassname">os.</code><code class="descname">wait</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1405">等待子进程完成，并返回一个包含它的pid和退出状态指示的元组：一个16位数字，其低字节是杀死进程的信号编号，其高字节是退出状态（如果信号数字为零）；如果生成核心文件，则设置低字节的高位。</span></p><p><span class="yiyi-st" id="yiyi-1406">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.waitid"><span class="yiyi-st" id="yiyi-1407"> <code class="descclassname">os.</code><code class="descname">waitid</code><span class="sig-paren">(</span><em>idtype</em>, <em>id</em>, <em>options</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1408">等待一个或多个子进程的完成。</span><span class="yiyi-st" id="yiyi-1409"><em>idtype</em>可以是<a class="reference internal" href="#os.P_PID" title="os.P_PID"><code class="xref py py-data docutils literal"><span class="pre">P_PID</span></code></a>，<a class="reference internal" href="#os.P_PGID" title="os.P_PGID"><code class="xref py py-data docutils literal"><span class="pre">P_PGID</span></code></a>或<a class="reference internal" href="#os.P_ALL" title="os.P_ALL"><code class="xref py py-data docutils literal"><span class="pre">P_ALL</span></code></a>。</span><span class="yiyi-st" id="yiyi-1410"><em>id</em>指定要等待的pid。</span><span class="yiyi-st" id="yiyi-1411"><em>options</em> is constructed from the ORing of one or more of <a class="reference internal" href="#os.WEXITED" title="os.WEXITED"><code class="xref py py-data docutils literal"><span class="pre">WEXITED</span></code></a>, <a class="reference internal" href="#os.WSTOPPED" title="os.WSTOPPED"><code class="xref py py-data docutils literal"><span class="pre">WSTOPPED</span></code></a> or <a class="reference internal" href="#os.WCONTINUED" title="os.WCONTINUED"><code class="xref py py-data docutils literal"><span class="pre">WCONTINUED</span></code></a> and additionally may be ORed with <a class="reference internal" href="#os.WNOHANG" title="os.WNOHANG"><code class="xref py py-data docutils literal"><span class="pre">WNOHANG</span></code></a> or <a class="reference internal" href="#os.WNOWAIT" title="os.WNOWAIT"><code class="xref py py-data docutils literal"><span class="pre">WNOWAIT</span></code></a>. </span><span class="yiyi-st" id="yiyi-1412">The return value is an object representing the data contained in the <code class="xref c c-type docutils literal"><span class="pre">siginfo_t</span></code> structure, namely: <code class="xref py py-attr docutils literal"><span class="pre">si_pid</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">si_uid</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">si_signo</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">si_status</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">si_code</span></code> or <code class="docutils literal"><span class="pre">None</span></code> if <a class="reference internal" href="#os.WNOHANG" title="os.WNOHANG"><code class="xref py py-data docutils literal"><span class="pre">WNOHANG</span></code></a> is specified and there are no children in a waitable state.</span></p><p><span class="yiyi-st" id="yiyi-1413">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1414"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="os.P_PID"><span class="yiyi-st" id="yiyi-1415"> <code class="descclassname">os.</code><code class="descname">P_PID</code></span></dt><dt id="os.P_PGID"><span class="yiyi-st" id="yiyi-1416"> <code class="descclassname">os.</code><code class="descname">P_PGID</code></span></dt><dt id="os.P_ALL"><span class="yiyi-st" id="yiyi-1417"> <code class="descclassname">os.</code><code class="descname">P_ALL</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1418">这些是<a class="reference internal" href="#os.waitid" title="os.waitid"><code class="xref py py-func docutils literal"><span class="pre">waitid()</span></code></a>中<em>idtype</em>的可能值。</span><span class="yiyi-st" id="yiyi-1419">它们影响如何解释<em>id</em>。</span></p><p><span class="yiyi-st" id="yiyi-1420">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1421"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="os.WEXITED"><span class="yiyi-st" id="yiyi-1422"> <code class="descclassname">os.</code><code class="descname">WEXITED</code></span></dt><dt id="os.WSTOPPED"><span class="yiyi-st" id="yiyi-1423"> <code class="descclassname">os.</code><code class="descname">WSTOPPED</code></span></dt><dt id="os.WNOWAIT"><span class="yiyi-st" id="yiyi-1424"> <code class="descclassname">os.</code><code class="descname">WNOWAIT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1425">可以在<a class="reference internal" href="#os.waitid" title="os.waitid"><code class="xref py py-func docutils literal"><span class="pre">waitid()</span></code></a>的<em>options</em>中使用的标志指定要等待的子信号。</span></p><p><span class="yiyi-st" id="yiyi-1426">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1427"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="os.CLD_EXITED"><span class="yiyi-st" id="yiyi-1428"> <code class="descclassname">os.</code><code class="descname">CLD_EXITED</code></span></dt><dt id="os.CLD_DUMPED"><span class="yiyi-st" id="yiyi-1429"> <code class="descclassname">os.</code><code class="descname">CLD_DUMPED</code></span></dt><dt id="os.CLD_TRAPPED"><span class="yiyi-st" id="yiyi-1430"> <code class="descclassname">os.</code><code class="descname">CLD_TRAPPED</code></span></dt><dt id="os.CLD_CONTINUED"><span class="yiyi-st" id="yiyi-1431"> <code class="descclassname">os.</code><code class="descname">CLD_CONTINUED</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1432">这些是由<a class="reference internal" href="#os.waitid" title="os.waitid"><code class="xref py py-func docutils literal"><span class="pre">waitid()</span></code></a>返回的结果中<code class="xref py py-attr docutils literal"><span class="pre">si_code</span></code>的可能值。</span></p><p><span class="yiyi-st" id="yiyi-1433">可用性：UNIX。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1434"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.waitpid"><span class="yiyi-st" id="yiyi-1435"> <code class="descclassname">os.</code><code class="descname">waitpid</code><span class="sig-paren">(</span><em>pid</em>, <em>options</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1436">这个功能的细节在Unix和Windows上有所不同。</span></p><p><span class="yiyi-st" id="yiyi-1437">在Unix上：等待进程id <em>pid</em>给出的子进程的完成，然后返回一个包含进程ID和退出状态指示（编码为<a class="reference internal" href="#os.wait" title="os.wait"><code class="xref py py-func docutils literal"><span class="pre">wait()</span></code></a>）的元组。 。</span><span class="yiyi-st" id="yiyi-1438">调用的语义受整数<em>options</em>的值影响，对于正常操作，该值应<code class="docutils literal"><span class="pre">0</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1439">如果<em>pid</em>大于<code class="docutils literal"><span class="pre">0</span></code>，则<a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>请求该特定进程的状态信息。</span><span class="yiyi-st" id="yiyi-1440">如果<em>pid</em>为<code class="docutils literal"><span class="pre">0</span></code>，则该请求用于当前进程的进程组中任何子进程的状态。</span><span class="yiyi-st" id="yiyi-1441">如果<em>pid</em>为<code class="docutils literal"><span class="pre">-1</span></code>，则请求与当前进程的任何子进程有关。</span><span class="yiyi-st" id="yiyi-1442">如果<em>pid</em>小于<code class="docutils literal"><span class="pre">-1</span></code>，则进程组<code class="docutils literal"><span class="pre">-pid</span></code>中的任何进程都请求状态（<em>pid的绝对值 T5&gt;）。</em></span></p><p><span class="yiyi-st" id="yiyi-1443">An <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> is raised with the value of errno when the syscall returns -1.</span></p><p><span class="yiyi-st" id="yiyi-1444">在Windows上：等待进程句柄<em>pid</em>给出的进程完成并返回一个包含<em>pid</em>的元组，并且其退出状态左移8位平台使用的功能更简单）。</span><span class="yiyi-st" id="yiyi-1445">小于或等于<code class="docutils literal"><span class="pre">0</span></code>的<em>pid</em>在Windows上没有特殊含义，并引发异常。</span><span class="yiyi-st" id="yiyi-1446">整数<em>选项</em>的值不起作用。</span><span class="yiyi-st" id="yiyi-1447"><em>pid</em>可以指任何已知id的进程，不一定是子进程。</span><span class="yiyi-st" id="yiyi-1448">用<a class="reference internal" href="#os.P_NOWAIT" title="os.P_NOWAIT"><code class="xref py py-const docutils literal"><span class="pre">P_NOWAIT</span></code></a>调用的<a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a>函数返回合适的进程句柄。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1449"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-33"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div></dd></dl><dl class="function"><dt id="os.wait3"><span class="yiyi-st" id="yiyi-1450"> <code class="descclassname">os.</code><code class="descname">wait3</code><span class="sig-paren">(</span><em>options</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1451">类似于<a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>，除了没有给出进程ID参数并且返回包含子进程ID，退出状态指示和资源使用信息的3元素元组。</span><span class="yiyi-st" id="yiyi-1452">有关资源使用情况的详细信息，请参阅<a class="reference internal" href="resource.html#module-resource" title="resource: An interface to provide resource usage information on the current process. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">resource</span></code></a>。<a class="reference internal" href="resource.html#resource.getrusage" title="resource.getrusage"><code class="xref py py-func docutils literal"><span class="pre">getrusage()</span></code></a>。</span><span class="yiyi-st" id="yiyi-1453">option参数与提供给<a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>和<a class="reference internal" href="#os.wait4" title="os.wait4"><code class="xref py py-func docutils literal"><span class="pre">wait4()</span></code></a>的参数相同。</span></p><p><span class="yiyi-st" id="yiyi-1454">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.wait4"><span class="yiyi-st" id="yiyi-1455"> <code class="descclassname">os.</code><code class="descname">wait4</code><span class="sig-paren">(</span><em>pid</em>, <em>options</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1456">类似于<a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>，除了包含子进程ID，退出状态指示和资源使用信息的3元素元组之外，它被返回。</span><span class="yiyi-st" id="yiyi-1457">有关资源使用情况的详细信息，请参阅<a class="reference internal" href="resource.html#module-resource" title="resource: An interface to provide resource usage information on the current process. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">resource</span></code></a>。<a class="reference internal" href="resource.html#resource.getrusage" title="resource.getrusage"><code class="xref py py-func docutils literal"><span class="pre">getrusage()</span></code></a>。</span><span class="yiyi-st" id="yiyi-1458"><a class="reference internal" href="#os.wait4" title="os.wait4"><code class="xref py py-func docutils literal"><span class="pre">wait4()</span></code></a>的参数与提供给<a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>的参数相同。</span></p><p><span class="yiyi-st" id="yiyi-1459">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.WNOHANG"><span class="yiyi-st" id="yiyi-1460"> <code class="descclassname">os.</code><code class="descname">WNOHANG</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1461">如果没有子进程状态立即可用，<a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>选项立即返回。</span><span class="yiyi-st" id="yiyi-1462">在这种情况下，函数返回<code class="docutils literal"><span class="pre">（0，</span> <span class="pre">0）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1463">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.WCONTINUED"><span class="yiyi-st" id="yiyi-1464"> <code class="descclassname">os.</code><code class="descname">WCONTINUED</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1465">此选项会导致子进程在自上次报告状态后已从作业控制停止继续进行报告。</span></p><p><span class="yiyi-st" id="yiyi-1466">可用性：一些Unix系统。</span></p></dd></dl><dl class="data"><dt id="os.WUNTRACED"><span class="yiyi-st" id="yiyi-1467"> <code class="descclassname">os.</code><code class="descname">WUNTRACED</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1468">这个选项会导致子进程被报告，如果它们已经被停止，但是它们的当前状态自停止以来还没有被报告。</span></p><p><span class="yiyi-st" id="yiyi-1469">可用性：UNIX。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-1470">以下函数将<a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-func docutils literal"><span class="pre">system()</span></code></a>，<a class="reference internal" href="#os.wait" title="os.wait"><code class="xref py py-func docutils literal"><span class="pre">wait()</span></code></a>或<a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>作为参数返回的进程状态码。</span><span class="yiyi-st" id="yiyi-1471">他们可能被用来确定一个过程的处置。</span></p><dl class="function"><dt id="os.WCOREDUMP"><span class="yiyi-st" id="yiyi-1472"> <code class="descclassname">os.</code><code class="descname">WCOREDUMP</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1473">如果为进程生成核心转储，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1474">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.WIFCONTINUED"><span class="yiyi-st" id="yiyi-1475"> <code class="descclassname">os.</code><code class="descname">WIFCONTINUED</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1476">如果进程从作业控制停止继续，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1477">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.WIFSTOPPED"><span class="yiyi-st" id="yiyi-1478"> <code class="descclassname">os.</code><code class="descname">WIFSTOPPED</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1479">如果进程已停止，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1480">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.WIFSIGNALED"><span class="yiyi-st" id="yiyi-1481"> <code class="descclassname">os.</code><code class="descname">WIFSIGNALED</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1482">如果进程由于信号而退出，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1483">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.WIFEXITED"><span class="yiyi-st" id="yiyi-1484"> <code class="descclassname">os.</code><code class="descname">WIFEXITED</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1485">如果进程使用<em class="manpage">exit（2）</em>系统调用退出，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1486">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.WEXITSTATUS"><span class="yiyi-st" id="yiyi-1487"> <code class="descclassname">os.</code><code class="descname">WEXITSTATUS</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1488">如果<code class="docutils literal"><span class="pre">WIFEXITED(status)</span></code>为true，则返回整型参数到<em class="manpage">exit（2）</em>系统调用。</span><span class="yiyi-st" id="yiyi-1489">否则，返回值是没有意义的。</span></p><p><span class="yiyi-st" id="yiyi-1490">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.WSTOPSIG"><span class="yiyi-st" id="yiyi-1491"> <code class="descclassname">os.</code><code class="descname">WSTOPSIG</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1492">返回导致进程停止的信号。</span></p><p><span class="yiyi-st" id="yiyi-1493">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.WTERMSIG"><span class="yiyi-st" id="yiyi-1494"> <code class="descclassname">os.</code><code class="descname">WTERMSIG</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1495">返回导致进程退出的信号。</span></p><p><span class="yiyi-st" id="yiyi-1496">可用性：UNIX。</span></p></dd></dl></div><div class="section" id="interface-to-the-scheduler"><h2><span class="yiyi-st" id="yiyi-1497">16.1.7. </span><span class="yiyi-st" id="yiyi-1498">调度程序的接口</span></h2><p><span class="yiyi-st" id="yiyi-1499">这些功能控制操作系统如何为进程分配CPU时间。</span><span class="yiyi-st" id="yiyi-1500">它们仅在某些Unix平台上可用。</span><span class="yiyi-st" id="yiyi-1501">有关更多详细信息，请参阅您的Unix手册页。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1502"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><p><span class="yiyi-st" id="yiyi-1503">如果操作系统支持以下调度策略，则会公开它们。</span></p><dl class="data"><dt id="os.SCHED_OTHER"><span class="yiyi-st" id="yiyi-1504"> <code class="descclassname">os.</code><code class="descname">SCHED_OTHER</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1505">默认调度策略。</span></p></dd></dl><dl class="data"><dt id="os.SCHED_BATCH"><span class="yiyi-st" id="yiyi-1506"> <code class="descclassname">os.</code><code class="descname">SCHED_BATCH</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1507">为尝试保留计算机其余部分的交互性的CPU密集型进程调度策略。</span></p></dd></dl><dl class="data"><dt id="os.SCHED_IDLE"><span class="yiyi-st" id="yiyi-1508"> <code class="descclassname">os.</code><code class="descname">SCHED_IDLE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1509">为极低优先级的后台任务调度策略。</span></p></dd></dl><dl class="data"><dt id="os.SCHED_SPORADIC"><span class="yiyi-st" id="yiyi-1510"> <code class="descclassname">os.</code><code class="descname">SCHED_SPORADIC</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1511">针对零星服务器程序的调度策略。</span></p></dd></dl><dl class="data"><dt id="os.SCHED_FIFO"><span class="yiyi-st" id="yiyi-1512"> <code class="descclassname">os.</code><code class="descname">SCHED_FIFO</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1513">先进先出调度策略。</span></p></dd></dl><dl class="data"><dt id="os.SCHED_RR"><span class="yiyi-st" id="yiyi-1514"> <code class="descclassname">os.</code><code class="descname">SCHED_RR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1515">循环调度策略。</span></p></dd></dl><dl class="data"><dt id="os.SCHED_RESET_ON_FORK"><span class="yiyi-st" id="yiyi-1516"> <code class="descclassname">os.</code><code class="descname">SCHED_RESET_ON_FORK</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1517">该标志可以与任何其他调度策略进行或运算。</span><span class="yiyi-st" id="yiyi-1518">当具有此标志的进程设置分支时，其子进程的调度策略和优先级将重置为默认值。</span></p></dd></dl><dl class="class"><dt id="os.sched_param"><span class="yiyi-st" id="yiyi-1519"> <em class="property">class </em><code class="descclassname">os.</code><code class="descname">sched_param</code><span class="sig-paren">(</span><em>sched_priority</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1520">该类表示在<a class="reference internal" href="#os.sched_setparam" title="os.sched_setparam"><code class="xref py py-func docutils literal"><span class="pre">sched_setparam()</span></code></a>，<a class="reference internal" href="#os.sched_setscheduler" title="os.sched_setscheduler"><code class="xref py py-func docutils literal"><span class="pre">sched_setscheduler()</span></code></a>和<a class="reference internal" href="#os.sched_getparam" title="os.sched_getparam"><code class="xref py py-func docutils literal"><span class="pre">sched_getparam()</span></code></a>中使用的可调参数。</span><span class="yiyi-st" id="yiyi-1521">它是不可变的。</span></p><p><span class="yiyi-st" id="yiyi-1522">目前，只有一个可能的参数：</span></p><dl class="attribute"><dt id="os.sched_param.sched_priority"><span class="yiyi-st" id="yiyi-1523"> <code class="descname">sched_priority</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1524">调度策略的调度优先级。</span></p></dd></dl></dd></dl><dl class="function"><dt id="os.sched_get_priority_min"><span class="yiyi-st" id="yiyi-1525"> <code class="descclassname">os.</code><code class="descname">sched_get_priority_min</code><span class="sig-paren">(</span><em>policy</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1526">获取<em>策略</em>的最低优先级值。</span><span class="yiyi-st" id="yiyi-1527"><em>policy</em>是以上调度策略常量之一。</span></p></dd></dl><dl class="function"><dt id="os.sched_get_priority_max"><span class="yiyi-st" id="yiyi-1528"> <code class="descclassname">os.</code><code class="descname">sched_get_priority_max</code><span class="sig-paren">(</span><em>policy</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1529">获取<em>策略</em>的最大优先级值。</span><span class="yiyi-st" id="yiyi-1530"><em>policy</em>是以上调度策略常量之一。</span></p></dd></dl><dl class="function"><dt id="os.sched_setscheduler"><span class="yiyi-st" id="yiyi-1531"> <code class="descclassname">os.</code><code class="descname">sched_setscheduler</code><span class="sig-paren">(</span><em>pid</em>, <em>policy</em>, <em>param</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1532">使用PID <em>pid</em>设置进程的调度策略。</span><span class="yiyi-st" id="yiyi-1533">A <em>pid</em> of 0 means the calling process. </span><span class="yiyi-st" id="yiyi-1534"><em>policy</em>是以上调度策略常量之一。</span><span class="yiyi-st" id="yiyi-1535"><em>param</em>是一个<a class="reference internal" href="#os.sched_param" title="os.sched_param"><code class="xref py py-class docutils literal"><span class="pre">sched_param</span></code></a>实例。</span></p></dd></dl><dl class="function"><dt id="os.sched_getscheduler"><span class="yiyi-st" id="yiyi-1536"> <code class="descclassname">os.</code><code class="descname">sched_getscheduler</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1537">用PID <em>pid</em>返回进程的调度策略。</span><span class="yiyi-st" id="yiyi-1538">A <em>pid</em> of 0 means the calling process. </span><span class="yiyi-st" id="yiyi-1539">结果是上面的一个调度策略常量。</span></p></dd></dl><dl class="function"><dt id="os.sched_setparam"><span class="yiyi-st" id="yiyi-1540"> <code class="descclassname">os.</code><code class="descname">sched_setparam</code><span class="sig-paren">(</span><em>pid</em>, <em>param</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1541">使用PID <em>pid</em>为进程设置调度参数。</span><span class="yiyi-st" id="yiyi-1542">A <em>pid</em> of 0 means the calling process. </span><span class="yiyi-st" id="yiyi-1543"><em>param</em>是一个<a class="reference internal" href="#os.sched_param" title="os.sched_param"><code class="xref py py-class docutils literal"><span class="pre">sched_param</span></code></a>实例。</span></p></dd></dl><dl class="function"><dt id="os.sched_getparam"><span class="yiyi-st" id="yiyi-1544"> <code class="descclassname">os.</code><code class="descname">sched_getparam</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1545">将具有PID <em>pid</em>的进程的调度参数作为<a class="reference internal" href="#os.sched_param" title="os.sched_param"><code class="xref py py-class docutils literal"><span class="pre">sched_param</span></code></a>实例返回。</span><span class="yiyi-st" id="yiyi-1546">A <em>pid</em> of 0 means the calling process.</span></p></dd></dl><dl class="function"><dt id="os.sched_rr_get_interval"><span class="yiyi-st" id="yiyi-1547"> <code class="descclassname">os.</code><code class="descname">sched_rr_get_interval</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1548">用PID <em>pid</em>返回循环过程的秒数。</span><span class="yiyi-st" id="yiyi-1549">A <em>pid</em> of 0 means the calling process.</span></p></dd></dl><dl class="function"><dt id="os.sched_yield"><span class="yiyi-st" id="yiyi-1550"> <code class="descclassname">os.</code><code class="descname">sched_yield</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1551">自愿放弃CPU。</span></p></dd></dl><dl class="function"><dt id="os.sched_setaffinity"><span class="yiyi-st" id="yiyi-1552"> <code class="descclassname">os.</code><code class="descname">sched_setaffinity</code><span class="sig-paren">(</span><em>pid</em>, <em>mask</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1553">用PID <em>pid</em>（或当前进程，如果为零）限制进程到一组CPU。</span><span class="yiyi-st" id="yiyi-1554"><em>掩码</em>是一个整数的迭代表示应该限制进程的CPU集合。</span></p></dd></dl><dl class="function"><dt id="os.sched_getaffinity"><span class="yiyi-st" id="yiyi-1555"> <code class="descclassname">os.</code><code class="descname">sched_getaffinity</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1556">返回具有PID <em>pid</em>（或当前过程，如果为零）的过程的CPU集合限制为。</span></p></dd></dl></div><div class="section" id="miscellaneous-system-information"><h2><span class="yiyi-st" id="yiyi-1557">16.1.8. </span><span class="yiyi-st" id="yiyi-1558">其他系统信息</span></h2><dl class="function"><dt id="os.confstr"><span class="yiyi-st" id="yiyi-1559"> <code class="descclassname">os.</code><code class="descname">confstr</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1560">返回字符串值的系统配置值。</span><span class="yiyi-st" id="yiyi-1561"><em>name</em>指定要检索的配置值；它可能是一个字符串，它是定义的系统值的名称；这些名称是在许多标准（POSIX，Unix 95，Unix 98等）中指定的。</span><span class="yiyi-st" id="yiyi-1562">一些平台也定义了其他名称。</span><span class="yiyi-st" id="yiyi-1563">主机操作系统已知的名称是作为<code class="docutils literal"><span class="pre">confstr_names</span></code>字典的关键字提供的。</span><span class="yiyi-st" id="yiyi-1564">对于不包含在该映射中的配置变量，也接受传递<em>name</em>的整数。</span></p><p><span class="yiyi-st" id="yiyi-1565">如果未定义<em>name</em>指定的配置值，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1566">如果<em>name</em>是一个字符串且未知，则引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span><span class="yiyi-st" id="yiyi-1567">如果主机系统不支持<em>name</em>的特定值，即使它包含在<code class="docutils literal"><span class="pre">confstr_names</span></code>中，<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>也会以<a class="reference internal" href="errno.html#errno.EINVAL" title="errno.EINVAL"><code class="xref py py-const docutils literal"><span class="pre">errno.EINVAL</span></code></a>作为错误号。</span></p><p><span class="yiyi-st" id="yiyi-1568">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.confstr_names"><span class="yiyi-st" id="yiyi-1569"> <code class="descclassname">os.</code><code class="descname">confstr_names</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1570">由<a class="reference internal" href="#os.confstr" title="os.confstr"><code class="xref py py-func docutils literal"><span class="pre">confstr()</span></code></a>接受的字典映射名称与主机操作系统为这些名称定义的整数值。</span><span class="yiyi-st" id="yiyi-1571">这可以用来确定系统已知的一组名称。</span></p><p><span class="yiyi-st" id="yiyi-1572">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.cpu_count"><span class="yiyi-st" id="yiyi-1573"> <code class="descclassname">os.</code><code class="descname">cpu_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1574">返回系统中的CPU数量。</span><span class="yiyi-st" id="yiyi-1575">如果不确定，则返回None。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1576"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="os.getloadavg"><span class="yiyi-st" id="yiyi-1577"> <code class="descclassname">os.</code><code class="descname">getloadavg</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1578">如果无法获得负载平均值，则返回系统运行队列中过去1分钟，5分钟和15分钟内平均的进程数量或引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-1579">可用性：UNIX。</span></p></dd></dl><dl class="function"><dt id="os.sysconf"><span class="yiyi-st" id="yiyi-1580"> <code class="descclassname">os.</code><code class="descname">sysconf</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1581">返回整数值的系统配置值。</span><span class="yiyi-st" id="yiyi-1582">如果未定义<em>name</em>指定的配置值，则返回<code class="docutils literal"><span class="pre">-1</span></code>。</span><span class="yiyi-st" id="yiyi-1583">关于<a class="reference internal" href="#os.confstr" title="os.confstr"><code class="xref py py-func docutils literal"><span class="pre">confstr()</span></code></a>的<em>name</em>参数的注释也适用于此处；提供已知名称信息的字典由<code class="docutils literal"><span class="pre">sysconf_names</span></code>给出。</span></p><p><span class="yiyi-st" id="yiyi-1584">可用性：UNIX。</span></p></dd></dl><dl class="data"><dt id="os.sysconf_names"><span class="yiyi-st" id="yiyi-1585"> <code class="descclassname">os.</code><code class="descname">sysconf_names</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1586">由<a class="reference internal" href="#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal"><span class="pre">sysconf()</span></code></a>接受的字典映射名称与主机操作系统为这些名称定义的整数值。</span><span class="yiyi-st" id="yiyi-1587">这可以用来确定系统已知的一组名称。</span></p><p><span class="yiyi-st" id="yiyi-1588">可用性：UNIX。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-1589">以下数据值用于支持路径操作操作。</span><span class="yiyi-st" id="yiyi-1590">这些都是为所有平台定义的。</span></p><p><span class="yiyi-st" id="yiyi-1591">路径名上的高级操作在<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>模块中定义。</span></p><dl class="data"><dt id="os.curdir"><span class="yiyi-st" id="yiyi-1592"> <code class="descclassname">os.</code><code class="descname">curdir</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1593">操作系统用来引用当前目录的常量字符串。</span><span class="yiyi-st" id="yiyi-1594">这是<code class="docutils literal"><span class="pre">'.'</span></code></span><span class="yiyi-st" id="yiyi-1595">对于Windows和POSIX。</span><span class="yiyi-st" id="yiyi-1596">也可以通过<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>使用。</span></p></dd></dl><dl class="data"><dt id="os.pardir"><span class="yiyi-st" id="yiyi-1597"> <code class="descclassname">os.</code><code class="descname">pardir</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1598">操作系统用来引用父目录的常量字符串。</span><span class="yiyi-st" id="yiyi-1599">这是Windows和POSIX的<code class="docutils literal"><span class="pre">'..'</span></code>。</span><span class="yiyi-st" id="yiyi-1600">也可以通过<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>使用。</span></p></dd></dl><dl class="data"><dt id="os.sep"><span class="yiyi-st" id="yiyi-1601"> <code class="descclassname">os.</code><code class="descname">sep</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1602">操作系统用来分隔路径名组件的字符。</span><span class="yiyi-st" id="yiyi-1603">这是针对Windows的<code class="docutils literal"><span class="pre">'/'</span></code>和Windows的<code class="docutils literal"><span class="pre">'\\'</span></code>。</span><span class="yiyi-st" id="yiyi-1604">请注意，知道这不足以解析或连接路径名 - 使用<a class="reference internal" href="os.path.html#os.path.split" title="os.path.split"><code class="xref py py-func docutils literal"><span class="pre">os.path.split()</span></code></a>和<a class="reference internal" href="os.path.html#os.path.join" title="os.path.join"><code class="xref py py-func docutils literal"><span class="pre">os.path.join()</span></code></a>  - 但它是偶尔有用。</span><span class="yiyi-st" id="yiyi-1605">也可以通过<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>使用。</span></p></dd></dl><dl class="data"><dt id="os.altsep"><span class="yiyi-st" id="yiyi-1606"> <code class="descclassname">os.</code><code class="descname">altsep</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1607">操作系统用来分隔路径名组件的替代字符，或者如果只有一个分隔符字符，则<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-1608">在<code class="docutils literal"><span class="pre">sep</span></code>是反斜杠的Windows系统上，它被设置为<code class="docutils literal"><span class="pre">'/'</span></code>。</span><span class="yiyi-st" id="yiyi-1609">也可以通过<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>使用。</span></p></dd></dl><dl class="data"><dt id="os.extsep"><span class="yiyi-st" id="yiyi-1610"> <code class="descclassname">os.</code><code class="descname">extsep</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1611">将基本文件名与扩展名分开的字符；例如，<code class="docutils literal"><span class="pre">'.'</span></code></span><span class="yiyi-st" id="yiyi-1612">在<code class="file docutils literal"><span class="pre">os.py</span></code>中。</span><span class="yiyi-st" id="yiyi-1613">也可以通过<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>使用。</span></p></dd></dl><dl class="data"><dt id="os.pathsep"><span class="yiyi-st" id="yiyi-1614"> <code class="descclassname">os.</code><code class="descname">pathsep</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1615">The character conventionally used by the operating system to separate search path components (as in <span class="target" id="index-34"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code>), such as <code class="docutils literal"><span class="pre">':'</span></code> for POSIX or <code class="docutils literal"><span class="pre">';'</span></code> for Windows. </span><span class="yiyi-st" id="yiyi-1616">也可以通过<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>使用。</span></p></dd></dl><dl class="data"><dt id="os.defpath"><span class="yiyi-st" id="yiyi-1617"> <code class="descclassname">os.</code><code class="descname">defpath</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1618">如果环境没有<code class="docutils literal"><span class="pre">'PATH'</span></code>键，<a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">exec*p*</span></code></a>和<a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*p*</span></code></a>使用的默认搜索路径。</span><span class="yiyi-st" id="yiyi-1619">也可以通过<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>使用。</span></p></dd></dl><dl class="data"><dt id="os.linesep"><span class="yiyi-st" id="yiyi-1620"> <code class="descclassname">os.</code><code class="descname">linesep</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1621">用于在当前平台上分隔（或相反，终止）行的字符串。</span><span class="yiyi-st" id="yiyi-1622">这可能是单个字符，例如POSIX的<code class="docutils literal"><span class="pre">'\n'</span></code>或Windows的多个字符，例如<code class="docutils literal"><span class="pre">'\r\n'</span></code>。</span><span class="yiyi-st" id="yiyi-1623">编写以文本模式打开的文件时（默认），不要使用<em>os.linesep</em>作为行终止符；在所有平台上使用单个<code class="docutils literal"><span class="pre">'\n'</span></code>。</span></p></dd></dl><dl class="data"><dt id="os.devnull"><span class="yiyi-st" id="yiyi-1624"> <code class="descclassname">os.</code><code class="descname">devnull</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1625">空设备的文件路径。</span><span class="yiyi-st" id="yiyi-1626">例如：用于Windows的<code class="docutils literal"><span class="pre">'/dev/null'</span></code>，用于Windows的<code class="docutils literal"><span class="pre">'nul'</span></code>。</span><span class="yiyi-st" id="yiyi-1627">也可以通过<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>使用。</span></p></dd></dl><dl class="data"><dt id="os.RTLD_LAZY"><span class="yiyi-st" id="yiyi-1628"> <code class="descclassname">os.</code><code class="descname">RTLD_LAZY</code></span></dt><dt id="os.RTLD_NOW"><span class="yiyi-st" id="yiyi-1629"> <code class="descclassname">os.</code><code class="descname">RTLD_NOW</code></span></dt><dt id="os.RTLD_GLOBAL"><span class="yiyi-st" id="yiyi-1630"> <code class="descclassname">os.</code><code class="descname">RTLD_GLOBAL</code></span></dt><dt id="os.RTLD_LOCAL"><span class="yiyi-st" id="yiyi-1631"> <code class="descclassname">os.</code><code class="descname">RTLD_LOCAL</code></span></dt><dt id="os.RTLD_NODELETE"><span class="yiyi-st" id="yiyi-1632"> <code class="descclassname">os.</code><code class="descname">RTLD_NODELETE</code></span></dt><dt id="os.RTLD_NOLOAD"><span class="yiyi-st" id="yiyi-1633"> <code class="descclassname">os.</code><code class="descname">RTLD_NOLOAD</code></span></dt><dt id="os.RTLD_DEEPBIND"><span class="yiyi-st" id="yiyi-1634"> <code class="descclassname">os.</code><code class="descname">RTLD_DEEPBIND</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1635">用于<a class="reference internal" href="sys.html#sys.setdlopenflags" title="sys.setdlopenflags"><code class="xref py py-func docutils literal"><span class="pre">setdlopenflags()</span></code></a>和<a class="reference internal" href="sys.html#sys.getdlopenflags" title="sys.getdlopenflags"><code class="xref py py-func docutils literal"><span class="pre">getdlopenflags()</span></code></a>函数的标志。</span><span class="yiyi-st" id="yiyi-1636">查看Unix手册页面<em class="manpage">dlopen（3）</em>了解不同标志的含义。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1637"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="miscellaneous-functions"><h2><span class="yiyi-st" id="yiyi-1638">16.1.9. </span><span class="yiyi-st" id="yiyi-1639">其他函数</span></h2><dl class="function"><dt id="os.urandom"><span class="yiyi-st" id="yiyi-1640"> <code class="descclassname">os.</code><code class="descname">urandom</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1641">返回<em>n</em>个字节的用以加密的随机字符串</span></p><p><span class="yiyi-st" id="yiyi-1642">此函数从操作系统特定的随机源返回随机字节.</span><span class="yiyi-st" id="yiyi-1643">返回的数据对于加密应用程序应该是不可预测的，尽管其确切的质量取决于OS实现。</span></p><p><span class="yiyi-st" id="yiyi-1644">在Linux上，使用<code class="docutils literal"><span class="pre">getrandom()</span></code>系统调用（如果可用且urandom熵池已初始化）（<code class="docutils literal"><span class="pre">getrandom()</span></code>不会阻止）。</span><span class="yiyi-st" id="yiyi-1645">在一个类似Unix的系统上，它会查询<code class="docutils literal"><span class="pre">/dev/urandom</span></code>。</span><span class="yiyi-st" id="yiyi-1646">在Windows上，它将使用<code class="docutils literal"><span class="pre">CryptGenRandom()</span></code>。</span><span class="yiyi-st" id="yiyi-1647">如果没有找到随机源，则会引发<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-1648">对于您平台提供的随机数生成器的易用界面，请参阅<a class="reference internal" href="random.html#random.SystemRandom" title="random.SystemRandom"><code class="xref py py-class docutils literal"><span class="pre">random.SystemRandom</span></code></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1649"><span class="versionmodified">版本3.5.2中已更改：</span>在Linux上，如果<code class="docutils literal"><span class="pre">getrandom()</span></code>块（urandom熵池尚未初始化），请回读<code class="docutils literal"><span class="pre">/dev/urandom</span></code></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1650"><span class="versionmodified">在版本3.5中更改：</span>在Linux 3.17及更新版本中，现在可以使用<code class="docutils literal"><span class="pre">getrandom()</span></code>系统调用。</span><span class="yiyi-st" id="yiyi-1651">在OpenBSD 5.6及更新版本上，现在使用C <code class="docutils literal"><span class="pre">getentropy()</span></code>函数。</span><span class="yiyi-st" id="yiyi-1652">这些函数避免使用内部文件描述符。</span></p></div></dd></dl></div></div></div>