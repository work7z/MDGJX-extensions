<div class="body" role="main"><div class="section" id="module-locale"><h1><span class="yiyi-st" id="yiyi-10">23.2. <a class="reference internal" href="#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a>  - 国际化服务</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/locale.py">Lib / locale.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a>模块打开对POSIX语言环境数据库和功能的访问。</span><span class="yiyi-st" id="yiyi-13">POSIX语言环境机制允许程序员处理应用程序中的某些文化问题，而不需要程序员知道执行软件的每个国家的所有细节。</span></p><p id="index-0"><span class="yiyi-st" id="yiyi-14"><a class="reference internal" href="#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a>模块在<code class="xref py py-mod docutils literal"><span class="pre">_locale</span></code>模块之上实现，而后者又使用ANSI C语言环境实现（如果可用）。</span></p><p><span class="yiyi-st" id="yiyi-15"><a class="reference internal" href="#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a>模块定义以下异常和函数：</span></p><dl class="exception"><dt id="locale.Error"><span class="yiyi-st" id="yiyi-16"> <em class="property">exception </em><code class="descclassname">locale.</code><code class="descname">Error</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-17">当区域设置传递到<a class="reference internal" href="#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal"><span class="pre">setlocale()</span></code></a>时无法识别异常。</span></p></dd></dl><dl class="function"><dt id="locale.setlocale"><span class="yiyi-st" id="yiyi-18"> <code class="descclassname">locale.</code><code class="descname">setlocale</code><span class="sig-paren">(</span><em>category</em>, <em>locale=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-19">如果给定<em>locale</em>且<code class="docutils literal"><span class="pre">None</span></code>，<a class="reference internal" href="#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal"><span class="pre">setlocale()</span></code></a>修改<em>类别</em>的区域设置。</span><span class="yiyi-st" id="yiyi-20">可用类别在下面的数据描述中列出。</span><span class="yiyi-st" id="yiyi-21"><em>locale</em>可以是字符串，也可以是两个字符串的迭代（语言代码和编码）。</span><span class="yiyi-st" id="yiyi-22">如果它是一个可迭代的，它将使用语言环境别名引擎转换为一个区域设置名称。</span><span class="yiyi-st" id="yiyi-23">空字符串指定用户的默认设置。</span><span class="yiyi-st" id="yiyi-24">如果语言环境的修改失败，则会引发异常<a class="reference internal" href="#locale.Error" title="locale.Error"><code class="xref py py-exc docutils literal"><span class="pre">Error</span></code></a>。</span><span class="yiyi-st" id="yiyi-25">如果成功，则返回新的区域设置。</span></p><p><span class="yiyi-st" id="yiyi-26">如果省略<em>locale</em>或<code class="docutils literal"><span class="pre">None</span></code>，将返回<em>类别</em>的当前设置。</span></p><p><span class="yiyi-st" id="yiyi-27"><a class="reference internal" href="#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal"><span class="pre">setlocale()</span></code></a>在大多数系统上不是线程安全的。</span><span class="yiyi-st" id="yiyi-28">应用程序通常从调用开始</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">locale</span>
<span class="n">locale</span><span class="o">.</span><span class="n">setlocale</span><span class="p">(</span><span class="n">locale</span><span class="o">.</span><span class="n">LC_ALL</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-29">这会将所有类别的区域设置设置为用户的默认设置（通常在<span class="target" id="index-1"></span> <code class="xref std std-envvar docutils literal"><span class="pre">LANG</span></code></span><span class="yiyi-st" id="yiyi-30">如果语言环境以后没有更改，使用多线程不应该导致问题。</span></p></dd></dl><dl class="function"><dt id="locale.localeconv"><span class="yiyi-st" id="yiyi-31"> <code class="descclassname">locale.</code><code class="descname">localeconv</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-32">将本地约定的数据库作为字典返回。</span><span class="yiyi-st" id="yiyi-33">此字典具有以下字符串作为键：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-34">类别</span></th><th class="head"><span class="yiyi-st" id="yiyi-35">键</span></th><th class="head"><span class="yiyi-st" id="yiyi-36">含义</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-37"><a class="reference internal" href="#locale.LC_NUMERIC" title="locale.LC_NUMERIC"><code class="xref py py-const docutils literal"><span class="pre">LC_NUMERIC</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-38"><code class="docutils literal"><span class="pre">'decimal_point'</span></code></span></td><td><span class="yiyi-st" id="yiyi-39">小数点字符。</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-40"><code class="docutils literal"><span class="pre">'grouping'</span></code></span></td><td><span class="yiyi-st" id="yiyi-41">预期<code class="docutils literal"><span class="pre">'thousands_sep'</span></code>的相对位置的数字序列。</span><span class="yiyi-st" id="yiyi-42">如果序列以<a class="reference internal" href="#locale.CHAR_MAX" title="locale.CHAR_MAX"><code class="xref py py-const docutils literal"><span class="pre">CHAR_MAX</span></code></a>结尾，则不会执行进一步的分组。</span><span class="yiyi-st" id="yiyi-43">如果序列以<code class="docutils literal"><span class="pre">0</span></code>结尾，则重复使用最后一个组大小。</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-44"><code class="docutils literal"><span class="pre">'thousands_sep'</span></code></span></td><td><span class="yiyi-st" id="yiyi-45">组之间使用的字符。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-46"><a class="reference internal" href="#locale.LC_MONETARY" title="locale.LC_MONETARY"><code class="xref py py-const docutils literal"><span class="pre">LC_MONETARY</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-47"><code class="docutils literal"><span class="pre">'int_curr_symbol'</span></code></span></td><td><span class="yiyi-st" id="yiyi-48">国际货币符号。</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-49"><code class="docutils literal"><span class="pre">'currency_symbol'</span></code></span></td><td><span class="yiyi-st" id="yiyi-50">本地货币符号。</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-51"><code class="docutils literal"><span class="pre">'p_cs_precedes/n_cs_precedes'</span></code></span></td><td><span class="yiyi-st" id="yiyi-52">货币符号是否在值之前（对于正值，</span><span class="yiyi-st" id="yiyi-53">负值）。</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-54"><code class="docutils literal"><span class="pre">'p_sep_by_space/n_sep_by_space'</span></code></span></td><td><span class="yiyi-st" id="yiyi-55">货币符号是否与值隔开一个空格（对于正号和反号。</span><span class="yiyi-st" id="yiyi-56">负值）。</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-57"><code class="docutils literal"><span class="pre">'mon_decimal_point'</span></code></span></td><td><span class="yiyi-st" id="yiyi-58">用于货币价值的小数点。</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-59"><code class="docutils literal"><span class="pre">'frac_digits'</span></code></span></td><td><span class="yiyi-st" id="yiyi-60">在货币值的本地格式中使用的小数位数。</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-61"><code class="docutils literal"><span class="pre">'int_frac_digits'</span></code></span></td><td><span class="yiyi-st" id="yiyi-62">在货币值的国际格式中使用的小数位数。</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-63"><code class="docutils literal"><span class="pre">'mon_thousands_sep'</span></code></span></td><td><span class="yiyi-st" id="yiyi-64">用于货币值的组分隔符。</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-65"><code class="docutils literal"><span class="pre">'mon_grouping'</span></code></span></td><td><span class="yiyi-st" id="yiyi-66">等于<code class="docutils literal"><span class="pre">'grouping'</span></code>，用于货币值。</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-67"><code class="docutils literal"><span class="pre">'positive_sign'</span></code></span></td><td><span class="yiyi-st" id="yiyi-68">用于注释正货币值的符号。</span></td></tr><tr class="row-odd"><td></td><td><span class="yiyi-st" id="yiyi-69"><code class="docutils literal"><span class="pre">'negative_sign'</span></code></span></td><td><span class="yiyi-st" id="yiyi-70">用于注释负货币值的符号。</span></td></tr><tr class="row-even"><td></td><td><span class="yiyi-st" id="yiyi-71"><code class="docutils literal"><span class="pre">'p_sign_posn/n_sign_posn'</span></code></span></td><td><span class="yiyi-st" id="yiyi-72">符号的位置（对于正和。</span><span class="yiyi-st" id="yiyi-73">负值），见下文。</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-74">所有数值都可以设置为<a class="reference internal" href="#locale.CHAR_MAX" title="locale.CHAR_MAX"><code class="xref py py-const docutils literal"><span class="pre">CHAR_MAX</span></code></a>，表示此区域设置中没有指定值。</span></p><p><span class="yiyi-st" id="yiyi-75">下面给出了<code class="docutils literal"><span class="pre">'p_sign_posn'</span></code>和<code class="docutils literal"><span class="pre">'n_sign_posn'</span></code>的可能值。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-76">值</span></th><th class="head"><span class="yiyi-st" id="yiyi-77">说明</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-78"><code class="docutils literal"><span class="pre">0</span></code></span></td><td><span class="yiyi-st" id="yiyi-79">货币和价值被圆括号包围。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-80"><code class="docutils literal"><span class="pre">1</span></code></span></td><td><span class="yiyi-st" id="yiyi-81">符号应位于值和货币符号之前。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-82"><code class="docutils literal"><span class="pre">2</span></code></span></td><td><span class="yiyi-st" id="yiyi-83">符号应该跟随值和货币符号。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-84"><code class="docutils literal"><span class="pre">3</span></code></span></td><td><span class="yiyi-st" id="yiyi-85">符号应紧接在值之前。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-86"><code class="docutils literal"><span class="pre">4</span></code></span></td><td><span class="yiyi-st" id="yiyi-87">符号应该紧跟在值之后。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-88"><code class="docutils literal"><span class="pre">CHAR_MAX</span></code></span></td><td><span class="yiyi-st" id="yiyi-89">此区域设置中未指定任何内容。</span></td></tr></tbody></table></dd></dl><dl class="function"><dt id="locale.nl_langinfo"><span class="yiyi-st" id="yiyi-90"> <code class="descclassname">locale.</code><code class="descname">nl_langinfo</code><span class="sig-paren">(</span><em>option</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-91">将一些特定于语言环境的信息作为字符串返回。</span><span class="yiyi-st" id="yiyi-92">此功能不适用于所有系统，并且可能的选项集也可能在不同平台上有所不同。</span><span class="yiyi-st" id="yiyi-93">可能的参数值是数字，符号常量在语言环境模块中可用。</span></p><p><span class="yiyi-st" id="yiyi-94"><a class="reference internal" href="#locale.nl_langinfo" title="locale.nl_langinfo"><code class="xref py py-func docutils literal"><span class="pre">nl_langinfo()</span></code></a>函数接受以下键之一。</span><span class="yiyi-st" id="yiyi-95">大多数描述取自GNU C库中的相应描述。</span></p><dl class="data"><dt id="locale.CODESET"><span class="yiyi-st" id="yiyi-96"> <code class="descclassname">locale.</code><code class="descname">CODESET</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-97">获取一个字符串，其中包含所选语言环境中使用的字符编码的名称。</span></p></dd></dl><dl class="data"><dt id="locale.D_T_FMT"><span class="yiyi-st" id="yiyi-98"> <code class="descclassname">locale.</code><code class="descname">D_T_FMT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-99">获取可用作<a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>的格式字符串的字符串，以特定于语言环境的方式表示日期和时间。</span></p></dd></dl><dl class="data"><dt id="locale.D_FMT"><span class="yiyi-st" id="yiyi-100"> <code class="descclassname">locale.</code><code class="descname">D_FMT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-101">获取可用作<a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>的格式字符串的字符串，以特定于语言环境的方式表示日期。</span></p></dd></dl><dl class="data"><dt id="locale.T_FMT"><span class="yiyi-st" id="yiyi-102"> <code class="descclassname">locale.</code><code class="descname">T_FMT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-103">获取可用作<a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>的格式字符串的字符串，以特定于语言环境的方式表示时间。</span></p></dd></dl><dl class="data"><dt id="locale.T_FMT_AMPM"><span class="yiyi-st" id="yiyi-104"> <code class="descclassname">locale.</code><code class="descname">T_FMT_AMPM</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-105">获取<a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>的格式字符串，以am / pm格式表示时间。</span></p></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-106"><code class="descname">DAY_1 ... DAY_7</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">获取一周的第n天的名称。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-108">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-109">这符合美国惯例<code class="xref py py-const docutils literal"><span class="pre">DAY_1</span></code>为星期日，而不是国际惯例（ISO 8601），星期一是一周的第一天。</span></p></div></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-110"><code class="descname">ABDAY_1 ... ABDAY_7</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">获取一周中第n天的缩写名称。</span></p></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-112"><code class="descname">MON_1 ... MON_12</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-113">获取第n个月的名称。</span></p></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-114"><code class="descname">ABMON_1 ... ABMON_12</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-115">获取第n个月的缩写名称。</span></p></dd></dl><dl class="data"><dt id="locale.RADIXCHAR"><span class="yiyi-st" id="yiyi-116"> <code class="descclassname">locale.</code><code class="descname">RADIXCHAR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-117">获取基数字符（小数点，十进制逗号等）</span><span class="yiyi-st" id="yiyi-118">）。</span></p></dd></dl><dl class="data"><dt id="locale.THOUSEP"><span class="yiyi-st" id="yiyi-119"> <code class="descclassname">locale.</code><code class="descname">THOUSEP</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-120">获取数千（三位数的组）的分隔符。</span></p></dd></dl><dl class="data"><dt id="locale.YESEXPR"><span class="yiyi-st" id="yiyi-121"> <code class="descclassname">locale.</code><code class="descname">YESEXPR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-122">获取可以与正则表达式函数一起使用的正则表达式，以识别对是/否问题的肯定响应。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-123">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-124">表达式的语法适合于C库的<code class="xref c c-func docutils literal"><span class="pre">regex()</span></code>函数，它可能与<a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a>中使用的语法不同。</span></p></div></dd></dl><dl class="data"><dt id="locale.NOEXPR"><span class="yiyi-st" id="yiyi-125"> <code class="descclassname">locale.</code><code class="descname">NOEXPR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-126">获取可以与regex（3）函数一起使用的正则表达式来识别对是/否问题的否定响应。</span></p></dd></dl><dl class="data"><dt id="locale.CRNCYSTR"><span class="yiyi-st" id="yiyi-127"> <code class="descclassname">locale.</code><code class="descname">CRNCYSTR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-128">获取货币符号，如果符号应出现在值前面，则以“ - ”开头，如果符号应出现在值后面，则为“+”，如果符号应替换基数字符，则为“。</span></p></dd></dl><dl class="data"><dt id="locale.ERA"><span class="yiyi-st" id="yiyi-129"> <code class="descclassname">locale.</code><code class="descname">ERA</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-130">获取表示当前语言环境中使用的时代的字符串。</span></p><p><span class="yiyi-st" id="yiyi-131">大多数语言环境不定义此值。</span><span class="yiyi-st" id="yiyi-132">定义此值的语言环境的示例是日语语言环境。</span><span class="yiyi-st" id="yiyi-133">在日本，日期的传统表示包括对应于当时皇帝统治的时代的名称。</span></p><p><span class="yiyi-st" id="yiyi-134">通常不需要直接使用这个值。</span><span class="yiyi-st" id="yiyi-135">在其格式字符串中指定<code class="docutils literal"><span class="pre">E</span></code>修饰符会导致<a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>函数使用此信息。</span><span class="yiyi-st" id="yiyi-136">返回的字符串的格式未指定，因此您不应该在不同的系统上假设它的知识。</span></p></dd></dl><dl class="data"><dt id="locale.ERA_D_T_FMT"><span class="yiyi-st" id="yiyi-137"> <code class="descclassname">locale.</code><code class="descname">ERA_D_T_FMT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-138">获取<a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>的格式字符串，以特定于语言环境的基于时代的方式表示日期和时间。</span></p></dd></dl><dl class="data"><dt id="locale.ERA_D_FMT"><span class="yiyi-st" id="yiyi-139"> <code class="descclassname">locale.</code><code class="descname">ERA_D_FMT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-140">获取<a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>的格式字符串，以特定于语言环境的基于时代的方式表示日期。</span></p></dd></dl><dl class="data"><dt id="locale.ERA_T_FMT"><span class="yiyi-st" id="yiyi-141"> <code class="descclassname">locale.</code><code class="descname">ERA_T_FMT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-142">获取<a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>的格式字符串，以特定于语言环境的基于时代的方式表示时间。</span></p></dd></dl><dl class="data"><dt id="locale.ALT_DIGITS"><span class="yiyi-st" id="yiyi-143"> <code class="descclassname">locale.</code><code class="descname">ALT_DIGITS</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-144">获取用于表示值0到99的最多100个值的表示。</span></p></dd></dl></dd></dl><dl class="function"><dt id="locale.getdefaultlocale"><span class="yiyi-st" id="yiyi-145"> <code class="descclassname">locale.</code><code class="descname">getdefaultlocale</code><span class="sig-paren">(</span><span class="optional">[</span><em>envvars</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-146">尝试确定默认语言环境设置，并以<code class="docutils literal"><span class="pre">（语言</span> <span class="pre">代码，</span> <span class="pre">编码）</span></code> 。</span></p><p><span class="yiyi-st" id="yiyi-147">根据POSIX，没有调用<code class="docutils literal"><span class="pre">setlocale（LC_ALL，</span> <span class="pre">“）</span></code>的程序使用便携式<code class="docutils literal"><span class="pre">'C'</span></code></span><span class="yiyi-st" id="yiyi-148">调用<code class="docutils literal"><span class="pre">setlocale（LC_ALL，</span> <span class="pre">''）</span></code>允许使用<span class="target" id="index-2"></span> <code class="xref std std-envvar docutils literal"><span class="pre">LANG</span></code>变量。</span><span class="yiyi-st" id="yiyi-149">由于我们不想干扰当前区域设置，因此我们以上述方式模拟行为。</span></p><p><span class="yiyi-st" id="yiyi-150">为了保持与其他平台的兼容性，不仅测试了<span class="target" id="index-3"></span> <code class="xref std std-envvar docutils literal"><span class="pre">LANG</span></code>变量，还提供了以envvars参数形式给出的变量列表。</span><span class="yiyi-st" id="yiyi-151">第一个发现被定义将被使用。</span><span class="yiyi-st" id="yiyi-152"><em>envvars</em>默认为在GNU gettext中使用的搜索路径；它必须始终包含变量名<code class="docutils literal"><span class="pre">'LANG'</span></code>。</span><span class="yiyi-st" id="yiyi-153">GNU gettext搜索路径包含<code class="docutils literal"><span class="pre">'LC_ALL'</span></code>，<code class="docutils literal"><span class="pre">'LC_CTYPE'</span></code>，<code class="docutils literal"><span class="pre">'LANG'</span></code>和<code class="docutils literal"><span class="pre">'LANGUAGE'</span></code> 。</span></p><p><span class="yiyi-st" id="yiyi-154">除了代码<code class="docutils literal"><span class="pre">'C'</span></code>，语言代码对应于<span class="target" id="index-4"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1766.html"><strong>RFC 1766</strong></a>。如果无法确定其值，则<em>语言代码</em>和<em>编码</em>可能是<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="function"><dt id="locale.getlocale"><span class="yiyi-st" id="yiyi-155"> <code class="descclassname">locale.</code><code class="descname">getlocale</code><span class="sig-paren">(</span><em>category=LC_CTYPE</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156">将指定语言代码类别的当前设置作为包含<em>语言代码</em>，<em>编码</em>的序列返回。</span><span class="yiyi-st" id="yiyi-157"><em>类别</em>可以是除<a class="reference internal" href="#locale.LC_ALL" title="locale.LC_ALL"><code class="xref py py-const docutils literal"><span class="pre">LC_ALL</span></code></a>之外的<code class="xref py py-const docutils literal"><span class="pre">LC_*</span></code>值之一。</span><span class="yiyi-st" id="yiyi-158">它默认为<a class="reference internal" href="#locale.LC_CTYPE" title="locale.LC_CTYPE"><code class="xref py py-const docutils literal"><span class="pre">LC_CTYPE</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-159">除了代码<code class="docutils literal"><span class="pre">'C'</span></code>，语言代码对应于<span class="target" id="index-5"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1766.html"><strong>RFC 1766</strong></a>。如果无法确定其值，则<em>语言代码</em>和<em>编码</em>可能是<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="function"><dt id="locale.getpreferredencoding"><span class="yiyi-st" id="yiyi-160"> <code class="descclassname">locale.</code><code class="descname">getpreferredencoding</code><span class="sig-paren">(</span><em>do_setlocale=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-161">根据用户偏好返回用于文本数据的编码。</span><span class="yiyi-st" id="yiyi-162">用户首选项在不同系统上的表达方式不同，并且在某些系统上可能无法以编程方式使用，因此此函数仅返回猜测。</span></p><p><span class="yiyi-st" id="yiyi-163">在某些系统上，有必要调用<a class="reference internal" href="#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal"><span class="pre">setlocale()</span></code></a>以获取用户首选项，因此此函数不是线程安全的。</span><span class="yiyi-st" id="yiyi-164">如果不需要或不需要调用setlocale，则应将<em>do_setlocale</em>设置为<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="function"><dt id="locale.normalize"><span class="yiyi-st" id="yiyi-165"> <code class="descclassname">locale.</code><code class="descname">normalize</code><span class="sig-paren">(</span><em>localename</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-166">返回给定语言环境名称的标准化语言环境代码。</span><span class="yiyi-st" id="yiyi-167">返回的语言环境代码的格式为与<a class="reference internal" href="#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal"><span class="pre">setlocale()</span></code></a>一起使用。</span><span class="yiyi-st" id="yiyi-168">如果规范化失败，原始名称将不更改地返回。</span></p><p><span class="yiyi-st" id="yiyi-169">如果给定的编码未知，该函数默认为区域设置代码的默认编码，就像<a class="reference internal" href="#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal"><span class="pre">setlocale()</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="locale.resetlocale"><span class="yiyi-st" id="yiyi-170"> <code class="descclassname">locale.</code><code class="descname">resetlocale</code><span class="sig-paren">(</span><em>category=LC_ALL</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-171">将<em>类别</em>的区域设置设置为默认设置。</span></p><p><span class="yiyi-st" id="yiyi-172">默认设置是通过调用<a class="reference internal" href="#locale.getdefaultlocale" title="locale.getdefaultlocale"><code class="xref py py-func docutils literal"><span class="pre">getdefaultlocale()</span></code></a>确定的。</span><span class="yiyi-st" id="yiyi-173"><em>类别</em>默认为<a class="reference internal" href="#locale.LC_ALL" title="locale.LC_ALL"><code class="xref py py-const docutils literal"><span class="pre">LC_ALL</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="locale.strcoll"><span class="yiyi-st" id="yiyi-174"> <code class="descclassname">locale.</code><code class="descname">strcoll</code><span class="sig-paren">(</span><em>string1</em>, <em>string2</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-175">根据当前<a class="reference internal" href="#locale.LC_COLLATE" title="locale.LC_COLLATE"><code class="xref py py-const docutils literal"><span class="pre">LC_COLLATE</span></code></a>设置比较两个字符串。</span><span class="yiyi-st" id="yiyi-176">作为任何其他比较函数，根据<em>string1</em>是在<em>string2</em>之前还是之后返回一个负值或正值或<code class="docutils literal"><span class="pre">0</span></code>等于它。</span></p></dd></dl><dl class="function"><dt id="locale.strxfrm"><span class="yiyi-st" id="yiyi-177"> <code class="descclassname">locale.</code><code class="descname">strxfrm</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-178">将字符串转换为可在区域设置感知比较中使用的字符串。</span><span class="yiyi-st" id="yiyi-179">例如，<code class="docutils literal"><span class="pre">strxfrm（s1）</span> <span class="pre"> <span class="pre">strxfrm（s2）</span></span></code>等效于<code class="docutils literal"><span class="pre">strcoll（s1，</span> <span class="pre">s2）</span> <span class="pre">＆lt；</span> <span class="pre">0</span></code>。</span><span class="yiyi-st" id="yiyi-180">当相同的字符串被重复比较时，可以使用该函数。</span><span class="yiyi-st" id="yiyi-181">当比较字符串序列时。</span></p></dd></dl><dl class="function"><dt id="locale.format"><span class="yiyi-st" id="yiyi-182"> <code class="descclassname">locale.</code><code class="descname">format</code><span class="sig-paren">(</span><em>format</em>, <em>val</em>, <em>grouping=False</em>, <em>monetary=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-183">根据当前的<a class="reference internal" href="#locale.LC_NUMERIC" title="locale.LC_NUMERIC"><code class="xref py py-const docutils literal"><span class="pre">LC_NUMERIC</span></code></a>设置格式化数字<em>val</em>。</span><span class="yiyi-st" id="yiyi-184">格式遵循<code class="docutils literal"><span class="pre">%</span></code>操作符号的约定。</span><span class="yiyi-st" id="yiyi-185">对于浮点值，如果适当，将修改小数点。</span><span class="yiyi-st" id="yiyi-186">如果<em>分组</em>为真，也会考虑分组。</span></p><p><span class="yiyi-st" id="yiyi-187">如果<em>currency</em>为真，则转换使用货币千位分隔符和分组字符串。</span></p><p><span class="yiyi-st" id="yiyi-188">请注意，此函数仅适用于正好一个％char说明符。</span><span class="yiyi-st" id="yiyi-189">对于整个格式字符串，请使用<a class="reference internal" href="#locale.format_string" title="locale.format_string"><code class="xref py py-func docutils literal"><span class="pre">format_string()</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="locale.format_string"><span class="yiyi-st" id="yiyi-190"> <code class="descclassname">locale.</code><code class="descname">format_string</code><span class="sig-paren">(</span><em>format</em>, <em>val</em>, <em>grouping=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-191">按<code class="docutils literal"><span class="pre">格式</span> <span class="pre">％</span> <span class="pre">val</span></code>处理格式说明符，但会考虑当前的区域设置。</span></p></dd></dl><dl class="function"><dt id="locale.currency"><span class="yiyi-st" id="yiyi-192"> <code class="descclassname">locale.</code><code class="descname">currency</code><span class="sig-paren">(</span><em>val</em>, <em>symbol=True</em>, <em>grouping=False</em>, <em>international=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-193">根据当前的<a class="reference internal" href="#locale.LC_MONETARY" title="locale.LC_MONETARY"><code class="xref py py-const docutils literal"><span class="pre">LC_MONETARY</span></code></a>设置格式化数字<em>val</em>。</span></p><p><span class="yiyi-st" id="yiyi-194">如果<em>符号</em>为true，则返回的字符串包含货币符号，这是默认值。</span><span class="yiyi-st" id="yiyi-195">如果<em>分组</em>为true（这不是默认值），则使用该值进行分组。</span><span class="yiyi-st" id="yiyi-196">如果<em>国际</em>为真（这不是默认值），则使用国际货币符号。</span></p><p><span class="yiyi-st" id="yiyi-197">请注意，此函数不能与“C”语言环境一起使用，因此您必须首先通过<a class="reference internal" href="#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal"><span class="pre">setlocale()</span></code></a>设置语言环境。</span></p></dd></dl><dl class="function"><dt id="locale.str"><span class="yiyi-st" id="yiyi-198"> <code class="descclassname">locale.</code><code class="descname">str</code><span class="sig-paren">(</span><em>float</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-199">使用与内建函数<code class="docutils literal"><span class="pre">str(float)</span></code>相同的格式格式化浮点数，但会考虑小数点。</span></p></dd></dl><dl class="function"><dt id="locale.delocalize"><span class="yiyi-st" id="yiyi-200"> <code class="descclassname">locale.</code><code class="descname">delocalize</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-201">在<a class="reference internal" href="#locale.LC_NUMERIC" title="locale.LC_NUMERIC"><code class="xref py py-const docutils literal"><span class="pre">LC_NUMERIC</span></code></a>设置后，将字符串转换为规范化的数字字符串。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-202"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="locale.atof"><span class="yiyi-st" id="yiyi-203"> <code class="descclassname">locale.</code><code class="descname">atof</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-204">将字符串转换为浮点数，紧跟<a class="reference internal" href="#locale.LC_NUMERIC" title="locale.LC_NUMERIC"><code class="xref py py-const docutils literal"><span class="pre">LC_NUMERIC</span></code></a>设置。</span></p></dd></dl><dl class="function"><dt id="locale.atoi"><span class="yiyi-st" id="yiyi-205"> <code class="descclassname">locale.</code><code class="descname">atoi</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-206">将字符串转换为整数，遵循<a class="reference internal" href="#locale.LC_NUMERIC" title="locale.LC_NUMERIC"><code class="xref py py-const docutils literal"><span class="pre">LC_NUMERIC</span></code></a>约定。</span></p></dd></dl><dl class="data"><dt id="locale.LC_CTYPE"><span class="yiyi-st" id="yiyi-207"> <code class="descclassname">locale.</code><code class="descname">LC_CTYPE</code></span></dt><dd><p id="index-6"><span class="yiyi-st" id="yiyi-208">字符类型函数的区域设置类别。</span><span class="yiyi-st" id="yiyi-209">Depending on the settings of this category, the functions of module <a class="reference internal" href="string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal"><span class="pre">string</span></code></a> dealing with case change their behaviour.</span></p></dd></dl><dl class="data"><dt id="locale.LC_COLLATE"><span class="yiyi-st" id="yiyi-210"> <code class="descclassname">locale.</code><code class="descname">LC_COLLATE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-211">用于排序字符串的区域设置类别。</span><span class="yiyi-st" id="yiyi-212"><a class="reference internal" href="#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a>模块的函数<a class="reference internal" href="#locale.strcoll" title="locale.strcoll"><code class="xref py py-func docutils literal"><span class="pre">strcoll()</span></code></a>和<a class="reference internal" href="#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal"><span class="pre">strxfrm()</span></code></a></span></p></dd></dl><dl class="data"><dt id="locale.LC_TIME"><span class="yiyi-st" id="yiyi-213"> <code class="descclassname">locale.</code><code class="descname">LC_TIME</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-214">时间格式化的区域设置类别。</span><span class="yiyi-st" id="yiyi-215">函数<a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>遵循这些约定。</span></p></dd></dl><dl class="data"><dt id="locale.LC_MONETARY"><span class="yiyi-st" id="yiyi-216"> <code class="descclassname">locale.</code><code class="descname">LC_MONETARY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-217">货币值格式化的区域设置类别。</span><span class="yiyi-st" id="yiyi-218">可用的选项可从<a class="reference internal" href="#locale.localeconv" title="locale.localeconv"><code class="xref py py-func docutils literal"><span class="pre">localeconv()</span></code></a>函数获得。</span></p></dd></dl><dl class="data"><dt id="locale.LC_MESSAGES"><span class="yiyi-st" id="yiyi-219"> <code class="descclassname">locale.</code><code class="descname">LC_MESSAGES</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-220">消息显示的区域设置类别。</span><span class="yiyi-st" id="yiyi-221">Python目前不支持特定于应用程序的区域设置感知消息。</span><span class="yiyi-st" id="yiyi-222">操作系统显示的消息（如<a class="reference internal" href="os.html#os.strerror" title="os.strerror"><code class="xref py py-func docutils literal"><span class="pre">os.strerror()</span></code></a>返回的消息可能会受此类别的影响）。</span></p></dd></dl><dl class="data"><dt id="locale.LC_NUMERIC"><span class="yiyi-st" id="yiyi-223"> <code class="descclassname">locale.</code><code class="descname">LC_NUMERIC</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-224">格式化数字的区域设置类别。</span><span class="yiyi-st" id="yiyi-225">The functions <a class="reference internal" href="#locale.format" title="locale.format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a>, <a class="reference internal" href="#locale.atoi" title="locale.atoi"><code class="xref py py-func docutils literal"><span class="pre">atoi()</span></code></a>, <a class="reference internal" href="#locale.atof" title="locale.atof"><code class="xref py py-func docutils literal"><span class="pre">atof()</span></code></a> and <a class="reference internal" href="#locale.str" title="locale.str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> of the <a class="reference internal" href="#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a> module are affected by that category. </span><span class="yiyi-st" id="yiyi-226">所有其他数字格式化操作不受影响。</span></p></dd></dl><dl class="data"><dt id="locale.LC_ALL"><span class="yiyi-st" id="yiyi-227"> <code class="descclassname">locale.</code><code class="descname">LC_ALL</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-228">所有区域设置的组合。</span><span class="yiyi-st" id="yiyi-229">如果在更改区域设置时使用此标志，则尝试设置所有类别的区域设置。</span><span class="yiyi-st" id="yiyi-230">如果对于任何类别失败，则不改变任何类别。</span><span class="yiyi-st" id="yiyi-231">当使用此标志检索语言环境时，将返回指示所有类别的设置的字符串。</span><span class="yiyi-st" id="yiyi-232">此字符串可以稍后用于恢复设置。</span></p></dd></dl><dl class="data"><dt id="locale.CHAR_MAX"><span class="yiyi-st" id="yiyi-233"> <code class="descclassname">locale.</code><code class="descname">CHAR_MAX</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-234">这是用于<a class="reference internal" href="#locale.localeconv" title="locale.localeconv"><code class="xref py py-func docutils literal"><span class="pre">localeconv()</span></code></a>返回的不同值的符号常量。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-235">例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">locale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loc</span> <span class="o">=</span> <span class="n">locale</span><span class="o">.</span><span class="n">getlocale</span><span class="p">()</span>  <span class="c1"># get current locale</span>
<span class="go"># use German locale; name might vary with platform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locale</span><span class="o">.</span><span class="n">setlocale</span><span class="p">(</span><span class="n">locale</span><span class="o">.</span><span class="n">LC_ALL</span><span class="p">,</span> <span class="s1">'de_DE'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locale</span><span class="o">.</span><span class="n">strcoll</span><span class="p">(</span><span class="s1">'f</span><span class="se">\xe4</span><span class="s1">n'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span>  <span class="c1"># compare a string containing an umlaut</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locale</span><span class="o">.</span><span class="n">setlocale</span><span class="p">(</span><span class="n">locale</span><span class="o">.</span><span class="n">LC_ALL</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>   <span class="c1"># use user's preferred locale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locale</span><span class="o">.</span><span class="n">setlocale</span><span class="p">(</span><span class="n">locale</span><span class="o">.</span><span class="n">LC_ALL</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">)</span>  <span class="c1"># use default (C) locale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locale</span><span class="o">.</span><span class="n">setlocale</span><span class="p">(</span><span class="n">locale</span><span class="o">.</span><span class="n">LC_ALL</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>  <span class="c1"># restore saved locale</span>
</code></pre><div class="section" id="background-details-hints-tips-and-caveats"><h2><span class="yiyi-st" id="yiyi-236">23.2.1. </span><span class="yiyi-st" id="yiyi-237">Background, details, hints, tips and caveats</span></h2><p><span class="yiyi-st" id="yiyi-238">C标准将区域设置定义为程序范围的属性，其可能相对昂贵以改变。</span><span class="yiyi-st" id="yiyi-239">最重要的是，一些实现被破坏，频繁的区域设置更改可能会导致核心转储。</span><span class="yiyi-st" id="yiyi-240">这使得locale有点痛苦，正确使用。</span></p><p><span class="yiyi-st" id="yiyi-241">最初，当程序启动时，区域设置是<code class="docutils literal"><span class="pre">C</span></code>区域设置，无论用户的首选区域设置是什么。</span><span class="yiyi-st" id="yiyi-242">有一个例外：在启动时更改<a class="reference internal" href="#locale.LC_CTYPE" title="locale.LC_CTYPE"><code class="xref py py-data docutils literal"><span class="pre">LC_CTYPE</span></code></a>类别，将当前语言环境编码设置为用户首选语言环境编码。</span><span class="yiyi-st" id="yiyi-243">程序必须通过调用<code class="docutils literal"><span class="pre">setlocale（LC_ALL，</span> <span class="pre">“'）</span></code>来明确表示需要用户对其他类别的首选语言环境设置。</span></p><p><span class="yiyi-st" id="yiyi-244">在一些库例程中调用<a class="reference internal" href="#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal"><span class="pre">setlocale()</span></code></a>通常是个坏主意，因为作为副作用它影响整个程序。</span><span class="yiyi-st" id="yiyi-245">保存和恢复它几乎同样糟糕：它是昂贵的，并影响在设置恢复之前运行的其他线程。</span></p><p><span class="yiyi-st" id="yiyi-246">如果在为一般使用的模块编码时，需要受语言环境影响的操作的语言环境独立版本（例如与<a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>一起使用的某些格式），则必须找到一种方法来做，而不使用标准库程序。</span><span class="yiyi-st" id="yiyi-247">更好的是说服自己使用区域设置是好的。</span><span class="yiyi-st" id="yiyi-248">作为最后的手段，您应该记录您的模块与非<code class="docutils literal"><span class="pre">C</span></code>区域设置不兼容。</span></p><p><span class="yiyi-st" id="yiyi-249">根据语言环境执行数字操作的唯一方法是使用此模块定义的特殊函数：<a class="reference internal" href="#locale.atof" title="locale.atof"><code class="xref py py-func docutils literal"><span class="pre">atof()</span></code></a>，<a class="reference internal" href="#locale.atoi" title="locale.atoi"><code class="xref py py-func docutils literal"><span class="pre">atoi()</span></code></a>，<a class="reference internal" href="#locale.format" title="locale.format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a>，<a class="reference internal" href="#locale.str" title="locale.str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-250">没有办法根据语言环境执行案例转换和字符分类。</span><span class="yiyi-st" id="yiyi-251">对于（Unicode）文本字符串，这些仅根据字符值完成，而对于字节字符串，转换和分类根据字节的ASCII值以及设置高位的字节（即，非ASCII字节）永远不会被转换或视为字符类的一部分，例如字母或空格。</span></p></div><div class="section" id="for-extension-writers-and-programs-that-embed-python"><h2><span class="yiyi-st" id="yiyi-252">23.2.2. </span><span class="yiyi-st" id="yiyi-253">For extension writers and programs that embed Python</span></h2><p><span class="yiyi-st" id="yiyi-254">扩展模块不应调用<a class="reference internal" href="#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal"><span class="pre">setlocale()</span></code></a>，除非找出当前语言环境。</span><span class="yiyi-st" id="yiyi-255">但是由于返回值只能用于可移植地恢复它，这不是非常有用（除非可能找出区域设置是否<code class="docutils literal"><span class="pre">C</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-256">当Python代码使用<a class="reference internal" href="#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a>模块更改语言环境时，这也会影响嵌入应用程序。</span><span class="yiyi-st" id="yiyi-257">If the embedding application doesn’t want this to happen, it should remove the <code class="xref py py-mod docutils literal"><span class="pre">_locale</span></code> extension module (which does all the work) from the table of built-in modules in the <code class="file docutils literal"><span class="pre">config.c</span></code> file, and make sure that the <code class="xref py py-mod docutils literal"><span class="pre">_locale</span></code> module is not accessible as a shared library.</span></p></div><div class="section" id="access-to-message-catalogs"><h2><span class="yiyi-st" id="yiyi-258">23.2.3. </span><span class="yiyi-st" id="yiyi-259">Access to message catalogs</span></h2><p><span class="yiyi-st" id="yiyi-260">locale模块在提供此接口的系统上公开了C库的gettext接口。</span><span class="yiyi-st" id="yiyi-261">It consists of the functions <a class="reference internal" href="gettext.html#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-func docutils literal"><span class="pre">gettext()</span></code></a>, <code class="xref py py-func docutils literal"><span class="pre">dgettext()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">dcgettext()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">textdomain()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">bindtextdomain()</span></code>, and <code class="xref py py-func docutils literal"><span class="pre">bind_textdomain_codeset()</span></code>. </span><span class="yiyi-st" id="yiyi-262">这些类似于<a class="reference internal" href="gettext.html#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">gettext</span></code></a>模块中的相同功能，但是对于消息目录使用C库的二进制格式，并且使用C库的搜索算法来定位消息目录。</span></p><p><span class="yiyi-st" id="yiyi-263">Python应用程序通常不需要调用这些函数，应该使用<a class="reference internal" href="gettext.html#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">gettext</span></code></a>。</span><span class="yiyi-st" id="yiyi-264">此规则的一个已知异常是应用程序与内部调用<code class="xref c c-func docutils literal"><span class="pre">gettext()</span></code>或<code class="xref py py-func docutils literal"><span class="pre">dcgettext()</span></code>的其他C库链接。</span><span class="yiyi-st" id="yiyi-265">对于这些应用程序，可能需要绑定文本域，以便库可以正确定位其消息目录。</span></p></div></div></div>