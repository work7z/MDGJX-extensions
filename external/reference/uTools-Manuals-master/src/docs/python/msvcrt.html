<div class="body" role="main"><div class="section" id="module-msvcrt"><h1><span class="yiyi-st" id="yiyi-10">34.2. <a class="reference internal" href="#module-msvcrt" title="msvcrt: Miscellaneous useful routines from the MS VC++ runtime. (Windows)"><code class="xref py py-mod docutils literal"><span class="pre">msvcrt</span></code></a>  - 从MS VC ++运行时的有用例程</span></h1><p><span class="yiyi-st" id="yiyi-11">这些函数提供对Windows平台上一些有用功能的访问。</span><span class="yiyi-st" id="yiyi-12">一些更高级别的模块使用这些功能来构建他们的服务的Windows实现。</span><span class="yiyi-st" id="yiyi-13">例如，<a class="reference internal" href="getpass.html#module-getpass" title="getpass: Portable reading of passwords and retrieval of the userid."><code class="xref py py-mod docutils literal"><span class="pre">getpass</span></code></a>模块在实现<a class="reference internal" href="getpass.html#module-getpass" title="getpass: Portable reading of passwords and retrieval of the userid."><code class="xref py py-func docutils literal"><span class="pre">getpass()</span></code></a>函数时使用此方法。</span></p><p><span class="yiyi-st" id="yiyi-14">有关这些功能的更多文档可以在Platform API文档中找到。</span></p><p><span class="yiyi-st" id="yiyi-15">该模块实现控制台I / O API的正常和宽字符变量。</span><span class="yiyi-st" id="yiyi-16">普通API仅处理ASCII字符，并且对于国际化应用程序的使用有限。</span><span class="yiyi-st" id="yiyi-17">应尽可能使用宽字符API。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-18"><span class="versionmodified">在版本3.3中更改：</span>此模块中的操作现已引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>其中<a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a>被引发。</span></p></div><div class="section" id="file-operations"><h2><span class="yiyi-st" id="yiyi-19">34.2.1. </span><span class="yiyi-st" id="yiyi-20">File Operations</span></h2><dl class="function"><dt id="msvcrt.locking"><span class="yiyi-st" id="yiyi-21"> <code class="descclassname">msvcrt.</code><code class="descname">locking</code><span class="sig-paren">(</span><em>fd</em>, <em>mode</em>, <em>nbytes</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-22">根据C运行时文件描述器<em>fd</em>锁定文件的一部分。</span><span class="yiyi-st" id="yiyi-23">失败时引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span><span class="yiyi-st" id="yiyi-24">文件的锁定区域从<em>nbytes</em>字节的当前文件位置延伸，并且可以继续超出文件结尾。</span><span class="yiyi-st" id="yiyi-25"><em>模式</em>必须是下面列出的<code class="xref py py-const docutils literal"><span class="pre">LK_*</span></code>常量之一。</span><span class="yiyi-st" id="yiyi-26">文件中的多个区域可以同时被锁定，但是可以不重叠。</span><span class="yiyi-st" id="yiyi-27">相邻区域不合并；它们必须单独解锁。</span></p></dd></dl><dl class="data"><dt id="msvcrt.LK_LOCK"><span class="yiyi-st" id="yiyi-28"> <code class="descclassname">msvcrt.</code><code class="descname">LK_LOCK</code></span></dt><dt id="msvcrt.LK_RLCK"><span class="yiyi-st" id="yiyi-29"> <code class="descclassname">msvcrt.</code><code class="descname">LK_RLCK</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-30">锁定指定的字节。</span><span class="yiyi-st" id="yiyi-31">如果字节不能被锁定，程序在1秒后立即再次尝试。</span><span class="yiyi-st" id="yiyi-32">如果在尝试10次后，字节不能被锁定，则会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></dd></dl><dl class="data"><dt id="msvcrt.LK_NBLCK"><span class="yiyi-st" id="yiyi-33"> <code class="descclassname">msvcrt.</code><code class="descname">LK_NBLCK</code></span></dt><dt id="msvcrt.LK_NBRLCK"><span class="yiyi-st" id="yiyi-34"> <code class="descclassname">msvcrt.</code><code class="descname">LK_NBRLCK</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-35">锁定指定的字节。</span><span class="yiyi-st" id="yiyi-36">如果字节不能锁定，则会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></dd></dl><dl class="data"><dt id="msvcrt.LK_UNLCK"><span class="yiyi-st" id="yiyi-37"> <code class="descclassname">msvcrt.</code><code class="descname">LK_UNLCK</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-38">解锁指定的字节，必须先前已锁定。</span></p></dd></dl><dl class="function"><dt id="msvcrt.setmode"><span class="yiyi-st" id="yiyi-39"> <code class="descclassname">msvcrt.</code><code class="descname">setmode</code><span class="sig-paren">(</span><em>fd</em>, <em>flags</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-40">设置文件描述器<em>fd</em>的行末翻译模式。</span><span class="yiyi-st" id="yiyi-41">要将其设置为文本模式，<em>标志</em>应为<a class="reference internal" href="os.html#os.O_TEXT" title="os.O_TEXT"><code class="xref py py-const docutils literal"><span class="pre">os.O_TEXT</span></code></a>；对于二进制，应为<a class="reference internal" href="os.html#os.O_BINARY" title="os.O_BINARY"><code class="xref py py-const docutils literal"><span class="pre">os.O_BINARY</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="msvcrt.open_osfhandle"><span class="yiyi-st" id="yiyi-42"> <code class="descclassname">msvcrt.</code><code class="descname">open_osfhandle</code><span class="sig-paren">(</span><em>handle</em>, <em>flags</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-43">从文件句柄<em>句柄</em>创建C运行时文件描述器。</span><span class="yiyi-st" id="yiyi-44"><em>标志</em>参数应为<a class="reference internal" href="os.html#os.O_APPEND" title="os.O_APPEND"><code class="xref py py-const docutils literal"><span class="pre">os.O_APPEND</span></code></a>，<a class="reference internal" href="os.html#os.O_RDONLY" title="os.O_RDONLY"><code class="xref py py-const docutils literal"><span class="pre">os.O_RDONLY</span></code></a>和<a class="reference internal" href="os.html#os.O_TEXT" title="os.O_TEXT"><code class="xref py py-const docutils literal"><span class="pre">os.O_TEXT</span></code></a>的按位或。</span><span class="yiyi-st" id="yiyi-45">返回的文件描述器可以用作<a class="reference internal" href="os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">os.fdopen()</span></code></a>的参数来创建文件对象。</span></p></dd></dl><dl class="function"><dt id="msvcrt.get_osfhandle"><span class="yiyi-st" id="yiyi-46"> <code class="descclassname">msvcrt.</code><code class="descname">get_osfhandle</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-47">返回文件描述器<em>fd</em>的文件句柄。</span><span class="yiyi-st" id="yiyi-48">引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>如果<em>fd</em>无法识别。</span></p></dd></dl></div><div class="section" id="console-i-o"><h2><span class="yiyi-st" id="yiyi-49">34.2.2. </span><span class="yiyi-st" id="yiyi-50">Console I/O</span></h2><dl class="function"><dt id="msvcrt.kbhit"><span class="yiyi-st" id="yiyi-51"> <code class="descclassname">msvcrt.</code><code class="descname">kbhit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-52">如果键盘正在等待读取，则返回true。</span></p></dd></dl><dl class="function"><dt id="msvcrt.getch"><span class="yiyi-st" id="yiyi-53"> <code class="descclassname">msvcrt.</code><code class="descname">getch</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-54">读取按键并将结果字符作为字节字符串返回。</span><span class="yiyi-st" id="yiyi-55">没有回声到控制台。</span><span class="yiyi-st" id="yiyi-56">如果按键不可用，则此调用将阻止，但不会等待按下<code class="kbd docutils literal"><span class="pre">Enter</span></code>。</span><span class="yiyi-st" id="yiyi-57">如果按下的键是特殊功能键，则将返回<code class="docutils literal"><span class="pre">'\000'</span></code>或<code class="docutils literal"><span class="pre">'\xe0'</span></code>；下一个调用将返回键码。</span><span class="yiyi-st" id="yiyi-58">使用此功能无法读取<code class="kbd docutils literal"><span class="pre">Control-C</span></code>按键。</span></p></dd></dl><dl class="function"><dt id="msvcrt.getwch"><span class="yiyi-st" id="yiyi-59"> <code class="descclassname">msvcrt.</code><code class="descname">getwch</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-60"><a class="reference internal" href="#msvcrt.getch" title="msvcrt.getch"><code class="xref py py-func docutils literal"><span class="pre">getch()</span></code></a>的宽字符变量，返回Unicode值。</span></p></dd></dl><dl class="function"><dt id="msvcrt.getche"><span class="yiyi-st" id="yiyi-61"> <code class="descclassname">msvcrt.</code><code class="descname">getche</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-62">类似于<a class="reference internal" href="#msvcrt.getch" title="msvcrt.getch"><code class="xref py py-func docutils literal"><span class="pre">getch()</span></code></a>，但是如果它代表一个可打印的字符，keypress将被回显。</span></p></dd></dl><dl class="function"><dt id="msvcrt.getwche"><span class="yiyi-st" id="yiyi-63"> <code class="descclassname">msvcrt.</code><code class="descname">getwche</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-64"><a class="reference internal" href="#msvcrt.getche" title="msvcrt.getche"><code class="xref py py-func docutils literal"><span class="pre">getche()</span></code></a>的宽字符变体，返回Unicode值。</span></p></dd></dl><dl class="function"><dt id="msvcrt.putch"><span class="yiyi-st" id="yiyi-65"> <code class="descclassname">msvcrt.</code><code class="descname">putch</code><span class="sig-paren">(</span><em>char</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-66">将字节字符串<em>char</em>打印到控制台，无需缓冲。</span></p></dd></dl><dl class="function"><dt id="msvcrt.putwch"><span class="yiyi-st" id="yiyi-67"> <code class="descclassname">msvcrt.</code><code class="descname">putwch</code><span class="sig-paren">(</span><em>unicode_char</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-68">宽字符变体<a class="reference internal" href="#msvcrt.putch" title="msvcrt.putch"><code class="xref py py-func docutils literal"><span class="pre">putch()</span></code></a>，接受Unicode值。</span></p></dd></dl><dl class="function"><dt id="msvcrt.ungetch"><span class="yiyi-st" id="yiyi-69"> <code class="descclassname">msvcrt.</code><code class="descname">ungetch</code><span class="sig-paren">(</span><em>char</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-70">导致字节串<em>char</em>被“推回”到控制台缓冲区；它将是由<a class="reference internal" href="#msvcrt.getch" title="msvcrt.getch"><code class="xref py py-func docutils literal"><span class="pre">getch()</span></code></a>或<a class="reference internal" href="#msvcrt.getche" title="msvcrt.getche"><code class="xref py py-func docutils literal"><span class="pre">getche()</span></code></a>读取的下一个字符。</span></p></dd></dl><dl class="function"><dt id="msvcrt.ungetwch"><span class="yiyi-st" id="yiyi-71"> <code class="descclassname">msvcrt.</code><code class="descname">ungetwch</code><span class="sig-paren">(</span><em>unicode_char</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-72"><a class="reference internal" href="#msvcrt.ungetch" title="msvcrt.ungetch"><code class="xref py py-func docutils literal"><span class="pre">ungetch()</span></code></a>的宽字符变体，接受Unicode值。</span></p></dd></dl></div><div class="section" id="other-functions"><h2><span class="yiyi-st" id="yiyi-73">34.2.3. </span><span class="yiyi-st" id="yiyi-74">Other Functions</span></h2><dl class="function"><dt id="msvcrt.heapmin"><span class="yiyi-st" id="yiyi-75"> <code class="descclassname">msvcrt.</code><code class="descname">heapmin</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-76">强制<code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code>堆清理自己并将未使用的块返回到操作系统。</span><span class="yiyi-st" id="yiyi-77">失败时，此引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></dd></dl></div></div></div>