<div class="body" role="main"><div class="section" id="module-xml.parsers.expat"><h1><span class="yiyi-st" id="yiyi-10">20.13. <a class="reference internal" href="#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal"><span class="pre">xml.parsers.expat</span></code></a>  - 使用Expat </span></h1><div class="admonition warning"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-11">警告</span></p><p class="last"><span class="yiyi-st" id="yiyi-12"><code class="xref py py-mod docutils literal"><span class="pre">pyexpat</span></code>模块对于恶意构造的数据不安全。</span><span class="yiyi-st" id="yiyi-13">如果需要解析不受信任或未经身份验证的数据，请参阅<a class="reference internal" href="xml.html#xml-vulnerabilities"><span>XML vulnerabilities</span></a>。</span></p></div><p id="index-0"><span class="yiyi-st" id="yiyi-14"><a class="reference internal" href="#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal"><span class="pre">xml.parsers.expat</span></code></a>模块是Expat非验证XML解析器的Python接口。</span><span class="yiyi-st" id="yiyi-15">模块提供了一个单一的扩展类型，<code class="xref py py-class docutils literal"><span class="pre">xmlparser</span></code>，它表示XML解析器的当前状态。</span><span class="yiyi-st" id="yiyi-16">在创建了<code class="xref py py-class docutils literal"><span class="pre">xmlparser</span></code>对象后，可以将对象的各种属性设置为处理函数。</span><span class="yiyi-st" id="yiyi-17">当XML文档然后被馈送到解析器时，为XML文档中的字符数据和标记调用处理程序函数。</span></p><p id="index-1"><span class="yiyi-st" id="yiyi-18">此模块使用<code class="xref py py-mod docutils literal"><span class="pre">pyexpat</span></code>模块提供对Expat解析器的访问。</span><span class="yiyi-st" id="yiyi-19">不推荐直接使用<code class="xref py py-mod docutils literal"><span class="pre">pyexpat</span></code>模块。</span></p><p><span class="yiyi-st" id="yiyi-20">此模块提供一个异常和一个类型对象：</span></p><dl class="exception"><dt id="xml.parsers.expat.ExpatError"><span class="yiyi-st" id="yiyi-21"> <em class="property">exception </em><code class="descclassname">xml.parsers.expat.</code><code class="descname">ExpatError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-22">当Expat报告错误时引发异常。</span><span class="yiyi-st" id="yiyi-23">有关解释Expat错误的更多信息，请参阅<a class="reference internal" href="#expaterror-objects"><span>ExpatError Exceptions</span></a>一节。</span></p></dd></dl><dl class="exception"><dt id="xml.parsers.expat.error"><span class="yiyi-st" id="yiyi-24"> <em class="property">exception </em><code class="descclassname">xml.parsers.expat.</code><code class="descname">error</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-25"><a class="reference internal" href="#xml.parsers.expat.ExpatError" title="xml.parsers.expat.ExpatError"><code class="xref py py-exc docutils literal"><span class="pre">ExpatError</span></code></a>的别名。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.XMLParserType"><span class="yiyi-st" id="yiyi-26"> <code class="descclassname">xml.parsers.expat.</code><code class="descname">XMLParserType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-27">来自<a class="reference internal" href="#xml.parsers.expat.ParserCreate" title="xml.parsers.expat.ParserCreate"><code class="xref py py-func docutils literal"><span class="pre">ParserCreate()</span></code></a>函数的返回值的类型。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-28"><a class="reference internal" href="#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal"><span class="pre">xml.parsers.expat</span></code></a>模块包含两个函数：</span></p><dl class="function"><dt id="xml.parsers.expat.ErrorString"><span class="yiyi-st" id="yiyi-29"> <code class="descclassname">xml.parsers.expat.</code><code class="descname">ErrorString</code><span class="sig-paren">(</span><em>errno</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-30">返回给定错误号<em>errno</em>的说明字符串。</span></p></dd></dl><dl class="function"><dt id="xml.parsers.expat.ParserCreate"><span class="yiyi-st" id="yiyi-31"> <code class="descclassname">xml.parsers.expat.</code><code class="descname">ParserCreate</code><span class="sig-paren">(</span><em>encoding=None</em>, <em>namespace_separator=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-32">创建并返回一个新的<code class="xref py py-class docutils literal"><span class="pre">xmlparser</span></code>对象。</span><span class="yiyi-st" id="yiyi-33"><em>encoding</em>（如果指定）必须是用于命名XML数据所使用的编码的字符串。</span><span class="yiyi-st" id="yiyi-34">Expat不支持和Python一样多的编码，编码的编码不能扩展；它支持UTF-8，UTF-16，ISO-8859-1（Latin1）和ASCII。</span><span class="yiyi-st" id="yiyi-35">如果给定<em>encoding</em> <a class="footnote-reference" href="#id3" id="id1">[1]</a>，它将覆盖文档的隐式或显式编码。</span></p><p><span class="yiyi-st" id="yiyi-36">Expat可以为您选择执行XML命名空间处理，通过为<em>namespace_separator</em>提供值来启用。</span><span class="yiyi-st" id="yiyi-37">The value must be a one-character string; a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> will be raised if the string has an illegal length (<code class="docutils literal"><span class="pre">None</span></code> is considered the same as omission). </span><span class="yiyi-st" id="yiyi-38">启用命名空间处理时，将扩展属于命名空间的元素类型名称和属性名称。</span><span class="yiyi-st" id="yiyi-39">传递给元素处理程序<code class="xref py py-attr docutils literal"><span class="pre">StartElementHandler</span></code>和<code class="xref py py-attr docutils literal"><span class="pre">EndElementHandler</span></code>的元素名称将是命名空间URI，命名空间分隔符字符和名称的本地部分的连接。</span><span class="yiyi-st" id="yiyi-40">如果命名空间分隔符是一个零字节（<code class="docutils literal"><span class="pre">chr(0)</span></code>），那么命名空间URI和本地部分将被连接而没有任何分隔符。</span></p><p><span class="yiyi-st" id="yiyi-41">例如，如果<em>namespace_separator</em>设置为空格字符（<code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code>），并解析以下文档：</span></p><div class="highlight-xml"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version="1.0"?&gt;</span>
<span class="nt">&lt;root</span> <span class="na">xmlns    =</span> <span class="s">"http://default-namespace.org/"</span>
      <span class="na">xmlns:py =</span> <span class="s">"http://www.python.org/ns/"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;py:elem1</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;elem2</span> <span class="na">xmlns=</span><span class="s">""</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/root&gt;</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-42"><code class="xref py py-attr docutils literal"><span class="pre">StartElementHandler</span></code>将为每个元素接收以下字符串：</span></p><pre><code class="language-python"><span></span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">default</span><span class="o">-</span><span class="n">namespace</span><span class="o">.</span><span class="n">org</span><span class="o">/</span> <span class="n">root</span>
<span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">ns</span><span class="o">/</span> <span class="n">elem1</span>
<span class="n">elem2</span>
</code></pre><p><span class="yiyi-st" id="yiyi-43">由于<code class="xref py py-mod docutils literal"><span class="pre">pyexpat</span></code>使用的<code class="docutils literal"><span class="pre">Expat</span></code>库的限制，返回的<code class="xref py py-class docutils literal"><span class="pre">xmlparser</span></code>实例只能用于解析单个XML文档。</span><span class="yiyi-st" id="yiyi-44">对每个文档调用<code class="docutils literal"><span class="pre">ParserCreate</span></code>以提供唯一的解析器实例。</span></p></dd></dl><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-45">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-46"><a class="reference external" href="http://www.libexpat.org/">Expat XML解析器</a></span></dt><dd><span class="yiyi-st" id="yiyi-47">Expat项目的主页。</span></dd></dl></div><div class="section" id="xmlparser-objects"><h2><span class="yiyi-st" id="yiyi-48">20.13.1. </span><span class="yiyi-st" id="yiyi-49">XMLParser Objects</span></h2><p><span class="yiyi-st" id="yiyi-50"><code class="xref py py-class docutils literal"><span class="pre">xmlparser</span></code>对象具有以下方法：</span></p><dl class="method"><dt id="xml.parsers.expat.xmlparser.Parse"><span class="yiyi-st" id="yiyi-51"> <code class="descclassname">xmlparser.</code><code class="descname">Parse</code><span class="sig-paren">(</span><em>data</em><span class="optional">[</span>, <em>isfinal</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-52">解析字符串<em>data</em>的内容，调用相应的处理函数来处理解析的数据。</span><span class="yiyi-st" id="yiyi-53"><em>isfinal</em>在最终调用此方法时必须为true；它允许在片段中解析单个文件，而不是提交多个文件。</span><span class="yiyi-st" id="yiyi-54"><em>数据</em>可以是任何时候的空字符串。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.ParseFile"><span class="yiyi-st" id="yiyi-55"> <code class="descclassname">xmlparser.</code><code class="descname">ParseFile</code><span class="sig-paren">(</span><em>file</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-56">解析对象<em>文件</em>中的XML数据读取。</span><span class="yiyi-st" id="yiyi-57"><em>文件</em>只需提供<code class="docutils literal"><span class="pre">read(nbytes)</span></code>方法，当没有更多数据时返回空字符串。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.SetBase"><span class="yiyi-st" id="yiyi-58"> <code class="descclassname">xmlparser.</code><code class="descname">SetBase</code><span class="sig-paren">(</span><em>base</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-59">设置用于解析声明中系统标识符中的相对URI的基址。</span><span class="yiyi-st" id="yiyi-60">解析相对标识符留给应用程序：该值将作为<a class="reference internal" href="#xml.parsers.expat.xmlparser.ExternalEntityRefHandler" title="xml.parsers.expat.xmlparser.ExternalEntityRefHandler"><code class="xref py py-func docutils literal"><span class="pre">ExternalEntityRefHandler()</span></code></a>，<a class="reference internal" href="#xml.parsers.expat.xmlparser.NotationDeclHandler" title="xml.parsers.expat.xmlparser.NotationDeclHandler"><code class="xref py py-func docutils literal"><span class="pre">NotationDeclHandler()</span></code></a>的<em>基址</em>和<a class="reference internal" href="#xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler" title="xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler"><code class="xref py py-func docutils literal"><span class="pre">UnparsedEntityDeclHandler()</span></code></a>函数。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.GetBase"><span class="yiyi-st" id="yiyi-61"> <code class="descclassname">xmlparser.</code><code class="descname">GetBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-62">如果<a class="reference internal" href="#xml.parsers.expat.xmlparser.SetBase" title="xml.parsers.expat.xmlparser.SetBase"><code class="xref py py-meth docutils literal"><span class="pre">SetBase()</span></code></a>未被调用，则返回一个包含先前调用<a class="reference internal" href="#xml.parsers.expat.xmlparser.SetBase" title="xml.parsers.expat.xmlparser.SetBase"><code class="xref py py-meth docutils literal"><span class="pre">SetBase()</span></code></a>或<code class="docutils literal"><span class="pre">None</span></code></span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.GetInputContext"><span class="yiyi-st" id="yiyi-63"> <code class="descclassname">xmlparser.</code><code class="descname">GetInputContext</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-64">以字符串形式返回生成当前事件的输入数据。</span><span class="yiyi-st" id="yiyi-65">数据在包含文本的实体的编码中。</span><span class="yiyi-st" id="yiyi-66">在事件处理程序未激活时调用时，返回值为<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.ExternalEntityParserCreate"><span class="yiyi-st" id="yiyi-67"> <code class="descclassname">xmlparser.</code><code class="descname">ExternalEntityParserCreate</code><span class="sig-paren">(</span><em>context</em><span class="optional">[</span>, <em>encoding</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-68">创建一个“子”解析器，可用于解析由父解析器解析的内容引用的外部解析实体。</span><span class="yiyi-st" id="yiyi-69"><em>上下文</em>参数应该是传递给<a class="reference internal" href="#xml.parsers.expat.xmlparser.ExternalEntityRefHandler" title="xml.parsers.expat.xmlparser.ExternalEntityRefHandler"><code class="xref py py-meth docutils literal"><span class="pre">ExternalEntityRefHandler()</span></code></a>处理函数的字符串，如下所述。</span><span class="yiyi-st" id="yiyi-70">使用设置为此解析器的值的<a class="reference internal" href="#xml.parsers.expat.xmlparser.ordered_attributes" title="xml.parsers.expat.xmlparser.ordered_attributes"><code class="xref py py-attr docutils literal"><span class="pre">ordered_attributes</span></code></a>和<a class="reference internal" href="#xml.parsers.expat.xmlparser.specified_attributes" title="xml.parsers.expat.xmlparser.specified_attributes"><code class="xref py py-attr docutils literal"><span class="pre">specified_attributes</span></code></a>创建子解析器。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.SetParamEntityParsing"><span class="yiyi-st" id="yiyi-71"> <code class="descclassname">xmlparser.</code><code class="descname">SetParamEntityParsing</code><span class="sig-paren">(</span><em>flag</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-72">参数实体的控制解析（包括外部DTD子集）。</span><span class="yiyi-st" id="yiyi-73">可能的<em>标志</em>值为<code class="xref py py-const docutils literal"><span class="pre">XML_PARAM_ENTITY_PARSING_NEVER</span></code>，<code class="xref py py-const docutils literal"><span class="pre">XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE</span></code>和<code class="xref py py-const docutils literal"><span class="pre">XML_PARAM_ENTITY_PARSING_ALWAYS</span></code>。</span><span class="yiyi-st" id="yiyi-74">如果设置标志成功，则返回true。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.UseForeignDTD"><span class="yiyi-st" id="yiyi-75"> <code class="descclassname">xmlparser.</code><code class="descname">UseForeignDTD</code><span class="sig-paren">(</span><span class="optional">[</span><em>flag</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-76">使用<em>标志</em>（默认值）的真值调用此函数将导致Expat使用<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>为所有参数调用<a class="reference internal" href="#xml.parsers.expat.xmlparser.ExternalEntityRefHandler" title="xml.parsers.expat.xmlparser.ExternalEntityRefHandler"><code class="xref py py-attr docutils literal"><span class="pre">ExternalEntityRefHandler</span></code></a>，以允许备用DTD加载。</span><span class="yiyi-st" id="yiyi-77">如果文档不包含文档类型声明，则仍会调用<a class="reference internal" href="#xml.parsers.expat.xmlparser.ExternalEntityRefHandler" title="xml.parsers.expat.xmlparser.ExternalEntityRefHandler"><code class="xref py py-attr docutils literal"><span class="pre">ExternalEntityRefHandler</span></code></a>，但不会调用<a class="reference internal" href="#xml.parsers.expat.xmlparser.StartDoctypeDeclHandler" title="xml.parsers.expat.xmlparser.StartDoctypeDeclHandler"><code class="xref py py-attr docutils literal"><span class="pre">StartDoctypeDeclHandler</span></code></a>和<a class="reference internal" href="#xml.parsers.expat.xmlparser.EndDoctypeDeclHandler" title="xml.parsers.expat.xmlparser.EndDoctypeDeclHandler"><code class="xref py py-attr docutils literal"><span class="pre">EndDoctypeDeclHandler</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-78">为<em>标志</em>传递false值将取消传递true值的以前调用，但其他方式没有效果。</span></p><p><span class="yiyi-st" id="yiyi-79">This method can only be called before the <a class="reference internal" href="#xml.parsers.expat.xmlparser.Parse" title="xml.parsers.expat.xmlparser.Parse"><code class="xref py py-meth docutils literal"><span class="pre">Parse()</span></code></a> or <a class="reference internal" href="#xml.parsers.expat.xmlparser.ParseFile" title="xml.parsers.expat.xmlparser.ParseFile"><code class="xref py py-meth docutils literal"><span class="pre">ParseFile()</span></code></a> methods are called; calling it after either of those have been called causes <a class="reference internal" href="#xml.parsers.expat.ExpatError" title="xml.parsers.expat.ExpatError"><code class="xref py py-exc docutils literal"><span class="pre">ExpatError</span></code></a> to be raised with the <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-attr docutils literal"><span class="pre">code</span></code></a> attribute set to <code class="docutils literal"><span class="pre">errors.codes[errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING]</span></code>.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-80"><code class="xref py py-class docutils literal"><span class="pre">xmlparser</span></code>对象具有以下属性：</span></p><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.buffer_size"><span class="yiyi-st" id="yiyi-81"> <code class="descclassname">xmlparser.</code><code class="descname">buffer_size</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-82"><a class="reference internal" href="#xml.parsers.expat.xmlparser.buffer_text" title="xml.parsers.expat.xmlparser.buffer_text"><code class="xref py py-attr docutils literal"><span class="pre">buffer_text</span></code></a>为真时使用的缓冲区大小。</span><span class="yiyi-st" id="yiyi-83">可以通过为此属性分配一个新的整数值来设置新的缓冲区大小。</span><span class="yiyi-st" id="yiyi-84">当大小改变时，缓冲区将被刷新。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.buffer_text"><span class="yiyi-st" id="yiyi-85"> <code class="descclassname">xmlparser.</code><code class="descname">buffer_text</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-86">将此设置为true会使<code class="xref py py-class docutils literal"><span class="pre">xmlparser</span></code>对象缓冲Expat返回的文本内容，以避免对可能的<a class="reference internal" href="#xml.parsers.expat.xmlparser.CharacterDataHandler" title="xml.parsers.expat.xmlparser.CharacterDataHandler"><code class="xref py py-meth docutils literal"><span class="pre">CharacterDataHandler()</span></code></a>回调的多次调用。</span><span class="yiyi-st" id="yiyi-87">这可以大大提高性能，因为Expat通常在每行结尾将字符数据分成块。</span><span class="yiyi-st" id="yiyi-88">默认情况下，此属性为false，并且可以随时更改。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.buffer_used"><span class="yiyi-st" id="yiyi-89"> <code class="descclassname">xmlparser.</code><code class="descname">buffer_used</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">如果启用<a class="reference internal" href="#xml.parsers.expat.xmlparser.buffer_text" title="xml.parsers.expat.xmlparser.buffer_text"><code class="xref py py-attr docutils literal"><span class="pre">buffer_text</span></code></a>，则存储在缓冲区中的字节数。</span><span class="yiyi-st" id="yiyi-91">这些字节表示UTF-8编码的文本。</span><span class="yiyi-st" id="yiyi-92">当<a class="reference internal" href="#xml.parsers.expat.xmlparser.buffer_text" title="xml.parsers.expat.xmlparser.buffer_text"><code class="xref py py-attr docutils literal"><span class="pre">buffer_text</span></code></a>为false时，此属性没有有意义的解释。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.ordered_attributes"><span class="yiyi-st" id="yiyi-93"> <code class="descclassname">xmlparser.</code><code class="descname">ordered_attributes</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">将此属性设置为非零整数会导致将属性报告为列表而不是字典。</span><span class="yiyi-st" id="yiyi-95">属性以文档文本中找到的顺序显示。</span><span class="yiyi-st" id="yiyi-96">对于每个属性，呈现两个列表条目：属性名称和属性值。</span><span class="yiyi-st" id="yiyi-97">（此模块的旧版本也使用此格式。）</span><span class="yiyi-st" id="yiyi-98">默认情况下，此属性为false；它可以随时更改。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.specified_attributes"><span class="yiyi-st" id="yiyi-99"> <code class="descclassname">xmlparser.</code><code class="descname">specified_attributes</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-100">如果设置为非零整数，解析器将仅报告在文档实例中指定的那些属性，而不是从属性声明派生的那些属性。</span><span class="yiyi-st" id="yiyi-101">设置这一点的应用程序需要特别小心，以便根据需要使用来自声明的额外信息，以符合XML处理器的行为标准。</span><span class="yiyi-st" id="yiyi-102">默认情况下，此属性为false；它可以随时更改。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-103">以下属性包含与<code class="xref py py-class docutils literal"><span class="pre">xmlparser</span></code>对象遇到的最近错误相关的值，并且只有在调用<code class="xref py py-meth docutils literal"><span class="pre">Parse()</span></code>或<code class="xref py py-meth docutils literal"><span class="pre">ParseFile()</span></code>引发了<a class="reference internal" href="#xml.parsers.expat.ExpatError" title="xml.parsers.expat.ExpatError"><code class="xref py py-exc docutils literal"><span class="pre">xml.parsers.expat.ExpatError</span></code></a>异常。</span></p><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.ErrorByteIndex"><span class="yiyi-st" id="yiyi-104"> <code class="descclassname">xmlparser.</code><code class="descname">ErrorByteIndex</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-105">发生错误的字节索引。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.ErrorCode"><span class="yiyi-st" id="yiyi-106"> <code class="descclassname">xmlparser.</code><code class="descname">ErrorCode</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">指定问题的数字代码。</span><span class="yiyi-st" id="yiyi-108">此值可以传递到<a class="reference internal" href="#xml.parsers.expat.ErrorString" title="xml.parsers.expat.ErrorString"><code class="xref py py-func docutils literal"><span class="pre">ErrorString()</span></code></a>函数，或者与<code class="docutils literal"><span class="pre">errors</span></code>对象中定义的常量之一进行比较。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.ErrorColumnNumber"><span class="yiyi-st" id="yiyi-109"> <code class="descclassname">xmlparser.</code><code class="descname">ErrorColumnNumber</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-110">发生错误的列号。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.ErrorLineNumber"><span class="yiyi-st" id="yiyi-111"> <code class="descclassname">xmlparser.</code><code class="descname">ErrorLineNumber</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-112">出现错误的行号。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-113">以下属性包含与<code class="xref py py-class docutils literal"><span class="pre">xmlparser</span></code>对象中当前解析位置相关的值。</span><span class="yiyi-st" id="yiyi-114">在回调报告解析事件期间，它们指示生成事件的字符序列中的第一个的位置。</span><span class="yiyi-st" id="yiyi-115">当在回调之外调用时，指示的位置将刚好超过最后一个解析事件（不管是否存在相关联的回调）。</span></p><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.CurrentByteIndex"><span class="yiyi-st" id="yiyi-116"> <code class="descclassname">xmlparser.</code><code class="descname">CurrentByteIndex</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-117">解析器输入中的当前字节索引。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.CurrentColumnNumber"><span class="yiyi-st" id="yiyi-118"> <code class="descclassname">xmlparser.</code><code class="descname">CurrentColumnNumber</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-119">解析器输入中的当前列号。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.xmlparser.CurrentLineNumber"><span class="yiyi-st" id="yiyi-120"> <code class="descclassname">xmlparser.</code><code class="descname">CurrentLineNumber</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-121">解析器输入中的当前行号。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-122">这里是可以设置的处理程序的列表。</span><span class="yiyi-st" id="yiyi-123">要在<code class="xref py py-class docutils literal"><span class="pre">xmlparser</span></code>对象<em>o</em>上设置处理程序，请使用<code class="docutils literal"><span class="pre">o.handlername</span> <span class="pre">=</span> <span class="pre">func </span></code>。</span><span class="yiyi-st" id="yiyi-124"><em>handlername</em>必须取自以下列表，<em>func</em>必须是接受正确数量参数的可调用对象。</span><span class="yiyi-st" id="yiyi-125">除非另有说明，参数都是字符串。</span></p><dl class="method"><dt id="xml.parsers.expat.xmlparser.XmlDeclHandler"><span class="yiyi-st" id="yiyi-126"> <code class="descclassname">xmlparser.</code><code class="descname">XmlDeclHandler</code><span class="sig-paren">(</span><em>version</em>, <em>encoding</em>, <em>standalone</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-127">在解析XML声明时调用。</span><span class="yiyi-st" id="yiyi-128">XML声明是XML推荐的适用版本的声明（可选），文档文本的编码以及可选的“独立”声明。</span><span class="yiyi-st" id="yiyi-129"><em>version</em> and <em>encoding</em> will be strings, and <em>standalone</em> will be <code class="docutils literal"><span class="pre">1</span></code> if the document is declared standalone, <code class="docutils literal"><span class="pre">0</span></code> if it is declared not to be standalone, or <code class="docutils literal"><span class="pre">-1</span></code> if the standalone clause was omitted. </span><span class="yiyi-st" id="yiyi-130">这仅适用于Expat版本1.95.0或更高版本。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.StartDoctypeDeclHandler"><span class="yiyi-st" id="yiyi-131"> <code class="descclassname">xmlparser.</code><code class="descname">StartDoctypeDeclHandler</code><span class="sig-paren">(</span><em>doctypeName</em>, <em>systemId</em>, <em>publicId</em>, <em>has_internal_subset</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-132">Expat开始解析文档类型声明（<code class="docutils literal"><span class="pre">＆lt；！DOCTYPE</span> <span class="pre">...</span></code>）时调用。</span><span class="yiyi-st" id="yiyi-133">提供的<em>doctypeName</em>与提供的完全相同。</span><span class="yiyi-st" id="yiyi-134"><em>systemId</em>和<em>publicId</em>参数指定系统和公共标识符，如果省略，则<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-135">如果文档包含内部文档声明子集，则<em>has_internal_subset</em>将为true。</span><span class="yiyi-st" id="yiyi-136">这需要Expat版本1.2或更高版本。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.EndDoctypeDeclHandler"><span class="yiyi-st" id="yiyi-137"> <code class="descclassname">xmlparser.</code><code class="descname">EndDoctypeDeclHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-138">当Expat完成解析文档类型声明时调用。</span><span class="yiyi-st" id="yiyi-139">这需要Expat版本1.2或更高版本。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.ElementDeclHandler"><span class="yiyi-st" id="yiyi-140"> <code class="descclassname">xmlparser.</code><code class="descname">ElementDeclHandler</code><span class="sig-paren">(</span><em>name</em>, <em>model</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-141">每个元素类型声明调用一次。</span><span class="yiyi-st" id="yiyi-142"><em>名称</em>是元素类型的名称，<em>模型</em>是内容模型的表示。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.AttlistDeclHandler"><span class="yiyi-st" id="yiyi-143"> <code class="descclassname">xmlparser.</code><code class="descname">AttlistDeclHandler</code><span class="sig-paren">(</span><em>elname</em>, <em>attname</em>, <em>type</em>, <em>default</em>, <em>required</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-144">为元素类型的每个已声明的属性调用。</span><span class="yiyi-st" id="yiyi-145">如果一个属性列表声明声明了三个属性，这个处理程序被调用三次，每个属性一次。</span><span class="yiyi-st" id="yiyi-146"><em>elname</em>是声明应用的元素的名称，<em>attname</em>是声明的属性的名称。</span><span class="yiyi-st" id="yiyi-147">属性类型是作为<em>类型传递的字符串</em>；可能的值为<code class="docutils literal"><span class="pre">'CDATA'</span></code>，<code class="docutils literal"><span class="pre">'ID'</span></code>，<code class="docutils literal"><span class="pre">'IDREF'</span></code>，... <em>如果没有默认值（<code class="docutils literal"><span class="pre">#IMPLIED</span></code>值），则在文档实例未指定属性时使用的属性默认值为<code class="docutils literal"><span class="pre">None</span></code>。</em></span><span class="yiyi-st" id="yiyi-148">如果需要在文档实例中给出属性，则<em>必需</em>将为真。</span><span class="yiyi-st" id="yiyi-149">这需要Expat版本1.95.0或更高版本。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.StartElementHandler"><span class="yiyi-st" id="yiyi-150"> <code class="descclassname">xmlparser.</code><code class="descname">StartElementHandler</code><span class="sig-paren">(</span><em>name</em>, <em>attributes</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-151">调用每个元素的开始。</span><span class="yiyi-st" id="yiyi-152"><em>name</em>是包含元素名称的字符串，<em>属性</em>是元素属性。</span><span class="yiyi-st" id="yiyi-153">如果<a class="reference internal" href="#xml.parsers.expat.xmlparser.ordered_attributes" title="xml.parsers.expat.xmlparser.ordered_attributes"><code class="xref py py-attr docutils literal"><span class="pre">ordered_attributes</span></code></a>为true，则这是一个列表（有关完整说明，请参阅<a class="reference internal" href="#xml.parsers.expat.xmlparser.ordered_attributes" title="xml.parsers.expat.xmlparser.ordered_attributes"><code class="xref py py-attr docutils literal"><span class="pre">ordered_attributes</span></code></a>）。</span><span class="yiyi-st" id="yiyi-154">否则，它是一个字典将名称映射到值。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.EndElementHandler"><span class="yiyi-st" id="yiyi-155"> <code class="descclassname">xmlparser.</code><code class="descname">EndElementHandler</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156">调用每个元素的结尾。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.ProcessingInstructionHandler"><span class="yiyi-st" id="yiyi-157"> <code class="descclassname">xmlparser.</code><code class="descname">ProcessingInstructionHandler</code><span class="sig-paren">(</span><em>target</em>, <em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-158">调用每个处理指令。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.CharacterDataHandler"><span class="yiyi-st" id="yiyi-159"> <code class="descclassname">xmlparser.</code><code class="descname">CharacterDataHandler</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-160">调用字符数据。</span><span class="yiyi-st" id="yiyi-161">这将被称为正常字符数据，CDATA标记的内容和可忽略的空格。</span><span class="yiyi-st" id="yiyi-162">必须区分这些情况的应用程序可以使用<a class="reference internal" href="#xml.parsers.expat.xmlparser.StartCdataSectionHandler" title="xml.parsers.expat.xmlparser.StartCdataSectionHandler"><code class="xref py py-attr docutils literal"><span class="pre">StartCdataSectionHandler</span></code></a>，<a class="reference internal" href="#xml.parsers.expat.xmlparser.EndCdataSectionHandler" title="xml.parsers.expat.xmlparser.EndCdataSectionHandler"><code class="xref py py-attr docutils literal"><span class="pre">EndCdataSectionHandler</span></code></a>和<a class="reference internal" href="#xml.parsers.expat.xmlparser.ElementDeclHandler" title="xml.parsers.expat.xmlparser.ElementDeclHandler"><code class="xref py py-attr docutils literal"><span class="pre">ElementDeclHandler</span></code></a>回调来收集所需的信息。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler"><span class="yiyi-st" id="yiyi-163"> <code class="descclassname">xmlparser.</code><code class="descname">UnparsedEntityDeclHandler</code><span class="sig-paren">(</span><em>entityName</em>, <em>base</em>, <em>systemId</em>, <em>publicId</em>, <em>notationName</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-164">调用已解析（NDATA）实体声明。</span><span class="yiyi-st" id="yiyi-165">这只存在于Expat库的1.2版本；对于更近的版本，请改用<a class="reference internal" href="#xml.parsers.expat.xmlparser.EntityDeclHandler" title="xml.parsers.expat.xmlparser.EntityDeclHandler"><code class="xref py py-attr docutils literal"><span class="pre">EntityDeclHandler</span></code></a>。</span><span class="yiyi-st" id="yiyi-166">（Expat库中的基础函数已声明为过时。）</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.EntityDeclHandler"><span class="yiyi-st" id="yiyi-167"> <code class="descclassname">xmlparser.</code><code class="descname">EntityDeclHandler</code><span class="sig-paren">(</span><em>entityName</em>, <em>is_parameter_entity</em>, <em>value</em>, <em>base</em>, <em>systemId</em>, <em>publicId</em>, <em>notationName</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-168">调用所有实体声明。</span><span class="yiyi-st" id="yiyi-169">对于参数和内部实体，<em>value</em>将是一个给出实体声明内容的字符串；这将是外部实体的<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-170">对于解析的实体，<em>notationName</em>参数将为<code class="docutils literal"><span class="pre">None</span></code>，以及未解析实体的符号名称。</span><span class="yiyi-st" id="yiyi-171">如果实体是参数实体，则<em>is_parameter_entity</em>将为true，对于一般实体为false（大多数应用程序只需要关注一般实体）。</span><span class="yiyi-st" id="yiyi-172">这只能从Expat库的1.95.0版本开始提供。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.NotationDeclHandler"><span class="yiyi-st" id="yiyi-173"> <code class="descclassname">xmlparser.</code><code class="descname">NotationDeclHandler</code><span class="sig-paren">(</span><em>notationName</em>, <em>base</em>, <em>systemId</em>, <em>publicId</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-174">调用符号声明。</span><span class="yiyi-st" id="yiyi-175"><em>notationName</em>，<em>base</em>和<em>systemId</em>和<em>publicId</em>都是字符串。</span><span class="yiyi-st" id="yiyi-176">如果省略公共标识符，<em>publicId</em>将为<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.StartNamespaceDeclHandler"><span class="yiyi-st" id="yiyi-177"> <code class="descclassname">xmlparser.</code><code class="descname">StartNamespaceDeclHandler</code><span class="sig-paren">(</span><em>prefix</em>, <em>uri</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-178">当元素包含命名空间声明时调用。</span><span class="yiyi-st" id="yiyi-179">在为放置声明的元素调用<a class="reference internal" href="#xml.parsers.expat.xmlparser.StartElementHandler" title="xml.parsers.expat.xmlparser.StartElementHandler"><code class="xref py py-attr docutils literal"><span class="pre">StartElementHandler</span></code></a>之前处理命名空间声明。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.EndNamespaceDeclHandler"><span class="yiyi-st" id="yiyi-180"> <code class="descclassname">xmlparser.</code><code class="descname">EndNamespaceDeclHandler</code><span class="sig-paren">(</span><em>prefix</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-181">当到达包含命名空间声明的元素的结束标记时调用。</span><span class="yiyi-st" id="yiyi-182">对于调用<a class="reference internal" href="#xml.parsers.expat.xmlparser.StartNamespaceDeclHandler" title="xml.parsers.expat.xmlparser.StartNamespaceDeclHandler"><code class="xref py py-attr docutils literal"><span class="pre">StartNamespaceDeclHandler</span></code></a>的顺序的反向，对元素上的每个命名空间声明调用一次，以指示每个命名空间声明的作用域的开始。</span><span class="yiyi-st" id="yiyi-183">对此处理程序的调用在对应的<a class="reference internal" href="#xml.parsers.expat.xmlparser.EndElementHandler" title="xml.parsers.expat.xmlparser.EndElementHandler"><code class="xref py py-attr docutils literal"><span class="pre">EndElementHandler</span></code></a>之后作为元素的结尾。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.CommentHandler"><span class="yiyi-st" id="yiyi-184"> <code class="descclassname">xmlparser.</code><code class="descname">CommentHandler</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-185">调用评论。</span><span class="yiyi-st" id="yiyi-186"><em>data</em> is the text of the comment, excluding the leading <code class="docutils literal"><span class="pre">'&lt;!-</span></code><code class="docutils literal"><span class="pre">-'</span></code> and trailing <code class="docutils literal"><span class="pre">'-</span></code><code class="docutils literal"><span class="pre">-&gt;'</span></code>.</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.StartCdataSectionHandler"><span class="yiyi-st" id="yiyi-187"> <code class="descclassname">xmlparser.</code><code class="descname">StartCdataSectionHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-188">在CDATA节开始时调用。</span><span class="yiyi-st" id="yiyi-189">需要这个和<a class="reference internal" href="#xml.parsers.expat.xmlparser.EndCdataSectionHandler" title="xml.parsers.expat.xmlparser.EndCdataSectionHandler"><code class="xref py py-attr docutils literal"><span class="pre">EndCdataSectionHandler</span></code></a>，以便能够识别CDATA段的句法开始和结束。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.EndCdataSectionHandler"><span class="yiyi-st" id="yiyi-190"> <code class="descclassname">xmlparser.</code><code class="descname">EndCdataSectionHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-191">在CDATA部分的末尾调用。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.DefaultHandler"><span class="yiyi-st" id="yiyi-192"> <code class="descclassname">xmlparser.</code><code class="descname">DefaultHandler</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-193">调用XML文档中未指定任何适用处理程序的任何字符。</span><span class="yiyi-st" id="yiyi-194">这意味着作为构造的一部分的字符可以被报告，但是没有提供处理程序。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.DefaultHandlerExpand"><span class="yiyi-st" id="yiyi-195"> <code class="descclassname">xmlparser.</code><code class="descname">DefaultHandlerExpand</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-196">这与<a class="reference internal" href="#xml.parsers.expat.xmlparser.DefaultHandler" title="xml.parsers.expat.xmlparser.DefaultHandler"><code class="xref py py-func docutils literal"><span class="pre">DefaultHandler()</span></code></a>相同，但不会抑制内部实体的扩展。</span><span class="yiyi-st" id="yiyi-197">实体引用不会传递给默认处理程序。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.NotStandaloneHandler"><span class="yiyi-st" id="yiyi-198"> <code class="descclassname">xmlparser.</code><code class="descname">NotStandaloneHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-199">如果XML文档尚未声明为独立文档，则调用此方法。</span><span class="yiyi-st" id="yiyi-200">当有一个外部子集或对一个参数实体的引用，但XML声明没有在XML声明中设置为独立到<code class="docutils literal"><span class="pre">yes</span></code>时，会发生这种情况。</span><span class="yiyi-st" id="yiyi-201">如果此处理程序返回<code class="docutils literal"><span class="pre">0</span></code>，则解析器将引发一个<code class="xref py py-const docutils literal"><span class="pre">XML_ERROR_NOT_STANDALONE</span></code>错误。</span><span class="yiyi-st" id="yiyi-202">如果未设置此处理程序，则此条件的解析器不会引发异常。</span></p></dd></dl><dl class="method"><dt id="xml.parsers.expat.xmlparser.ExternalEntityRefHandler"><span class="yiyi-st" id="yiyi-203"> <code class="descclassname">xmlparser.</code><code class="descname">ExternalEntityRefHandler</code><span class="sig-paren">(</span><em>context</em>, <em>base</em>, <em>systemId</em>, <em>publicId</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-204">调用对外部实体的引用。</span><span class="yiyi-st" id="yiyi-205"><em>base</em>是由先前调用<a class="reference internal" href="#xml.parsers.expat.xmlparser.SetBase" title="xml.parsers.expat.xmlparser.SetBase"><code class="xref py py-meth docutils literal"><span class="pre">SetBase()</span></code></a>设置的当前基数。</span><span class="yiyi-st" id="yiyi-206">公共和系统标识符<em>systemId</em>和<em>publicId</em>是字符串，如果给定的话；如果未给出公共标识符，则<em>publicId</em>将为<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-207"><em>上下文</em>值是不透明的，并且应该仅按如下所述使用。</span></p><p><span class="yiyi-st" id="yiyi-208">对于要解析的外部实体，必须实现此处理程序。</span><span class="yiyi-st" id="yiyi-209">它负责使用<code class="docutils literal"><span class="pre">ExternalEntityParserCreate(context)</span></code>创建子解析器，使用适当的回调初始化它，并解析实体。</span><span class="yiyi-st" id="yiyi-210">这个处理程序应该返回一个整数；如果返回<code class="docutils literal"><span class="pre">0</span></code>，解析器将引发一个<code class="xref py py-const docutils literal"><span class="pre">XML_ERROR_EXTERNAL_ENTITY_HANDLING</span></code>错误，否则解析将继续。</span></p><p><span class="yiyi-st" id="yiyi-211">如果未提供此处理程序，则通过<a class="reference internal" href="#xml.parsers.expat.xmlparser.DefaultHandler" title="xml.parsers.expat.xmlparser.DefaultHandler"><code class="xref py py-attr docutils literal"><span class="pre">DefaultHandler</span></code></a>回调（如果提供）报告外部实体。</span></p></dd></dl></div><div class="section" id="expaterror-exceptions"><h2><span class="yiyi-st" id="yiyi-212">20.13.2. </span><span class="yiyi-st" id="yiyi-213">ExpatError Exceptions</span></h2><p><span class="yiyi-st" id="yiyi-214"><a class="reference internal" href="#xml.parsers.expat.ExpatError" title="xml.parsers.expat.ExpatError"><code class="xref py py-exc docutils literal"><span class="pre">ExpatError</span></code></a>异常有一些有趣的属性：</span></p><dl class="attribute"><dt id="xml.parsers.expat.ExpatError.code"><span class="yiyi-st" id="yiyi-215"> <code class="descclassname">ExpatError.</code><code class="descname">code</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-216">Expat的特定错误的内部错误编号。</span><span class="yiyi-st" id="yiyi-217"><a class="reference internal" href="#xml.parsers.expat.errors.messages" title="xml.parsers.expat.errors.messages"><code class="xref py py-data docutils literal"><span class="pre">errors.messages</span></code></a>字典将这些错误号映射到Expat的错误消息。</span><span class="yiyi-st" id="yiyi-218">例如：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">xml.parsers.expat</span> <span class="k">import</span> <span class="n">ParserCreate</span><span class="p">,</span> <span class="n">ExpatError</span><span class="p">,</span> <span class="n">errors</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">ParserCreate</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">p</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">some_xml_document</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ExpatError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Error:"</span><span class="p">,</span> <span class="n">errors</span><span class="o">.</span><span class="n">messages</span><span class="p">[</span><span class="n">err</span><span class="o">.</span><span class="n">code</span><span class="p">])</span>
</code></pre><p><span class="yiyi-st" id="yiyi-219"><a class="reference internal" href="#module-xml.parsers.expat.errors" title="xml.parsers.expat.errors"><code class="xref py py-mod docutils literal"><span class="pre">errors</span></code></a>模块还提供错误消息常量和字典<a class="reference internal" href="#xml.parsers.expat.errors.codes" title="xml.parsers.expat.errors.codes"><code class="xref py py-data docutils literal"><span class="pre">codes</span></code></a>将这些消息映射回错误代码，请参见下文。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.ExpatError.lineno"><span class="yiyi-st" id="yiyi-220"> <code class="descclassname">ExpatError.</code><code class="descname">lineno</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-221">检测到错误的行号。</span><span class="yiyi-st" id="yiyi-222">第一行编号为<code class="docutils literal"><span class="pre">1</span></code>。</span></p></dd></dl><dl class="attribute"><dt id="xml.parsers.expat.ExpatError.offset"><span class="yiyi-st" id="yiyi-223"> <code class="descclassname">ExpatError.</code><code class="descname">offset</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-224">字符偏移到发生错误的行。</span><span class="yiyi-st" id="yiyi-225">第一列的编号为<code class="docutils literal"><span class="pre">0</span></code>。</span></p></dd></dl></div><div class="section" id="example"><h2><span class="yiyi-st" id="yiyi-226">20.13.3. </span><span class="yiyi-st" id="yiyi-227">Example</span></h2><p><span class="yiyi-st" id="yiyi-228">下面的程序定义了三个处理程序，只是打印出它们的参数。</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">xml.parsers.expat</span>

<span class="c1"># 3 handler functions</span>
<span class="k">def</span> <span class="nf">start_element</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Start element:'</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">end_element</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'End element:'</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">char_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Character data:'</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">parsers</span><span class="o">.</span><span class="n">expat</span><span class="o">.</span><span class="n">ParserCreate</span><span class="p">()</span>

<span class="n">p</span><span class="o">.</span><span class="n">StartElementHandler</span> <span class="o">=</span> <span class="n">start_element</span>
<span class="n">p</span><span class="o">.</span><span class="n">EndElementHandler</span> <span class="o">=</span> <span class="n">end_element</span>
<span class="n">p</span><span class="o">.</span><span class="n">CharacterDataHandler</span> <span class="o">=</span> <span class="n">char_data</span>

<span class="n">p</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s2">"""&lt;?xml version="1.0"?&gt;</span>
<span class="s2">&lt;parent id="top"&gt;&lt;child1 name="paul"&gt;Text goes here&lt;/child1&gt;</span>
<span class="s2">&lt;child2 name="fred"&gt;More text&lt;/child2&gt;</span>
<span class="s2">&lt;/parent&gt;"""</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-229">该程序的输出是：</span></p><pre><code class="language-python"><span></span><span class="n">Start</span> <span class="n">element</span><span class="p">:</span> <span class="n">parent</span> <span class="p">{</span><span class="s1">'id'</span><span class="p">:</span> <span class="s1">'top'</span><span class="p">}</span>
<span class="n">Start</span> <span class="n">element</span><span class="p">:</span> <span class="n">child1</span> <span class="p">{</span><span class="s1">'name'</span><span class="p">:</span> <span class="s1">'paul'</span><span class="p">}</span>
<span class="n">Character</span> <span class="n">data</span><span class="p">:</span> <span class="s1">'Text goes here'</span>
<span class="n">End</span> <span class="n">element</span><span class="p">:</span> <span class="n">child1</span>
<span class="n">Character</span> <span class="n">data</span><span class="p">:</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span>
<span class="n">Start</span> <span class="n">element</span><span class="p">:</span> <span class="n">child2</span> <span class="p">{</span><span class="s1">'name'</span><span class="p">:</span> <span class="s1">'fred'</span><span class="p">}</span>
<span class="n">Character</span> <span class="n">data</span><span class="p">:</span> <span class="s1">'More text'</span>
<span class="n">End</span> <span class="n">element</span><span class="p">:</span> <span class="n">child2</span>
<span class="n">Character</span> <span class="n">data</span><span class="p">:</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span>
<span class="n">End</span> <span class="n">element</span><span class="p">:</span> <span class="n">parent</span>
</code></pre></div><div class="section" id="module-xml.parsers.expat.model"><h2><span class="yiyi-st" id="yiyi-230">20.13.4. </span><span class="yiyi-st" id="yiyi-231">Content Model Descriptions</span></h2><p><span class="yiyi-st" id="yiyi-232">使用嵌套元组描述内容模型。</span><span class="yiyi-st" id="yiyi-233">每个元组包含四个值：类型，量词，名称和子元组。</span><span class="yiyi-st" id="yiyi-234">孩子只是额外的内容模型描述。</span></p><p><span class="yiyi-st" id="yiyi-235">前两个字段的值是在<a class="reference internal" href="#module-xml.parsers.expat.model" title="xml.parsers.expat.model"><code class="xref py py-mod docutils literal"><span class="pre">xml.parsers.expat.model</span></code></a>模块中定义的常量。</span><span class="yiyi-st" id="yiyi-236">这些常量可以分为两组：模型类型组和量词组。</span></p><p><span class="yiyi-st" id="yiyi-237">模型类型组中的常量为：</span></p><dl class="data"><dt><span class="yiyi-st" id="yiyi-238"><code class="descclassname">xml.parsers.expat.model。</code> <code class="descname">XML_CTYPE_ANY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-239">由模型名称命名的元素声明为具有<code class="docutils literal"><span class="pre">ANY</span></code>的内容模型。</span></p></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-240"><code class="descclassname">xml.parsers.expat.model。</code> <code class="descname">XML_CTYPE_CHOICE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-241">命名的元素允许从多个选项中进行选择；这用于内容模型，例如<code class="docutils literal"><span class="pre">（A</span> <span class="pre">|</span> <span class="pre">B</span> <span class="pre">|</span> <span class="pre">C） / t5&gt;</span></code>。</span></p></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-242"><code class="descclassname">xml.parsers.expat.model。</code> <code class="descname">XML_CTYPE_EMPTY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-243">声明为<code class="docutils literal"><span class="pre">EMPTY</span></code>的元素具有此模型类型。</span></p></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-244"><code class="descclassname">xml.parsers.expat.model。</code> <code class="descname">XML_CTYPE_MIXED</code></span></dt><dd></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-245"><code class="descclassname">xml.parsers.expat.model。</code> <code class="descname">XML_CTYPE_NAME</code></span></dt><dd></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-246"><code class="descclassname">xml.parsers.expat.model。</code> <code class="descname">XML_CTYPE_SEQ</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-247">用该模型类型表示代表一个接一个跟随的一系列模型的模型。</span><span class="yiyi-st" id="yiyi-248">这用于诸如<code class="docutils literal"><span class="pre">（A，</span> <span class="pre">B，</span> <span class="pre">C）</span></code>等型号。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-249">定量程序组中的常量为：</span></p><dl class="data"><dt><span class="yiyi-st" id="yiyi-250"><code class="descclassname">xml.parsers.expat.model。</code> <code class="descname">XML_CQUANT_NONE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-251">没有给出修饰符，因此它可以只出现一次，如<code class="docutils literal"><span class="pre">A</span></code>。</span></p></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-252"><code class="descclassname">xml.parsers.expat.model。</code> <code class="descname">XML_CQUANT_OPT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-253">该模型是可选的：它可以出现一次或根本不出现，如<code class="docutils literal"><span class="pre">A?</span></code>。</span></p></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-254"><code class="descclassname">xml.parsers.expat.model。</code> <code class="descname">XML_CQUANT_PLUS</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-255">模型必须出现一次或多次（如<code class="docutils literal"><span class="pre">A+</span></code>）。</span></p></dd></dl><dl class="data"><dt><span class="yiyi-st" id="yiyi-256"><code class="descclassname">xml.parsers.expat.model。</code> <code class="descname">XML_CQUANT_REP</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-257">该模型必须发生零次或多次，如<code class="docutils literal"><span class="pre">A*</span></code>。</span></p></dd></dl></div><div class="section" id="module-xml.parsers.expat.errors"><h2><span class="yiyi-st" id="yiyi-258">20.13.5. </span><span class="yiyi-st" id="yiyi-259">Expat error constants</span></h2><p><span class="yiyi-st" id="yiyi-260">以下常量在<a class="reference internal" href="#module-xml.parsers.expat.errors" title="xml.parsers.expat.errors"><code class="xref py py-mod docutils literal"><span class="pre">xml.parsers.expat.errors</span></code></a>模块中提供。</span><span class="yiyi-st" id="yiyi-261">这些常量在解释发生错误时引发的<code class="xref py py-exc docutils literal"><span class="pre">ExpatError</span></code>异常对象的某些属性非常有用。</span><span class="yiyi-st" id="yiyi-262">由于向后兼容性原因，常量的值是错误<em>消息</em>而不是数字错误<em>代码</em>，您可以通过比较其<a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-attr docutils literal"><span class="pre">code</span></code></a>属性与<code class="samp docutils literal"><span class="pre">errors.codes [errors.XML_ERROR _</span> <em><span class="pre">CONSTANT_NAME</span></em> <span class="pre">]</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-263"><code class="docutils literal"><span class="pre">errors</span></code>模块具有以下属性：</span></p><dl class="data"><dt id="xml.parsers.expat.errors.codes"><span class="yiyi-st" id="yiyi-264"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">codes</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-265">将数字错误代码映射到其字符串描述的字典。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-266"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.messages"><span class="yiyi-st" id="yiyi-267"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">messages</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-268">将字符串描述映射到其错误代码的字典。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-269"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_ASYNC_ENTITY"><span class="yiyi-st" id="yiyi-270"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_ASYNC_ENTITY</code></span></dt><dd></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF"><span class="yiyi-st" id="yiyi-271"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-272">引用到外部实体而不是内部实体的属性值中的实体引用。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_BAD_CHAR_REF"><span class="yiyi-st" id="yiyi-273"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_BAD_CHAR_REF</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-274">字符引用指的是XML中非法字符（例如，字符<code class="docutils literal"><span class="pre">0</span></code>或'<code class="docutils literal"><span class="pre">&amp;#0;</span></code>'）。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_BINARY_ENTITY_REF"><span class="yiyi-st" id="yiyi-275"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_BINARY_ENTITY_REF</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-276">实体引用指的是用符号声明的实体，因此不能被解析。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_DUPLICATE_ATTRIBUTE"><span class="yiyi-st" id="yiyi-277"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_DUPLICATE_ATTRIBUTE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-278">一个属性在开始标记中多次使用。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_INCORRECT_ENCODING"><span class="yiyi-st" id="yiyi-279"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_INCORRECT_ENCODING</code></span></dt><dd></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_INVALID_TOKEN"><span class="yiyi-st" id="yiyi-280"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_INVALID_TOKEN</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-281">在输入字节无法正确分配给字符时引发；例如，UTF-8输入流中的NUL字节（值<code class="docutils literal"><span class="pre">0</span></code>）。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_JUNK_AFTER_DOC_ELEMENT"><span class="yiyi-st" id="yiyi-282"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_JUNK_AFTER_DOC_ELEMENT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-283">文档元素之后出现了除空格之外的其他内容。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_MISPLACED_XML_PI"><span class="yiyi-st" id="yiyi-284"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_MISPLACED_XML_PI</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-285">在除了输入数据的开始之外的某处发现了XML声明。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_NO_ELEMENTS"><span class="yiyi-st" id="yiyi-286"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_NO_ELEMENTS</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-287">文档不包含元素（XML要求所有文档只包含一个顶级元素）。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_NO_MEMORY"><span class="yiyi-st" id="yiyi-288"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_NO_MEMORY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-289">Expat无法在内部分配内存。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_PARAM_ENTITY_REF"><span class="yiyi-st" id="yiyi-290"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_PARAM_ENTITY_REF</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-291">发现不允许参数实体引用的位置。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_PARTIAL_CHAR"><span class="yiyi-st" id="yiyi-292"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_PARTIAL_CHAR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-293">在输入中找到不完整的字符。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_RECURSIVE_ENTITY_REF"><span class="yiyi-st" id="yiyi-294"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_RECURSIVE_ENTITY_REF</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-295">实体引用包含对同一实体的另一引用；可能通过不同的名称，并且可能间接。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_SYNTAX"><span class="yiyi-st" id="yiyi-296"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_SYNTAX</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-297">遇到一些未指定的语法错误。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_TAG_MISMATCH"><span class="yiyi-st" id="yiyi-298"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_TAG_MISMATCH</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-299">结束标记与最内部的开始标记不匹配。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_UNCLOSED_TOKEN"><span class="yiyi-st" id="yiyi-300"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_UNCLOSED_TOKEN</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-301">某些令牌（例如开始标签）在流结束或遇到下一个令牌之前未关闭。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_UNDEFINED_ENTITY"><span class="yiyi-st" id="yiyi-302"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_UNDEFINED_ENTITY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-303">引用未定义的实体。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_UNKNOWN_ENCODING"><span class="yiyi-st" id="yiyi-304"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_UNKNOWN_ENCODING</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-305">Expat不支持文档编码。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_UNCLOSED_CDATA_SECTION"><span class="yiyi-st" id="yiyi-306"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_UNCLOSED_CDATA_SECTION</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-307">未关闭标有CDATA的部分。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_EXTERNAL_ENTITY_HANDLING"><span class="yiyi-st" id="yiyi-308"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_EXTERNAL_ENTITY_HANDLING</code></span></dt><dd></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_NOT_STANDALONE"><span class="yiyi-st" id="yiyi-309"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_NOT_STANDALONE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-310">解析器确定文档不是“独立”，尽管它声明自己在XML声明中，并且设置了<code class="xref py py-attr docutils literal"><span class="pre">NotStandaloneHandler</span></code>并返回<code class="docutils literal"><span class="pre">0</span></code>。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_UNEXPECTED_STATE"><span class="yiyi-st" id="yiyi-311"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_UNEXPECTED_STATE</code></span></dt><dd></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_ENTITY_DECLARED_IN_PE"><span class="yiyi-st" id="yiyi-312"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_ENTITY_DECLARED_IN_PE</code></span></dt><dd></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_FEATURE_REQUIRES_XML_DTD"><span class="yiyi-st" id="yiyi-313"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_FEATURE_REQUIRES_XML_DTD</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-314">需要操作，需要编译DTD支持，但是在没有DTD支持的情况下配置了Expat。</span><span class="yiyi-st" id="yiyi-315">这不应该由<a class="reference internal" href="#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal"><span class="pre">xml.parsers.expat</span></code></a>模块的标准构建报告。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING"><span class="yiyi-st" id="yiyi-316"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-317">在解析开始后请求行为更改，只能在解析开始前更改。</span><span class="yiyi-st" id="yiyi-318">这是（目前）仅由<code class="xref py py-meth docutils literal"><span class="pre">UseForeignDTD()</span></code>引发。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_UNBOUND_PREFIX"><span class="yiyi-st" id="yiyi-319"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_UNBOUND_PREFIX</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-320"></span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_UNDECLARING_PREFIX"><span class="yiyi-st" id="yiyi-321"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_UNDECLARING_PREFIX</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-322">该文档试图删除与前缀相关联的名称空间声明。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_INCOMPLETE_PE"><span class="yiyi-st" id="yiyi-323"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_INCOMPLETE_PE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-324">参数实体包含不完整标记。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_XML_DECL"><span class="yiyi-st" id="yiyi-325"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_XML_DECL</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-326">文档根本没有文档元素。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_TEXT_DECL"><span class="yiyi-st" id="yiyi-327"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_TEXT_DECL</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-328">解析外部实体中的文本声明时出错。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_PUBLICID"><span class="yiyi-st" id="yiyi-329"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_PUBLICID</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-330">在公共ID中找到不允许的字符。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_SUSPENDED"><span class="yiyi-st" id="yiyi-331"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_SUSPENDED</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-332">请求的操作是在已暂停的解析器上进行的，但不允许。</span><span class="yiyi-st" id="yiyi-333">这包括尝试提供额外的输入或停止解析器。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_NOT_SUSPENDED"><span class="yiyi-st" id="yiyi-334"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_NOT_SUSPENDED</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-335">当解析器未被挂起时，尝试恢复解析器。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_ABORTED"><span class="yiyi-st" id="yiyi-336"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_ABORTED</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-337">这不应该报告给Python应用程序。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_FINISHED"><span class="yiyi-st" id="yiyi-338"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_FINISHED</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-339">所请求的操作是在已完成解析输入的解析器上进行的，但不允许。</span><span class="yiyi-st" id="yiyi-340">这包括尝试提供额外的输入或停止解析器。</span></p></dd></dl><dl class="data"><dt id="xml.parsers.expat.errors.XML_ERROR_SUSPEND_PE"><span class="yiyi-st" id="yiyi-341"> <code class="descclassname">xml.parsers.expat.errors.</code><code class="descname">XML_ERROR_SUSPEND_PE</code></span></dt><dd></dd></dl><p class="rubric"><span class="yiyi-st" id="yiyi-342">脚注</span></p><table class="docutils footnote" frame="void" id="id3" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-343">[1]</span></td><td><span class="yiyi-st" id="yiyi-344">XML输出中包含的编码字符串应符合相应的标准。</span><span class="yiyi-st" id="yiyi-345">例如，“UTF-8”有效，但“UTF8”不是。</span><span class="yiyi-st" id="yiyi-346">请参阅<a class="reference external" href="https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl">https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl</a>和<a class="reference external" href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">https://www.iana.org/assignments/character- sets / character-sets.xhtml</a>。</span></td></tr></tbody></table></div></div></div>