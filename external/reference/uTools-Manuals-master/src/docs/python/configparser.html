<div class="body" role="main"><div class="section" id="module-configparser"><h1><span class="yiyi-st" id="yiyi-10">14.2. <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal"><span class="pre">configparser</span></code></a>  - 配置文件解析器</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/configparser.py">Lib / configparser.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">此模块提供实现基本配置语言的<a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal"><span class="pre">ConfigParser</span></code></a>类，该语言提供类似于Microsoft Windows INI文件中的结构。</span><span class="yiyi-st" id="yiyi-13">您可以使用它来编写可以由终端用户轻松定制的Python程序。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-14">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-15">此库 <em>不</em>解释或写入在Windows注册表扩展版本的INI语法中使用的值类型前缀。</span></p></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-16">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-17">模块<a class="reference internal" href="shlex.html#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal"><span class="pre">shlex</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-18">支持创建的Unix shell样微型语言，可以用作应用程序配置文件的备用格式。</span></dd><dt><span class="yiyi-st" id="yiyi-19">模块<a class="reference internal" href="json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal"><span class="pre">json</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-20">json模块实现了JavaScript语法的一个子集，也可以用于此目的。</span></dd></dl></div><div class="section" id="quick-start"><h2><span class="yiyi-st" id="yiyi-21">14.2.1. </span><span class="yiyi-st" id="yiyi-22">快速启动</span></h2><p><span class="yiyi-st" id="yiyi-23">让我们来看一个非常基本的配置文件，如下所示：</span></p><div class="highlight-ini"><div class="highlight"><pre><span></span><span class="k">[DEFAULT]</span>
<span class="na">ServerAliveInterval</span> <span class="o">=</span> <span class="s">45</span>
<span class="na">Compression</span> <span class="o">=</span> <span class="s">yes</span>
<span class="na">CompressionLevel</span> <span class="o">=</span> <span class="s">9</span>
<span class="na">ForwardX11</span> <span class="o">=</span> <span class="s">yes</span>

<span class="k">[bitbucket.org]</span>
<span class="na">User</span> <span class="o">=</span> <span class="s">hg</span>

<span class="k">[topsecret.server.com]</span>
<span class="na">Port</span> <span class="o">=</span> <span class="s">50022</span>
<span class="na">ForwardX11</span> <span class="o">=</span> <span class="s">no</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-24">如果想了解INI文件的结构，请看<a class="reference external" href="#supported-ini-file-structure">这一节</a>。</span><span class="yiyi-st" id="yiyi-25">本质上，文件由块组成，每个块包含带值的键。</span><span class="yiyi-st" id="yiyi-26"><a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal"><span class="pre">configparser</span></code></a>类可以读写此类文件。</span><span class="yiyi-st" id="yiyi-27">让我们从编程上面创建上面的配置文件开始。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">configparser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">'DEFAULT'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'ServerAliveInterval'</span><span class="p">:</span> <span class="s1">'45'</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="s1">'Compression'</span><span class="p">:</span> <span class="s1">'yes'</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="s1">'CompressionLevel'</span><span class="p">:</span> <span class="s1">'9'</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">'bitbucket.org'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">'bitbucket.org'</span><span class="p">][</span><span class="s1">'User'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'hg'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">'topsecret.server.com'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">'topsecret.server.com'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="p">[</span><span class="s1">'Port'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'50022'</span>     <span class="c1"># mutates the parser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="p">[</span><span class="s1">'ForwardX11'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'no'</span>  <span class="c1"># same here</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">'DEFAULT'</span><span class="p">][</span><span class="s1">'ForwardX11'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'yes'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'example.ini'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">configfile</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">config</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">configfile</span><span class="p">)</span>
<span class="gp">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-28">正如你所看到的，我们可以把一个配置解析器看作一个字典。</span><span class="yiyi-st" id="yiyi-29">这里有所区别，<a class="reference external" href="#mapping-protocol-access">稍后概述</a>，但是行为非常接近您从字典中期望的行为。</span></p><p><span class="yiyi-st" id="yiyi-30">现在我们已经创建并保存了一个配置文件，让我们从文件中读取和查看所拥有的数据。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">configparser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">'example.ini'</span><span class="p">)</span>
<span class="go">['example.ini']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">['bitbucket.org', 'topsecret.server.com']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'bitbucket.org'</span> <span class="ow">in</span> <span class="n">config</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'bytebong.com'</span> <span class="ow">in</span> <span class="n">config</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">'bitbucket.org'</span><span class="p">][</span><span class="s1">'User'</span><span class="p">]</span>
<span class="go">'hg'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">'DEFAULT'</span><span class="p">][</span><span class="s1">'Compression'</span><span class="p">]</span>
<span class="go">'yes'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">'topsecret.server.com'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="p">[</span><span class="s1">'ForwardX11'</span><span class="p">]</span>
<span class="go">'no'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="p">[</span><span class="s1">'Port'</span><span class="p">]</span>
<span class="go">'50022'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">'bitbucket.org'</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">user</span>
<span class="go">compressionlevel</span>
<span class="go">serveraliveinterval</span>
<span class="go">compression</span>
<span class="go">forwardx11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">'bitbucket.org'</span><span class="p">][</span><span class="s1">'ForwardX11'</span><span class="p">]</span>
<span class="go">'yes'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-31">正如我们上面可以看到的，API是相当简单。</span><span class="yiyi-st" id="yiyi-32">唯一的魔法位包括<code class="docutils literal"><span class="pre">DEFAULT</span></code>部分，为所有其他部分<a class="footnote-reference" href="#id14" id="id1">[1]</a>提供默认值。</span><span class="yiyi-st" id="yiyi-33">还要注意，块中的键不区分大小写，并以小写<a class="footnote-reference" href="#id14" id="id2">[1]</a>存储。</span></p></div><div class="section" id="supported-datatypes"><h2><span class="yiyi-st" id="yiyi-34">14.2.2. </span><span class="yiyi-st" id="yiyi-35">支持的数据类型</span></h2><p><span class="yiyi-st" id="yiyi-36">Config解析器不会猜测配置文件中的值的数据类型，始终将它们作为字符串存储在内部。</span><span class="yiyi-st" id="yiyi-37">这意味着如果你需要其他数据类型，你应该自己转换：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">topsecret</span><span class="p">[</span><span class="s1">'Port'</span><span class="p">])</span>
<span class="go">50022</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">topsecret</span><span class="p">[</span><span class="s1">'CompressionLevel'</span><span class="p">])</span>
<span class="go">9.0</span>
</code></pre><p><span class="yiyi-st" id="yiyi-38">由于这个任务很常见，config解析器提供了一系列方便的getter方法来处理整数，浮点数和布尔值。</span><span class="yiyi-st" id="yiyi-39">最后一个是最有趣的，因为只是将值传递给<code class="docutils literal"><span class="pre">bool()</span></code>将没有什么好的，因为<code class="docutils literal"><span class="pre">bool('False')</span></code>仍然是<code class="docutils literal"><span class="pre">True</span></code></span><span class="yiyi-st" id="yiyi-40">这就是为什么config解析器也提供<code class="xref py py-meth docutils literal"><span class="pre">getboolean()</span></code>。</span><span class="yiyi-st" id="yiyi-41">此方法不区分大小写，并且识别来自<code class="docutils literal"><span class="pre">'yes'</span></code> / <code class="docutils literal"><span class="pre">'no'</span></code>，<code class="docutils literal"><span class="pre">'on'</span></code> / <code class="docutils literal"><span class="pre">'off'</span></code>，<code class="docutils literal"><span class="pre">'true'</span></code> / <code class="docutils literal"><span class="pre">'false'</span></code>和<code class="docutils literal"><span class="pre">'1'</span></code> / <code class="docutils literal"><span class="pre">'0'</span></code> <a class="footnote-reference" href="#id14" id="id3"> [1]</a>。</span><span class="yiyi-st" id="yiyi-42">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">'ForwardX11'</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">'bitbucket.org'</span><span class="p">]</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">'ForwardX11'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">'bitbucket.org'</span><span class="p">,</span> <span class="s1">'Compression'</span><span class="p">)</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-43">除了<code class="xref py py-meth docutils literal"><span class="pre">getboolean()</span></code>，config解析器还提供等效的<code class="xref py py-meth docutils literal"><span class="pre">getint()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">getfloat()</span></code>方法。</span><span class="yiyi-st" id="yiyi-44">您可以注册自己的转换器并自定义提供的转换器。</span><span class="yiyi-st" id="yiyi-45"><a class="footnote-reference" href="#id14" id="id4"> [1]  T0&gt;</a></span></p></div><div class="section" id="fallback-values"><h2><span class="yiyi-st" id="yiyi-46">14.2.3. </span><span class="yiyi-st" id="yiyi-47">回退值</span></h2><p><span class="yiyi-st" id="yiyi-48">与字典一样，您可以使用节的<code class="xref py py-meth docutils literal"><span class="pre">get()</span></code>方法来提供回退值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Port'</span><span class="p">)</span>
<span class="go">'50022'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'CompressionLevel'</span><span class="p">)</span>
<span class="go">'9'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Cipher'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Cipher'</span><span class="p">,</span> <span class="s1">'3des-cbc'</span><span class="p">)</span>
<span class="go">'3des-cbc'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-49">请注意，默认值优先于回退值。</span><span class="yiyi-st" id="yiyi-50">对于实例，在我们的示例中，<code class="docutils literal"><span class="pre">'CompressionLevel'</span></code>键仅在<code class="docutils literal"><span class="pre">'DEFAULT'</span></code>部分指定。</span><span class="yiyi-st" id="yiyi-51">如果我们尝试从<code class="docutils literal"><span class="pre">'topsecret.server.com'</span></code>节获取它，我们将始终获取默认值，即使我们指定了后备：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'CompressionLevel'</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">)</span>
<span class="go">'9'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-52">还需要注意的是，解析器级<code class="xref py py-meth docutils literal"><span class="pre">get()</span></code>方法提供了一个自定义的，更复杂的接口，为向后兼容性而保留。</span><span class="yiyi-st" id="yiyi-53">使用此方法时，可以通过<code class="docutils literal"><span class="pre">fallback</span></code>关键字参数提供后备值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'bitbucket.org'</span><span class="p">,</span> <span class="s1">'monster'</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">fallback</span><span class="o">=</span><span class="s1">'No such things as monsters'</span><span class="p">)</span>
<span class="go">'No such things as monsters'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-54">相同的<code class="docutils literal"><span class="pre">fallback</span></code>参数可以与<code class="xref py py-meth docutils literal"><span class="pre">getint()</span></code>，<code class="xref py py-meth docutils literal"><span class="pre">getfloat()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">getboolean()</span></code></span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'BatchMode'</span> <span class="ow">in</span> <span class="n">topsecret</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">'BatchMode'</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">'DEFAULT'</span><span class="p">][</span><span class="s1">'BatchMode'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'no'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">'BatchMode'</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
</code></pre></div><div class="section" id="supported-ini-file-structure"><h2><span class="yiyi-st" id="yiyi-55">14.2.4. </span><span class="yiyi-st" id="yiyi-56">支持的INI文件结构</span></h2><p><span class="yiyi-st" id="yiyi-57">A configuration file consists of sections, each led by a <code class="docutils literal"><span class="pre">[section]</span></code> header, followed by key/value entries separated by a specific string (<code class="docutils literal"><span class="pre">=</span></code> or <code class="docutils literal"><span class="pre">:</span></code> by default <a class="footnote-reference" href="#id14" id="id5">[1]</a>). </span><span class="yiyi-st" id="yiyi-58">默认情况下，节名称区分大小写，但键不是<a class="footnote-reference" href="#id14" id="id6">[1]</a>。</span><span class="yiyi-st" id="yiyi-59">前导和尾随空格将从键和值中删除。</span><span class="yiyi-st" id="yiyi-60">可以省略值，在这种情况下，键/值分隔符也可以省略。</span><span class="yiyi-st" id="yiyi-61">值也可以跨越多行，只要它们缩进得比值的第一行更深。</span><span class="yiyi-st" id="yiyi-62">根据解析器的模式，空白行可能被视为多行值的部分或被忽略。</span></p><p><span class="yiyi-st" id="yiyi-63">配置文件可以包括以特定字符（<code class="docutils literal"><span class="pre">#</span></code>和<code class="docutils literal"><span class="pre">;</span></code>，默认为<a class="footnote-reference" href="#id14" id="id7">[1]</a>）作为前缀的注释。</span><span class="yiyi-st" id="yiyi-64">注释可以自己出现在空行上，可能缩进。</span><span class="yiyi-st" id="yiyi-65"><a class="footnote-reference" href="#id14" id="id8"> [1]  T0&gt;</a></span></p><p><span class="yiyi-st" id="yiyi-66">例如：</span></p><div class="highlight-ini"><div class="highlight"><pre><span></span>[Simple Values]
key=value
spaces in keys=allowed
spaces in values=allowed as well
spaces around the delimiter = obviously
you can also use : to delimit keys from values

[All Values Are Strings]
values like this: 1000000
or this: 3.14159265359
are they treated as numbers? : no
integers, floats and booleans are held as: strings
can use the API to get converted values directly: true

[Multiline Values]
chorus: I'm a lumberjack, and I'm okay
    I sleep all night and I work all day

[No Values]
key_without_value
empty string value here =

[You can use comments]
# like this
; or this

# By default only in an empty line.
# Inline comments can be harmful because they prevent users
# from using the delimiting characters as parts of values.
# That being said, this can be customized.

    [Sections Can Be Indented]
        can_values_be_as_well = True
        does_that_mean_anything_special = False
        purpose = formatting for readability
        multiline_values = are
            handled just fine as
            long as they are indented
            deeper than the first line
            of a value
        # Did I mention we can indent comments, too?
</pre></div></div></div><div class="section" id="interpolation-of-values"><h2><span class="yiyi-st" id="yiyi-67">14.2.5. </span><span class="yiyi-st" id="yiyi-68">插值</span></h2><p><span class="yiyi-st" id="yiyi-69">在核心功能之上，<a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal"><span class="pre">ConfigParser</span></code></a>支持插值。</span><span class="yiyi-st" id="yiyi-70">这意味着可以在从<code class="docutils literal"><span class="pre">get()</span></code>调用返回值之前对值进行预处理。</span></p><dl class="class"><dt id="configparser.BasicInterpolation"><span class="yiyi-st" id="yiyi-71"> <em class="property">class </em><code class="descclassname">configparser.</code><code class="descname">BasicInterpolation</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-72"><a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal"><span class="pre">ConfigParser</span></code></a>使用的默认实现。</span><span class="yiyi-st" id="yiyi-73">它允许值包含引用同一段中其他值的格式字符串，或特殊缺省段<a class="footnote-reference" href="#id14" id="id9">[1]</a>中的值。</span><span class="yiyi-st" id="yiyi-74">可以在初始化时提供其他默认值。</span></p><p><span class="yiyi-st" id="yiyi-75">例如：</span></p><div class="highlight-ini"><div class="highlight"><pre><span></span>[Paths]
home_dir: /Users
my_dir: %(home_dir)s/lumberjack
my_pictures: %(my_dir)s/Pictures
</pre></div></div><p><span class="yiyi-st" id="yiyi-76">在上面的示例中，将<a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal"><span class="pre">ConfigParser</span></code></a>与<em>插值</em>设置为<code class="docutils literal"><span class="pre">BasicInterpolation()</span></code>会将<code class="docutils literal"><span class="pre">%(home_dir)s</span></code>值<code class="docutils literal"><span class="pre">home_dir</span></code>（在这种情况下为<code class="docutils literal"><span class="pre">/Users</span></code>）。</span><span class="yiyi-st" id="yiyi-77"><code class="docutils literal"><span class="pre">%(my_dir)s</span></code>实际上会解析为<code class="docutils literal"><span class="pre">/Users/lumberjack</span></code>。</span><span class="yiyi-st" id="yiyi-78">所有内插均按需完成，因此引用链中使用的键不必在配置文件中以任何特定顺序指定。</span></p><p><span class="yiyi-st" id="yiyi-79">With <code class="docutils literal"><span class="pre">interpolation</span></code> set to <code class="docutils literal"><span class="pre">None</span></code>, the parser would simply return <code class="docutils literal"><span class="pre">%(my_dir)s/Pictures</span></code> as the value of <code class="docutils literal"><span class="pre">my_pictures</span></code> and <code class="docutils literal"><span class="pre">%(home_dir)s/lumberjack</span></code> as the value of <code class="docutils literal"><span class="pre">my_dir</span></code>.</span></p></dd></dl><dl class="class"><dt id="configparser.ExtendedInterpolation"><span class="yiyi-st" id="yiyi-80"> <em class="property">class </em><code class="descclassname">configparser.</code><code class="descname">ExtendedInterpolation</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">用于实现更高级语法的插值替代处理程序，用于<code class="docutils literal"><span class="pre">zc.buildout</span></code>中的实例。</span><span class="yiyi-st" id="yiyi-82">扩展插值使用<code class="docutils literal"><span class="pre">${section:option}</span></code>表示来自外部节的值。</span><span class="yiyi-st" id="yiyi-83">插值可以跨越多个级别。</span><span class="yiyi-st" id="yiyi-84">为方便起见，如果省略了<code class="docutils literal"><span class="pre">section:</span></code>部分，则内插默认为当前部分（可能为特殊部分的默认值）。</span></p><p><span class="yiyi-st" id="yiyi-85">例如，上面用基本插值指定的配置，在扩展插值中看起来像这样：</span></p><div class="highlight-ini"><div class="highlight"><pre><span></span>[Paths]
home_dir: /Users
my_dir: ${home_dir}/lumberjack
my_pictures: ${my_dir}/Pictures
</pre></div></div><p><span class="yiyi-st" id="yiyi-86">还可以获取来自其他部分的值：</span></p><div class="highlight-ini"><div class="highlight"><pre><span></span>[Common]
home_dir: /Users
library_dir: /Library
system_dir: /System
macports_dir: /opt/local

[Frameworks]
Python: 3.2
path: ${Common:system_dir}/Library/Frameworks/

[Arthur]
nickname: Two Sheds
last_name: Jackson
my_dir: ${Common:home_dir}/twosheds
my_pictures: ${my_dir}/Pictures
python_dir: ${Frameworks:path}/Python/Versions/${Frameworks:Python}
</pre></div></div></dd></dl></div><div class="section" id="mapping-protocol-access"><h2><span class="yiyi-st" id="yiyi-87">14.2.6. </span><span class="yiyi-st" id="yiyi-88">映射协议访问</span></h2><div class="versionadded"><p><span class="yiyi-st" id="yiyi-89"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div><p><span class="yiyi-st" id="yiyi-90">映射协议访问是功能的通用名称，它允许使用自定义对象，就像它们是字典一样。</span><span class="yiyi-st" id="yiyi-91">在<a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal"><span class="pre">configparser</span></code></a>的情况下，映射接口实现使用<code class="docutils literal"><span class="pre">parser['section']['option']</span></code>符号。</span></p><p><span class="yiyi-st" id="yiyi-92"><code class="docutils literal"><span class="pre">parser['section']</span></code>特别是在解析器中返回该节的数据的代理。</span><span class="yiyi-st" id="yiyi-93">这意味着不会复制这些值，但是它们是根据需要从原始解析器获取的。</span><span class="yiyi-st" id="yiyi-94">更重要的是，当值在段代理上改变时，它们实际上在原始解析器中被改变。</span></p><p><span class="yiyi-st" id="yiyi-95"><a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal"><span class="pre">configparser</span></code></a>对象的行为尽可能接近实际字典。</span><span class="yiyi-st" id="yiyi-96">映射界面已完成，并且符合<a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal"><span class="pre">MutableMapping</span></code></a> ABC。</span><span class="yiyi-st" id="yiyi-97">但是，还有一些差异应该考虑：</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-98">默认情况下，部分中的所有键都可以以不区分大小写的方式访问<a class="footnote-reference" href="#id14" id="id10">[1]</a>。</span><span class="yiyi-st" id="yiyi-99">例如。</span><span class="yiyi-st" id="yiyi-100"><code class="docutils literal"><span class="pre">for</span> <span class="pre">option</span> <span class="pre">in</span> <span class="pre">parser["section"]</span></code> yields only <code class="docutils literal"><span class="pre">optionxform</span></code>‘ed option key names. </span><span class="yiyi-st" id="yiyi-101">这意味着默认情况下较低级的键。</span><span class="yiyi-st" id="yiyi-102">同时，对于保存键<code class="docutils literal"><span class="pre">'a'</span></code>的部分，这两个表达式返回<code class="docutils literal"><span class="pre">True</span></code>：</span></p><pre><code class="language-python"><span></span><span class="s2">"a"</span> <span class="ow">in</span> <span class="n">parser</span><span class="p">[</span><span class="s2">"section"</span><span class="p">]</span>
<span class="s2">"A"</span> <span class="ow">in</span> <span class="n">parser</span><span class="p">[</span><span class="s2">"section"</span><span class="p">]</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-103">所有部分都包含<code class="docutils literal"><span class="pre">DEFAULTSECT</span></code>值，这意味着<code class="docutils literal"><span class="pre">.clear()</span></code>可能不会将该部分留空。</span><span class="yiyi-st" id="yiyi-104">这是因为默认值不能从节中删除（因为在技术上它们不在那里）。</span><span class="yiyi-st" id="yiyi-105">如果它们在部分中被覆盖，则删除导致默认值再次可见。</span><span class="yiyi-st" id="yiyi-106">试图删除默认值会导致一个<code class="docutils literal"><span class="pre">KeyError</span></code></span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-107"><code class="docutils literal"><span class="pre">DEFAULTSECT</span></code>无法从解析器中移除：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-108">试图删除它引发<code class="docutils literal"><span class="pre">ValueError</span></code>，</span></li><li><span class="yiyi-st" id="yiyi-109"><code class="docutils literal"><span class="pre">parser.clear()</span></code>保持原样，</span></li><li><span class="yiyi-st" id="yiyi-110"><code class="docutils literal"><span class="pre">parser.popitem()</span></code>从不返回。</span></li></ul></li><li><p class="first"><span class="yiyi-st" id="yiyi-111"><code class="docutils literal"><span class="pre">parser.get（section，</span> <span class="pre">option，</span> <span class="pre">** kwargs）</span></code>  - 第二个参数是<strong>/ t4&gt;回退值。</strong></span><span class="yiyi-st" id="yiyi-112">但请注意，区段级<code class="docutils literal"><span class="pre">get()</span></code>方法与映射协议和经典的configparser API兼容。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-113"><code class="docutils literal"><span class="pre">parser.items()</span></code>与映射协议兼容（返回包含DEFAULTSECT的<em>section_name</em>，<em>section_proxy</em>对的列表）。</span><span class="yiyi-st" id="yiyi-114">但是，此方法也可以使用参数调用：<code class="docutils literal"><span class="pre">parser.items（section，</span> <span class="pre">raw，</span> <span class="pre">vars）</span></code>。</span><span class="yiyi-st" id="yiyi-115">后一个调用返回指定<code class="docutils literal"><span class="pre">section</span></code>的<em>选项</em>，<em>值</em>对的列表，其中所有内插展开（除非<code class="docutils literal"><span class="pre">raw=True</span></code></span></p></li></ul><p><span class="yiyi-st" id="yiyi-116">映射协议在现有的遗留API之上实现，以便覆盖原始接口的子类仍然应该具有按预期工作的映射。</span></p></div><div class="section" id="customizing-parser-behaviour"><h2><span class="yiyi-st" id="yiyi-117">14.2.7. </span><span class="yiyi-st" id="yiyi-118">自定义解析器行为</span></h2><p><span class="yiyi-st" id="yiyi-119">有几乎和使用它的应用程序一样多的INI格式变体。</span><span class="yiyi-st" id="yiyi-120"><a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal"><span class="pre">configparser</span></code></a>很大程度上为最大的可用的INI样式集提供支持。</span><span class="yiyi-st" id="yiyi-121">默认功能主要由历史背景决定，很有可能您想要自定义一些功能。</span></p><p><span class="yiyi-st" id="yiyi-122">更改特定配置解析器工作方式的最常见方法是使用<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a>选项：</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-123"><em>默认值</em>，默认值：<code class="docutils literal"><span class="pre">None</span></code></span></p><p><span class="yiyi-st" id="yiyi-124">此选项接受键值对的字典，该字典将最初放在<code class="docutils literal"><span class="pre">DEFAULT</span></code>部分中。</span><span class="yiyi-st" id="yiyi-125">这使得一种优雅的方式来支持不指定与记录的默认值相同的值的简明配置文件。</span></p><p><span class="yiyi-st" id="yiyi-126">提示：如果要为特定段指定默认值，请在读取实际文件之前使用<code class="xref py py-meth docutils literal"><span class="pre">read_dict()</span></code>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-127"><em>dict_type</em>，默认值：<a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal"><span class="pre">collections.OrderedDict</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-128">此选项对映射协议的行为以及写入配置文件的外观有重大影响。</span><span class="yiyi-st" id="yiyi-129">使用默认有序字典，每个部分按它们添加到解析器的顺序存储。</span><span class="yiyi-st" id="yiyi-130">部分中的选项也是如此。</span></p><p><span class="yiyi-st" id="yiyi-131">可以使用替代字典类型来例如对回写上的段和选项进行排序。</span><span class="yiyi-st" id="yiyi-132">出于性能原因，您还可以使用常规字典。</span></p><p><span class="yiyi-st" id="yiyi-133">请注意：有一些方法可以在单个操作中添加一组键值对。</span><span class="yiyi-st" id="yiyi-134">当在这些操作中使用常规字典时，键的顺序可以是随机的。</span><span class="yiyi-st" id="yiyi-135">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">read_dict</span><span class="p">({</span><span class="s1">'section1'</span><span class="p">:</span> <span class="p">{</span><span class="s1">'key1'</span><span class="p">:</span> <span class="s1">'value1'</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">'key2'</span><span class="p">:</span> <span class="s1">'value2'</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">'key3'</span><span class="p">:</span> <span class="s1">'value3'</span><span class="p">},</span>
<span class="gp">... </span>                  <span class="s1">'section2'</span><span class="p">:</span> <span class="p">{</span><span class="s1">'keyA'</span><span class="p">:</span> <span class="s1">'valueA'</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">'keyB'</span><span class="p">:</span> <span class="s1">'valueB'</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">'keyC'</span><span class="p">:</span> <span class="s1">'valueC'</span><span class="p">},</span>
<span class="gp">... </span>                  <span class="s1">'section3'</span><span class="p">:</span> <span class="p">{</span><span class="s1">'foo'</span><span class="p">:</span> <span class="s1">'x'</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">'bar'</span><span class="p">:</span> <span class="s1">'y'</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">'baz'</span><span class="p">:</span> <span class="s1">'z'</span><span class="p">}</span>
<span class="gp">... </span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">['section3', 'section2', 'section1']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">option</span> <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">parser</span><span class="p">[</span><span class="s1">'section3'</span><span class="p">]]</span>
<span class="go">['baz', 'foo', 'bar']</span>
</code></pre><p><span class="yiyi-st" id="yiyi-136">在这些操作中，您还需要使用有序字典：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">read_dict</span><span class="p">(</span>
<span class="gp">... </span>  <span class="n">OrderedDict</span><span class="p">((</span>
<span class="gp">... </span>    <span class="p">(</span><span class="s1">'s1'</span><span class="p">,</span>
<span class="gp">... </span>     <span class="n">OrderedDict</span><span class="p">((</span>
<span class="gp">... </span>       <span class="p">(</span><span class="s1">'1'</span><span class="p">,</span> <span class="s1">'2'</span><span class="p">),</span>
<span class="gp">... </span>       <span class="p">(</span><span class="s1">'3'</span><span class="p">,</span> <span class="s1">'4'</span><span class="p">),</span>
<span class="gp">... </span>       <span class="p">(</span><span class="s1">'5'</span><span class="p">,</span> <span class="s1">'6'</span><span class="p">),</span>
<span class="gp">... </span>     <span class="p">))</span>
<span class="gp">... </span>    <span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="s1">'s2'</span><span class="p">,</span>
<span class="gp">... </span>     <span class="n">OrderedDict</span><span class="p">((</span>
<span class="gp">... </span>       <span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">),</span>
<span class="gp">... </span>       <span class="p">(</span><span class="s1">'c'</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">),</span>
<span class="gp">... </span>       <span class="p">(</span><span class="s1">'e'</span><span class="p">,</span> <span class="s1">'f'</span><span class="p">),</span>
<span class="gp">... </span>     <span class="p">))</span>
<span class="gp">... </span>    <span class="p">),</span>
<span class="gp">... </span>  <span class="p">))</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">['s1', 's2']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">option</span> <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">parser</span><span class="p">[</span><span class="s1">'s1'</span><span class="p">]]</span>
<span class="go">['1', '3', '5']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">option</span> <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">parser</span><span class="p">[</span><span class="s1">'s2'</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
<span class="go">['b', 'd', 'f']</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-137"><em>allow_no_value</em>，默认值：<code class="docutils literal"><span class="pre">False</span></code></span></p><p><span class="yiyi-st" id="yiyi-138">已知一些配置文件包括没有值的设置，但符合<a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal"><span class="pre">configparser</span></code></a>支持的语法。</span><span class="yiyi-st" id="yiyi-139">构造函数的<em>allow_no_value</em>参数可用于指示应接受此类值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">configparser</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sample_config</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="gp">... </span><span class="s2">[mysqld]</span>
<span class="gp">... </span><span class="s2">  user = mysql</span>
<span class="gp">... </span><span class="s2">  pid-file = /var/run/mysqld/mysqld.pid</span>
<span class="gp">... </span><span class="s2">  skip-external-locking</span>
<span class="gp">... </span><span class="s2">  old_passwords = 1</span>
<span class="gp">... </span><span class="s2">  skip-bdb</span>
<span class="gp">... </span><span class="s2">  # we don't need ACID today</span>
<span class="gp">... </span><span class="s2">  skip-innodb</span>
<span class="gp">... </span><span class="s2">"""</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">(</span><span class="n">allow_no_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="n">sample_config</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Settings with values are treated as before:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s2">"mysqld"</span><span class="p">][</span><span class="s2">"user"</span><span class="p">]</span>
<span class="go">'mysql'</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Settings without values provide None:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s2">"mysqld"</span><span class="p">][</span><span class="s2">"skip-bdb"</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Settings which aren't specified still raise an error:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s2">"mysqld"</span><span class="p">][</span><span class="s2">"does-not-exist"</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">KeyError</span>: <span class="n">'does-not-exist'</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-140"><em>分隔符</em>，默认值：<code class="docutils literal"><span class="pre">（'='，</span> <span class="pre">'：'）</span></code></span></p><p><span class="yiyi-st" id="yiyi-141">分隔符是从段中的值分隔键的子字符串。</span><span class="yiyi-st" id="yiyi-142">线上的第一个分隔子字符串被视为分隔符。</span><span class="yiyi-st" id="yiyi-143">这意味着值（但不是键）可以包含分隔符。</span></p><p><span class="yiyi-st" id="yiyi-144">另请参阅<a class="reference internal" href="#configparser.ConfigParser.write" title="configparser.ConfigParser.write"><code class="xref py py-meth docutils literal"><span class="pre">ConfigParser.write()</span></code></a>的<em>space_around_delimiters</em>参数。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-145"><em>comment_prefixes</em>，默认值：<code class="docutils literal"><span class="pre">（'＃'，</span> <span class="pre">'；'）</span></code></span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-146"><em>inline_comment_prefixes</em>，默认值：<code class="docutils literal"><span class="pre">None</span></code></span></p><p><span class="yiyi-st" id="yiyi-147">注释前缀是指示配置文件中有效注释的开始的字符串。</span><span class="yiyi-st" id="yiyi-148"><em>comment_prefixes</em>仅用于其他空行（可选缩进），而<em>inline_comment_prefixes</em>可用于每个有效值之后。</span><span class="yiyi-st" id="yiyi-149">部分名称，选项和空行）。</span><span class="yiyi-st" id="yiyi-150">默认情况下，禁用行内注释，并且<code class="docutils literal"><span class="pre">'#'</span></code>和<code class="docutils literal"><span class="pre">';'</span></code>用作整行注释的前缀。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-151"><span class="versionmodified">在版本3.2中更改了</span>：<a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal"><span class="pre">configparser</span></code></a>行为匹配<code class="docutils literal"><span class="pre">comment_prefixes=('#',';')</span></code>和<code class="docutils literal"><span class="pre">inline_comment_prefixes=(';',)</span></code>。</span></p></div><p><span class="yiyi-st" id="yiyi-152">请注意，配置解析器不支持转义注释前缀，因此使用<em>inline_comment_prefixes</em>可能会阻止用户指定带有用作注释前缀的字符的选项值。</span><span class="yiyi-st" id="yiyi-153">遇到疑问时，请避免设置<em>inline_comment_prefixes</em>。</span><span class="yiyi-st" id="yiyi-154">在任何情况下，在多行值中在行的开始处存储注释前缀字符的唯一方法是内插前缀，例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">configparser</span> <span class="k">import</span> <span class="n">ConfigParser</span><span class="p">,</span> <span class="n">ExtendedInterpolation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">(</span><span class="n">interpolation</span><span class="o">=</span><span class="n">ExtendedInterpolation</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the default BasicInterpolation could be used as well</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="s2">"""</span>
<span class="gp">... </span><span class="s2">[DEFAULT]</span>
<span class="gp">... </span><span class="s2">hash = #</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">[hashes]</span>
<span class="gp">... </span><span class="s2">shebang =</span>
<span class="gp">... </span><span class="s2">  $</span><span class="si">{hash}</span><span class="s2">!/usr/bin/env python</span>
<span class="gp">... </span><span class="s2">  $</span><span class="si">{hash}</span><span class="s2"> -*- coding: utf-8 -*-</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">extensions =</span>
<span class="gp">... </span><span class="s2">  enabled_extension</span>
<span class="gp">... </span><span class="s2">  another_extension</span>
<span class="gp">... </span><span class="s2">  #disabled_by_comment</span>
<span class="gp">... </span><span class="s2">  yet_another_extension</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">interpolation not necessary = if # is not at line start</span>
<span class="gp">... </span><span class="s2">even in multiline values = line #1</span>
<span class="gp">... </span><span class="s2">  line #2</span>
<span class="gp">... </span><span class="s2">  line #3</span>
<span class="gp">... </span><span class="s2">"""</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="p">[</span><span class="s1">'hashes'</span><span class="p">][</span><span class="s1">'shebang'</span><span class="p">])</span>

<span class="go">#!/usr/bin/env python</span>
<span class="go"># -*- coding: utf-8 -*-</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="p">[</span><span class="s1">'hashes'</span><span class="p">][</span><span class="s1">'extensions'</span><span class="p">])</span>

<span class="go">enabled_extension</span>
<span class="go">another_extension</span>
<span class="go">yet_another_extension</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="p">[</span><span class="s1">'hashes'</span><span class="p">][</span><span class="s1">'interpolation not necessary'</span><span class="p">])</span>
<span class="go">if # is not at line start</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="p">[</span><span class="s1">'hashes'</span><span class="p">][</span><span class="s1">'even in multiline values'</span><span class="p">])</span>
<span class="go">line #1</span>
<span class="go">line #2</span>
<span class="go">line #3</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-155"><em>严格</em>，默认值：<code class="docutils literal"><span class="pre">True</span></code></span></p><p><span class="yiyi-st" id="yiyi-156">When set to <code class="docutils literal"><span class="pre">True</span></code>, the parser will not allow for any section or option duplicates while reading from a single source (using <code class="xref py py-meth docutils literal"><span class="pre">read_file()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">read_string()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">read_dict()</span></code>). </span><span class="yiyi-st" id="yiyi-157">建议在新应用程序中使用严格的解析器。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-158"><span class="versionmodified">在版本3.2中更改：</span>在以前版本的<a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal"><span class="pre">configparser</span></code></a>行为匹配<code class="docutils literal"><span class="pre">strict=False</span></code>。</span></p></div></li><li><p class="first"><span class="yiyi-st" id="yiyi-159"><em>empty_lines_in_values</em>，默认值：<code class="docutils literal"><span class="pre">True</span></code></span></p><p><span class="yiyi-st" id="yiyi-160">在配置解析器中，值可以跨越多行，只要它们比包含它们的键缩进。</span><span class="yiyi-st" id="yiyi-161">默认情况下，解析器还允许空行成为值的一部分。</span><span class="yiyi-st" id="yiyi-162">同时，键可以任意缩进以提高可读性。</span><span class="yiyi-st" id="yiyi-163">因此，当配置文件变得大而复杂时，用户很容易丢失对文件结构的跟踪。</span><span class="yiyi-st" id="yiyi-164">实例：</span></p><div class="highlight-ini"><div class="highlight"><pre><span></span><span class="k">[Section]</span>
<span class="na">key</span> <span class="o">=</span> <span class="s">multiline</span>
<span class="s">  value with a gotcha</span>

 <span class="na">this</span> <span class="o">=</span> <span class="s">is still a part of the multiline value of 'key'</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-165">这对于用户来说是特别有问题的，以查看她是否使用比例字体来编辑文件。</span><span class="yiyi-st" id="yiyi-166">这就是为什么当你的应用程序不需要空行的值，你应该考虑不允许它们。</span><span class="yiyi-st" id="yiyi-167">这将使空行分裂键每次。</span><span class="yiyi-st" id="yiyi-168">在上面的例子中，它会产生两个键，<code class="docutils literal"><span class="pre">key</span></code>和<code class="docutils literal"><span class="pre">this</span></code>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-169"><em>default_section</em>，默认值：<code class="docutils literal"><span class="pre">configparser.DEFAULTSECT</span></code>（即：<code class="docutils literal"><span class="pre">"DEFAULT"</span></code>）</span></p><p><span class="yiyi-st" id="yiyi-170">允许其他段或插值目的的一个特殊部分的默认值的约定是这个库的一个强大的概念，让用户创建复杂的声明性配置。</span><span class="yiyi-st" id="yiyi-171">此部分通常称为<code class="docutils literal"><span class="pre">"DEFAULT"</span></code>，但可以自定义为指向任何其他有效的节名称。</span><span class="yiyi-st" id="yiyi-172">一些典型值包括：<code class="docutils literal"><span class="pre">"general"</span></code>或<code class="docutils literal"><span class="pre">"common"</span></code>。</span><span class="yiyi-st" id="yiyi-173">提供的名称用于在从任何源读取时识别默认部分，并在将配置写回到文件时使用。</span><span class="yiyi-st" id="yiyi-174">其当前值可以使用<code class="docutils literal"><span class="pre">parser_instance.default_section</span></code>属性来检索，并且可以在运行时被修改。</span><span class="yiyi-st" id="yiyi-175">将文件从一种格式转换为另一种格式）。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-176"><em>插值</em>，默认值：<code class="docutils literal"><span class="pre">configparser.BasicInterpolation</span></code></span></p><p><span class="yiyi-st" id="yiyi-177">插值行为可以通过<em>插值</em>参数提供自定义处理程序来定制。</span><span class="yiyi-st" id="yiyi-178"><code class="docutils literal"><span class="pre">None</span></code>可用于完全关闭插值，<code class="docutils literal"><span class="pre">ExtendedInterpolation()</span></code>提供了受<code class="docutils literal"><span class="pre">zc.buildout</span></code>启发的更高级变体。</span><span class="yiyi-st" id="yiyi-179">有关此主题的更多信息，请参见<a class="reference external" href="#interpolation-of-values">专用文档部分</a>。</span><span class="yiyi-st" id="yiyi-180"><a class="reference internal" href="#configparser.RawConfigParser" title="configparser.RawConfigParser"><code class="xref py py-class docutils literal"><span class="pre">RawConfigParser</span></code></a>的默认值为<code class="docutils literal"><span class="pre">None</span></code>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-181"><em>转换器</em>，默认值：未设置</span></p><p><span class="yiyi-st" id="yiyi-182">Config解析器提供执行类型转换的选项值getter。</span><span class="yiyi-st" id="yiyi-183">默认情况下，实现<code class="xref py py-meth docutils literal"><span class="pre">getint()</span></code>，<code class="xref py py-meth docutils literal"><span class="pre">getfloat()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">getboolean()</span></code>。</span><span class="yiyi-st" id="yiyi-184">如果需要其他getter，用户可以在子类中定义它们，或者传递一个字典，其中每个键是转换器的名称，每个值是一个可调用的实现所述转换。</span><span class="yiyi-st" id="yiyi-185">对于实例，传递<code class="docutils literal"><span class="pre">{'decimal'：</span> <span class="pre">decimal.Decimal}</span></code>会将<code class="xref py py-meth docutils literal"><span class="pre">getdecimal()</span></code></span><span class="yiyi-st" id="yiyi-186">换句话说，可以同时写入<code class="docutils literal"><span class="pre">parser_instance.getdecimal（'section'，</span> <span class="pre">'key'，</span> <span class="pre">fallback = 0） t3 &gt;</span></code>和<code class="docutils literal"><span class="pre">parser_instance ['section']。getdecimal（'key'，</span> <span class="pre">0）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-187">如果转换器需要访问解析器的状态，它可以被实现为配置解析器子类上的方法。</span><span class="yiyi-st" id="yiyi-188">如果此方法的名称以<code class="docutils literal"><span class="pre">get</span></code>开头，它将在所有段代理上以dict兼容的形式提供（参见上面的<code class="docutils literal"><span class="pre">getdecimal()</span></code>示例）。</span></p></li></ul><p><span class="yiyi-st" id="yiyi-189">更高级的定制可以通过覆盖这些解析器属性的默认值来实现。</span><span class="yiyi-st" id="yiyi-190">默认值是在类上定义的，因此它们可能被子类或属性赋值重写。</span></p><dl class="attribute"><dt id="configparser.BOOLEAN_STATES"><span class="yiyi-st" id="yiyi-191"> <code class="descclassname">configparser.</code><code class="descname">BOOLEAN_STATES</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-192">By default when using <code class="xref py py-meth docutils literal"><span class="pre">getboolean()</span></code>, config parsers consider the following values <code class="docutils literal"><span class="pre">True</span></code>: <code class="docutils literal"><span class="pre">'1'</span></code>, <code class="docutils literal"><span class="pre">'yes'</span></code>, <code class="docutils literal"><span class="pre">'true'</span></code>, <code class="docutils literal"><span class="pre">'on'</span></code> and the following values <code class="docutils literal"><span class="pre">False</span></code>: <code class="docutils literal"><span class="pre">'0'</span></code>, <code class="docutils literal"><span class="pre">'no'</span></code>, <code class="docutils literal"><span class="pre">'false'</span></code>, <code class="docutils literal"><span class="pre">'off'</span></code>. </span><span class="yiyi-st" id="yiyi-193">您可以通过指定字符串及其布尔结果的自定义字典来覆盖此。</span><span class="yiyi-st" id="yiyi-194">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="p">[</span><span class="s1">'section1'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'funky'</span><span class="p">:</span> <span class="s1">'nope'</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="p">[</span><span class="s1">'section1'</span><span class="p">]</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">'funky'</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Not a boolean: nope</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">BOOLEAN_STATES</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'sure'</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">'nope'</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="p">[</span><span class="s1">'section1'</span><span class="p">]</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">'funky'</span><span class="p">)</span>
<span class="go">False</span>
</code></pre><p><span class="yiyi-st" id="yiyi-195">其他典型的布尔对包括<code class="docutils literal"><span class="pre">accept</span></code> / <code class="docutils literal"><span class="pre">reject</span></code>或<code class="docutils literal"><span class="pre">enabled</span></code> / <code class="docutils literal"><span class="pre">disabled</span></code>。</span></p></dd></dl><dl class="method"><dt id="configparser.optionxform"><span class="yiyi-st" id="yiyi-196"> <code class="descclassname">configparser.</code><code class="descname">optionxform</code><span class="sig-paren">(</span><em>option</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-197">此方法在每次读取，获取或设置操作时转换选项名称。</span><span class="yiyi-st" id="yiyi-198">默认将名称转换为小写。</span><span class="yiyi-st" id="yiyi-199">这也意味着当配置文件被写时，所有的键都将是小写的。</span><span class="yiyi-st" id="yiyi-200">如果不适合，则覆盖此方法。</span><span class="yiyi-st" id="yiyi-201">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="gp">... </span><span class="s2">[Section1]</span>
<span class="gp">... </span><span class="s2">Key = Value</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">[Section2]</span>
<span class="gp">... </span><span class="s2">AnotherKey = Value</span>
<span class="gp">... </span><span class="s2">"""</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typical</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typical</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">typical</span><span class="p">[</span><span class="s1">'Section1'</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">['key']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">typical</span><span class="p">[</span><span class="s1">'Section2'</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">['anotherkey']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">RawConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">optionxform</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">option</span><span class="p">:</span> <span class="n">option</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">custom</span><span class="p">[</span><span class="s1">'Section1'</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">['Key']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">custom</span><span class="p">[</span><span class="s1">'Section2'</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">['AnotherKey']</span>
</code></pre></dd></dl><dl class="attribute"><dt id="configparser.SECTCRE"><span class="yiyi-st" id="yiyi-202"> <code class="descclassname">configparser.</code><code class="descname">SECTCRE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-203">用于解析节头的编译正则表达式。</span><span class="yiyi-st" id="yiyi-204">默认匹配<code class="docutils literal"><span class="pre">[section]</span></code>到名称<code class="docutils literal"><span class="pre">"section"</span></code>。</span><span class="yiyi-st" id="yiyi-205">Whitespace is considered part of the section name, thus <code class="docutils literal"><span class="pre">[</span> <span class="pre">larch</span> <span class="pre">]</span></code> will be read as a section of name <code class="docutils literal"><span class="pre">"</span> <span class="pre">larch</span> <span class="pre">"</span></code>. </span><span class="yiyi-st" id="yiyi-206">如果此属性不适用，则覆盖此属性。</span><span class="yiyi-st" id="yiyi-207">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="gp">... </span><span class="s2">[Section 1]</span>
<span class="gp">... </span><span class="s2">option = value</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">[  Section 2  ]</span>
<span class="gp">... </span><span class="s2">another = val</span>
<span class="gp">... </span><span class="s2">"""</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typical</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typical</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typical</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">['Section 1', '  Section 2  ']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">SECTCRE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">r"\[ *(?P&lt;header&gt;[^]]+?) *\]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">['Section 1', 'Section 2']</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-208">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-209">虽然ConfigParser对象也使用<code class="docutils literal"><span class="pre">OPTCRE</span></code>属性来识别选项行，但不建议覆盖它，因为这会干扰构造函数选项<em>allow_no_value</em>和<em>分隔符</em> 。</span></p></div></dd></dl></div><div class="section" id="legacy-api-examples"><h2><span class="yiyi-st" id="yiyi-210">14.2.8. </span><span class="yiyi-st" id="yiyi-211">旧版API示例</span></h2><p><span class="yiyi-st" id="yiyi-212">主要是因为向后兼容性问题，<a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal"><span class="pre">configparser</span></code></a>还提供具有显式<code class="docutils literal"><span class="pre">get</span></code> / <code class="docutils literal"><span class="pre">set</span></code>方法的遗留API。</span><span class="yiyi-st" id="yiyi-213">尽管下面概述的方法有有效的用例，但是对于新项目，优选映射协议访问。</span><span class="yiyi-st" id="yiyi-214">传统的API有时是更先进，低级和彻头彻尾的违反直觉。</span></p><p><span class="yiyi-st" id="yiyi-215">写入配置文件的示例：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">configparser</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">RawConfigParser</span><span class="p">()</span>

<span class="c1"># Please note that using RawConfigParser's set functions, you can assign</span>
<span class="c1"># non-string values to keys internally, but will receive an error when</span>
<span class="c1"># attempting to write to a file or when you get it in non-raw mode. Setting</span>
<span class="c1"># values using the mapping protocol or ConfigParser's set() does not allow</span>
<span class="c1"># such assignments to take place.</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'an_int'</span><span class="p">,</span> <span class="s1">'15'</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'a_bool'</span><span class="p">,</span> <span class="s1">'true'</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'a_float'</span><span class="p">,</span> <span class="s1">'3.1415'</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'baz'</span><span class="p">,</span> <span class="s1">'fun'</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">,</span> <span class="s1">'Python'</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'</span><span class="si">%(bar)s</span><span class="s1"> is </span><span class="si">%(baz)s</span><span class="s1">!'</span><span class="p">)</span>

<span class="c1"># Writing our configuration file to 'example.cfg'</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'example.cfg'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">configfile</span><span class="p">:</span>
    <span class="n">config</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">configfile</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-216">再次读取配置文件的示例：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">configparser</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">RawConfigParser</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">'example.cfg'</span><span class="p">)</span>

<span class="c1"># getfloat() raises an exception if the value is not a float</span>
<span class="c1"># getint() and getboolean() also do this for their respective types</span>
<span class="n">a_float</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'a_float'</span><span class="p">)</span>
<span class="n">an_int</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'an_int'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a_float</span> <span class="o">+</span> <span class="n">an_int</span><span class="p">)</span>

<span class="c1"># Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.</span>
<span class="c1"># This is because we are using a RawConfigParser().</span>
<span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'a_bool'</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">))</span>
</code></pre><p><span class="yiyi-st" id="yiyi-217">要获得插值，请使用<a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal"><span class="pre">ConfigParser</span></code></a>：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">configparser</span>

<span class="n">cfg</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="n">cfg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">'example.cfg'</span><span class="p">)</span>

<span class="c1"># Set the optional *raw* argument of get() to True if you wish to disable</span>
<span class="c1"># interpolation in a single get operation.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>  <span class="c1"># -&gt; "Python is fun!"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>   <span class="c1"># -&gt; "%(bar)s is %(baz)s!"</span>

<span class="c1"># The optional *vars* argument is a dict with members that will take</span>
<span class="c1"># precedence in interpolation.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="p">{</span><span class="s1">'bar'</span><span class="p">:</span> <span class="s1">'Documentation'</span><span class="p">,</span>
                                       <span class="s1">'baz'</span><span class="p">:</span> <span class="s1">'evil'</span><span class="p">}))</span>

<span class="c1"># The optional *fallback* argument can be used to provide a fallback value</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">))</span>
      <span class="c1"># -&gt; "Python is fun!"</span>

<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="s1">'Monty is not.'</span><span class="p">))</span>
      <span class="c1"># -&gt; "Python is fun!"</span>

<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'monster'</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="s1">'No such things as monsters.'</span><span class="p">))</span>
      <span class="c1"># -&gt; "No such things as monsters."</span>

<span class="c1"># A bare print(cfg.get('Section1', 'monster')) would raise NoOptionError</span>
<span class="c1"># but we can also use:</span>

<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'monster'</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
      <span class="c1"># -&gt; None</span>
</code></pre><p><span class="yiyi-st" id="yiyi-218">默认值在两种类型的ConfigParsers中可用。</span><span class="yiyi-st" id="yiyi-219">如果未在其他地方定义使用的选项，则用于插值。</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">configparser</span>

<span class="c1"># New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' each</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">({</span><span class="s1">'bar'</span><span class="p">:</span> <span class="s1">'Life'</span><span class="p">,</span> <span class="s1">'baz'</span><span class="p">:</span> <span class="s1">'hard'</span><span class="p">})</span>
<span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">'example.cfg'</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">))</span>     <span class="c1"># -&gt; "Python is fun!"</span>
<span class="n">config</span><span class="o">.</span><span class="n">remove_option</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">remove_option</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'baz'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'Section1'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">))</span>     <span class="c1"># -&gt; "Life is hard!"</span>
</code></pre></div><div class="section" id="configparser-objects"><h2><span class="yiyi-st" id="yiyi-220">14.2.9. </span><span class="yiyi-st" id="yiyi-221">ConfigParser对象</span></h2><dl class="class"><dt id="configparser.ConfigParser"><span class="yiyi-st" id="yiyi-222"><em class="property">class </em><code class="descclassname">configparser.</code><code class="descname">ConfigParser</code><span class="sig-paren">(</span><em>defaults=None</em>, <em>dict_type=collections.OrderedDict</em>, <em>allow_no_value=False</em>, <em>delimiters=('='</em>, <em>':')</em>, <em>comment_prefixes=('#'</em>, <em>';')</em>, <em>inline_comment_prefixes=None</em>, <em>strict=True</em>, <em>empty_lines_in_values=True</em>, <em>default_section=configparser.DEFAULTSECT</em>, <em>interpolation=BasicInterpolation()</em>, <em>converters={}</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-223">主配置解析器。</span><span class="yiyi-st" id="yiyi-224">当给定<em>默认值</em>时，它被初始化为内部默认值的字典。</span><span class="yiyi-st" id="yiyi-225">当给定<em>dict_type</em>时，它将用于为节列表，节中的选项和默认值创建字典对象。</span></p><p><span class="yiyi-st" id="yiyi-226">当给定<em>分隔符</em>时，它用作将键与值分隔开的子串集合。</span><span class="yiyi-st" id="yiyi-227">当给定<em>comment_prefixes</em>时，它将用作前缀为空的行中的注释的子串集合。</span><span class="yiyi-st" id="yiyi-228">注释可以缩进。</span><span class="yiyi-st" id="yiyi-229">当给定<em>inline_comment_prefixes</em>时，它将用作非空行中的注释前面的子字符集。</span></p><p><span class="yiyi-st" id="yiyi-230">当<em>strict</em>是<code class="docutils literal"><span class="pre">True</span></code>（默认值）时，解析器将不允许从单个源（文件，字符串或字典）读取任何节或选项重复， <a class="reference internal" href="#configparser.DuplicateSectionError" title="configparser.DuplicateSectionError"><code class="xref py py-exc docutils literal"><span class="pre">DuplicateSectionError</span></code></a>或<a class="reference internal" href="#configparser.DuplicateOptionError" title="configparser.DuplicateOptionError"><code class="xref py py-exc docutils literal"><span class="pre">DuplicateOptionError</span></code></a>。</span><span class="yiyi-st" id="yiyi-231">当<em>empty_lines_in_values</em>为<code class="docutils literal"><span class="pre">False</span></code>（默认值：<code class="docutils literal"><span class="pre">True</span></code>）时，每个空行标记选项的结尾。</span><span class="yiyi-st" id="yiyi-232">否则，多行选项的内部空行将保留为值的一部分。</span><span class="yiyi-st" id="yiyi-233">当<em>allow_no_value</em>为<code class="docutils literal"><span class="pre">True</span></code>（默认值：<code class="docutils literal"><span class="pre">False</span></code>）时，接受不带值的选项；为它们保留的值为<code class="docutils literal"><span class="pre">None</span></code>，它们被序列化，没有尾部分隔符。</span></p><p><span class="yiyi-st" id="yiyi-234">当给定<em>default_section</em>时，它指定保存其他段和插值目的（通常命名为<code class="docutils literal"><span class="pre">"DEFAULT"</span></code>）的默认值的特殊段的名称。</span><span class="yiyi-st" id="yiyi-235">可以使用<code class="docutils literal"><span class="pre">default_section</span></code>实例属性在运行时检索和更改此值。</span></p><p><span class="yiyi-st" id="yiyi-236">可以通过提供自定义处理程序通过<em>插值</em>参数来定制插值行为。</span><span class="yiyi-st" id="yiyi-237"><code class="docutils literal"><span class="pre">None</span></code>可用于完全关闭插值，<code class="docutils literal"><span class="pre">ExtendedInterpolation()</span></code>提供了受<code class="docutils literal"><span class="pre">zc.buildout</span></code>启发的更高级变体。</span><span class="yiyi-st" id="yiyi-238">有关此主题的更多信息，请参见<a class="reference external" href="#interpolation-of-values">专用文档部分</a>。</span></p><p><span class="yiyi-st" id="yiyi-239">插值中使用的所有选项名称将像任何其他选项名称引用一样通过<a class="reference internal" href="#configparser.optionxform" title="configparser.optionxform"><code class="xref py py-meth docutils literal"><span class="pre">optionxform()</span></code></a>方法传递。</span><span class="yiyi-st" id="yiyi-240">例如，使用<a class="reference internal" href="#configparser.optionxform" title="configparser.optionxform"><code class="xref py py-meth docutils literal"><span class="pre">optionxform()</span></code></a>（将选项名称转换为小写）的默认实现，值<code class="docutils literal"><span class="pre">foo</span> <span class="pre">％（bar） / t5&gt;</span></code>和<code class="docutils literal"><span class="pre">foo</span> <span class="pre">％（BAR）s</span></code></span></p><p><span class="yiyi-st" id="yiyi-241">当给出<em>转换器</em>时，它应该是一个字典，其中每个键代表一个类型转换器的名称，每个值是一个可调用实现从字符串转换到所需的数据类型。</span><span class="yiyi-st" id="yiyi-242">每个转换器在解析器对象和段代理上都有自己对应的<code class="xref py py-meth docutils literal"><span class="pre">get*()</span></code>方法。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-243"><span class="versionmodified">在版本3.1中更改：</span>默认<em>dict_type</em>为<a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal"><span class="pre">collections.OrderedDict</span></code></a>。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-244"><span class="versionmodified">在版本3.2中更改：</span> <em>allow_no_value</em>，<em>分隔符</em>，<em>comment_prefixes</em>，<em>严格</em>，<em> empty_lines_in_values</em>，<em>default_section</em>和<em>插值</em>。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-245"><span class="versionmodified">在版本3.5中已更改：</span>添加了<em>转换器</em>参数。</span></p></div><dl class="method"><dt id="configparser.ConfigParser.defaults"><span class="yiyi-st" id="yiyi-246"> <code class="descname">defaults</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-247">返回包含实例范围默认值的字典。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.sections"><span class="yiyi-st" id="yiyi-248"> <code class="descname">sections</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-249">返回可用节的列表； <em>默认部分</em>不包括在列表中。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.add_section"><span class="yiyi-st" id="yiyi-250"> <code class="descname">add_section</code><span class="sig-paren">(</span><em>section</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-251">在实例中添加一个名为<em>的部分</em>。</span><span class="yiyi-st" id="yiyi-252">如果给定名称的段已经存在，则会引发<a class="reference internal" href="#configparser.DuplicateSectionError" title="configparser.DuplicateSectionError"><code class="xref py py-exc docutils literal"><span class="pre">DuplicateSectionError</span></code></a>。</span><span class="yiyi-st" id="yiyi-253">如果传递<em>默认部分</em>名称，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span><span class="yiyi-st" id="yiyi-254">节的名称必须是字符串；如果不是，则引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-255"><span class="versionmodified">在版本3.2中更改：</span>非字符串段名称引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="configparser.ConfigParser.has_section"><span class="yiyi-st" id="yiyi-256"> <code class="descname">has_section</code><span class="sig-paren">(</span><em>section</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-257">指示配置中是否存在名为<em>节</em>。</span><span class="yiyi-st" id="yiyi-258"><em>默认部分</em>未确认。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.options"><span class="yiyi-st" id="yiyi-259"> <code class="descname">options</code><span class="sig-paren">(</span><em>section</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-260">返回指定<em>部分</em>中可用的选项列表。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.has_option"><span class="yiyi-st" id="yiyi-261"> <code class="descname">has_option</code><span class="sig-paren">(</span><em>section</em>, <em>option</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-262">如果给定的<em>节</em>存在，并且包含给定的<em>选项</em>，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>；否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span><span class="yiyi-st" id="yiyi-263">如果指定的<em>节</em>为<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>或空字符串，则假定为DEFAULT。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.read"><span class="yiyi-st" id="yiyi-264"> <code class="descname">read</code><span class="sig-paren">(</span><em>filenames</em>, <em>encoding=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-265">尝试读取和解析文件名列表，返回已成功解析的文件名列表。</span><span class="yiyi-st" id="yiyi-266">如果<em>文件名</em>是字符串，则将其视为单个文件名。</span><span class="yiyi-st" id="yiyi-267">如果无法打开<em>文件名</em>中命名的文件，该文件将被忽略。</span><span class="yiyi-st" id="yiyi-268">这是为了能够指定潜在的配置文件位置列表（例如，当前目录，用户的主目录和一些系统范围的目录），并且将读取列表中的所有现有配置文件。</span><span class="yiyi-st" id="yiyi-269">如果没有命名文件存在，则<a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal"><span class="pre">ConfigParser</span></code></a>实例将包含一个空数据集。</span><span class="yiyi-st" id="yiyi-270">需要从文件加载初始值的应用程序应在调用<a class="reference internal" href="#configparser.ConfigParser.read" title="configparser.ConfigParser.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>之前使用<a class="reference internal" href="#configparser.ConfigParser.read_file" title="configparser.ConfigParser.read_file"><code class="xref py py-meth docutils literal"><span class="pre">read_file()</span></code></a>加载所需的一个或多个文件：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">configparser</span><span class="o">,</span> <span class="nn">os</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">'defaults.cfg'</span><span class="p">))</span>
<span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">([</span><span class="s1">'site.cfg'</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">'~/.myapp.cfg'</span><span class="p">)],</span>
            <span class="n">encoding</span><span class="o">=</span><span class="s1">'cp1250'</span><span class="p">)</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-271"><span class="versionmodified">版本3.2中的新功能：</span> <em>编码</em>参数。</span><span class="yiyi-st" id="yiyi-272">以前，使用<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>的默认编码读取所有文件。</span></p></div></dd></dl><dl class="method"><dt id="configparser.ConfigParser.read_file"><span class="yiyi-st" id="yiyi-273"> <code class="descname">read_file</code><span class="sig-paren">(</span><em>f</em>, <em>source=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-274">从<em>f</em>读取并解析配置数据，该数据必须是可迭代的，以生成Unicode字符串（例如以文本模式打开的文件）。</span></p><p><span class="yiyi-st" id="yiyi-275">可选参数<em>源</em>指定要读取的文件的名称。</span><span class="yiyi-st" id="yiyi-276">如果未给出，并且<em>f</em>具有<code class="xref py py-attr docutils literal"><span class="pre">name</span></code>属性，则用于<em>源</em>；默认值为<code class="docutils literal"><span class="pre">'&lt;???&gt;'</span></code>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-277"><span class="versionmodified">版本3.2中的新功能：</span>替换<a class="reference internal" href="#configparser.ConfigParser.readfp" title="configparser.ConfigParser.readfp"><code class="xref py py-meth docutils literal"><span class="pre">readfp()</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="configparser.ConfigParser.read_string"><span class="yiyi-st" id="yiyi-278"> <code class="descname">read_string</code><span class="sig-paren">(</span><em>string</em>, <em>source='&lt;string&gt;'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-279">从字符串解析配置数据。</span></p><p><span class="yiyi-st" id="yiyi-280">可选参数<em>source</em>指定传递的字符串的上下文特定名称。</span><span class="yiyi-st" id="yiyi-281">如果未给出，则使用<code class="docutils literal"><span class="pre">'&lt;string&gt;'</span></code>。</span><span class="yiyi-st" id="yiyi-282">这通常应该是文件系统路径或URL。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-283"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="configparser.ConfigParser.read_dict"><span class="yiyi-st" id="yiyi-284"> <code class="descname">read_dict</code><span class="sig-paren">(</span><em>dictionary</em>, <em>source='&lt;dict&gt;'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-285">从提供类似于dict的<code class="docutils literal"><span class="pre">items()</span></code>方法的任何对象加载配置。</span><span class="yiyi-st" id="yiyi-286">键是段名称，值是具有应存在于段中的键和值的字典。</span><span class="yiyi-st" id="yiyi-287">如果使用的字典类型保留顺序，则将按顺序添加节及其键。</span><span class="yiyi-st" id="yiyi-288">值自动转换为字符串。</span></p><p><span class="yiyi-st" id="yiyi-289">可选参数<em>source</em>指定传递的字典的上下文特定名称。</span><span class="yiyi-st" id="yiyi-290">如果没有给出，则使用<code class="docutils literal"><span class="pre">&lt;dict&gt;</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-291">此方法可用于在解析器之间复制状态。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-292"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="configparser.ConfigParser.get"><span class="yiyi-st" id="yiyi-293"> <code class="descname">get</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>*</em>, <em>raw=False</em>, <em>vars=None</em><span class="optional">[</span>, <em>fallback</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-294">为命名的<em>节</em>获取<em>选项</em>值。</span><span class="yiyi-st" id="yiyi-295">如果提供<em>vars</em>，它必须是字典。</span><span class="yiyi-st" id="yiyi-296">在<em>vars</em>（如果提供），<em>节</em>和<em>DEFAULTSECT</em>中按顺序查找<em>选项</em>。</span><span class="yiyi-st" id="yiyi-297">如果未找到键且提供<em>fallback</em>，则将其用作回退值。</span><span class="yiyi-st" id="yiyi-298"><code class="docutils literal"><span class="pre">None</span></code>可以作为<em>回退</em>值提供。</span></p><p><span class="yiyi-st" id="yiyi-299">除非<em>raw</em>参数为真，所有<code class="docutils literal"><span class="pre">'%'</span></code>内插都会在返回值中展开。</span><span class="yiyi-st" id="yiyi-300">插值键的值以与选项相同的方式查找。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-301"><span class="versionmodified">在版本3.2中更改：</span>参数<em>raw</em>，<em>vars</em>和<em>fallback</em>是关键字，仅用于保护用户不要使用第三个参数作为<em>fallback</em>回退（尤其是在使用映射协议时）。</span></p></div></dd></dl><dl class="method"><dt id="configparser.ConfigParser.getint"><span class="yiyi-st" id="yiyi-302"> <code class="descname">getint</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>*</em>, <em>raw=False</em>, <em>vars=None</em><span class="optional">[</span>, <em>fallback</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-303">一种方便的方法，将指定的<em>节</em>中的<em>选项</em>强制为整数。</span><span class="yiyi-st" id="yiyi-304">有关<em>raw</em>，<em>vars</em>和<em>fallback</em>的说明，请参阅<a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code class="xref py py-meth docutils literal"><span class="pre">get()</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.getfloat"><span class="yiyi-st" id="yiyi-305"> <code class="descname">getfloat</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>*</em>, <em>raw=False</em>, <em>vars=None</em><span class="optional">[</span>, <em>fallback</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-306">一种方便的方法，将指定的<em>节</em>中的<em>选项</em>强制为浮点数。</span><span class="yiyi-st" id="yiyi-307">有关<em>raw</em>，<em>vars</em>和<em>fallback</em>的说明，请参阅<a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code class="xref py py-meth docutils literal"><span class="pre">get()</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.getboolean"><span class="yiyi-st" id="yiyi-308"> <code class="descname">getboolean</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>*</em>, <em>raw=False</em>, <em>vars=None</em><span class="optional">[</span>, <em>fallback</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-309">一种方便的方法，用于将指定的<em>节</em>中的<em>选项</em>强制为布尔值。</span><span class="yiyi-st" id="yiyi-310">Note that the accepted values for the option are <code class="docutils literal"><span class="pre">'1'</span></code>, <code class="docutils literal"><span class="pre">'yes'</span></code>, <code class="docutils literal"><span class="pre">'true'</span></code>, and <code class="docutils literal"><span class="pre">'on'</span></code>, which cause this method to return <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">'0'</span></code>, <code class="docutils literal"><span class="pre">'no'</span></code>, <code class="docutils literal"><span class="pre">'false'</span></code>, and <code class="docutils literal"><span class="pre">'off'</span></code>, which cause it to return <code class="docutils literal"><span class="pre">False</span></code>. </span><span class="yiyi-st" id="yiyi-311">这些字符串值以不区分大小写的方式进行检查。</span><span class="yiyi-st" id="yiyi-312">任何其他值将导致它引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span><span class="yiyi-st" id="yiyi-313">有关<em>raw</em>，<em>vars</em>和<em>fallback</em>的说明，请参阅<a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code class="xref py py-meth docutils literal"><span class="pre">get()</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.items"><span class="yiyi-st" id="yiyi-314"> <code class="descname">items</code><span class="sig-paren">(</span><em>raw=False</em>, <em>vars=None</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-315"> <code class="descname">items</code><span class="sig-paren">(</span><em>section</em>, <em>raw=False</em>, <em>vars=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-316">当未提供<em>节</em>时，返回<em>section_name</em>，<em>section_proxy</em>对的列表，包括DEFAULTSECT。</span></p><p><span class="yiyi-st" id="yiyi-317">否则，返回给定<em>节</em>中的选项的<em>名称</em>，<em>值</em>对的列表。</span><span class="yiyi-st" id="yiyi-318">可选参数与<a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code class="xref py py-meth docutils literal"><span class="pre">get()</span></code></a>方法具有相同的含义。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-319"><span class="versionmodified">在版本3.2中更改：</span> <em>vars</em>中显示的项目不再显示在结果中。</span><span class="yiyi-st" id="yiyi-320">之前的行为将实际解析器选项与为插值提供的变量混合。</span></p></div></dd></dl><dl class="method"><dt id="configparser.ConfigParser.set"><span class="yiyi-st" id="yiyi-321"> <code class="descname">set</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>value</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-322">如果给定段存在，则将给定选项设置为指定值；否则引发<a class="reference internal" href="#configparser.NoSectionError" title="configparser.NoSectionError"><code class="xref py py-exc docutils literal"><span class="pre">NoSectionError</span></code></a></span><span class="yiyi-st" id="yiyi-323"><em>选项</em>和<em>值</em>必须是字符串；如果不是，则会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.write"><span class="yiyi-st" id="yiyi-324"> <code class="descname">write</code><span class="sig-paren">(</span><em>fileobject</em>, <em>space_around_delimiters=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-325">将配置的表示写入指定的<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>，必须在文本模式下打开（接受字符串）。</span><span class="yiyi-st" id="yiyi-326">此表示可以通过未来的<a class="reference internal" href="#configparser.ConfigParser.read" title="configparser.ConfigParser.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>调用进行解析。</span><span class="yiyi-st" id="yiyi-327">如果<em>space_around_delimiters</em>为真，则键和值之间的分隔符由空格包围。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.remove_option"><span class="yiyi-st" id="yiyi-328"> <code class="descname">remove_option</code><span class="sig-paren">(</span><em>section</em>, <em>option</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-329">从指定的<em>部分</em>中删除指定的<em>选项</em>。</span><span class="yiyi-st" id="yiyi-330">如果该部分不存在，引发<a class="reference internal" href="#configparser.NoSectionError" title="configparser.NoSectionError"><code class="xref py py-exc docutils literal"><span class="pre">NoSectionError</span></code></a>。</span><span class="yiyi-st" id="yiyi-331">如果该选项存在要删除，请返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>；否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.remove_section"><span class="yiyi-st" id="yiyi-332"> <code class="descname">remove_section</code><span class="sig-paren">(</span><em>section</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-333">从配置中删除指定的<em>节</em>。</span><span class="yiyi-st" id="yiyi-334">如果该部分实际上存在，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-335">否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.optionxform"><span class="yiyi-st" id="yiyi-336"> <code class="descname">optionxform</code><span class="sig-paren">(</span><em>option</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-337">将在输入文件中找到的或由客户端代码传递的选项名称<em>选项</em>转换为应在内部结构中使用的形式。</span><span class="yiyi-st" id="yiyi-338">默认实现返回<em>选项</em>的小写版本；子类可以覆盖此或客户端代码可以在实例上设置此名称的属性以影响此行为。</span></p><p><span class="yiyi-st" id="yiyi-339">您不需要将解析器子类化为使用此方法，您也可以将其设置为实例，一个接受字符串参数并返回字符串的函数。</span><span class="yiyi-st" id="yiyi-340">例如，将其设置为<code class="docutils literal"><span class="pre">str</span></code>会使选项名区分大小写：</span></p><pre><code class="language-python"><span></span><span class="n">cfgparser</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">()</span>
<span class="n">cfgparser</span><span class="o">.</span><span class="n">optionxform</span> <span class="o">=</span> <span class="nb">str</span>
</code></pre><p><span class="yiyi-st" id="yiyi-341">请注意，当读取配置文件时，在调用<a class="reference internal" href="#configparser.optionxform" title="configparser.optionxform"><code class="xref py py-meth docutils literal"><span class="pre">optionxform()</span></code></a>之前，选项名称周围的空格被去除。</span></p></dd></dl><dl class="method"><dt id="configparser.ConfigParser.readfp"><span class="yiyi-st" id="yiyi-342"> <code class="descname">readfp</code><span class="sig-paren">(</span><em>fp</em>, <em>filename=None</em><span class="sig-paren">)</span></span></dt><dd><div class="deprecated"><p><span class="yiyi-st" id="yiyi-343"><span class="versionmodified">自版本3.2后已弃用：</span>改用<a class="reference internal" href="#configparser.ConfigParser.read_file" title="configparser.ConfigParser.read_file"><code class="xref py py-meth docutils literal"><span class="pre">read_file()</span></code></a>。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-344"><span class="versionmodified">在版本3.2中更改：</span> <a class="reference internal" href="#configparser.ConfigParser.readfp" title="configparser.ConfigParser.readfp"><code class="xref py py-meth docutils literal"><span class="pre">readfp()</span></code></a>现在在<em>f</em>上迭代，而不是调用<code class="docutils literal"><span class="pre">f.readline()</span></code>。</span></p></div><p><span class="yiyi-st" id="yiyi-345">对于使用不支持迭代的参数调用<a class="reference internal" href="#configparser.ConfigParser.readfp" title="configparser.ConfigParser.readfp"><code class="xref py py-meth docutils literal"><span class="pre">readfp()</span></code></a>的现有代码，以下生成器可用作类文件对象的包装器：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">readline_generator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">line</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-346">而不是<code class="docutils literal"><span class="pre">parser.readfp(f)</span></code>使用<code class="docutils literal"><span class="pre">parser.read_file(readline_generator(f))</span></code>。</span></p></dd></dl></dd></dl><dl class="data"><dt id="configparser.MAX_INTERPOLATION_DEPTH"><span class="yiyi-st" id="yiyi-347"><code class="descclassname"> configparser。 T0&gt; <code class="descname"> MAX_INTERPOLATION_DEPTH  T1&gt; </code></code></span></dt><dd><p><span class="yiyi-st" id="yiyi-348">当<em>raw</em>参数为false时，<code class="xref py py-meth docutils literal"><span class="pre">get()</span></code>的递归插值的最大深度。</span><span class="yiyi-st" id="yiyi-349">仅当使用默认的<em>插值</em>时，这一点才相关。</span></p></dd></dl></div><div class="section" id="rawconfigparser-objects"><h2><span class="yiyi-st" id="yiyi-350">14.2.10. </span><span class="yiyi-st" id="yiyi-351">RawConfigParser对象</span></h2><dl class="class"><dt id="configparser.RawConfigParser"><span class="yiyi-st" id="yiyi-352"> <em class="property">class </em><code class="descclassname">configparser.</code><code class="descname">RawConfigParser</code><span class="sig-paren">(</span><em>defaults=None</em>, <em>dict_type=collections.OrderedDict</em>, <em>allow_no_value=False</em>, <em>*</em>, <em>delimiters=('='</em>, <em>':')</em>, <em>comment_prefixes=('#'</em>, <em>';')</em>, <em>inline_comment_prefixes=None</em>, <em>strict=True</em>, <em>empty_lines_in_values=True</em>, <em>default_section=configparser.DEFAULTSECT</em><span class="optional">[</span>, <em>interpolation</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-353">默认情况下禁用插值的<a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal"><span class="pre">ConfigParser</span></code></a>的旧版本和不安全的<code class="docutils literal"><span class="pre">add_section</span></code>和<code class="docutils literal"><span class="pre">set</span></code>方法。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-354">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-355">考虑使用<a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal"><span class="pre">ConfigParser</span></code></a>来检查要在内部存储的值的类型。</span><span class="yiyi-st" id="yiyi-356">如果不需要插值，可以使用<code class="docutils literal"><span class="pre">ConfigParser(interpolation=None)</span></code>。</span></p></div><dl class="method"><dt id="configparser.RawConfigParser.add_section"><span class="yiyi-st" id="yiyi-357"> <code class="descname">add_section</code><span class="sig-paren">(</span><em>section</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-358">在实例中添加一个名为<em>的部分</em>。</span><span class="yiyi-st" id="yiyi-359">如果给定名称的段已经存在，则会引发<a class="reference internal" href="#configparser.DuplicateSectionError" title="configparser.DuplicateSectionError"><code class="xref py py-exc docutils literal"><span class="pre">DuplicateSectionError</span></code></a>。</span><span class="yiyi-st" id="yiyi-360">如果传递<em>默认部分</em>名称，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-361">不检查<em>节</em>的类型，它允许用户创建非字符串命名节。</span><span class="yiyi-st" id="yiyi-362">此行为不受支持，可能会导致内部错误。</span></p></dd></dl><dl class="method"><dt id="configparser.RawConfigParser.set"><span class="yiyi-st" id="yiyi-363"> <code class="descname">set</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>value</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-364">如果给定段存在，则将给定选项设置为指定值；否则引发<a class="reference internal" href="#configparser.NoSectionError" title="configparser.NoSectionError"><code class="xref py py-exc docutils literal"><span class="pre">NoSectionError</span></code></a></span><span class="yiyi-st" id="yiyi-365">虽然<a class="reference internal" href="#configparser.RawConfigParser" title="configparser.RawConfigParser"><code class="xref py py-class docutils literal"><span class="pre">RawConfigParser</span></code></a>（或<a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal"><span class="pre">ConfigParser</span></code></a>与<em>raw</em>参数设置为true）可用于<em>内部</em>字符串值，完整功能（包括插值和文件输出）只能使用字符串值来实现。</span></p><p><span class="yiyi-st" id="yiyi-366">此方法允许用户在内部为键分配非字符串值。</span><span class="yiyi-st" id="yiyi-367">此行为不受支持，并且将在尝试写入文件或将其置于非原始模式时导致错误。</span><span class="yiyi-st" id="yiyi-368"><strong>使用不允许进行此类分配的映射协议API</strong>。</span></p></dd></dl></dd></dl></div><div class="section" id="exceptions"><h2><span class="yiyi-st" id="yiyi-369">14.2.11. </span><span class="yiyi-st" id="yiyi-370">例外</span></h2><dl class="exception"><dt id="configparser.Error"><span class="yiyi-st" id="yiyi-371"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">Error</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-372">所有其他<a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal"><span class="pre">configparser</span></code></a>异常的基类。</span></p></dd></dl><dl class="exception"><dt id="configparser.NoSectionError"><span class="yiyi-st" id="yiyi-373"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">NoSectionError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-374">未找到指定节时引发异常。</span></p></dd></dl><dl class="exception"><dt id="configparser.DuplicateSectionError"><span class="yiyi-st" id="yiyi-375"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">DuplicateSectionError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-376">如果<code class="xref py py-meth docutils literal"><span class="pre">add_section()</span></code>使用已存在的节的名称或在严格解析器中调用时，如果在单个输入文件，字符串或字典中发现多个节，则会引发异常。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-377"><span class="versionmodified">版本3.2中的新功能：</span>添加了可选的<code class="docutils literal"><span class="pre">source</span></code>和<code class="docutils literal"><span class="pre">lineno</span></code>属性和参数<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a></span></p></div></dd></dl><dl class="exception"><dt id="configparser.DuplicateOptionError"><span class="yiyi-st" id="yiyi-378"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">DuplicateOptionError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-379">如果单个选项在从单个文件，字符串或字典读取期间出现两次，则严格解析器引发的异常。</span><span class="yiyi-st" id="yiyi-380">这会捕获错误拼写和区分大小写相关的错误，例如</span><span class="yiyi-st" id="yiyi-381">字典可以具有表示相同的不区分大小写的配置键的两个键。</span></p></dd></dl><dl class="exception"><dt id="configparser.NoOptionError"><span class="yiyi-st" id="yiyi-382"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">NoOptionError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-383">在指定的部分中找不到指定的选项时引发异常。</span></p></dd></dl><dl class="exception"><dt id="configparser.InterpolationError"><span class="yiyi-st" id="yiyi-384"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">InterpolationError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-385">执行字符串插值时发生问题时出现的异常的基类。</span></p></dd></dl><dl class="exception"><dt id="configparser.InterpolationDepthError"><span class="yiyi-st" id="yiyi-386"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">InterpolationDepthError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-387">由于迭代次数超过<a class="reference internal" href="#configparser.MAX_INTERPOLATION_DEPTH" title="configparser.MAX_INTERPOLATION_DEPTH"><code class="xref py py-const docutils literal"><span class="pre">MAX_INTERPOLATION_DEPTH</span></code></a>，无法完成字符串插值时出现异常。</span><span class="yiyi-st" id="yiyi-388"><a class="reference internal" href="#configparser.InterpolationError" title="configparser.InterpolationError"><code class="xref py py-exc docutils literal"><span class="pre">InterpolationError</span></code></a>的子类。</span></p></dd></dl><dl class="exception"><dt id="configparser.InterpolationMissingOptionError"><span class="yiyi-st" id="yiyi-389"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">InterpolationMissingOptionError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-390">从值引用的选项不存在时引发异常。</span><span class="yiyi-st" id="yiyi-391"><a class="reference internal" href="#configparser.InterpolationError" title="configparser.InterpolationError"><code class="xref py py-exc docutils literal"><span class="pre">InterpolationError</span></code></a>的子类。</span></p></dd></dl><dl class="exception"><dt id="configparser.InterpolationSyntaxError"><span class="yiyi-st" id="yiyi-392"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">InterpolationSyntaxError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-393">在进行替换的源文本不符合所需语法时引发异常。</span><span class="yiyi-st" id="yiyi-394"><a class="reference internal" href="#configparser.InterpolationError" title="configparser.InterpolationError"><code class="xref py py-exc docutils literal"><span class="pre">InterpolationError</span></code></a>的子类。</span></p></dd></dl><dl class="exception"><dt id="configparser.MissingSectionHeaderError"><span class="yiyi-st" id="yiyi-395"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">MissingSectionHeaderError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-396">尝试解析没有段头的文件时抛出异常。</span></p></dd></dl><dl class="exception"><dt id="configparser.ParsingError"><span class="yiyi-st" id="yiyi-397"> <em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">ParsingError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-398">尝试解析文件时发生错误时抛出异常。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-399"><span class="versionmodified">在版本3.2中更改：</span>为了一致性，将<code class="docutils literal"><span class="pre">filename</span></code>属性和<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a>参数重命名为<code class="docutils literal"><span class="pre">source</span></code></span></p></div></dd></dl><p class="rubric"><span class="yiyi-st" id="yiyi-400">脚注</span></p><table class="docutils footnote" frame="void" id="id14" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-401">[1]</span></td><td><span class="yiyi-st" id="yiyi-402"><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id3">3</a>, <a class="fn-backref" href="#id4">4</a>, <a class="fn-backref" href="#id5">5</a>, <a class="fn-backref" href="#id6">6</a>, <a class="fn-backref" href="#id7">7</a>, <a class="fn-backref" href="#id8">8</a>, <a class="fn-backref" href="#id9">9</a>, <a class="fn-backref" href="#id10">10</a>)</em> Config parsers allow for heavy customization. </span><span class="yiyi-st" id="yiyi-403">如果您有兴趣更改脚注参考中概述的行为，请参阅<a class="reference internal" href="#customizing-parser-behaviour">自定义解析器行为</a>部分。</span></td></tr></tbody></table></div></div></div>