<div class="body" role="main"><div class="section" id="module-argparse"><h1><span class="yiyi-st" id="yiyi-10">16.4. <a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a> — 命令行选项、参数、子命令的解析</span></h1><div class="versionadded"><p><span class="yiyi-st" id="yiyi-11"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div><p><span class="yiyi-st" id="yiyi-12"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/argparse.py">Lib / argparse.py</a></span></p><div class="sidebar"><p class="first sidebar-title"><span class="yiyi-st" id="yiyi-13">教程</span></p><p class="last"><span class="yiyi-st" id="yiyi-14">本页包含API参考信息.</span><span class="yiyi-st" id="yiyi-15">要知道更多的python命令行转化,请看<a class="reference internal" href="../howto/argparse.html#id1"><span>argparse教程</span></a>.</span></p></div><p><span class="yiyi-st" id="yiyi-16"><a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a> 模块使编写用户友好的命令行界面变得更容易.</span><span class="yiyi-st" id="yiyi-17">程序指出了它需要的参数, 并且 <a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a>会指出参数怎样导出 <a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal"><span class="pre">sys.argv</span></code></a>. </span><span class="yiyi-st" id="yiyi-18">这 <a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a> 模块会自动生成帮助和使用信息和当用户给程序错误参数的时候产生的错误。</span></p><div class="section" id="example"><h2><span class="yiyi-st" id="yiyi-19">16.4.1. </span><span class="yiyi-st" id="yiyi-20">示例</span></h2><p><span class="yiyi-st" id="yiyi-21">下面的python程序输入整数列表并且求和或取最大值。</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">argparse</span>

<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">'Process some integers.'</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'integers'</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">'N'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'+'</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">'an integer for the accumulator'</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--sum'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">'accumulate'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_const'</span><span class="p">,</span>
                    <span class="n">const</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">'sum the integers (default: find the max)'</span><span class="p">)</span>

<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">integers</span><span class="p">))</span>
</code></pre><p><span class="yiyi-st" id="yiyi-22">假设上面的Python代码保存在名为<code class="docutils literal"><span class="pre">prog.py</span></code>的文件中，它可以在命令行运行并提供有用的帮助信息：</span></p><div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> python prog.py -h
<span class="go">usage: prog.py [-h] [--sum] N [N ...]</span>

<span class="go">Process some integers.</span>

<span class="go">positional arguments:</span>
<span class="go"> N           an integer for the accumulator</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
<span class="go"> --sum       sum the integers (default: find the max)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-23">当使用适当的参数运行时，它会输出命令行整数的总和或最大值：</span></p><div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> python prog.py <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> 4
<span class="go">4</span>

<span class="gp">$</span> python prog.py <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> --sum
<span class="go">10</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-24">如果传入无效参数，它将发出错误：</span></p><div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> python prog.py a b c
<span class="go">usage: prog.py [-h] [--sum] N [N ...]</span>
<span class="go">prog.py: error: argument N: invalid int value: 'a'</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-25">以下部分将引导您完成此示例。</span></p><div class="section" id="creating-a-parser"><h3><span class="yiyi-st" id="yiyi-26">16.4.1.1. </span><span class="yiyi-st" id="yiyi-27">创建解析器</span></h3><p><span class="yiyi-st" id="yiyi-28">使用 <a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a> 的第一步是创建一个<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a> 对象:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">'Process some integers.'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-29"><a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a> 对象会将命令行信息解析并保存为python需要的信息及类型</span></p></div><div class="section" id="adding-arguments"><h3><span class="yiyi-st" id="yiyi-30">16.4.1.2. </span><span class="yiyi-st" id="yiyi-31">添加参数</span></h3><p><span class="yiyi-st" id="yiyi-32">通过调用<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>方法为<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>添加程序参数信息.</span><span class="yiyi-st" id="yiyi-33">一般来说, 这些调用会告知<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a> 如何将命令行参数转换成Python对象.</span><span class="yiyi-st" id="yiyi-34">这些信息将在 <a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a> 被调用时被存储及使用.</span><span class="yiyi-st" id="yiyi-35">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'integers'</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">'N'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'+'</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">help</span><span class="o">=</span><span class="s1">'an integer for the accumulator'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--sum'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">'accumulate'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_const'</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">const</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">help</span><span class="o">=</span><span class="s1">'sum the integers (default: find the max)'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-36">之后, 调用 <a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>会返回一个拥有2个属性的对象, <code class="docutils literal"><span class="pre">integers</span></code> 和<code class="docutils literal"><span class="pre">accumulate</span></code>.</span><span class="yiyi-st" id="yiyi-37"><code class="docutils literal"><span class="pre">integers</span></code> 属性是一个 list 包含一个或多个整数,  <code class="docutils literal"><span class="pre">accumulate</span></code>属性 可能是 <a class="reference internal" href="functions.html#sum" title="sum"><code class="xref py py-func docutils literal"><span class="pre">sum()</span></code></a> 函数, 如果 <code class="docutils literal"><span class="pre">--sum</span></code>参数在命令行中有提供的话, 否则就是<a class="reference internal" href="functions.html#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a> 函数.</span></p></div><div class="section" id="parsing-arguments"><h3><span class="yiyi-st" id="yiyi-38">16.4.1.3. </span><span class="yiyi-st" id="yiyi-39">解析参数</span></h3><p><span class="yiyi-st" id="yiyi-40"><a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>通过<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>方法解析参数。</span><span class="yiyi-st" id="yiyi-41">这将检查命令行，将每个参数转换为适当的类型，然后调用相应的操作。</span><span class="yiyi-st" id="yiyi-42">在大多数情况下，这意味着一个简单的<a class="reference internal" href="#argparse.Namespace" title="argparse.Namespace"><code class="xref py py-class docutils literal"><span class="pre">Namespace</span></code></a>对象将由从命令行解析出来的属性构建：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--sum'</span><span class="p">,</span> <span class="s1">'7'</span><span class="p">,</span> <span class="s1">'-1'</span><span class="p">,</span> <span class="s1">'42'</span><span class="p">])</span>
<span class="go">Namespace(accumulate=&lt;built-in function sum&gt;, integers=[7, -1, 42])</span>
</code></pre><p><span class="yiyi-st" id="yiyi-43">In a script, <a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a> will typically be called with no arguments, and the <a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a> will automatically determine the command-line arguments from <a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal"><span class="pre">sys.argv</span></code></a>.</span></p></div></div><div class="section" id="argumentparser-objects"><h2><span class="yiyi-st" id="yiyi-44">16.4.2. </span><span class="yiyi-st" id="yiyi-45">ArgumentParser对象</span></h2><dl class="class"><dt id="argparse.ArgumentParser"><span class="yiyi-st" id="yiyi-46"> <em class="property">class </em><code class="descclassname">argparse.</code><code class="descname">ArgumentParser</code><span class="sig-paren">(</span><em>prog=None</em>, <em>usage=None</em>, <em>description=None</em>, <em>epilog=None</em>, <em>parents=[]</em>, <em>formatter_class=argparse.HelpFormatter</em>, <em>prefix_chars='-'</em>, <em>fromfile_prefix_chars=None</em>, <em>argument_default=None</em>, <em>conflict_handler='error'</em>, <em>add_help=True</em>, <em>allow_abbrev=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-47">创建一个新的<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-48">所有的参数都是关键字参数.</span><span class="yiyi-st" id="yiyi-49">以下每个参数都有其更详细的描述，但总之是：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-50"><a class="reference internal" href="#prog">prog</a> - 程序的名字 (default: <code class="docutils literal"><span class="pre">sys.argv[0]</span></code>)</span></li><li><span class="yiyi-st" id="yiyi-51"><a class="reference internal" href="#usage">用法</a>  - 描述程序用法的字符串（默认值：从添加到解析器的参数生成）</span></li><li><span class="yiyi-st" id="yiyi-52"><a class="reference internal" href="#description">description</a>  - 参数帮助前显示的文本（默认值：无）</span></li><li><span class="yiyi-st" id="yiyi-53"><a class="reference internal" href="#epilog">epilog</a>  - 参数帮助后显示的文本（默认值：无）</span></li><li><span class="yiyi-st" id="yiyi-54"><a class="reference internal" href="#parents">父母</a>  - 其参数也应包含在内的<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象列表</span></li><li><span class="yiyi-st" id="yiyi-55"><a class="reference internal" href="#formatter-class">formatter_class</a>  - 用于自定义帮助输出的类</span></li><li><span class="yiyi-st" id="yiyi-56"><a class="reference internal" href="#prefix-chars">prefix_chars</a>  - 可选参数前缀的字符集（默认值：' - '）</span></li><li><span class="yiyi-st" id="yiyi-57"><a class="reference internal" href="#fromfile-prefix-chars">fromfile_prefix_chars</a>  - 前缀附加参数应读取的文件的字符集（默认值：<code class="docutils literal"><span class="pre">None</span></code>）</span></li><li><span class="yiyi-st" id="yiyi-58"><a class="reference internal" href="#argument-default">argument_default</a>  - 参数的全局默认值（默认值：<code class="docutils literal"><span class="pre">None</span></code>）</span></li><li><span class="yiyi-st" id="yiyi-59"><a class="reference internal" href="#conflict-handler">conflict_handler</a>  - 解决冲突选项的策略（通常不需要）</span></li><li><span class="yiyi-st" id="yiyi-60"><a class="reference internal" href="#add-help">add_help</a>  - 为解析器添加-h / -help选项（默认值：<code class="docutils literal"><span class="pre">True</span></code>）</span></li><li><span class="yiyi-st" id="yiyi-61"><a class="reference internal" href="#allow-abbrev">allow_abbrev</a>  - 如果缩写是明确的，允许长选项被缩写。</span><span class="yiyi-st" id="yiyi-62">（默认：<code class="docutils literal"><span class="pre">True</span></code>）</span></li></ul><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-63"><span class="versionmodified">版本3.5已更改：</span> <em>allow_abbrev</em>参数已添加。</span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-64">以下部分描述如何使用每个这些。</span></p><div class="section" id="prog"><h3><span class="yiyi-st" id="yiyi-65">16.4.2.1.  PROG </span></h3><p><span class="yiyi-st" id="yiyi-66">默认情况下，<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象使用<code class="docutils literal"><span class="pre">sys.argv[0]</span></code>来确定如何在帮助消息中显示程序的名称。</span><span class="yiyi-st" id="yiyi-67">这个默认值几乎总是可取的，因为它会使帮助消息与命令行上的程序调用方式相匹配。</span><span class="yiyi-st" id="yiyi-68">例如，考虑一个名为<code class="docutils literal"><span class="pre">myprogram.py</span></code>的文件，其代码如下：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'foo help'</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-69">该程序的帮助将显示<code class="docutils literal"><span class="pre">myprogram.py</span></code>作为程序名称（不管程序从何处被调用）：</span></p><div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> python myprogram.py --help
<span class="go">usage: myprogram.py [-h] [--foo FOO]</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
<span class="go"> --foo FOO   foo help</span>
<span class="gp">$</span> <span class="nb">cd</span> ..
<span class="gp">$</span> python subdir<span class="se">\m</span>yprogram.py --help
<span class="go">usage: myprogram.py [-h] [--foo FOO]</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
<span class="go"> --foo FOO   foo help</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-70">To change this default behavior, another value can be supplied using the <code class="docutils literal"><span class="pre">prog=</span></code> argument to <a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'myprogram'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: myprogram [-h]</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
</code></pre><p><span class="yiyi-st" id="yiyi-71">请注意，无论从<code class="docutils literal"><span class="pre">sys.argv[0]</span></code>还是从<code class="docutils literal"><span class="pre">prog=</span></code>参数确定的程序名都可用于帮助使用<code class="docutils literal"><span class="pre">%(prog)s</span></code>格式说明符。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'myprogram'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'foo of the </span><span class="si">%(prog)s</span><span class="s1"> program'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: myprogram [-h] [--foo FOO]</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
<span class="go"> --foo FOO   foo of the myprogram program</span>
</code></pre></div><div class="section" id="usage"><h3><span class="yiyi-st" id="yiyi-72">16.4.2.2. usage</span></h3><p><span class="yiyi-st" id="yiyi-73">默认情况下，<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>根据它包含的参数计算使用情况消息：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'foo help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'+'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'bar help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [-h] [--foo [FOO]] bar [bar ...]</span>

<span class="go">positional arguments:</span>
<span class="go"> bar          bar help</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help   show this help message and exit</span>
<span class="go"> --foo [FOO]  foo help</span>
</code></pre><p><span class="yiyi-st" id="yiyi-74">默认消息可以用<code class="docutils literal"><span class="pre">usage=</span></code>关键字参数覆盖：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span> <span class="n">usage</span><span class="o">=</span><span class="s1">'</span><span class="si">%(prog)s</span><span class="s1"> [options]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'foo help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'+'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'bar help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [options]</span>

<span class="go">positional arguments:</span>
<span class="go"> bar          bar help</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help   show this help message and exit</span>
<span class="go"> --foo [FOO]  foo help</span>
</code></pre><p><span class="yiyi-st" id="yiyi-75">可以使用<code class="docutils literal"><span class="pre">%(prog)s</span></code>格式说明符在您的使用消息中填写程序名称。</span></p></div><div class="section" id="description"><h3><span class="yiyi-st" id="yiyi-76">16.4.2.3. 描述</span></h3><p><span class="yiyi-st" id="yiyi-77">大多数对<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>构造函数的调用将使用<code class="docutils literal"><span class="pre">description=</span></code>关键字参数。</span><span class="yiyi-st" id="yiyi-78">这个观点简要介绍了程序的功能和工作原理。</span><span class="yiyi-st" id="yiyi-79">在帮助消息中，说明显示在命令行用法字符串和各种参数的帮助消息之间：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">'A foo that bars'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: argparse.py [-h]</span>

<span class="go">A foo that bars</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
</code></pre><p><span class="yiyi-st" id="yiyi-80">默认情况下，描述将被行包裹，以便它符合给定的空间。</span><span class="yiyi-st" id="yiyi-81">要改变这种行为，请参阅<a class="reference internal" href="#formatter-class">formatter_class</a>参数。</span></p></div><div class="section" id="epilog"><h3><span class="yiyi-st" id="yiyi-82">16.4.2.4. 结语</span></h3><p><span class="yiyi-st" id="yiyi-83">一些程序喜欢在参数描述之后显示程序的附加描述。</span><span class="yiyi-st" id="yiyi-84">这样的文本可以使用参数<code class="docutils literal"><span class="pre">epilog=</span></code>指定给<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">description</span><span class="o">=</span><span class="s1">'A foo that bars'</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">epilog</span><span class="o">=</span><span class="s2">"And that's how you'd foo a bar"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: argparse.py [-h]</span>

<span class="go">A foo that bars</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>

<span class="go">And that's how you'd foo a bar</span>
</code></pre><p><span class="yiyi-st" id="yiyi-85">As with the <a class="reference internal" href="#description">description</a> argument, the <code class="docutils literal"><span class="pre">epilog=</span></code> text is by default line-wrapped, but this behavior can be adjusted with the <a class="reference internal" href="#formatter-class">formatter_class</a> argument to <a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>.</span></p></div><div class="section" id="parents"><h3><span class="yiyi-st" id="yiyi-86">16.4.2.5. parents</span></h3><p><span class="yiyi-st" id="yiyi-87">有时，几个解析器共享一组通用参数。</span><span class="yiyi-st" id="yiyi-88">Rather than repeating the definitions of these arguments, a single parser with all the shared arguments and passed to <code class="docutils literal"><span class="pre">parents=</span></code> argument to <a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a> can be used. </span><span class="yiyi-st" id="yiyi-89"><code class="docutils literal"><span class="pre">parents=</span></code>参数采用<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象列表，收集所有位置和可选操作，并将这些操作添加到<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象正在构建：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parent_parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">add_help</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent_parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--parent'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">foo_parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="p">[</span><span class="n">parent_parser</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo_parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo_parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--parent'</span><span class="p">,</span> <span class="s1">'2'</span><span class="p">,</span> <span class="s1">'XXX'</span><span class="p">])</span>
<span class="go">Namespace(foo='XXX', parent=2)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">bar_parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="p">[</span><span class="n">parent_parser</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar_parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar_parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--bar'</span><span class="p">,</span> <span class="s1">'YYY'</span><span class="p">])</span>
<span class="go">Namespace(bar='YYY', parent=None)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-90">请注意，大多数父解析器将指定<code class="docutils literal"><span class="pre">add_help=False</span></code>。</span><span class="yiyi-st" id="yiyi-91">否则，<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>会看到两个<code class="docutils literal"><span class="pre">-h/--help</span></code>选项（一个在父节点中，另一个在子节点中）并引发一个错误。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-92">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-93">在通过<code class="docutils literal"><span class="pre">parents=</span></code>传递分析器之前，您必须完全初始化分析器。</span><span class="yiyi-st" id="yiyi-94">如果在子解析器之后更改父解析器，那些更改将不会反映到子解析器中。</span></p></div></div><div class="section" id="formatter-class"><h3><span class="yiyi-st" id="yiyi-95">16.4.2.6.  formatter_class </span></h3><p><span class="yiyi-st" id="yiyi-96"><a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象允许通过指定备用格式类来自定义帮助格式。</span><span class="yiyi-st" id="yiyi-97">目前，有四个这样的类：</span></p><dl class="class"><dt id="argparse.RawDescriptionHelpFormatter"><span class="yiyi-st" id="yiyi-98"><em class="property">class</em> <code class="descclassname">argparse。</code> <code class="descname">RawDescriptionHelpFormatter</code> </span></dt><dt id="argparse.RawTextHelpFormatter"><span class="yiyi-st" id="yiyi-99"><em class="property">class</em> <code class="descclassname">argparse。</code> <code class="descname">RawTextHelpFormatter</code> </span></dt><dt id="argparse.ArgumentDefaultsHelpFormatter"><span class="yiyi-st" id="yiyi-100"><em class="property">class</em> <code class="descclassname">argparse。</code> <code class="descname">ArgumentDefaultsHelpFormatter</code> </span></dt><dt id="argparse.MetavarTypeHelpFormatter"><span class="yiyi-st" id="yiyi-101"><em class="property">class</em> <code class="descclassname">argparse。</code> <code class="descname">MetavarTypeHelpFormatter</code> </span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-102"><a class="reference internal" href="#argparse.RawDescriptionHelpFormatter" title="argparse.RawDescriptionHelpFormatter"><code class="xref py py-class docutils literal"><span class="pre">RawDescriptionHelpFormatter</span></code></a> and <a class="reference internal" href="#argparse.RawTextHelpFormatter" title="argparse.RawTextHelpFormatter"><code class="xref py py-class docutils literal"><span class="pre">RawTextHelpFormatter</span></code></a> give more control over how textual descriptions are displayed. </span><span class="yiyi-st" id="yiyi-103">默认情况下，<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象在命令行帮助消息中包装<a class="reference internal" href="#description">描述</a>和<a class="reference internal" href="#epilog">epilog</a>文本：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">description</span><span class="o">=</span><span class="s1">'''this description</span>
<span class="gp">... </span><span class="s1">        was indented weird</span>
<span class="gp">... </span><span class="s1">            but that is okay'''</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">epilog</span><span class="o">=</span><span class="s1">'''</span>
<span class="gp">... </span><span class="s1">            likewise for this epilog whose whitespace will</span>
<span class="gp">... </span><span class="s1">        be cleaned up and whose words will be wrapped</span>
<span class="gp">... </span><span class="s1">        across a couple lines'''</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [-h]</span>

<span class="go">this description was indented weird but that is okay</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>

<span class="go">likewise for this epilog whose whitespace will be cleaned up and whose words</span>
<span class="go">will be wrapped across a couple lines</span>
</code></pre><p><span class="yiyi-st" id="yiyi-104">将<a class="reference internal" href="#argparse.RawDescriptionHelpFormatter" title="argparse.RawDescriptionHelpFormatter"><code class="xref py py-class docutils literal"><span class="pre">RawDescriptionHelpFormatter</span></code></a>传递为<code class="docutils literal"><span class="pre">formatter_class=</span></code>表明<a class="reference internal" href="#description">描述</a>和<a class="reference internal" href="#epilog">epilog</a>已经被正确格式化，不应该被换行：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">formatter_class</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">RawDescriptionHelpFormatter</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">description</span><span class="o">=</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s1">'''</span><span class="se">\</span>
<span class="gp">... </span><span class="s1">        Please do not mess up this text!</span>
<span class="gp">... </span><span class="s1">        --------------------------------</span>
<span class="gp">... </span><span class="s1">            I have indented it</span>
<span class="gp">... </span><span class="s1">            exactly the way</span>
<span class="gp">... </span><span class="s1">            I want it</span>
<span class="gp">... </span><span class="s1">        '''</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [-h]</span>

<span class="go">Please do not mess up this text!</span>
<span class="go">--------------------------------</span>
<span class="go">   I have indented it</span>
<span class="go">   exactly the way</span>
<span class="go">   I want it</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
</code></pre><p><span class="yiyi-st" id="yiyi-105"><a class="reference internal" href="#argparse.RawTextHelpFormatter" title="argparse.RawTextHelpFormatter"><code class="xref py py-class docutils literal"><span class="pre">RawTextHelpFormatter</span></code></a>为各种帮助文本保留空格，包括参数描述。</span></p><p><span class="yiyi-st" id="yiyi-106"><a class="reference internal" href="#argparse.ArgumentDefaultsHelpFormatter" title="argparse.ArgumentDefaultsHelpFormatter"><code class="xref py py-class docutils literal"><span class="pre">ArgumentDefaultsHelpFormatter</span></code></a>自动为每个参数帮助消息添加有关默认值的信息：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">formatter_class</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentDefaultsHelpFormatter</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'FOO!'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'*'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">help</span><span class="o">=</span><span class="s1">'BAR!'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [-h] [--foo FOO] [bar [bar ...]]</span>

<span class="go">positional arguments:</span>
<span class="go"> bar         BAR! (default: [1, 2, 3])</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
<span class="go"> --foo FOO   FOO! (default: 42)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-107"><a class="reference internal" href="#argparse.MetavarTypeHelpFormatter" title="argparse.MetavarTypeHelpFormatter"><code class="xref py py-class docutils literal"><span class="pre">MetavarTypeHelpFormatter</span></code></a> uses the name of the <a class="reference internal" href="#type">type</a> argument for each argument as the display name for its values (rather than using the <a class="reference internal" href="#dest">dest</a> as the regular formatter does):</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">formatter_class</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">MetavarTypeHelpFormatter</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [-h] [--foo int] float</span>

<span class="go">positional arguments:</span>
<span class="go">  float</span>

<span class="go">optional arguments:</span>
<span class="go">  -h, --help  show this help message and exit</span>
<span class="go">  --foo int</span>
</code></pre></div><div class="section" id="prefix-chars"><h3><span class="yiyi-st" id="yiyi-108">16.4.2.7.  prefix_chars </span></h3><p><span class="yiyi-st" id="yiyi-109">大多数命令行选项将使用<code class="docutils literal"><span class="pre">-</span></code>作为前缀，例如</span><span class="yiyi-st" id="yiyi-110"><code class="docutils literal"><span class="pre">-f/--foo</span></code></span><span class="yiyi-st" id="yiyi-111">需要支持不同或附加前缀字符的解析器，例如</span><span class="yiyi-st" id="yiyi-112">对于<code class="docutils literal"><span class="pre">+f</span></code>或<code class="docutils literal"><span class="pre">/foo</span></code>等选项，可以使用ArgumentParser构造函数的<code class="docutils literal"><span class="pre">prefix_chars=</span></code>参数指定它们：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span> <span class="n">prefix_chars</span><span class="o">=</span><span class="s1">'-+'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'+f'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'++bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'+f X ++bar Y'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(bar='Y', f='X')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-113"><code class="docutils literal"><span class="pre">prefix_chars=</span></code>参数默认为<code class="docutils literal"><span class="pre">'-'</span></code>。</span><span class="yiyi-st" id="yiyi-114">提供一组不包含<code class="docutils literal"><span class="pre">-</span></code>的字符将导致<code class="docutils literal"><span class="pre">-f/--foo</span></code>选项不被允许。</span></p></div><div class="section" id="fromfile-prefix-chars"><h3><span class="yiyi-st" id="yiyi-115">16.4.2.8.  fromfile_prefix_chars </span></h3><p><span class="yiyi-st" id="yiyi-116">有时候，例如当处理特别长的参数列表时，将参数列表保存在文件中而不是在命令行输入它可能是有意义的。</span><span class="yiyi-st" id="yiyi-117">如果给<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>构造函数提供<code class="docutils literal"><span class="pre">fromfile_prefix_chars=</span></code>参数，那么以任何指定字符开头的参数将被视为文件，并将被参数包含。</span><span class="yiyi-st" id="yiyi-118">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'args.txt'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'-f</span><span class="se">\n</span><span class="s1">bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">fromfile_prefix_chars</span><span class="o">=</span><span class="s1">'@'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-f'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-f'</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'@args.txt'</span><span class="p">])</span>
<span class="go">Namespace(f='bar')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-119">从文件中读取的参数必须默认为每行一个（但也可参见<a class="reference internal" href="#argparse.ArgumentParser.convert_arg_line_to_args" title="argparse.ArgumentParser.convert_arg_line_to_args"><code class="xref py py-meth docutils literal"><span class="pre">convert_arg_line_to_args()</span></code></a>），并将它们视为与命令行中原始文件引用参数位于同一位置。</span><span class="yiyi-st" id="yiyi-120">So in the example above, the expression <code class="docutils literal"><span class="pre">['-f',</span> <span class="pre">'foo',</span> <span class="pre">'@args.txt']</span></code> is considered equivalent to the expression <code class="docutils literal"><span class="pre">['-f',</span> <span class="pre">'foo',</span> <span class="pre">'-f',</span> <span class="pre">'bar']</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-121"><code class="docutils literal"><span class="pre">fromfile_prefix_chars=</span></code>参数默认为<code class="docutils literal"><span class="pre">None</span></code>，这意味着参数永远不会被视为文件引用。</span></p></div><div class="section" id="argument-default"><h3><span class="yiyi-st" id="yiyi-122">16.4.2.9.  argument_default </span></h3><p><span class="yiyi-st" id="yiyi-123">通常，通过将缺省值传递给<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>或通过使用特定的一组名称值对调用<a class="reference internal" href="#argparse.ArgumentParser.set_defaults" title="argparse.ArgumentParser.set_defaults"><code class="xref py py-meth docutils literal"><span class="pre">set_defaults()</span></code></a>方法来指定参数缺省值。</span><span class="yiyi-st" id="yiyi-124">然而，有时候，为参数指定单个解析器范围的默认值可能很有用。</span><span class="yiyi-st" id="yiyi-125">这可以通过将<code class="docutils literal"><span class="pre">argument_default=</span></code>关键字参数传递给<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>来完成。</span><span class="yiyi-st" id="yiyi-126">例如，要全局禁止<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>调用上的属性创建，我们提供<code class="docutils literal"><span class="pre">argument_default=SUPPRESS</span></code>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">argument_default</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">SUPPRESS</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">,</span> <span class="s1">'BAR'</span><span class="p">])</span>
<span class="go">Namespace(bar='BAR', foo='1')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="go">Namespace()</span>
</code></pre></div><div class="section" id="allow-abbrev"><h3><span class="yiyi-st" id="yiyi-127">16.4.2.10.  allow_abbrev </span></h3><p><span class="yiyi-st" id="yiyi-128">正常情况下, 当你传递参数列表给ArgumentParser的parse_args()方法时，它会自动识别出长选项的简写形式。<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre"></span></code></a><a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre"></span></code></a><a class="reference internal" href="#prefix-matching"><span></span></a></span></p><p><span class="yiyi-st" id="yiyi-129">将<code class="docutils literal"><span class="pre">allow_abbrev</span></code>设置为<code class="docutils literal"><span class="pre">False</span></code>即可禁用此功能：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span> <span class="n">allow_abbrev</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foobar'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_true'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foonley'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_false'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foon'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] [--foobar] [--foonley]</span>
<span class="go">PROG: error: unrecognized arguments: --foon</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-130"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></div><div class="section" id="conflict-handler"><h3><span class="yiyi-st" id="yiyi-131">16.4.2.11.  conflict_handler </span></h3><p><span class="yiyi-st" id="yiyi-132"><a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象不允许具有相同选项字符串的两个操作。</span><span class="yiyi-st" id="yiyi-133">默认情况下，如果尝试使用已在使用的选项字符串创建参数，则<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象会引发异常：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-f'</span><span class="p">,</span> <span class="s1">'--foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'old foo help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'new foo help'</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr"> ..</span>
<span class="gr">ArgumentError</span>: <span class="n">argument --foo: conflicting option string(s): --foo</span>
</code></pre><p><span class="yiyi-st" id="yiyi-134">有时（例如</span><span class="yiyi-st" id="yiyi-135">当使用<a class="reference internal" href="#parents">父母</a>时）使用相同的选项字符串覆盖任何较旧的参数可能会很有用。</span><span class="yiyi-st" id="yiyi-136">要获得这种行为，可以将<code class="docutils literal"><span class="pre">'resolve'</span></code>值提供给<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>的<code class="docutils literal"><span class="pre">conflict_handler=</span></code>参数：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span> <span class="n">conflict_handler</span><span class="o">=</span><span class="s1">'resolve'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-f'</span><span class="p">,</span> <span class="s1">'--foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'old foo help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'new foo help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [-h] [-f FOO] [--foo FOO]</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
<span class="go"> -f FOO      old foo help</span>
<span class="go"> --foo FOO   new foo help</span>
</code></pre><p><span class="yiyi-st" id="yiyi-137">请注意，<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象只会在所有选项字符串被覆盖的情况下移除一个操作。</span><span class="yiyi-st" id="yiyi-138">因此，在上面的例子中，旧的<code class="docutils literal"><span class="pre">-f/--foo</span></code>动作保留为<code class="docutils literal"><span class="pre">-f</span></code>动作，因为只有<code class="docutils literal"><span class="pre">--foo</span></code></span></p></div><div class="section" id="add-help"><h3><span class="yiyi-st" id="yiyi-139">16.4.2.12.  add_help </span></h3><p><span class="yiyi-st" id="yiyi-140">默认情况下，ArgumentParser对象添加一个选项，该选项只显示解析器的帮助消息。</span><span class="yiyi-st" id="yiyi-141">例如，考虑一个名为<code class="docutils literal"><span class="pre">myprogram.py</span></code>的文件，其中包含以下代码：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'foo help'</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-142">如果在命令行提供<code class="docutils literal"><span class="pre">-h</span></code>或<code class="docutils literal"><span class="pre">--help</span></code>，则会打印参数帮助器帮助：</span></p><div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> python myprogram.py --help
<span class="go">usage: myprogram.py [-h] [--foo FOO]</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
<span class="go"> --foo FOO   foo help</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-143">偶尔，禁用此帮助选项可能会有用。</span><span class="yiyi-st" id="yiyi-144">这可以通过将<code class="docutils literal"><span class="pre">False</span></code>作为<code class="docutils literal"><span class="pre">add_help=</span></code>参数传递给<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>来实现：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span> <span class="n">add_help</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'foo help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [--foo FOO]</span>

<span class="go">optional arguments:</span>
<span class="go"> --foo FOO  foo help</span>
</code></pre><p><span class="yiyi-st" id="yiyi-145">帮助选项通常是<code class="docutils literal"><span class="pre">-h/--help</span></code>。</span><span class="yiyi-st" id="yiyi-146">例外情况是，如果<code class="docutils literal"><span class="pre">prefix_chars=</span></code>被指定并且不包含<code class="docutils literal"><span class="pre">-</span></code>，在这种情况下<code class="docutils literal"><span class="pre">-h</span></code>和<code class="docutils literal"><span class="pre">--help</span></code>不是有效的选项。</span><span class="yiyi-st" id="yiyi-147">在这种情况下，<code class="docutils literal"><span class="pre">prefix_chars</span></code>中的第一个字符用于作为帮助选项的前缀：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span> <span class="n">prefix_chars</span><span class="o">=</span><span class="s1">'+/'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [+h]</span>

<span class="go">optional arguments:</span>
<span class="go">  +h, ++help  show this help message and exit</span>
</code></pre></div></div><div class="section" id="the-add-argument-method"><h2><span class="yiyi-st" id="yiyi-148">16.4.3. </span><span class="yiyi-st" id="yiyi-149">add_argument()方法</span></h2><dl class="method"><dt id="argparse.ArgumentParser.add_argument"><span class="yiyi-st" id="yiyi-150"> <code class="descclassname">ArgumentParser.</code><code class="descname">add_argument</code><span class="sig-paren">(</span><em>name or flags...</em><span class="optional">[</span>, <em>action</em><span class="optional">]</span><span class="optional">[</span>, <em>nargs</em><span class="optional">]</span><span class="optional">[</span>, <em>const</em><span class="optional">]</span><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="optional">[</span>, <em>type</em><span class="optional">]</span><span class="optional">[</span>, <em>choices</em><span class="optional">]</span><span class="optional">[</span>, <em>required</em><span class="optional">]</span><span class="optional">[</span>, <em>help</em><span class="optional">]</span><span class="optional">[</span>, <em>metavar</em><span class="optional">]</span><span class="optional">[</span>, <em>dest</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-151">定义如何解析单个命令行参数。</span><span class="yiyi-st" id="yiyi-152">以下每个参数都有其更详细的描述，但总之是：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-153"><a class="reference internal" href="#name-or-flags">名称或标志</a>  - 可以是名称或选项字符串列表，例如</span><span class="yiyi-st" id="yiyi-154"><code class="docutils literal"><span class="pre">foo</span></code>或<code class="docutils literal"><span class="pre">-f,</span> <span class="pre">--foo</span></code>。</span></li><li><span class="yiyi-st" id="yiyi-155"><a class="reference internal" href="#action">action</a>  - 在命令行中遇到此参数时要采取的基本操作类型。</span></li><li><span class="yiyi-st" id="yiyi-156"><a class="reference internal" href="#nargs">nargs</a>  - 应该使用的命令行参数的数量。</span></li><li><span class="yiyi-st" id="yiyi-157">const  - 某些动作和nargs选择所需的常量值。 <a class="reference internal" href="#const"></a><a class="reference internal" href="#action"></a><a class="reference internal" href="#nargs"></a></span></li><li><span class="yiyi-st" id="yiyi-158"><a class="reference internal" href="#default">默认</a>  - 如果参数在命令行中不存在，则生成的值。</span></li><li><span class="yiyi-st" id="yiyi-159"><a class="reference internal" href="#type">type</a>  - 命令行参数应转换到的类型。</span></li><li><span class="yiyi-st" id="yiyi-160"><a class="reference internal" href="#choices">选择</a>  - 参数允许值的容器。</span></li><li><span class="yiyi-st" id="yiyi-161"><a class="reference internal" href="#required">required</a>  - 是否可以省略命令行选项（仅针对可选参数）。</span></li><li><span class="yiyi-st" id="yiyi-162"><a class="reference internal" href="#help">帮助</a>  - 参数所做的简要说明。</span></li><li><span class="yiyi-st" id="yiyi-163"><a class="reference internal" href="#metavar">metavar</a> - A name for the argument in usage messages.</span></li><li><span class="yiyi-st" id="yiyi-164"><a class="reference internal" href="#dest">dest</a>  - 要添加到由<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>返回的对象的属性的名称。</span></li></ul></dd></dl><p><span class="yiyi-st" id="yiyi-165">以下部分描述如何使用每个这些。</span></p><div class="section" id="name-or-flags"><h3><span class="yiyi-st" id="yiyi-166">16.4.3.1. 名称或标志</span></h3><p><span class="yiyi-st" id="yiyi-167"><a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>方法必须知道可选参数（如<code class="docutils literal"><span class="pre">-f</span></code>或<code class="docutils literal"><span class="pre">--foo</span></code>）或位置参数，如列表文件名，预计。</span><span class="yiyi-st" id="yiyi-168">传递给<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>的第一个参数必须是一系列标志或一个简单的参数名称。</span><span class="yiyi-st" id="yiyi-169">例如，可以创建一个可选参数，如下所示：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-f'</span><span class="p">,</span> <span class="s1">'--foo'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-170">而一个位置参数可以创建如下：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-171">当调用<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>时，可选参数将由<code class="docutils literal"><span class="pre">-</span></code>前缀标识，其余参数将被假定为位置：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-f'</span><span class="p">,</span> <span class="s1">'--foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'BAR'</span><span class="p">])</span>
<span class="go">Namespace(bar='BAR', foo=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'BAR'</span><span class="p">,</span> <span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'FOO'</span><span class="p">])</span>
<span class="go">Namespace(bar='BAR', foo='FOO')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'FOO'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] [-f FOO] bar</span>
<span class="go">PROG: error: too few arguments</span>
</code></pre></div><div class="section" id="action"><h3><span class="yiyi-st" id="yiyi-172">16.4.3.2. action</span></h3><p><span class="yiyi-st" id="yiyi-173"><a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象将命令行参数与操作相关联。</span><span class="yiyi-st" id="yiyi-174">尽管大多数操作只是向由<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>返回的对象添加一个属性，但这些操作可以完成与它们相关的任何命令行参数。</span><span class="yiyi-st" id="yiyi-175"><code class="docutils literal"><span class="pre">action</span></code>关键字参数指定应如何处理命令行参数。</span><span class="yiyi-st" id="yiyi-176">提供的操作是：</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-177"><code class="docutils literal"><span class="pre">'store'</span></code> - This just stores the argument’s value. </span><span class="yiyi-st" id="yiyi-178">这是默认操作。</span><span class="yiyi-st" id="yiyi-179">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'--foo 1'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(foo='1')</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-180"><code class="docutils literal"><span class="pre">'store_const'</span></code>  - 存储由<a class="reference internal" href="#const">const</a>关键字参数指定的值。</span><span class="yiyi-st" id="yiyi-181"><code class="docutils literal"><span class="pre">'store_const'</span></code>动作最常用于指定某种标志的可选参数。</span><span class="yiyi-st" id="yiyi-182">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_const'</span><span class="p">,</span> <span class="n">const</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">])</span>
<span class="go">Namespace(foo=42)</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-183"><code class="docutils literal"><span class="pre">'store_true'</span></code>和<code class="docutils literal"><span class="pre">'store_false'</span></code> - 他们是 <code class="docutils literal"><span class="pre">'store_const'</span></code> 的特例,分别用于存储 <code class="docutils literal"><span class="pre">True</span></code> 和 <code class="docutils literal"><span class="pre">False</span></code>.</span><span class="yiyi-st" id="yiyi-184">另外，它们分别创建<code class="docutils literal"><span class="pre">False</span></code>和<code class="docutils literal"><span class="pre">True</span></code>的默认值。</span><span class="yiyi-st" id="yiyi-185">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_true'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--bar'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_false'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--baz'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_false'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'--foo --bar'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(foo=True, bar=False, baz=True)</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-186"><code class="docutils literal"><span class="pre">'append'</span></code>  - 存储一个列表，并将每个参数值附加到列表中。</span><span class="yiyi-st" id="yiyi-187">这对于允许多次指定选项很有用。</span><span class="yiyi-st" id="yiyi-188">用法示例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'append'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'--foo 1 --foo 2'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(foo=['1', '2'])</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-189"><code class="docutils literal"><span class="pre">'append_const'</span></code>  - 存储列表，并将<a class="reference internal" href="#const">const</a>关键字参数指定的值附加到列表中。</span><span class="yiyi-st" id="yiyi-190">（请注意，<a class="reference internal" href="#const">const</a>关键字参数默认为<code class="docutils literal"><span class="pre">None</span></code>。）</span><span class="yiyi-st" id="yiyi-191">当多个参数需要将常量存储到同一列表时，<code class="docutils literal"><span class="pre">'append_const'</span></code>动作通常很有用。</span><span class="yiyi-st" id="yiyi-192">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--str'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">'types'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'append_const'</span><span class="p">,</span> <span class="n">const</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--int'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">'types'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'append_const'</span><span class="p">,</span> <span class="n">const</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'--str --int'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(types=[&lt;class 'str'&gt;, &lt;class 'int'&gt;])</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-193"><code class="docutils literal"><span class="pre">'count'</span></code>  - 这会计算关键字参数发生的次数。</span><span class="yiyi-st" id="yiyi-194">例如，这对增加冗长级别很有用：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--verbose'</span><span class="p">,</span> <span class="s1">'-v'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'count'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-vvv'</span><span class="p">])</span>
<span class="go">Namespace(verbose=3)</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-195"><code class="docutils literal"><span class="pre">'help'</span></code>  - 这将显示当前解析器中所有选项的完整帮助消息，然后退出。</span><span class="yiyi-st" id="yiyi-196">默认情况下，帮助操作会自动添加到解析器中。</span><span class="yiyi-st" id="yiyi-197">有关如何创建输出的详细信息，请参阅<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-198"><code class="docutils literal"><span class="pre">'version'</span></code>  - 在<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>调用中需要<code class="docutils literal"><span class="pre">version=</span></code>关键字参数，并打印版本信息并在调用时退出：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">argparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--version'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'version'</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">'</span><span class="si">%(prog)s</span><span class="s1"> 2.0'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--version'</span><span class="p">])</span>
<span class="go">PROG 2.0</span>
</code></pre></li></ul><p><span class="yiyi-st" id="yiyi-199">您也可以通过传递一个Action子类或其他实现相同接口的对象来指定一个任意的动作。</span><span class="yiyi-st" id="yiyi-200">推荐的方法是扩展<a class="reference internal" href="#argparse.Action" title="argparse.Action"><code class="xref py py-class docutils literal"><span class="pre">Action</span></code></a>，覆盖<code class="docutils literal"><span class="pre">__call__</span></code>方法和可选的<code class="docutils literal"><span class="pre">__init__</span></code>方法。</span></p><p><span class="yiyi-st" id="yiyi-201">自定义操作的示例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">FooAction</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option_strings</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">nargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"nargs not allowed"</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">(</span><span class="n">FooAction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">option_strings</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="si">%r</span><span class="s1"> </span><span class="si">%r</span><span class="s1"> </span><span class="si">%r</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="p">))</span>
<span class="gp">... </span>        <span class="nb">setattr</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">FooAction</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">FooAction</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'1 --foo 2'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(bar=None, foo=None) '1' None</span>
<span class="go">Namespace(bar='1', foo=None) '2' '--foo'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span>
<span class="go">Namespace(bar='1', foo='2')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-202">有关更多详细信息，请参阅<a class="reference internal" href="#argparse.Action" title="argparse.Action"><code class="xref py py-class docutils literal"><span class="pre">Action</span></code></a>。</span></p></div><div class="section" id="nargs"><h3><span class="yiyi-st" id="yiyi-203">16.4.3.3.  NARGS </span></h3><p><span class="yiyi-st" id="yiyi-204">ArgumentParser对象通常会将单个命令行参数与要执行的单个操作相关联。</span><span class="yiyi-st" id="yiyi-205"><code class="docutils literal"><span class="pre">nargs</span></code>关键字参数将不同数量的命令行参数与单个操作相关联。</span><span class="yiyi-st" id="yiyi-206">支持的值是：</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-207"><code class="docutils literal"><span class="pre">N</span></code> (an integer). </span><span class="yiyi-st" id="yiyi-208"><code class="docutils literal"><span class="pre">N</span></code> arguments from the command line will be gathered together into a list. </span><span class="yiyi-st" id="yiyi-209">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'c --foo a b'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(bar=['c'], foo=['a', 'b'])</span>
</code></pre><p><span class="yiyi-st" id="yiyi-210">注意<code class="docutils literal"><span class="pre">nargs=1</span></code>生成的是一个只有一个元素的列表。</span><span class="yiyi-st" id="yiyi-211">这和默认的行为是不一样的，默认情况下生成的是元素自己,而不是列表。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-212"><code class="docutils literal"><span class="pre">'?'</span></code></span><span class="yiyi-st" id="yiyi-213">如有可能，将从命令行中消耗一个参数，并将其作为单个项目生成。</span><span class="yiyi-st" id="yiyi-214">如果没有命令行参数，则会产生<a class="reference internal" href="#default">默认</a>中的值。</span><span class="yiyi-st" id="yiyi-215">请注意，对于可选参数，还有一个额外的情况 - 选项字符串存在，但后面没有命令行参数。</span><span class="yiyi-st" id="yiyi-216">在这种情况下，将产生来自<a class="reference internal" href="#const">const</a>的值。</span><span class="yiyi-st" id="yiyi-217">一些例子来说明这一点：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">,</span> <span class="n">const</span><span class="o">=</span><span class="s1">'c'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">'d'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">'d'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'XX'</span><span class="p">,</span> <span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'YY'</span><span class="p">])</span>
<span class="go">Namespace(bar='XX', foo='YY')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'XX'</span><span class="p">,</span> <span class="s1">'--foo'</span><span class="p">])</span>
<span class="go">Namespace(bar='XX', foo='c')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="go">Namespace(bar='d', foo='d')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-218"><code class="docutils literal"><span class="pre">nargs='?'</span></code>更常见的用途之一</span><span class="yiyi-st" id="yiyi-219">是允许可选的输入和输出文件：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'infile'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">FileType</span><span class="p">(</span><span class="s1">'r'</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">default</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'outfile'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">FileType</span><span class="p">(</span><span class="s1">'w'</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">default</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'input.txt'</span><span class="p">,</span> <span class="s1">'output.txt'</span><span class="p">])</span>
<span class="go">Namespace(infile=&lt;_io.TextIOWrapper name='input.txt' encoding='UTF-8'&gt;,</span>
<span class="go">          outfile=&lt;_io.TextIOWrapper name='output.txt' encoding='UTF-8'&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="go">Namespace(infile=&lt;_io.TextIOWrapper name='&lt;stdin&gt;' encoding='UTF-8'&gt;,</span>
<span class="go">          outfile=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' encoding='UTF-8'&gt;)</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-220"><code class="docutils literal"><span class="pre">'*'</span></code></span><span class="yiyi-st" id="yiyi-221">所有存在的命令行参数都被收集到一个列表中。</span><span class="yiyi-st" id="yiyi-222">请注意，使用<code class="docutils literal"><span class="pre">nargs='*'</span></code>具有多个位置参数通常没什么意义，但可以使用具有<code class="docutils literal"><span class="pre">nargs='*'</span></code>的多个可选参数。</span><span class="yiyi-st" id="yiyi-223">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'*'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--bar'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'*'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'baz'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'*'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'a b --foo x y --bar 1 2'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-224"><code class="docutils literal"><span class="pre">'+'</span></code></span><span class="yiyi-st" id="yiyi-225">就像<code class="docutils literal"><span class="pre">'*'</span></code>一样，所有存在的命令行参数都被收集到一个列表中。</span><span class="yiyi-st" id="yiyi-226">此外，如果没有至少一个命令行参数，则会生成错误消息。</span><span class="yiyi-st" id="yiyi-227">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'+'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">])</span>
<span class="go">Namespace(foo=['a', 'b'])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="go">usage: PROG [-h] foo [foo ...]</span>
<span class="go">PROG: error: too few arguments</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-228"><code class="docutils literal"><span class="pre">argparse.REMAINDER</span></code></span><span class="yiyi-st" id="yiyi-229">所有其余的命令行参数都被收集到一个列表中。</span><span class="yiyi-st" id="yiyi-230">这对于派发到其他命令行实用程序的命令行实用程序通常很有用：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'command'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'args'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">REMAINDER</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'--foo B cmd --arg1 XX ZZ'</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="go">Namespace(args=['--arg1', 'XX', 'ZZ'], command='cmd', foo='B')</span>
</code></pre></li></ul><p><span class="yiyi-st" id="yiyi-231">如果未提供<code class="docutils literal"><span class="pre">nargs</span></code>关键字参数，则消耗的参数数量由<a class="reference internal" href="#action">操作</a>决定。</span><span class="yiyi-st" id="yiyi-232">通常这意味着一个命令行参数将被消耗，并且将生成单个项目（不是列表）。</span></p></div><div class="section" id="const"><h3><span class="yiyi-st" id="yiyi-233">16.4.3.4. 常量</span></h3><p><span class="yiyi-st" id="yiyi-234"><a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>的<code class="docutils literal"><span class="pre">const</span></code>参数用于保存不从命令行读取的常量值，但是对于各种<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>动作。</span><span class="yiyi-st" id="yiyi-235">它最常见的两种用途是：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-236">当使用<code class="docutils literal"><span class="pre">action='store_const'</span></code>或<code class="docutils literal"><span class="pre">action='append_const'</span></code>调用<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>时。</span><span class="yiyi-st" id="yiyi-237">这些操作将<code class="docutils literal"><span class="pre">const</span></code>值添加到由<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>返回的对象的其中一个属性中。</span><span class="yiyi-st" id="yiyi-238">示例请参阅<a class="reference internal" href="#action">action</a>描述。</span></li><li><span class="yiyi-st" id="yiyi-239">当采用可选参数(例如<code class="docutils literal"><span class="pre">-f</span></code>或者<code class="docutils literal"><span class="pre">--foo</span></code>)和采用<code class="docutils literal"><span class="pre">nargs='?'</span></code>调用<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>的时候,</span><span class="yiyi-st" id="yiyi-240">这会创建一个可选参数，后面跟零个或一个命令行参数。</span><span class="yiyi-st" id="yiyi-241">在解析命令行时，如果在后面没有命令行参数时遇到选项字符串，则会假定<code class="docutils literal"><span class="pre">const</span></code>的值。</span><span class="yiyi-st" id="yiyi-242">示例请参阅<a class="reference internal" href="#nargs">nargs</a>描述。</span></li></ul><p><span class="yiyi-st" id="yiyi-243">通过<code class="docutils literal"><span class="pre">'store_const'</span></code>和<code class="docutils literal"><span class="pre">'append_const'</span></code>动作，必须给出<code class="docutils literal"><span class="pre">const</span></code>关键字参数。</span><span class="yiyi-st" id="yiyi-244">对于其他操作，它默认为<code class="docutils literal"><span class="pre">None</span></code>。</span></p></div><div class="section" id="default"><h3><span class="yiyi-st" id="yiyi-245">16.4.3.5. default</span></h3><p><span class="yiyi-st" id="yiyi-246">所有可选参数和一些位置参数可以在命令行中省略。</span><span class="yiyi-st" id="yiyi-247">The <code class="docutils literal"><span class="pre">default</span></code> keyword argument of <a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>, whose value defaults to <code class="docutils literal"><span class="pre">None</span></code>, specifies what value should be used if the command-line argument is not present. </span><span class="yiyi-st" id="yiyi-248">对于可选参数，当选项字符串不存在于命令行时，将使用<code class="docutils literal"><span class="pre">default</span></code>值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'2'</span><span class="p">])</span>
<span class="go">Namespace(foo='2')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="go">Namespace(foo=42)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-249">如果<code class="docutils literal"><span class="pre">default</span></code>值是一个字符串，那么解析器就会将该值解析为一个命令行参数。</span><span class="yiyi-st" id="yiyi-250">特别是，在设置<a class="reference internal" href="#argparse.Namespace" title="argparse.Namespace"><code class="xref py py-class docutils literal"><span class="pre">Namespace</span></code></a>返回值的属性之前，解析器应用任何<a class="reference internal" href="#type">type</a>转换参数（如果提供）。</span><span class="yiyi-st" id="yiyi-251">否则，解析器按原样使用该值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--length'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">'10'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--width'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">10.5</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="go">Namespace(length=10, width=10.5)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-252">对于<a class="reference internal" href="#nargs">nargs</a>等于<code class="docutils literal"><span class="pre">?</span></code>的位置参数</span><span class="yiyi-st" id="yiyi-253">或<code class="docutils literal"><span class="pre">*</span></code>，当没有命令行参数时，使用<code class="docutils literal"><span class="pre">default</span></code>值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'a'</span><span class="p">])</span>
<span class="go">Namespace(foo='a')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="go">Namespace(foo=42)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-254">如果命令行参数不存在，则提供<code class="docutils literal"><span class="pre">default=argparse.SUPPRESS</span></code>将导致不添加任何属性。</span><span class="yiyi-st" id="yiyi-255">:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">SUPPRESS</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="go">Namespace()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">])</span>
<span class="go">Namespace(foo='1')</span>
</code></pre></div><div class="section" id="type"><h3><span class="yiyi-st" id="yiyi-256">16.4.3.6. type</span></h3><p><span class="yiyi-st" id="yiyi-257">默认情况下，<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>对象以简单的字符串读取命令行参数。</span><span class="yiyi-st" id="yiyi-258">但是，通常命令行字符串应该被解释为另一种类型，例如<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>或<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>。</span><span class="yiyi-st" id="yiyi-259"><a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>的<code class="docutils literal"><span class="pre">type</span></code>关键字参数允许执行任何必需的类型检查和类型转换。</span><span class="yiyi-st" id="yiyi-260">常见的内置类型和函数可以直接用作<code class="docutils literal"><span class="pre">type</span></code>参数的值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">open</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'2 temp.txt'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(bar=&lt;_io.TextIOWrapper name='temp.txt' encoding='UTF-8'&gt;, foo=2)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-261">有关何时将<code class="docutils literal"><span class="pre">type</span></code>参数应用于缺省参数的信息，请参阅<a class="reference internal" href="#default">default</a>关键字参数中的一节。</span></p><p><span class="yiyi-st" id="yiyi-262">To ease the use of various types of files, the argparse module provides the factory FileType which takes the <code class="docutils literal"><span class="pre">mode=</span></code>, <code class="docutils literal"><span class="pre">bufsize=</span></code>, <code class="docutils literal"><span class="pre">encoding=</span></code> and <code class="docutils literal"><span class="pre">errors=</span></code> arguments of the <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> function. </span><span class="yiyi-st" id="yiyi-263">例如，可以使用<code class="docutils literal"><span class="pre">FileType('w')</span></code>创建可写文件：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">FileType</span><span class="p">(</span><span class="s1">'w'</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'out.txt'</span><span class="p">])</span>
<span class="go">Namespace(bar=&lt;_io.TextIOWrapper name='out.txt' encoding='UTF-8'&gt;)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-264"><code class="docutils literal"><span class="pre">type=</span></code>可以接受任何可接受单个字符串参数的可调用函数，并返回转换后的值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">perfect_square</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sqrt</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">sqrt</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sqrt</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">msg</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%r</span><span class="s2"> is not a perfect square"</span> <span class="o">%</span> <span class="n">string</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentTypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">perfect_square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'9'</span><span class="p">])</span>
<span class="go">Namespace(foo=9)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'7'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] foo</span>
<span class="go">PROG: error: argument foo: '7' is not a perfect square</span>
</code></pre><p><span class="yiyi-st" id="yiyi-265">对于类型检查器，<a class="reference internal" href="#choices">choices</a>关键字参数可能会更方便，它只需检查一系列值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'7'</span><span class="p">])</span>
<span class="go">Namespace(foo=7)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'11'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] {5,6,7,8,9}</span>
<span class="go">PROG: error: argument foo: invalid choice: 11 (choose from 5, 6, 7, 8, 9)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-266">有关更多详细信息，请参阅<a class="reference internal" href="#choices">choices</a>部分。</span></p></div><div class="section" id="choices"><h3><span class="yiyi-st" id="yiyi-267">16.4.3.7. 选择</span></h3><p><span class="yiyi-st" id="yiyi-268">一些命令行参数应该从一组受限制的值中选择。</span><span class="yiyi-st" id="yiyi-269">这些可以通过将容器对象作为<em>choices</em>关键字参数传递给<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>来处理。</span><span class="yiyi-st" id="yiyi-270">在解析命令行时，将检查参数值，如果参数不是可接受值之一，则会显示错误消息：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'game.py'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'move'</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">'rock'</span><span class="p">,</span> <span class="s1">'paper'</span><span class="p">,</span> <span class="s1">'scissors'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'rock'</span><span class="p">])</span>
<span class="go">Namespace(move='rock')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'fire'</span><span class="p">])</span>
<span class="go">usage: game.py [-h] {rock,paper,scissors}</span>
<span class="go">game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',</span>
<span class="go">'paper', 'scissors')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-271">请注意，在执行了任何<a class="reference internal" href="#type">类型</a>转换后，将检查包含在<em>choices</em>容器中的内容，以便<em>choices</em>容器中的对象类型应匹配指定的<a class="reference internal" href="#type">类型</a>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'doors.py'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'door'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'3'</span><span class="p">]))</span>
<span class="go">Namespace(door=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'4'</span><span class="p">])</span>
<span class="go">usage: doors.py [-h] {1,2,3}</span>
<span class="go">doors.py: error: argument door: invalid choice: 4 (choose from 1, 2, 3)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-272">任何的<code class="docutils literal"><span class="pre">in</span></code>运算符所支持的对象都可以作为<em>choice</em>的值,例如<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>对象,<a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>对象,以及自定义的容器对象.</span><span class="yiyi-st" id="yiyi-273">都支持。</span></p></div><div class="section" id="required"><h3><span class="yiyi-st" id="yiyi-274">16.4.3.8. required </span></h3><p><span class="yiyi-st" id="yiyi-275">通常，<a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a>模块假定象<code class="docutils literal"><span class="pre">-f</span></code>和<code class="docutils literal"><span class="pre">--bar</span></code>这样的标志表示<em>可选的</em>参数，总是在命令行中被省略。</span><span class="yiyi-st" id="yiyi-276">要使选项<em>必需</em>，可以为<code class="docutils literal"><span class="pre">required=</span></code>关键字参数指定<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>中的<code class="docutils literal"><span class="pre">True</span></code>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'BAR'</span><span class="p">])</span>
<span class="go">Namespace(foo='BAR')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="go">usage: argparse.py [-h] [--foo FOO]</span>
<span class="go">argparse.py: error: option --foo is required</span>
</code></pre><p><span class="yiyi-st" id="yiyi-277">如示例所示，如果某个选项被标记为<code class="docutils literal"><span class="pre">required</span></code>，则<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>将报告错误，如果该选项不存在于命令行中。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-278">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-279">由于用户期望<em>options</em>为<em>可选</em>，所以必需的选项通常被认为是错误的形式，因此应尽可能避免。</span></p></div></div><div class="section" id="help"><h3><span class="yiyi-st" id="yiyi-280">16.4.3.9. 帮助</span></h3><p><span class="yiyi-st" id="yiyi-281"><code class="docutils literal"><span class="pre">help</span></code>值是一个包含参数简要描述的字符串。</span><span class="yiyi-st" id="yiyi-282">当用户请求帮助时（通常在命令行使用<code class="docutils literal"><span class="pre">-h</span></code>或<code class="docutils literal"><span class="pre">--help</span></code>），这些<code class="docutils literal"><span class="pre">help</span></code>论据：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'frobble'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_true'</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">help</span><span class="o">=</span><span class="s1">'foo the bars before frobbling'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'+'</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">help</span><span class="o">=</span><span class="s1">'one of the bars to be frobbled'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-h'</span><span class="p">])</span>
<span class="go">usage: frobble [-h] [--foo] bar [bar ...]</span>

<span class="go">positional arguments:</span>
<span class="go"> bar     one of the bars to be frobbled</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
<span class="go"> --foo   foo the bars before frobbling</span>
</code></pre><p><span class="yiyi-st" id="yiyi-283"><code class="docutils literal"><span class="pre">help</span></code>字符串可以包含各种格式说明符以避免重复诸如程序名称或参数<a class="reference internal" href="#default">default</a>之类的内容。</span><span class="yiyi-st" id="yiyi-284">可用的说明符包括程序名称，<code class="docutils literal"><span class="pre">%(prog)s</span></code>和大多数关于<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>的关键字参数。</span><span class="yiyi-st" id="yiyi-285"><code class="docutils literal"><span class="pre">%(default)s</span></code>，<code class="docutils literal"><span class="pre">%(type)s</span></code>等。</span><span class="yiyi-st" id="yiyi-286">:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'frobble'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">help</span><span class="o">=</span><span class="s1">'the bar to </span><span class="si">%(prog)s</span><span class="s1"> (default: </span><span class="si">%(default)s</span><span class="s1">)'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: frobble [-h] [bar]</span>

<span class="go">positional arguments:</span>
<span class="go"> bar     the bar to frobble (default: 42)</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
</code></pre><p><span class="yiyi-st" id="yiyi-287">由于帮助字符串支持％格式化，如果您希望文字<code class="docutils literal"><span class="pre">%</span></code>出现在帮助字符串中，您必须将其作为<code class="docutils literal"><span class="pre">%%</span></code>转义。</span></p><p><span class="yiyi-st" id="yiyi-288"><a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a> supports silencing the help entry for certain options, by setting the <code class="docutils literal"><span class="pre">help</span></code> value to <code class="docutils literal"><span class="pre">argparse.SUPPRESS</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'frobble'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">SUPPRESS</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: frobble [-h]</span>

<span class="go">optional arguments:</span>
<span class="go">  -h, --help  show this help message and exit</span>
</code></pre></div><div class="section" id="metavar"><h3><span class="yiyi-st" id="yiyi-289">16.4.3.10.  metavar </span></h3><p><span class="yiyi-st" id="yiyi-290">当<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>生成帮助消息时，它需要一些方法来引用每个期望的参数。</span><span class="yiyi-st" id="yiyi-291">默认情况下，ArgumentParser对象使用<a class="reference internal" href="#dest">dest</a>值作为每个对象的“名称”。</span><span class="yiyi-st" id="yiyi-292">默认情况下，对于位置参数操作，直接使用<a class="reference internal" href="#dest">dest</a>值，对于可选参数操作，<a class="reference internal" href="#dest">dest</a>值是大写的。</span><span class="yiyi-st" id="yiyi-293">因此，<code class="docutils literal"><span class="pre">dest='bar'</span></code>的单个位置参数将被称为<code class="docutils literal"><span class="pre">bar</span></code>。</span><span class="yiyi-st" id="yiyi-294">一个可选参数<code class="docutils literal"><span class="pre">--foo</span></code>应该跟随一个命令行参数，它将被称为<code class="docutils literal"><span class="pre">FOO</span></code>。</span><span class="yiyi-st" id="yiyi-295">一个例子：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'X --foo Y'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(bar='X', foo='Y')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage:  [-h] [--foo FOO] bar</span>

<span class="go">positional arguments:</span>
<span class="go"> bar</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
<span class="go"> --foo FOO</span>
</code></pre><p><span class="yiyi-st" id="yiyi-296">An alternative name can be specified with <code class="docutils literal"><span class="pre">metavar</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">'YYY'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">'XXX'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'X --foo Y'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(bar='X', foo='Y')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage:  [-h] [--foo YYY] XXX</span>

<span class="go">positional arguments:</span>
<span class="go"> XXX</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help  show this help message and exit</span>
<span class="go"> --foo YYY</span>
</code></pre><p><span class="yiyi-st" id="yiyi-297">Note that <code class="docutils literal"><span class="pre">metavar</span></code> only changes the <em>displayed</em> name - the name of the attribute on the <a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a> object is still determined by the <a class="reference internal" href="#dest">dest</a> value.</span></p><p><span class="yiyi-st" id="yiyi-298"><code class="docutils literal"><span class="pre">nargs</span></code>的不同值可能会导致metavar被多次使用。</span><span class="yiyi-st" id="yiyi-299">Providing a tuple to <code class="docutils literal"><span class="pre">metavar</span></code> specifies a different display for each of the arguments:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-x'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="s1">'baz'</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [-h] [-x X X] [--foo bar baz]</span>

<span class="go">optional arguments:</span>
<span class="go"> -h, --help     show this help message and exit</span>
<span class="go"> -x X X</span>
<span class="go"> --foo bar baz</span>
</code></pre></div><div class="section" id="dest"><h3><span class="yiyi-st" id="yiyi-300">16.4.3.11.  DEST </span></h3><p><span class="yiyi-st" id="yiyi-301">大多数<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>操作都会添加一些值作为由<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>返回的对象的属性。</span><span class="yiyi-st" id="yiyi-302">该属性的名称由<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>的<code class="docutils literal"><span class="pre">dest</span></code>关键字参数确定。</span><span class="yiyi-st" id="yiyi-303">对于位置参数动作，<code class="docutils literal"><span class="pre">dest</span></code>通常作为<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>的第一个参数提供：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'XXX'</span><span class="p">])</span>
<span class="go">Namespace(bar='XXX')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-304">对于可选参数操作，<code class="docutils literal"><span class="pre">dest</span></code>的值通常是从选项字符串中推断出来的。</span><span class="yiyi-st" id="yiyi-305"><a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>通过取第一个长选项字符串并剥离初始字符串<code class="docutils literal"><span class="pre">--</span></code>来生成<code class="docutils literal"><span class="pre">dest</span></code>的值。</span><span class="yiyi-st" id="yiyi-306">如果没有提供长选项字符串，则通过剥离初始的<code class="docutils literal"><span class="pre">-</span></code>字符从第一个短选项字符串中派生<code class="docutils literal"><span class="pre">dest</span></code>。</span><span class="yiyi-st" id="yiyi-307">任何内部的<code class="docutils literal"><span class="pre">-</span></code>字符将被转换为<code class="docutils literal"><span class="pre">_</span></code>字符以确保该字符串是有效的属性名称。</span><span class="yiyi-st" id="yiyi-308">下面的例子说明了这种行为：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-f'</span><span class="p">,</span> <span class="s1">'--foo-bar'</span><span class="p">,</span> <span class="s1">'--foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-x'</span><span class="p">,</span> <span class="s1">'-y'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'-f 1 -x 2'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(foo_bar='1', x='2')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'--foo 1 -y 2'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(foo_bar='1', x='2')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-309"><code class="docutils literal"><span class="pre">dest</span></code>允许提供自定义属性名称：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'--foo XXX'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(bar='XXX')</span>
</code></pre></div><div class="section" id="action-classes"><h3><span class="yiyi-st" id="yiyi-310">16.4.3.12. </span><span class="yiyi-st" id="yiyi-311">动作类</span></h3><p><span class="yiyi-st" id="yiyi-312">Action类实现Action API，这是一个可调用的函数，它返回一个可从命令行处理参数的可调用对象。</span><span class="yiyi-st" id="yiyi-313">任何遵循此API的对象都可以作为<code class="docutils literal"><span class="pre">action</span></code>参数传递给<code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code>。</span></p><dl class="class"><dt id="argparse.Action"><span class="yiyi-st" id="yiyi-314"> <em class="property">class </em><code class="descclassname">argparse.</code><code class="descname">Action</code><span class="sig-paren">(</span><em>option_strings</em>, <em>dest</em>, <em>nargs=None</em>, <em>const=None</em>, <em>default=None</em>, <em>type=None</em>, <em>choices=None</em>, <em>required=False</em>, <em>help=None</em>, <em>metavar=None</em><span class="sig-paren">)</span></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-315">ArgumentParser使用Action对象来表示解析来自命令行的一个或多个字符串的单个参数所需的信息。</span><span class="yiyi-st" id="yiyi-316">除了<code class="docutils literal"><span class="pre">action</span></code>本身，Action类必须接受两个位置参数以及传递给<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">ArgumentParser.add_argument()</span></code></a>的所有关键字参数。</span></p><p><span class="yiyi-st" id="yiyi-317">Action的实例（或任何可调用到<code class="docutils literal"><span class="pre">action</span></code>参数的返回值）应该具有属性“dest”，“option_strings”，“default”，“type”，“required”，“help”等。</span><span class="yiyi-st" id="yiyi-318">定义。</span><span class="yiyi-st" id="yiyi-319">确定这些属性的最简单方法是调用<code class="docutils literal"><span class="pre">Action.__init__</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-320">Action实例应该是可调用的，所以子类必须覆盖<code class="docutils literal"><span class="pre">__call__</span></code>方法，该方法应该接受四个参数：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-321"><code class="docutils literal"><span class="pre">parser</span></code>  - 包含此操作的ArgumentParser对象。</span></li><li><span class="yiyi-st" id="yiyi-322"><code class="docutils literal"><span class="pre">namespace</span></code>  - 将由<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>返回的<a class="reference internal" href="#argparse.Namespace" title="argparse.Namespace"><code class="xref py py-class docutils literal"><span class="pre">Namespace</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-323">大多数操作都使用<a class="reference internal" href="functions.html#setattr" title="setattr"><code class="xref py py-func docutils literal"><span class="pre">setattr()</span></code></a>向此对象添加属性。</span></li><li><span class="yiyi-st" id="yiyi-324"><code class="docutils literal"><span class="pre">values</span></code>  - 关联的命令行参数，应用了任何类型的转换。</span><span class="yiyi-st" id="yiyi-325">类型转换通过<a class="reference internal" href="#type">type</a>关键字参数指定给<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>。</span></li><li><span class="yiyi-st" id="yiyi-326"><code class="docutils literal"><span class="pre">option_string</span></code>  - 用于调用此操作的选项字符串。</span><span class="yiyi-st" id="yiyi-327"><code class="docutils literal"><span class="pre">option_string</span></code>参数是可选的，如果该动作与位置参数关联，则该参数将不存在。</span></li></ul><p><span class="yiyi-st" id="yiyi-328"><code class="docutils literal"><span class="pre">__call__</span></code>方法可以执行任意操作，但通常会根据<code class="docutils literal"><span class="pre">dest</span></code>和<code class="docutils literal"><span class="pre">values</span></code>在<code class="docutils literal"><span class="pre">namespace</span></code>上设置属性。</span></p></div></div><div class="section" id="the-parse-args-method"><h2><span class="yiyi-st" id="yiyi-329">16.4.4. </span><span class="yiyi-st" id="yiyi-330">parse_args()方法</span></h2><dl class="method"><dt id="argparse.ArgumentParser.parse_args"><span class="yiyi-st" id="yiyi-331"><code class="descclassname">ArgumentParser。</code> <code class="descname">parse_args</code> <span class="sig-paren">（</span> <em>args = None</em>，<em>namespace = None</em> <span class="sig-paren">）  T5&gt; </span></span></dt><dd><p><span class="yiyi-st" id="yiyi-332">将参数字符串转换为对象并将它们分配为命名空间的属性。</span><span class="yiyi-st" id="yiyi-333">返回填充的命名空间。</span></p><p><span class="yiyi-st" id="yiyi-334">之前对<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>的调用确切地确定了哪些对象被创建以及它们如何分配。</span><span class="yiyi-st" id="yiyi-335">有关详细信息，请参阅<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>的文档。</span></p><p><span class="yiyi-st" id="yiyi-336">默认情况下，参数字符串取自<a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal"><span class="pre">sys.argv</span></code></a>，并为属性创建一个新的空<a class="reference internal" href="#argparse.Namespace" title="argparse.Namespace"><code class="xref py py-class docutils literal"><span class="pre">Namespace</span></code></a>对象。</span></p></dd></dl><div class="section" id="option-value-syntax"><h3><span class="yiyi-st" id="yiyi-337">16.4.4.1. </span><span class="yiyi-st" id="yiyi-338">选项值语法</span></h3><p><span class="yiyi-st" id="yiyi-339"><a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>方法支持多种方式来指定选项的值（如果它需要一个）。</span><span class="yiyi-st" id="yiyi-340">在最简单的情况下，该选项及其值作为两个单独的参数传递：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-x'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-x'</span><span class="p">,</span> <span class="s1">'X'</span><span class="p">])</span>
<span class="go">Namespace(foo=None, x='X')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'FOO'</span><span class="p">])</span>
<span class="go">Namespace(foo='FOO', x=None)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-341">对于长选项（名称长于单个字符的选项），该选项和值也可以作为单个命令行参数传递，使用<code class="docutils literal"><span class="pre">=</span></code>来分隔它们：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo=FOO'</span><span class="p">])</span>
<span class="go">Namespace(foo='FOO', x=None)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-342">对于短期选项（选项只有一个字符长），选项和它的值可以连接起来：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-xX'</span><span class="p">])</span>
<span class="go">Namespace(foo=None, x='X')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-343">只要使用一个<code class="docutils literal"><span class="pre">-</span></code>前缀，几个简短选项就可以连接在一起，只要最后一个选项（或它们中没有一个）需要一个值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-x'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_true'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-y'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_true'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-z'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-xyzZ'</span><span class="p">])</span>
<span class="go">Namespace(x=True, y=True, z='Z')</span>
</code></pre></div><div class="section" id="invalid-arguments"><h3><span class="yiyi-st" id="yiyi-344">16.4.4.2. </span><span class="yiyi-st" id="yiyi-345">无效参数</span></h3><p><span class="yiyi-st" id="yiyi-346">在解析命令行时，<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>检查各种错误，包括不明确的选项，无效的类型，无效的选项，错误的位置参数数量等。</span><span class="yiyi-st" id="yiyi-347">遇到此类错误时，它会退出并将错误与使用消息一起打印出来：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># invalid type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'spam'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] [--foo FOO] [bar]</span>
<span class="go">PROG: error: argument --foo: invalid int value: 'spam'</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># invalid option</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--bar'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] [--foo FOO] [bar]</span>
<span class="go">PROG: error: no such option: --bar</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># wrong number of arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'spam'</span><span class="p">,</span> <span class="s1">'badger'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] [--foo FOO] [bar]</span>
<span class="go">PROG: error: extra arguments found: badger</span>
</code></pre></div><div class="section" id="arguments-containing"><h3><span class="yiyi-st" id="yiyi-348">16.4.4.3. </span><span class="yiyi-st" id="yiyi-349">包含<code class="docutils literal"><span class="pre">-</span></code>的参数</span></h3><p><span class="yiyi-st" id="yiyi-350">每当用户明确犯了错误时，<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>方法都会尝试给出错误，但是有些情况本质上是不明确的。</span><span class="yiyi-st" id="yiyi-351">例如，命令行参数<code class="docutils literal"><span class="pre">-1</span></code>可能是尝试指定选项或尝试提供位置参数。</span><span class="yiyi-st" id="yiyi-352"><a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>方法在此处谨慎：如果位置参数看起来像负数，并且在解析器中没有看起来像负数的选项，则它们只能以<code class="docutils literal"><span class="pre">-</span></code></span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-x'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># no negative number options, so -1 is a positional argument</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-x'</span><span class="p">,</span> <span class="s1">'-1'</span><span class="p">])</span>
<span class="go">Namespace(foo=None, x='-1')</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># no negative number options, so -1 and -5 are positional arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-x'</span><span class="p">,</span> <span class="s1">'-1'</span><span class="p">,</span> <span class="s1">'-5'</span><span class="p">])</span>
<span class="go">Namespace(foo='-5', x='-1')</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-1'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">'one'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># negative number options present, so -1 is an option</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-1'</span><span class="p">,</span> <span class="s1">'X'</span><span class="p">])</span>
<span class="go">Namespace(foo=None, one='X')</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># negative number options present, so -2 is an option</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-2'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] [-1 ONE] [foo]</span>
<span class="go">PROG: error: no such option: -2</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># negative number options present, so both -1s are options</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-1'</span><span class="p">,</span> <span class="s1">'-1'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] [-1 ONE] [foo]</span>
<span class="go">PROG: error: argument -1: expected one argument</span>
</code></pre><p><span class="yiyi-st" id="yiyi-353">如果您的位置参数必须以<code class="docutils literal"><span class="pre">-</span></code>开始，而且看起来不像负数，那么可以插入伪参数<code class="docutils literal"><span class="pre">'--'</span></code>，它告诉<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>之后的所有内容都是一个位置参数：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--'</span><span class="p">,</span> <span class="s1">'-f'</span><span class="p">])</span>
<span class="go">Namespace(foo='-f', one=None)</span>
</code></pre></div><div class="section" id="argument-abbreviations-prefix-matching"><h3><span class="yiyi-st" id="yiyi-354">16.4.4.4. </span><span class="yiyi-st" id="yiyi-355">参数缩写（前缀匹配）</span></h3><p><span class="yiyi-st" id="yiyi-356">默认情况下，<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>方法<a class="reference internal" href="#allow-abbrev"><span>by default</span></a></span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-bacon'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-badger'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'-bac MMM'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(bacon='MMM', badger=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'-bad WOOD'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">Namespace(bacon=None, badger='WOOD')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'-ba BA'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">usage: PROG [-h] [-bacon BACON] [-badger BADGER]</span>
<span class="go">PROG: error: ambiguous option: -ba could match -badger, -bacon</span>
</code></pre><p><span class="yiyi-st" id="yiyi-357">对于可能产生多个选项的参数会产生错误。</span><span class="yiyi-st" id="yiyi-358">通过将<a class="reference internal" href="#allow-abbrev"><span>allow_abbrev</span></a>设置为<code class="docutils literal"><span class="pre">False</span></code>，可以禁用此功能。</span></p></div><div class="section" id="beyond-sys-argv"><h3><span class="yiyi-st" id="yiyi-359">16.4.4.5. </span><span class="yiyi-st" id="yiyi-360">超越<code class="docutils literal"><span class="pre">sys.argv</span></code> </span></h3><p><span class="yiyi-st" id="yiyi-361">有时，有一个ArgumentParser解析不同于<a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal"><span class="pre">sys.argv</span></code></a>的参数可能很有用。</span><span class="yiyi-st" id="yiyi-362">这可以通过将字符串列表传递给<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>来完成。</span><span class="yiyi-st" id="yiyi-363">这对于在交互式提示下进行测试很有用：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">'integers'</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">'int'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">nargs</span><span class="o">=</span><span class="s1">'+'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'an integer in the range 0..9'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">'--sum'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">'accumulate'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_const'</span><span class="p">,</span> <span class="n">const</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">default</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'sum the integers (default: find the max)'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'1'</span><span class="p">,</span> <span class="s1">'2'</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">,</span> <span class="s1">'4'</span><span class="p">])</span>
<span class="go">Namespace(accumulate=&lt;built-in function max&gt;, integers=[1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'1'</span><span class="p">,</span> <span class="s1">'2'</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">,</span> <span class="s1">'4'</span><span class="p">,</span> <span class="s1">'--sum'</span><span class="p">])</span>
<span class="go">Namespace(accumulate=&lt;built-in function sum&gt;, integers=[1, 2, 3, 4])</span>
</code></pre></div><div class="section" id="the-namespace-object"><h3><span class="yiyi-st" id="yiyi-364">16.4.4.6. </span><span class="yiyi-st" id="yiyi-365">名称空间对象</span></h3><dl class="class"><dt id="argparse.Namespace"><span class="yiyi-st" id="yiyi-366"> <em class="property">class </em><code class="descclassname">argparse.</code><code class="descname">Namespace</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-367">默认由<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>使用的简单类来创建一个拥有属性的对象并将其返回。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-368">这个类是故意很简单的，只是一个带有可读字符串表示的<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>子类。</span><span class="yiyi-st" id="yiyi-369">如果您更喜欢使用类似字典的属性视图，则可以使用标准Python成语<a class="reference internal" href="functions.html#vars" title="vars"><code class="xref py py-func docutils literal"><span class="pre">vars()</span></code></a>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'BAR'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="go">{'foo': 'BAR'}</span>
</code></pre><p><span class="yiyi-st" id="yiyi-370">将<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>分配给已存在的对象，而不是新的<a class="reference internal" href="#argparse.Namespace" title="argparse.Namespace"><code class="xref py py-class docutils literal"><span class="pre">Namespace</span></code></a>对象可能也很有用。</span><span class="yiyi-st" id="yiyi-371">这可以通过指定<code class="docutils literal"><span class="pre">namespace=</span></code>关键字参数来实现：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'BAR'</span><span class="p">],</span> <span class="n">namespace</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">foo</span>
<span class="go">'BAR'</span>
</code></pre></div></div><div class="section" id="other-utilities"><h2><span class="yiyi-st" id="yiyi-372">16.4.5. </span><span class="yiyi-st" id="yiyi-373">其他功能</span></h2><div class="section" id="sub-commands"><h3><span class="yiyi-st" id="yiyi-374">16.4.5.1. </span><span class="yiyi-st" id="yiyi-375">子命令</span></h3><dl class="method"><dt id="argparse.ArgumentParser.add_subparsers"><span class="yiyi-st" id="yiyi-376"> <code class="descclassname">ArgumentParser.</code><code class="descname">add_subparsers</code><span class="sig-paren">(</span><span class="optional">[</span><em>title</em><span class="optional">]</span><span class="optional">[</span>, <em>description</em><span class="optional">]</span><span class="optional">[</span>, <em>prog</em><span class="optional">]</span><span class="optional">[</span>, <em>parser_class</em><span class="optional">]</span><span class="optional">[</span>, <em>action</em><span class="optional">]</span><span class="optional">[</span>, <em>option_string</em><span class="optional">]</span><span class="optional">[</span>, <em>dest</em><span class="optional">]</span><span class="optional">[</span>, <em>help</em><span class="optional">]</span><span class="optional">[</span>, <em>metavar</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-377">Many programs split up their functionality into a number of sub-commands, for example, the <code class="docutils literal"><span class="pre">svn</span></code> program can invoke sub-commands like <code class="docutils literal"><span class="pre">svn</span> <span class="pre">checkout</span></code>, <code class="docutils literal"><span class="pre">svn</span> <span class="pre">update</span></code>, and <code class="docutils literal"><span class="pre">svn</span> <span class="pre">commit</span></code>. </span><span class="yiyi-st" id="yiyi-378">当程序执行需要不同种类的命令行参数的几个不同功能时，以这种方式拆分功能可能是一个特别好的想法。</span><span class="yiyi-st" id="yiyi-379"><a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>支持使用<a class="reference internal" href="#argparse.ArgumentParser.add_subparsers" title="argparse.ArgumentParser.add_subparsers"><code class="xref py py-meth docutils literal"><span class="pre">add_subparsers()</span></code></a>方法创建这样的子命令。</span><span class="yiyi-st" id="yiyi-380">通常不带参数调用<a class="reference internal" href="#argparse.ArgumentParser.add_subparsers" title="argparse.ArgumentParser.add_subparsers"><code class="xref py py-meth docutils literal"><span class="pre">add_subparsers()</span></code></a>方法，并返回一个特殊的操作对象。</span><span class="yiyi-st" id="yiyi-381">这个对象有一个方法，<code class="xref py py-meth docutils literal"><span class="pre">add_parser()</span></code>，它接受一个命令名和任何<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>构造函数参数，并返回一个<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>照常修改。</span></p><p><span class="yiyi-st" id="yiyi-382">参数描述：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-383">title  - 帮助输出中的子分析器组的标题；如果提供了描述，则默认为“子命令”，否则使用标题作为位置参数</span></li><li><span class="yiyi-st" id="yiyi-384">描述 - 默认情况下帮助输出中的子分析器组的描述无</span></li><li><span class="yiyi-st" id="yiyi-385">将使用子命令帮助显示的prog  - 使用信息，默认情况下程序的名称和子分析器参数前的任何位置参数</span></li><li><span class="yiyi-st" id="yiyi-386">parser_class  - 将用于创建子分析器实例的类，默认情况下是当前分析器的类（例如，</span><span class="yiyi-st" id="yiyi-387">ArgumentParser）</span></li><li><span class="yiyi-st" id="yiyi-388"><a class="reference internal" href="#action">action</a>  - 在命令行中遇到此参数时要采取的基本操作类型</span></li><li><span class="yiyi-st" id="yiyi-389"><a class="reference internal" href="#dest">dest</a>  - 存储子命令名称的属性的名称；默认情况下为None并且不存储任何值</span></li><li><span class="yiyi-st" id="yiyi-390"><a class="reference internal" href="#help">帮助</a>  - 帮助帮助输出中的子分析器组，默认为无</span></li><li><span class="yiyi-st" id="yiyi-391"><a class="reference internal" href="#metavar">metavar</a> - string presenting available sub-commands in help; by default it is None and presents sub-commands in form {cmd1, cmd2, ..}</span></li></ul><p><span class="yiyi-st" id="yiyi-392">一些示例用法：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># create the top-level parser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_true'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'foo help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparsers</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_subparsers</span><span class="p">(</span><span class="n">help</span><span class="o">=</span><span class="s1">'sub-command help'</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create the parser for the "a" command</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_a</span> <span class="o">=</span> <span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'a help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_a</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'bar help'</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create the parser for the "b" command</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_b</span> <span class="o">=</span> <span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'b help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_b</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--baz'</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="s1">'XYZ'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'baz help'</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># parse some argument lists</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'12'</span><span class="p">])</span>
<span class="go">Namespace(bar=12, foo=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'--baz'</span><span class="p">,</span> <span class="s1">'Z'</span><span class="p">])</span>
<span class="go">Namespace(baz='Z', foo=True)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-393">请注意，由<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>返回的对象将只包含由命令行（而不是任何其他子分析器）选择的主分析器和子分析器的属性。</span><span class="yiyi-st" id="yiyi-394">因此，在上面的示例中，当指定<code class="docutils literal"><span class="pre">a</span></code>命令时，仅存在<code class="docutils literal"><span class="pre">foo</span></code>和<code class="docutils literal"><span class="pre">bar</span></code>属性，并且当<code class="docutils literal"><span class="pre">b</span></code>命令被指定，只有<code class="docutils literal"><span class="pre">foo</span></code>和<code class="docutils literal"><span class="pre">baz</span></code>属性存在。</span></p><p><span class="yiyi-st" id="yiyi-395">同样，当从分析器请求帮助消息时，只会打印该特定分析器的帮助。</span><span class="yiyi-st" id="yiyi-396">帮助消息将不包括父解析器或同级解析器消息。</span><span class="yiyi-st" id="yiyi-397">（但是，可以通过向<code class="xref py py-meth docutils literal"><span class="pre">add_parser()</span></code>提供<code class="docutils literal"><span class="pre">help=</span></code>参数来给出每个子分析器命令的帮助消息，如上所示。）</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--help'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] [--foo] {a,b} ...</span>

<span class="go">positional arguments:</span>
<span class="go">  {a,b}   sub-command help</span>
<span class="go">    a     a help</span>
<span class="go">    b     b help</span>

<span class="go">optional arguments:</span>
<span class="go">  -h, --help  show this help message and exit</span>
<span class="go">  --foo   foo help</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'--help'</span><span class="p">])</span>
<span class="go">usage: PROG a [-h] bar</span>

<span class="go">positional arguments:</span>
<span class="go">  bar     bar help</span>

<span class="go">optional arguments:</span>
<span class="go">  -h, --help  show this help message and exit</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'b'</span><span class="p">,</span> <span class="s1">'--help'</span><span class="p">])</span>
<span class="go">usage: PROG b [-h] [--baz {X,Y,Z}]</span>

<span class="go">optional arguments:</span>
<span class="go">  -h, --help     show this help message and exit</span>
<span class="go">  --baz {X,Y,Z}  baz help</span>
</code></pre><p><span class="yiyi-st" id="yiyi-398"><a class="reference internal" href="#argparse.ArgumentParser.add_subparsers" title="argparse.ArgumentParser.add_subparsers"><code class="xref py py-meth docutils literal"><span class="pre">add_subparsers()</span></code></a>方法也支持<code class="docutils literal"><span class="pre">title</span></code>和<code class="docutils literal"><span class="pre">description</span></code>关键字参数。</span><span class="yiyi-st" id="yiyi-399">当出现任何一个时，子分析器的命令将出现在帮助输出中的他们自己的组中。</span><span class="yiyi-st" id="yiyi-400">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparsers</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_subparsers</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">'subcommands'</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">description</span><span class="o">=</span><span class="s1">'valid subcommands'</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">help</span><span class="o">=</span><span class="s1">'additional help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-h'</span><span class="p">])</span>
<span class="go">usage:  [-h] {foo,bar} ...</span>

<span class="go">optional arguments:</span>
<span class="go">  -h, --help  show this help message and exit</span>

<span class="go">subcommands:</span>
<span class="go">  valid subcommands</span>

<span class="go">  {foo,bar}   additional help</span>
</code></pre><p><span class="yiyi-st" id="yiyi-401">此外，<code class="docutils literal"><span class="pre">add_parser</span></code>支持额外的<code class="docutils literal"><span class="pre">aliases</span></code>参数，它允许多个字符串引用相同的子分析器。</span><span class="yiyi-st" id="yiyi-402">举个例子,就像<code class="docutils literal"><span class="pre">svn</span></code>一样,用缩写<code class="docutils literal"><span class="pre">co</span></code>来实现<code class="docutils literal"><span class="pre">checkout</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparsers</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_subparsers</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkout</span> <span class="o">=</span> <span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">'checkout'</span><span class="p">,</span> <span class="n">aliases</span><span class="o">=</span><span class="p">[</span><span class="s1">'co'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkout</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'co'</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">])</span>
<span class="go">Namespace(foo='bar')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-403">处理子命令的一个特别有效的方法是将<a class="reference internal" href="#argparse.ArgumentParser.add_subparsers" title="argparse.ArgumentParser.add_subparsers"><code class="xref py py-meth docutils literal"><span class="pre">add_subparsers()</span></code></a>方法的使用与对<a class="reference internal" href="#argparse.ArgumentParser.set_defaults" title="argparse.ArgumentParser.set_defaults"><code class="xref py py-meth docutils literal"><span class="pre">set_defaults()</span></code></a>的调用相结合，以便每个子分析器知道应该使用哪个Python函数执行。</span><span class="yiyi-st" id="yiyi-404">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># sub-command functions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">args</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'((</span><span class="si">%s</span><span class="s1">))'</span> <span class="o">%</span> <span class="n">args</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create the top-level parser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparsers</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_subparsers</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create the parser for the "foo" command</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_foo</span> <span class="o">=</span> <span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_foo</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-x'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_foo</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'y'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_foo</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">foo</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create the parser for the "bar" command</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_bar</span> <span class="o">=</span> <span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_bar</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'z'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_bar</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">bar</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># parse the args and call whatever function was selected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'foo 1 -x 2'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># parse the args and call whatever function was selected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="s1">'bar XYZYX'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="go">((XYZYX))</span>
</code></pre><p><span class="yiyi-st" id="yiyi-405">通过这种方式，可以让参数解析完成后，<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>完成调用相应函数的工作。</span><span class="yiyi-st" id="yiyi-406">将功能与这样的动作相关联通常是处理每个子分析器的不同动作的最简单方法。</span><span class="yiyi-st" id="yiyi-407">但是，如果需要检查调用的子分析器的名称，则<a class="reference internal" href="#argparse.ArgumentParser.add_subparsers" title="argparse.ArgumentParser.add_subparsers"><code class="xref py py-meth docutils literal"><span class="pre">add_subparsers()</span></code></a>调用的<code class="docutils literal"><span class="pre">dest</span></code>关键字参数将起作用：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparsers</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_subparsers</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="s1">'subparser_name'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparser1</span> <span class="o">=</span> <span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparser1</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-x'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparser2</span> <span class="o">=</span> <span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">'2'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subparser2</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'y'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'2'</span><span class="p">,</span> <span class="s1">'frobble'</span><span class="p">])</span>
<span class="go">Namespace(subparser_name='2', y='frobble')</span>
</code></pre></dd></dl></div><div class="section" id="filetype-objects"><h3><span class="yiyi-st" id="yiyi-408">16.4.5.2. </span><span class="yiyi-st" id="yiyi-409">FileType对象</span></h3><dl class="class"><dt id="argparse.FileType"><span class="yiyi-st" id="yiyi-410"> <em class="property">class </em><code class="descclassname">argparse.</code><code class="descname">FileType</code><span class="sig-paren">(</span><em>mode='r'</em>, <em>bufsize=-1</em>, <em>encoding=None</em>, <em>errors=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-411"><a class="reference internal" href="#argparse.FileType" title="argparse.FileType"><code class="xref py py-class docutils literal"><span class="pre">FileType</span></code></a>工厂创建可传递给<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">ArgumentParser.add_argument()</span></code></a>的类型参数的对象。</span><span class="yiyi-st" id="yiyi-412">将<a class="reference internal" href="#argparse.FileType" title="argparse.FileType"><code class="xref py py-class docutils literal"><span class="pre">FileType</span></code></a>对象作为它们的类型的参数将打开命令行参数作为具有所请求模式，缓冲区大小，编码和错误处理的文件（请参阅<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>函数更多细节）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--raw'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">FileType</span><span class="p">(</span><span class="s1">'wb'</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'out'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">FileType</span><span class="p">(</span><span class="s1">'w'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">'UTF-8'</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--raw'</span><span class="p">,</span> <span class="s1">'raw.dat'</span><span class="p">,</span> <span class="s1">'file.txt'</span><span class="p">])</span>
<span class="go">Namespace(out=&lt;_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'&gt;, raw=&lt;_io.FileIO name='raw.dat' mode='wb'&gt;)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-413">FileType对象理解伪参数<code class="docutils literal"><span class="pre">'-'</span></code>并自动将其转换为<code class="docutils literal"><span class="pre">sys.stdin</span></code>，以便读取<a class="reference internal" href="#argparse.FileType" title="argparse.FileType"><code class="xref py py-class docutils literal"><span class="pre">FileType</span></code></a>对象和<code class="docutils literal"><span class="pre">sys.stdout</span></code>用于写入<a class="reference internal" href="#argparse.FileType" title="argparse.FileType"><code class="xref py py-class docutils literal"><span class="pre">FileType</span></code></a>对象：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'infile'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">FileType</span><span class="p">(</span><span class="s1">'r'</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'-'</span><span class="p">])</span>
<span class="go">Namespace(infile=&lt;_io.TextIOWrapper name='&lt;stdin&gt;' encoding='UTF-8'&gt;)</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-414"><span class="versionmodified">版本3.4新增：</span> <em>编码</em>和<em>错误</em>关键字参数。</span></p></div></dd></dl></div><div class="section" id="argument-groups"><h3><span class="yiyi-st" id="yiyi-415">16.4.5.3. </span><span class="yiyi-st" id="yiyi-416">参数组</span></h3><dl class="method"><dt id="argparse.ArgumentParser.add_argument_group"><span class="yiyi-st" id="yiyi-417"> <code class="descclassname">ArgumentParser.</code><code class="descname">add_argument_group</code><span class="sig-paren">(</span><em>title=None</em>, <em>description=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-418">默认情况下，当显示帮助消息时，<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>将命令行参数分组为“位置参数”和“可选参数”。</span><span class="yiyi-st" id="yiyi-419">如果参数的概念分组比这个默认分组更好，则可以使用<a class="reference internal" href="#argparse.ArgumentParser.add_argument_group" title="argparse.ArgumentParser.add_argument_group"><code class="xref py py-meth docutils literal"><span class="pre">add_argument_group()</span></code></a>方法创建适当的分组：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span> <span class="n">add_help</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_argument_group</span><span class="p">(</span><span class="s1">'group'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'foo help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'bar help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [--foo FOO] bar</span>

<span class="go">group:</span>
<span class="go">  bar    bar help</span>
<span class="go">  --foo FOO  foo help</span>
</code></pre><p><span class="yiyi-st" id="yiyi-420"><a class="reference internal" href="#argparse.ArgumentParser.add_argument_group" title="argparse.ArgumentParser.add_argument_group"><code class="xref py py-meth docutils literal"><span class="pre">add_argument_group()</span></code></a>方法返回一个参数组对象，它具有<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>方法，就像常规的<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>一样。</span><span class="yiyi-st" id="yiyi-421">当将参数添加到组中时，解析器将其视为与普通参数类似，但将参数显示在单独的组中以获取帮助消息。</span><span class="yiyi-st" id="yiyi-422"><a class="reference internal" href="#argparse.ArgumentParser.add_argument_group" title="argparse.ArgumentParser.add_argument_group"><code class="xref py py-meth docutils literal"><span class="pre">add_argument_group()</span></code></a>方法接受可用于自定义此显示的<em>title</em>和<em>description</em>参数：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">,</span> <span class="n">add_help</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group1</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_argument_group</span><span class="p">(</span><span class="s1">'group1'</span><span class="p">,</span> <span class="s1">'group1 description'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group1</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'foo help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group2</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_argument_group</span><span class="p">(</span><span class="s1">'group2'</span><span class="p">,</span> <span class="s1">'group2 description'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group2</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--bar'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">'bar help'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
<span class="go">usage: PROG [--bar BAR] foo</span>

<span class="go">group1:</span>
<span class="go">  group1 description</span>

<span class="go">  foo    foo help</span>

<span class="go">group2:</span>
<span class="go">  group2 description</span>

<span class="go">  --bar BAR  bar help</span>
</code></pre><p><span class="yiyi-st" id="yiyi-423">请注意，任何不在用户定义组中的参数将返回到通常的“位置参数”和“可选参数”部分。</span></p></dd></dl></div><div class="section" id="mutual-exclusion"><h3><span class="yiyi-st" id="yiyi-424">16.4.5.4. </span><span class="yiyi-st" id="yiyi-425">相互排斥</span></h3><dl class="method"><dt id="argparse.ArgumentParser.add_mutually_exclusive_group"><span class="yiyi-st" id="yiyi-426"> <code class="descclassname">ArgumentParser.</code><code class="descname">add_mutually_exclusive_group</code><span class="sig-paren">(</span><em>required=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-427">创建一个互斥组。</span><span class="yiyi-st" id="yiyi-428"><a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a> will make sure that only one of the arguments in the mutually exclusive group was present on the command line:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_mutually_exclusive_group</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_true'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--bar'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_false'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">])</span>
<span class="go">Namespace(bar=True, foo=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--bar'</span><span class="p">])</span>
<span class="go">Namespace(bar=False, foo=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'--bar'</span><span class="p">])</span>
<span class="go">usage: PROG [-h] [--foo | --bar]</span>
<span class="go">PROG: error: argument --bar: not allowed with argument --foo</span>
</code></pre><p><span class="yiyi-st" id="yiyi-429"><a class="reference internal" href="#argparse.ArgumentParser.add_mutually_exclusive_group" title="argparse.ArgumentParser.add_mutually_exclusive_group"><code class="xref py py-meth docutils literal"><span class="pre">add_mutually_exclusive_group()</span></code></a>方法还接受一个<em>必需的</em>参数，以表明至少需要一个互斥参数：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'PROG'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_mutually_exclusive_group</span><span class="p">(</span><span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_true'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--bar'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_false'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="go">usage: PROG [-h] (--foo | --bar)</span>
<span class="go">PROG: error: one of the arguments --foo --bar is required</span>
</code></pre><p><span class="yiyi-st" id="yiyi-430">请注意，目前互斥的参数组不支持<a class="reference internal" href="#argparse.ArgumentParser.add_argument_group" title="argparse.ArgumentParser.add_argument_group"><code class="xref py py-meth docutils literal"><span class="pre">add_argument_group()</span></code></a>的<em>title</em>和<em>description</em>参数。</span></p></dd></dl></div><div class="section" id="parser-defaults"><h3><span class="yiyi-st" id="yiyi-431">16.4.5.5. </span><span class="yiyi-st" id="yiyi-432">解析器默认为</span></h3><dl class="method"><dt id="argparse.ArgumentParser.set_defaults"><span class="yiyi-st" id="yiyi-433"> <code class="descclassname">ArgumentParser.</code><code class="descname">set_defaults</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-434">大多数情况下，通过检查命令行参数和参数操作，将完全确定由<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>返回的对象的属性。</span><span class="yiyi-st" id="yiyi-435"><a class="reference internal" href="#argparse.ArgumentParser.set_defaults" title="argparse.ArgumentParser.set_defaults"><code class="xref py py-meth docutils literal"><span class="pre">set_defaults()</span></code></a>允许在没有检查命令行的情况下确定一些额外的属性：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">bar</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">baz</span><span class="o">=</span><span class="s1">'badger'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([</span><span class="s1">'736'</span><span class="p">])</span>
<span class="go">Namespace(bar=42, baz='badger', foo=736)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-436">请注意，解析器级别的默认值总是覆盖参数级别的默认值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="s1">'spam'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="go">Namespace(foo='spam')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-437">解析器级别的默认值在使用多个解析器时可能特别有用。</span><span class="yiyi-st" id="yiyi-438">有关此类型的示例，请参阅<a class="reference internal" href="#argparse.ArgumentParser.add_subparsers" title="argparse.ArgumentParser.add_subparsers"><code class="xref py py-meth docutils literal"><span class="pre">add_subparsers()</span></code></a>方法。</span></p></dd></dl><dl class="method"><dt id="argparse.ArgumentParser.get_default"><span class="yiyi-st" id="yiyi-439"> <code class="descclassname">ArgumentParser.</code><code class="descname">get_default</code><span class="sig-paren">(</span><em>dest</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-440">获取由<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">add_argument()</span></code></a>或<a class="reference internal" href="#argparse.ArgumentParser.set_defaults" title="argparse.ArgumentParser.set_defaults"><code class="xref py py-meth docutils literal"><span class="pre">set_defaults()</span></code></a>设置的命名空间属性的默认值：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">'badger'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">get_default</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="go">'badger'</span>
</code></pre></dd></dl></div><div class="section" id="printing-help"><h3><span class="yiyi-st" id="yiyi-441">16.4.5.6. </span><span class="yiyi-st" id="yiyi-442">打印帮助</span></h3><p><span class="yiyi-st" id="yiyi-443">在大多数典型应用程序中，<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>将负责格式化和打印任何使用或错误消息。</span><span class="yiyi-st" id="yiyi-444">但是，有几种格式化方法可用：</span></p><dl class="method"><dt id="argparse.ArgumentParser.print_usage"><span class="yiyi-st" id="yiyi-445"> <code class="descclassname">ArgumentParser.</code><code class="descname">print_usage</code><span class="sig-paren">(</span><em>file=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-446">打印关于如何在命令行上调用<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>的简要说明。</span><span class="yiyi-st" id="yiyi-447">如果<em>文件</em>为<code class="docutils literal"><span class="pre">None</span></code>，则假定<a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="argparse.ArgumentParser.print_help"><span class="yiyi-st" id="yiyi-448"> <code class="descclassname">ArgumentParser.</code><code class="descname">print_help</code><span class="sig-paren">(</span><em>file=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-449">打印帮助信息，包括程序使用情况以及有关使用<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>注册的参数的信息。</span><span class="yiyi-st" id="yiyi-450">如果<em>文件</em>为<code class="docutils literal"><span class="pre">None</span></code>，则假定<a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-451">也有这些方法的变体，只是返回一个字符串，而不是打印它：</span></p><dl class="method"><dt id="argparse.ArgumentParser.format_usage"><span class="yiyi-st" id="yiyi-452"> <code class="descclassname">ArgumentParser.</code><code class="descname">format_usage</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-453">返回一个字符串，其中包含应该如何在命令行上调用<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>的简要说明。</span></p></dd></dl><dl class="method"><dt id="argparse.ArgumentParser.format_help"><span class="yiyi-st" id="yiyi-454"> <code class="descclassname">ArgumentParser.</code><code class="descname">format_help</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-455">返回一个包含帮助信息的字符串，包括程序使用情况和有关使用<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>注册的参数的信息。</span></p></dd></dl></div><div class="section" id="partial-parsing"><h3><span class="yiyi-st" id="yiyi-456">16.4.5.7. </span><span class="yiyi-st" id="yiyi-457">部分解析</span></h3><dl class="method"><dt id="argparse.ArgumentParser.parse_known_args"><span class="yiyi-st" id="yiyi-458"> <code class="descclassname">ArgumentParser.</code><code class="descname">parse_known_args</code><span class="sig-paren">(</span><em>args=None</em>, <em>namespace=None</em><span class="sig-paren">)</span></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-459">有时脚本可能只解析一些命令行参数，将剩下的参数传递给另一个脚本或程序。</span><span class="yiyi-st" id="yiyi-460">在这些情况下，<a class="reference internal" href="#argparse.ArgumentParser.parse_known_args" title="argparse.ArgumentParser.parse_known_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_known_args()</span></code></a>方法可能很有用。</span><span class="yiyi-st" id="yiyi-461">它的工作方式与<a class="reference internal" href="#argparse.ArgumentParser.parse_args" title="argparse.ArgumentParser.parse_args"><code class="xref py py-meth docutils literal"><span class="pre">parse_args()</span></code></a>非常相似，只是在出现额外参数时不会产生错误。</span><span class="yiyi-st" id="yiyi-462">相反，它会返回一个包含已填充名称空间和剩余参数字符串列表的两个项目元组。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_true'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_known_args</span><span class="p">([</span><span class="s1">'--foo'</span><span class="p">,</span> <span class="s1">'--badger'</span><span class="p">,</span> <span class="s1">'BAR'</span><span class="p">,</span> <span class="s1">'spam'</span><span class="p">])</span>
<span class="go">(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])</span>
</code></pre><div class="admonition warning"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-463">警告</span></p><p class="last"><span class="yiyi-st" id="yiyi-464"><a class="reference internal" href="#prefix-matching"><span>Prefix matching</span></a>规则适用于<code class="xref py py-meth docutils literal"><span class="pre">parse_known_args()</span></code>。</span><span class="yiyi-st" id="yiyi-465">解析器可能会使用一个选项，即使它只是其中一个已知选项的前缀，而不是将它留在剩余的参数列表中。</span></p></div></div><div class="section" id="customizing-file-parsing"><h3><span class="yiyi-st" id="yiyi-466">16.4.5.8. </span><span class="yiyi-st" id="yiyi-467">自定义文件解析</span></h3><dl class="method"><dt id="argparse.ArgumentParser.convert_arg_line_to_args"><span class="yiyi-st" id="yiyi-468"> <code class="descclassname">ArgumentParser.</code><code class="descname">convert_arg_line_to_args</code><span class="sig-paren">(</span><em>arg_line</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-469">从文件读取的参数（请参阅<em>fromfile_prefix_chars</em>关键字参数到<a class="reference internal" href="#argparse.ArgumentParser" title="argparse.ArgumentParser"><code class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></code></a>构造函数）每行读取一个参数。</span><span class="yiyi-st" id="yiyi-470"><a class="reference internal" href="#argparse.ArgumentParser.convert_arg_line_to_args" title="argparse.ArgumentParser.convert_arg_line_to_args"><code class="xref py py-meth docutils literal"><span class="pre">convert_arg_line_to_args()</span></code></a>可以替代发烧友阅读。</span></p><p><span class="yiyi-st" id="yiyi-471">该方法接受一个参数<em>arg_line</em>，它是从参数文件读取的字符串。</span><span class="yiyi-st" id="yiyi-472">它返回从此字符串解析的参数列表。</span><span class="yiyi-st" id="yiyi-473">按顺序从参数文件中读取每行一次的方法。</span></p><p><span class="yiyi-st" id="yiyi-474">这种方法的有用重写是将每个空格分隔的单词作为参数对待：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">convert_arg_line_to_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_line</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">arg_line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
</code></pre></dd></dl></div><div class="section" id="exiting-methods"><h3><span class="yiyi-st" id="yiyi-475">16.4.5.9. </span><span class="yiyi-st" id="yiyi-476">退出方法</span></h3><dl class="method"><dt id="argparse.ArgumentParser.exit"><span class="yiyi-st" id="yiyi-477"> <code class="descclassname">ArgumentParser.</code><code class="descname">exit</code><span class="sig-paren">(</span><em>status=0</em>, <em>message=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-478">该方法终止程序，以指定的<em>状态</em>退出，并且如果给定，则在此之前打印<em>消息</em>。</span></p></dd></dl><dl class="method"><dt id="argparse.ArgumentParser.error"><span class="yiyi-st" id="yiyi-479"> <code class="descclassname">ArgumentParser.</code><code class="descname">error</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-480">该方法将包含<em>消息</em>的使用消息打印到标准错误，并终止状态代码为2的程序。</span></p></dd></dl></div></div><div class="section" id="upgrading-optparse-code"><h2><span class="yiyi-st" id="yiyi-481">16.4.6. </span><span class="yiyi-st" id="yiyi-482">升级optparse代码</span></h2><p><span class="yiyi-st" id="yiyi-483">最初，<a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a>模块试图保持与<a class="reference internal" href="optparse.html#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code class="xref py py-mod docutils literal"><span class="pre">optparse</span></code></a>的兼容性。</span><span class="yiyi-st" id="yiyi-484">However, <a class="reference internal" href="optparse.html#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code class="xref py py-mod docutils literal"><span class="pre">optparse</span></code></a> was difficult to extend transparently, particularly with the changes required to support the new <code class="docutils literal"><span class="pre">nargs=</span></code> specifiers and better usage messages. </span><span class="yiyi-st" id="yiyi-485">When most everything in <a class="reference internal" href="optparse.html#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code class="xref py py-mod docutils literal"><span class="pre">optparse</span></code></a> had either been copy-pasted over or monkey-patched, it no longer seemed practical to try to maintain the backwards compatibility.</span></p><p><span class="yiyi-st" id="yiyi-486"><a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a>模块通过多种方式改进了标准库<a class="reference internal" href="optparse.html#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code class="xref py py-mod docutils literal"><span class="pre">optparse</span></code></a>模块，其中包括：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-487">处理位置参数。</span></li><li><span class="yiyi-st" id="yiyi-488">支持子命令。</span></li><li><span class="yiyi-st" id="yiyi-489">允许替代选项前缀，如<code class="docutils literal"><span class="pre">+</span></code>和<code class="docutils literal"><span class="pre">/</span></code>。</span></li><li><span class="yiyi-st" id="yiyi-490">处理零个或多个以及一个或多个样式的参数。</span></li><li><span class="yiyi-st" id="yiyi-491">生成更多信息的使用信息。</span></li><li><span class="yiyi-st" id="yiyi-492">为自定义<code class="docutils literal"><span class="pre">type</span></code>和<code class="docutils literal"><span class="pre">action</span></code>提供更简单的界面。</span></li></ul><p><span class="yiyi-st" id="yiyi-493">从<a class="reference internal" href="optparse.html#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code class="xref py py-mod docutils literal"><span class="pre">optparse</span></code></a>到<a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a>的部分升级路径：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-494">用<a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">ArgumentParser.add_argument()</span></code></a>调用替换所有<a class="reference internal" href="optparse.html#optparse.OptionParser.add_option" title="optparse.OptionParser.add_option"><code class="xref py py-meth docutils literal"><span class="pre">optparse.OptionParser.add_option()</span></code></a>调用。</span></li><li><span class="yiyi-st" id="yiyi-495">Replace <code class="docutils literal"><span class="pre">(options,</span> <span class="pre">args)</span> <span class="pre">=</span> <span class="pre">parser.parse_args()</span></code> with <code class="docutils literal"><span class="pre">args</span> <span class="pre">=</span> <span class="pre">parser.parse_args()</span></code> and add additional <a class="reference internal" href="#argparse.ArgumentParser.add_argument" title="argparse.ArgumentParser.add_argument"><code class="xref py py-meth docutils literal"><span class="pre">ArgumentParser.add_argument()</span></code></a> calls for the positional arguments. </span><span class="yiyi-st" id="yiyi-496">请记住，以前称为<code class="docutils literal"><span class="pre">options</span></code>，现在在<a class="reference internal" href="#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal"><span class="pre">argparse</span></code></a>上下文中称为<code class="docutils literal"><span class="pre">args</span></code>。</span></li><li><span class="yiyi-st" id="yiyi-497">用<code class="docutils literal"><span class="pre">type</span></code>或<code class="docutils literal"><span class="pre">action</span></code>参数替换回调操作和<code class="docutils literal"><span class="pre">callback_*</span></code>关键字参数。</span></li><li><span class="yiyi-st" id="yiyi-498">将<code class="docutils literal"><span class="pre">type</span></code>关键字参数的字符串名称替换为相应的类型对​​象（例如，</span><span class="yiyi-st" id="yiyi-499">int，float，complex等）。</span></li><li><span class="yiyi-st" id="yiyi-500">用<a class="reference internal" href="#argparse.Namespace" title="argparse.Namespace"><code class="xref py py-class docutils literal"><span class="pre">Namespace</span></code></a>和<code class="xref py py-exc docutils literal"><span class="pre">optparse.OptionError</span></code>和<code class="xref py py-exc docutils literal"><span class="pre">optparse.OptionValueError</span></code>替换<code class="xref py py-class docutils literal"><span class="pre">optparse.Values</span></code>与<code class="xref py py-exc docutils literal"><span class="pre">ArgumentError</span></code></span></li><li><span class="yiyi-st" id="yiyi-501">Replace strings with implicit arguments such as <code class="docutils literal"><span class="pre">%default</span></code> or <code class="docutils literal"><span class="pre">%prog</span></code> with the standard Python syntax to use dictionaries to format strings, that is, <code class="docutils literal"><span class="pre">%(default)s</span></code> and <code class="docutils literal"><span class="pre">%(prog)s</span></code>.</span></li><li><span class="yiyi-st" id="yiyi-502">用<code class="docutils literal"><span class="pre">调用替换OptionParser构造函数<code class="docutils literal"><span class="pre">version</span></code>参数parser.add_argument（' -  version'，</span> <span class="pre">action ='version'，</span> <span class="pre">version ='＆lt； / t5&gt; <span class="pre">version＆gt；'）</span></span></code>。</span></li></ul></div></div></div>