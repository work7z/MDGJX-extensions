<div class="body" role="main"><div class="section" id="module-wsgiref"><h1><span class="yiyi-st" id="yiyi-10">21.4. <a class="reference internal" href="#module-wsgiref" title="wsgiref: WSGI Utilities and Reference Implementation."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref</span></code></a> — WSGI实用程序和参考实现</span></h1><p><span class="yiyi-st" id="yiyi-11">Web服务器网关接口（WSGI）是Web服务器软件和用Python编写的Web应用程序之间的标准接口。</span><span class="yiyi-st" id="yiyi-12">拥有这样的标准接口是便于应用程序支持有WSGI的大量的不同的web服务器。</span></p><p><span class="yiyi-st" id="yiyi-13">只有Web服务器和编程框架的作者需要知道WSGI设计的每个细节和角落情况。</span><span class="yiyi-st" id="yiyi-14">您不需要了解WSGI的每个细节，只是为了安装WSGI应用程序或使用现有框架编写Web应用程序。</span></p><p><span class="yiyi-st" id="yiyi-15"><a class="reference internal" href="#module-wsgiref" title="wsgiref: WSGI Utilities and Reference Implementation."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref</span></code></a>是WSGI规范的参考实现，可用于向Web服务器或框架添加WSGI支持。</span><span class="yiyi-st" id="yiyi-16">它提供了用于操作WSGI环境变量和响应头的实用程序，用于实现WSGI服务器的基类，用于服务WSGI应用程序的演示HTTP服务器以及用于检查WSGI服务器和应用程序以符合WSGI规范（<span class="target" id="index-0"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>）。</span></p><p><span class="yiyi-st" id="yiyi-17">有关WSGI的更多信息，以及教程和其他资源的链接，请参阅<a class="reference external" href="https://wsgi.readthedocs.org/">https://wsgi.readthedocs.org/</a>。</span></p><div class="section" id="module-wsgiref.util"><h2><span class="yiyi-st" id="yiyi-18">21.4.1。 <a class="reference internal" href="#module-wsgiref.util" title="wsgiref.util: WSGI environment utilities."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.util</span></code></a>  -  WSGI环境实用程序</span></h2><p><span class="yiyi-st" id="yiyi-19">此模块提供了用于使用WSGI环境的各种实用程序功能。</span><span class="yiyi-st" id="yiyi-20">WSGI环境是包含如<span class="target" id="index-1"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>中所述的HTTP请求变量的字典。</span><span class="yiyi-st" id="yiyi-21">所有采用<em>environ</em>参数的函数都需要提供符合WSGI的字典；有关详细规格，请参阅<span class="target" id="index-2"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>。</span></p><dl class="function"><dt id="wsgiref.util.guess_scheme"><span class="yiyi-st" id="yiyi-22"> <code class="descclassname">wsgiref.util.</code><code class="descname">guess_scheme</code><span class="sig-paren">(</span><em>environ</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-23">通过检查<em>environ </em>字典中的<code class="docutils literal"><span class="pre">HTTPS</span></code>环境变量，返回对<code class="docutils literal"><span class="pre">wsgi.url_scheme</span></code>应为“http”还是“https”的猜测。</span><span class="yiyi-st" id="yiyi-24">返回值是一个字符串。</span></p><p><span class="yiyi-st" id="yiyi-25">当创建包含CGI或类似CGI的协议（如FastCGI）的网关时，此功能非常有用。</span><span class="yiyi-st" id="yiyi-26">通常，提供这样的协议的服务器将包括具有值“1”“是”的“<code class="docutils literal"><span class="pre">HTTPS</span></code>变量​​或当经由SSL接收请求时”on“。</span><span class="yiyi-st" id="yiyi-27">因此，如果找到这样的值，此函数返回“https”，否则返回“http”。</span></p></dd></dl><dl class="function"><dt id="wsgiref.util.request_uri"><span class="yiyi-st" id="yiyi-28"> <code class="descclassname">wsgiref.util.</code><code class="descname">request_uri</code><span class="sig-paren">(</span><em>environ</em>, <em>include_query=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-29">使用<span class="target" id="index-3"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>的“URL重建”部分中找到的算法返回完整的请求URI（可选择包括查询字符串）。</span><span class="yiyi-st" id="yiyi-30">如果<em>include_query</em>为false，则查询字符串不包含在生成的URI中。</span></p></dd></dl><dl class="function"><dt id="wsgiref.util.application_uri"><span class="yiyi-st" id="yiyi-31"> <code class="descclassname">wsgiref.util.</code><code class="descname">application_uri</code><span class="sig-paren">(</span><em>environ</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-32">类似于<a class="reference internal" href="#wsgiref.util.request_uri" title="wsgiref.util.request_uri"><code class="xref py py-func docutils literal"><span class="pre">request_uri()</span></code></a>，除了忽略<code class="docutils literal"><span class="pre">PATH_INFO</span></code>和<code class="docutils literal"><span class="pre">QUERY_STRING</span></code>变量。</span><span class="yiyi-st" id="yiyi-33">结果是由请求寻址的应用程序对象的基本URI。</span></p></dd></dl><dl class="function"><dt id="wsgiref.util.shift_path_info"><span class="yiyi-st" id="yiyi-34"> <code class="descclassname">wsgiref.util.</code><code class="descname">shift_path_info</code><span class="sig-paren">(</span><em>environ</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-35">将单个名称从<code class="docutils literal"><span class="pre">PATH_INFO</span></code>切换到<code class="docutils literal"><span class="pre">SCRIPT_NAME</span></code>，并返回名称。</span><span class="yiyi-st" id="yiyi-36"><em>environ</em>字典<em>已修改</em>到位；如果您需要保留原始的<code class="docutils literal"><span class="pre">PATH_INFO</span></code>或<code class="docutils literal"><span class="pre">SCRIPT_NAME</span></code>，请使用副本。</span></p><p><span class="yiyi-st" id="yiyi-37">如果<code class="docutils literal"><span class="pre">PATH_INFO</span></code>中没有剩余路径段，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-38">通常，此例程用于处理请求URI路径的每个部分，例如将路径视为一系列字典键。</span><span class="yiyi-st" id="yiyi-39">此例程修改传入的环境以使其适合于调用位于目标URI的另一WSGI应用程序。</span><span class="yiyi-st" id="yiyi-40">例如，如果在<code class="docutils literal"><span class="pre">/foo</span></code>处有一个WSGI应用程序，并且请求URI路径是<code class="docutils literal"><span class="pre">/foo/bar/baz</span></code>，并且WSGI应用程序位于<code class="docutils literal"><span class="pre">/foo</span></code>调用<a class="reference internal" href="#wsgiref.util.shift_path_info" title="wsgiref.util.shift_path_info"><code class="xref py py-func docutils literal"><span class="pre">shift_path_info()</span></code></a>，它将接收字符串“bar”，并且环境将被更新为适合于在<code class="docutils literal"><span class="pre">/foo/bar</span></code></span><span class="yiyi-st" id="yiyi-41">也就是说，<code class="docutils literal"><span class="pre">SCRIPT_NAME</span></code>将从<code class="docutils literal"><span class="pre">/foo</span></code>更改为<code class="docutils literal"><span class="pre">/foo/bar</span></code>，并且<code class="docutils literal"><span class="pre">PATH_INFO</span></code>将从<code class="docutils literal"><span class="pre">/bar/baz</span></code>到<code class="docutils literal"><span class="pre">/baz</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-42">当<code class="docutils literal"><span class="pre">PATH_INFO</span></code>只是一个“/”时，此例程返回一个空字符串，并将尾部斜线追加到<code class="docutils literal"><span class="pre">SCRIPT_NAME</span></code>，即使空路径段通常被忽略，<code class="docutils literal"><span class="pre">SCRIPT_NAME</span></code>通常不会以斜杠结尾。</span><span class="yiyi-st" id="yiyi-43">这是有意的行为，以确保在使用此例程执行对象遍历时，应用程序可以区分以<code class="docutils literal"><span class="pre">/x</span></code>结尾的URI与以<code class="docutils literal"><span class="pre">/x/</span></code>结尾的URI之间的差异。</span></p></dd></dl><dl class="function"><dt id="wsgiref.util.setup_testing_defaults"><span class="yiyi-st" id="yiyi-44"> <code class="descclassname">wsgiref.util.</code><code class="descname">setup_testing_defaults</code><span class="sig-paren">(</span><em>environ</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-45">使用琐碎的默认值更新<em>environ</em>以进行测试。</span></p><p><span class="yiyi-st" id="yiyi-46">This routine adds various parameters required for WSGI, including <code class="docutils literal"><span class="pre">HTTP_HOST</span></code>, <code class="docutils literal"><span class="pre">SERVER_NAME</span></code>, <code class="docutils literal"><span class="pre">SERVER_PORT</span></code>, <code class="docutils literal"><span class="pre">REQUEST_METHOD</span></code>, <code class="docutils literal"><span class="pre">SCRIPT_NAME</span></code>, <code class="docutils literal"><span class="pre">PATH_INFO</span></code>, and all of the <span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>-defined <code class="docutils literal"><span class="pre">wsgi.*</span></code> variables. </span><span class="yiyi-st" id="yiyi-47">它仅提供默认值，不会替换这些变量的任何现有设置。</span></p><p><span class="yiyi-st" id="yiyi-48">此例程旨在使WSGI服务器和应用程序的单元测试更容易设置虚拟环境。</span><span class="yiyi-st" id="yiyi-49">它不应该被实际的WSGI服务器或应用程序使用，因为数据是假的！</span></p><p><span class="yiyi-st" id="yiyi-50">用法示例：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">wsgiref.util</span> <span class="k">import</span> <span class="n">setup_testing_defaults</span>
<span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="k">import</span> <span class="n">make_server</span>

<span class="c1"># A relatively simple WSGI application. It's going to print out the</span>
<span class="c1"># environment dictionary after being updated by setup_testing_defaults</span>
<span class="k">def</span> <span class="nf">simple_app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">setup_testing_defaults</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>

    <span class="n">status</span> <span class="o">=</span> <span class="s1">'200 OK'</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'Content-type'</span><span class="p">,</span> <span class="s1">'text/plain; charset=utf-8'</span><span class="p">)]</span>

    <span class="n">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"utf-8"</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">environ</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="n">httpd</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">''</span><span class="p">,</span> <span class="mi">8000</span><span class="p">,</span> <span class="n">simple_app</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Serving on port 8000..."</span><span class="p">)</span>
<span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</code></pre></dd></dl><p><span class="yiyi-st" id="yiyi-51">除了上面的环境函数，<a class="reference internal" href="#module-wsgiref.util" title="wsgiref.util: WSGI environment utilities."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.util</span></code></a>模块还提供了这些杂项实用程序：</span></p><dl class="function"><dt id="wsgiref.util.is_hop_by_hop"><span class="yiyi-st" id="yiyi-52"> <code class="descclassname">wsgiref.util.</code><code class="descname">is_hop_by_hop</code><span class="sig-paren">(</span><em>header_name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-53">如果'header_name'是由<span class="target" id="index-5"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a>定义的HTTP / 1.1“Hop-by-Hop”标头，则返回true。</span></p></dd></dl><dl class="class"><dt id="wsgiref.util.FileWrapper"><span class="yiyi-st" id="yiyi-54"> <em class="property">class </em><code class="descclassname">wsgiref.util.</code><code class="descname">FileWrapper</code><span class="sig-paren">(</span><em>filelike</em>, <em>blksize=8192</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-55">用于将类似文件的对象转换为<a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>。</span><span class="yiyi-st" id="yiyi-56">生成的对象支持<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>和<a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a>迭代样式，以与Python 2.1和Jython兼容。</span><span class="yiyi-st" id="yiyi-57">随着对象被迭代，可选的<em>blksize</em>参数将被重复传递给<em>文件样 t&gt;对象的<code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>方法，以获取bytestrings to yield。</em></span><span class="yiyi-st" id="yiyi-58">当<code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>返回一个空的字节时，迭代结束，不能恢复。</span></p><p><span class="yiyi-st" id="yiyi-59">If <em>filelike</em> has a <code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> method, the returned object will also have a <code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> method, and it will invoke the <em>filelike</em> object’s <code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> method when called.</span></p><p><span class="yiyi-st" id="yiyi-60">用法示例：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">wsgiref.util</span> <span class="k">import</span> <span class="n">FileWrapper</span>

<span class="c1"># We're using a StringIO-buffer for as the file-like object</span>
<span class="n">filelike</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s2">"This is an example file-like object"</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
<span class="n">wrapper</span> <span class="o">=</span> <span class="n">FileWrapper</span><span class="p">(</span><span class="n">filelike</span><span class="p">,</span> <span class="n">blksize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">wrapper</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</code></pre></dd></dl></div><div class="section" id="module-wsgiref.headers"><h2><span class="yiyi-st" id="yiyi-61">21.4.2。 <a class="reference internal" href="#module-wsgiref.headers" title="wsgiref.headers: WSGI response header tools."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.headers</span></code></a>  -  WSGI响应头工具</span></h2><p><span class="yiyi-st" id="yiyi-62">此模块提供了一个类，<a class="reference internal" href="#wsgiref.headers.Headers" title="wsgiref.headers.Headers"><code class="xref py py-class docutils literal"><span class="pre">Headers</span></code></a>，以便于使用类似映射的接口处理WSGI响应头。</span></p><dl class="class"><dt id="wsgiref.headers.Headers"><span class="yiyi-st" id="yiyi-63"> <em class="property">class </em><code class="descclassname">wsgiref.headers.</code><code class="descname">Headers</code><span class="sig-paren">(</span><span class="optional">[</span><em>headers</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-64">创建包含<em>headers</em>的映射样对象，它必须是<span class="target" id="index-6"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>中所述的头名称/值元组列表。</span><span class="yiyi-st" id="yiyi-65"><em>headers</em>的默认值是一个空列表。</span></p><p><span class="yiyi-st" id="yiyi-66"><a class="reference internal" href="#wsgiref.headers.Headers" title="wsgiref.headers.Headers"><code class="xref py py-class docutils literal"><span class="pre">Headers</span></code></a> objects support typical mapping operations including <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">get()</span></code>, <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">setdefault()</span></code>, <a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal"><span class="pre">__delitem__()</span></code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a>. </span><span class="yiyi-st" id="yiyi-67">对于这些方法中的每一个，键是头名称（不区分大小写），值是与该头名称相关联的第一个值。</span><span class="yiyi-st" id="yiyi-68">设置标头会删除该标头的任何现有值，然后在包装标头列表的末尾添加一个新值。</span><span class="yiyi-st" id="yiyi-69">通常保持标题的现有顺序，将新标题添加到包装列表的末尾。</span></p><p><span class="yiyi-st" id="yiyi-70">与字典不同，当尝试获取或删除不在包装标题列表中的键时，<a class="reference internal" href="#wsgiref.headers.Headers" title="wsgiref.headers.Headers"><code class="xref py py-class docutils literal"><span class="pre">Headers</span></code></a>对象不会引发错误。</span><span class="yiyi-st" id="yiyi-71">获取一个不存在的头只返回<code class="docutils literal"><span class="pre">None</span></code>，删除一个不存在的头什么也不做。</span></p><p><span class="yiyi-st" id="yiyi-72"><a class="reference internal" href="#wsgiref.headers.Headers" title="wsgiref.headers.Headers"><code class="xref py py-class docutils literal"><span class="pre">Headers</span></code></a>物件也支援<code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code>，<code class="xref py py-meth docutils literal"><span class="pre">values()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">items()</span></code></span><span class="yiyi-st" id="yiyi-73">如果存在多值标头，则<code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">items()</span></code>返回的列表可以多次包含相同的键。</span><span class="yiyi-st" id="yiyi-74"><a class="reference internal" href="#wsgiref.headers.Headers" title="wsgiref.headers.Headers"><code class="xref py py-class docutils literal"><span class="pre">Headers</span></code></a>对象的<code class="docutils literal"><span class="pre">len()</span></code>与其<code class="xref py py-meth docutils literal"><span class="pre">items()</span></code>的长度相同，包装头列表。</span><span class="yiyi-st" id="yiyi-75">实际上，<code class="xref py py-meth docutils literal"><span class="pre">items()</span></code>方法只返回包装的标题列表的副本。</span></p><p><span class="yiyi-st" id="yiyi-76">在<a class="reference internal" href="#wsgiref.headers.Headers" title="wsgiref.headers.Headers"><code class="xref py py-class docutils literal"><span class="pre">Headers</span></code></a>对象上调用<code class="docutils literal"><span class="pre">bytes()</span></code>返回适合于作为HTTP响应头传输的格式化的测试。</span><span class="yiyi-st" id="yiyi-77">每个标题放置在一个具有其值的行上，用冒号和空格分隔。</span><span class="yiyi-st" id="yiyi-78">每行由回车和换行符终止，并且字节以空行终止。</span></p><p><span class="yiyi-st" id="yiyi-79">除了映射接口和格式化功能之外，<a class="reference internal" href="#wsgiref.headers.Headers" title="wsgiref.headers.Headers"><code class="xref py py-class docutils literal"><span class="pre">Headers</span></code></a>对象还有以下方法用于查询和添加多值标头，以及用于添加带有MIME参数的标头：</span></p><dl class="method"><dt id="wsgiref.headers.Headers.get_all"><span class="yiyi-st" id="yiyi-80"> <code class="descname">get_all</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">返回命名标头的所有值的列表。</span></p><p><span class="yiyi-st" id="yiyi-82">返回的列表将按照它们在原始标题列表中出现或添加到此实例的顺序排序，并且可能包含重复项。</span><span class="yiyi-st" id="yiyi-83">删除和重新插入的任何字段始终附加到标题列表。</span><span class="yiyi-st" id="yiyi-84">如果没有具有给定名称的字段，则返回空列表。</span></p></dd></dl><dl class="method"><dt id="wsgiref.headers.Headers.add_header"><span class="yiyi-st" id="yiyi-85"> <code class="descname">add_header</code><span class="sig-paren">(</span><em>name</em>, <em>value</em>, <em>**_params</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-86">添加（可能是多值）标头，通过关键字参数指定可选的MIME参数。</span></p><p><span class="yiyi-st" id="yiyi-87"><em>name</em>是要添加的标头字段。</span><span class="yiyi-st" id="yiyi-88">关键字参数可用于设置标题字段的MIME参数。</span><span class="yiyi-st" id="yiyi-89">每个参数必须是字符串或<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-90">参数名称中的下划线转换为破折号，因为破折号在Python标识符中是非法的，但许多MIME参数名称包括破折号。</span><span class="yiyi-st" id="yiyi-91">如果参数值是字符串，则以<code class="docutils literal"><span class="pre">name="value"</span></code>的形式将其添加到标头值参数。</span><span class="yiyi-st" id="yiyi-92">如果<code class="docutils literal"><span class="pre">None</span></code>，则只添加参数名称。</span><span class="yiyi-st" id="yiyi-93">（这用于没有值的MIME参数。）</span><span class="yiyi-st" id="yiyi-94">用法示例：</span></p><pre><code class="language-python"><span></span><span class="n">h</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">'content-disposition'</span><span class="p">,</span> <span class="s1">'attachment'</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">'bud.gif'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-95">上面将添加一个标题，看起来像这样：</span></p><pre><code class="language-python"><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Disposition</span><span class="p">:</span> <span class="n">attachment</span><span class="p">;</span> <span class="n">filename</span><span class="o">=</span><span class="s2">"bud.gif"</span>
</code></pre></dd></dl><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-96"><span class="versionmodified">在3.5版本中更改：</span> <em>headers</em>参数是可选的。</span></p></div></dd></dl></div><div class="section" id="module-wsgiref.simple_server"><h2><span class="yiyi-st" id="yiyi-97">21.4.3。 <a class="reference internal" href="#module-wsgiref.simple_server" title="wsgiref.simple_server: A simple WSGI HTTP server."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.simple_server</span></code></a>  - 一个简单的WSGI HTTP服务器</span></h2><p><span class="yiyi-st" id="yiyi-98">此模块实现为WSGI应用程序提供服务的简单HTTP服务器（基于<a class="reference internal" href="http.server.html#module-http.server" title="http.server: HTTP server and request handlers."><code class="xref py py-mod docutils literal"><span class="pre">http.server</span></code></a>）。</span><span class="yiyi-st" id="yiyi-99">每个服务器实例在给定主机和端口上服务单个WSGI应用程序。</span><span class="yiyi-st" id="yiyi-100">如果要在单个主机和端口上提供多个应用程序，则应创建一个WSGI应用程序，该应用程序解析<code class="docutils literal"><span class="pre">PATH_INFO</span></code>以选择要为每个请求调用的应用程序。</span><span class="yiyi-st" id="yiyi-101">（例如，使用<a class="reference internal" href="#module-wsgiref.util" title="wsgiref.util: WSGI environment utilities."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.util</span></code></a>的<code class="xref py py-func docutils literal"><span class="pre">shift_path_info()</span></code>函数。）</span></p><dl class="function"><dt id="wsgiref.simple_server.make_server"><span class="yiyi-st" id="yiyi-102"> <code class="descclassname">wsgiref.simple_server.</code><code class="descname">make_server</code><span class="sig-paren">(</span><em>host</em>, <em>port</em>, <em>app</em>, <em>server_class=WSGIServer</em>, <em>handler_class=WSGIRequestHandler</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-103">创建在<em>host</em>和<em>port</em>上侦听的新WSGI服务器，接受<em>app</em>的连接。</span><span class="yiyi-st" id="yiyi-104">返回值是提供的<em>server_class</em>的实例，将使用指定的<em>handler_class</em>处理请求。</span><span class="yiyi-st" id="yiyi-105"><em>app</em>必须是由<span class="target" id="index-7"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>定义的WSGI应用程序对象。</span></p><p><span class="yiyi-st" id="yiyi-106">用法示例：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="k">import</span> <span class="n">make_server</span><span class="p">,</span> <span class="n">demo_app</span>

<span class="n">httpd</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">''</span><span class="p">,</span> <span class="mi">8000</span><span class="p">,</span> <span class="n">demo_app</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Serving HTTP on port 8000..."</span><span class="p">)</span>

<span class="c1"># Respond to requests until process is killed</span>
<span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="c1"># Alternative: serve one request, then exit</span>
<span class="n">httpd</span><span class="o">.</span><span class="n">handle_request</span><span class="p">()</span>
</code></pre></dd></dl><dl class="function"><dt id="wsgiref.simple_server.demo_app"><span class="yiyi-st" id="yiyi-107"> <code class="descclassname">wsgiref.simple_server.</code><code class="descname">demo_app</code><span class="sig-paren">(</span><em>environ</em>, <em>start_response</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-108">此函数是一个小但完整的WSGI应用程序，它返回一个包含消息“Hello world！”的文本页面以及<em>environ</em>参数中提供的键/值对列表。</span><span class="yiyi-st" id="yiyi-109">它有助于验证WSGI服务器（例如<a class="reference internal" href="#module-wsgiref.simple_server" title="wsgiref.simple_server: A simple WSGI HTTP server."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.simple_server</span></code></a>）能够正确运行简单的WSGI应用程序。</span></p></dd></dl><dl class="class"><dt id="wsgiref.simple_server.WSGIServer"><span class="yiyi-st" id="yiyi-110"> <em class="property">class </em><code class="descclassname">wsgiref.simple_server.</code><code class="descname">WSGIServer</code><span class="sig-paren">(</span><em>server_address</em>, <em>RequestHandlerClass</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">创建<a class="reference internal" href="#wsgiref.simple_server.WSGIServer" title="wsgiref.simple_server.WSGIServer"><code class="xref py py-class docutils literal"><span class="pre">WSGIServer</span></code></a>实例。</span><span class="yiyi-st" id="yiyi-112"><em>server_address</em>应为<code class="docutils literal"><span class="pre">（host，port）</span></code>元组，<em>RequestHandlerClass</em>应为<a class="reference internal" href="http.server.html#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code class="xref py py-class docutils literal"><span class="pre">http.server.BaseHTTPRequestHandler </span></code></a>将用于处理请求。</span></p><p><span class="yiyi-st" id="yiyi-113">通常不需要调用此构造函数，因为<a class="reference internal" href="#wsgiref.simple_server.make_server" title="wsgiref.simple_server.make_server"><code class="xref py py-func docutils literal"><span class="pre">make_server()</span></code></a>函数可以处理所有详细信息。</span></p><p><span class="yiyi-st" id="yiyi-114"><a class="reference internal" href="#wsgiref.simple_server.WSGIServer" title="wsgiref.simple_server.WSGIServer"><code class="xref py py-class docutils literal"><span class="pre">WSGIServer</span></code></a>是<a class="reference internal" href="http.server.html#http.server.HTTPServer" title="http.server.HTTPServer"><code class="xref py py-class docutils literal"><span class="pre">http.server.HTTPServer</span></code></a>的子类，因此其所有方法（如<code class="xref py py-meth docutils literal"><span class="pre">serve_forever()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">handle_request </span></code>）。</span><span class="yiyi-st" id="yiyi-115"><a class="reference internal" href="#wsgiref.simple_server.WSGIServer" title="wsgiref.simple_server.WSGIServer"><code class="xref py py-class docutils literal"><span class="pre">WSGIServer</span></code></a>还提供了这些WSGI特定的方法：</span></p><dl class="method"><dt id="wsgiref.simple_server.WSGIServer.set_app"><span class="yiyi-st" id="yiyi-116"> <code class="descname">set_app</code><span class="sig-paren">(</span><em>application</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-117">将可调用的<em>应用程序</em>设置为将接收请求的WSGI应用程序。</span></p></dd></dl><dl class="method"><dt id="wsgiref.simple_server.WSGIServer.get_app"><span class="yiyi-st" id="yiyi-118"> <code class="descname">get_app</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-119">返回当前设置的应用程序可调用项。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-120">但通常情况下，不需要使用这些附加方法，因为<a class="reference internal" href="#wsgiref.simple_server.WSGIServer.set_app" title="wsgiref.simple_server.WSGIServer.set_app"><code class="xref py py-meth docutils literal"><span class="pre">set_app()</span></code></a>通常由<a class="reference internal" href="#wsgiref.simple_server.make_server" title="wsgiref.simple_server.make_server"><code class="xref py py-func docutils literal"><span class="pre">make_server()</span></code></a>和<a class="reference internal" href="#wsgiref.simple_server.WSGIServer.get_app" title="wsgiref.simple_server.WSGIServer.get_app"><code class="xref py py-meth docutils literal"><span class="pre">get_app()</span></code></a></span></p></dd></dl><dl class="class"><dt id="wsgiref.simple_server.WSGIRequestHandler"><span class="yiyi-st" id="yiyi-121"> <em class="property">class </em><code class="descclassname">wsgiref.simple_server.</code><code class="descname">WSGIRequestHandler</code><span class="sig-paren">(</span><em>request</em>, <em>client_address</em>, <em>server</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-122">为给定的<em>请求</em>创建HTTP处理程序。</span><span class="yiyi-st" id="yiyi-123">套接字），<em>client_address</em>（<code class="docutils literal"><span class="pre">(host,port)</span></code>元组）和<em>服务器</em>（<a class="reference internal" href="#wsgiref.simple_server.WSGIServer" title="wsgiref.simple_server.WSGIServer"><code class="xref py py-class docutils literal"><span class="pre">WSGIServer</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-124">您不需要直接创建此类的实例；它们会根据<a class="reference internal" href="#wsgiref.simple_server.WSGIServer" title="wsgiref.simple_server.WSGIServer"><code class="xref py py-class docutils literal"><span class="pre">WSGIServer</span></code></a>对象的需要自动创建。</span><span class="yiyi-st" id="yiyi-125">但是，您可以将此类作为子类，并将其作为<em>handler_class</em>提供给<a class="reference internal" href="#wsgiref.simple_server.make_server" title="wsgiref.simple_server.make_server"><code class="xref py py-func docutils literal"><span class="pre">make_server()</span></code></a>函数。</span><span class="yiyi-st" id="yiyi-126">一些可能相关的重写子类中的方法：</span></p><dl class="method"><dt id="wsgiref.simple_server.WSGIRequestHandler.get_environ"><span class="yiyi-st" id="yiyi-127"> <code class="descname">get_environ</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-128">返回包含请求的WSGI环境的字典。</span><span class="yiyi-st" id="yiyi-129">默认实现复制<a class="reference internal" href="#wsgiref.simple_server.WSGIServer" title="wsgiref.simple_server.WSGIServer"><code class="xref py py-class docutils literal"><span class="pre">WSGIServer</span></code></a>对象的<code class="xref py py-attr docutils literal"><span class="pre">base_environ</span></code>字典属性的内容，然后添加从HTTP请求中派生的各种标头。</span><span class="yiyi-st" id="yiyi-130">对此方法的每次调用都应返回包含<span class="target" id="index-8"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>中指定的所有相关CGI环境变量的新字典。</span></p></dd></dl><dl class="method"><dt id="wsgiref.simple_server.WSGIRequestHandler.get_stderr"><span class="yiyi-st" id="yiyi-131"> <code class="descname">get_stderr</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-132">返回应用作<code class="docutils literal"><span class="pre">wsgi.errors</span></code>流的对象。</span><span class="yiyi-st" id="yiyi-133">默认实现只返回<code class="docutils literal"><span class="pre">sys.stderr</span></code>。</span></p></dd></dl><dl class="method"><dt id="wsgiref.simple_server.WSGIRequestHandler.handle"><span class="yiyi-st" id="yiyi-134"> <code class="descname">handle</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-135">处理HTTP请求。</span><span class="yiyi-st" id="yiyi-136">默认实现使用<a class="reference internal" href="#module-wsgiref.handlers" title="wsgiref.handlers: WSGI server/gateway base classes."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.handlers</span></code></a>类创建一个处理程序实例，以实现实际的WSGI应用程序接口。</span></p></dd></dl></dd></dl></div><div class="section" id="module-wsgiref.validate"><h2><span class="yiyi-st" id="yiyi-137">21.4.4。 <a class="reference internal" href="#module-wsgiref.validate" title="wsgiref.validate: WSGI conformance checker."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.validate</span></code></a>  -  WSGI一致性检查器</span></h2><p><span class="yiyi-st" id="yiyi-138">当创建新的WSGI应用程序对象，框架，服务器或中间件时，使用<a class="reference internal" href="#module-wsgiref.validate" title="wsgiref.validate: WSGI conformance checker."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.validate</span></code></a>验证新代码的一致性可能很有用。</span><span class="yiyi-st" id="yiyi-139">此模块提供了一个函数，用于创建验证WSGI服务器或网关与WSGI应用程序对象之间的通信的WSGI应用程序对象，以检查协议一致性的双方。</span></p><p><span class="yiyi-st" id="yiyi-140">请注意，此实用程序不能保证完整的<span class="target" id="index-9"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>合规性；该模块没有错误并不一定意味着错误不存在。</span><span class="yiyi-st" id="yiyi-141">但是，如果此模块确实产生错误，则几乎肯定服务器或应用程序不是100％兼容。</span></p><p><span class="yiyi-st" id="yiyi-142">该模块基于Ian Bicking的“Python Paste”库中的<code class="xref py py-mod docutils literal"><span class="pre">paste.lint</span></code>模块。</span></p><dl class="function"><dt id="wsgiref.validate.validator"><span class="yiyi-st" id="yiyi-143"> <code class="descclassname">wsgiref.validate.</code><code class="descname">validator</code><span class="sig-paren">(</span><em>application</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-144">换行<em>应用程序</em>并返回一个新的WSGI应用程序对象。</span><span class="yiyi-st" id="yiyi-145">返回的应用程序将所有请求转发到原始<em>应用程序</em>，并且将检查<em>应用程序</em>和调用它的服务器是否符合WSGI规范和RFC 2616。</span></p><p><span class="yiyi-st" id="yiyi-146">任何检测到的不符会导致<a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code></a>出现；请注意，这些错误的处理方式取决于服务器。</span><span class="yiyi-st" id="yiyi-147">例如，<a class="reference internal" href="#module-wsgiref.simple_server" title="wsgiref.simple_server: A simple WSGI HTTP server."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.simple_server</span></code></a>和其他基于<a class="reference internal" href="#module-wsgiref.handlers" title="wsgiref.handlers: WSGI server/gateway base classes."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.handlers</span></code></a>的服务器（不覆盖错误处理方法来执行其他操作）只会输出一条消息，错误，并将跟踪转储到<code class="docutils literal"><span class="pre">sys.stderr</span></code>或某个其他错误流。</span></p><p><span class="yiyi-st" id="yiyi-148">此封装程序还可以使用<a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a>模块生成输出，以指示有问题但可能未被<span class="target" id="index-10"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>禁止的行为。</span><span class="yiyi-st" id="yiyi-149">除非使用Python命令行选项或<a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a> API抑制它们，否则任何此类警告都将写入<code class="docutils literal"><span class="pre">sys.stderr</span></code>（<em>而不是</em> <code class="docutils literal"><span class="pre">wsgi.errors</span></code>，除非它们恰好是同一个对象）。</span></p><p><span class="yiyi-st" id="yiyi-150">用法示例：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">wsgiref.validate</span> <span class="k">import</span> <span class="n">validator</span>
<span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="k">import</span> <span class="n">make_server</span>

<span class="c1"># Our callable object which is intentionally not compliant to the</span>
<span class="c1"># standard, so the validator is going to break</span>
<span class="k">def</span> <span class="nf">simple_app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s1">'200 OK'</span>  <span class="c1"># HTTP Status</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'Content-type'</span><span class="p">,</span> <span class="s1">'text/plain'</span><span class="p">)]</span>  <span class="c1"># HTTP Headers</span>
    <span class="n">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>

    <span class="c1"># This is going to break because we need to return a list, and</span>
    <span class="c1"># the validator is going to inform us</span>
    <span class="k">return</span> <span class="n">b</span><span class="s2">"Hello World"</span>

<span class="c1"># This is the application wrapped in a validator</span>
<span class="n">validator_app</span> <span class="o">=</span> <span class="n">validator</span><span class="p">(</span><span class="n">simple_app</span><span class="p">)</span>

<span class="n">httpd</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">''</span><span class="p">,</span> <span class="mi">8000</span><span class="p">,</span> <span class="n">validator_app</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Listening on port 8000...."</span><span class="p">)</span>
<span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</code></pre></dd></dl></div><div class="section" id="module-wsgiref.handlers"><h2><span class="yiyi-st" id="yiyi-151">21.4.5. <a class="reference internal" href="#module-wsgiref.handlers" title="wsgiref.handlers: WSGI server/gateway base classes."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.handlers</span></code></a>  - 服务器/网关基类</span></h2><p><span class="yiyi-st" id="yiyi-152">此模块提供用于实现WSGI服务器和网关的基本处理程序类。</span><span class="yiyi-st" id="yiyi-153">这些基类处理与WSGI应用程序通信的大部分工作，只要它们给出类似CGI的环境以及输入，输出和错误流。</span></p><dl class="class"><dt id="wsgiref.handlers.CGIHandler"><span class="yiyi-st" id="yiyi-154"> <em class="property">class </em><code class="descclassname">wsgiref.handlers.</code><code class="descname">CGIHandler</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-155">基于CGI的调用通过<code class="docutils literal"><span class="pre">sys.stdin</span></code>，<code class="docutils literal"><span class="pre">sys.stdout</span></code>，<code class="docutils literal"><span class="pre">sys.stderr</span></code>和<code class="docutils literal"><span class="pre">os.environ</span></code></span><span class="yiyi-st" id="yiyi-156">当您有一个WSGI应用程序并想要将其作为CGI脚本运行时，这是有用的。</span><span class="yiyi-st" id="yiyi-157">只需调用<code class="docutils literal"><span class="pre">CGIHandler().run(app)</span></code>，其中<code class="docutils literal"><span class="pre">app</span></code>是您要调用的WSGI应用程序对象。</span></p><p><span class="yiyi-st" id="yiyi-158">This class is a subclass of <a class="reference internal" href="#wsgiref.handlers.BaseCGIHandler" title="wsgiref.handlers.BaseCGIHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseCGIHandler</span></code></a> that sets <code class="docutils literal"><span class="pre">wsgi.run_once</span></code> to true, <code class="docutils literal"><span class="pre">wsgi.multithread</span></code> to false, and <code class="docutils literal"><span class="pre">wsgi.multiprocess</span></code> to true, and always uses <a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a> and <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> to obtain the necessary CGI streams and environment.</span></p></dd></dl><dl class="class"><dt id="wsgiref.handlers.IISCGIHandler"><span class="yiyi-st" id="yiyi-159"> <em class="property">class </em><code class="descclassname">wsgiref.handlers.</code><code class="descname">IISCGIHandler</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-160"><a class="reference internal" href="#wsgiref.handlers.CGIHandler" title="wsgiref.handlers.CGIHandler"><code class="xref py py-class docutils literal"><span class="pre">CGIHandler</span></code></a>的特殊替代，用于在Microsoft的IIS Web服务器上部署时，无需设置config allowPathInfo选项（IIS&gt; = 7）或metabase allowPathInfoForScriptMappings（IIS</span></p><p><span class="yiyi-st" id="yiyi-161">默认情况下，IIS给出一个<code class="docutils literal"><span class="pre">PATH_INFO</span></code>，它与前面的<code class="docutils literal"><span class="pre">SCRIPT_NAME</span></code>重复，从而导致希望实现路由的WSGI应用程序出现问题。</span><span class="yiyi-st" id="yiyi-162">此处理程序将删除任何此类重复的路径。</span></p><p><span class="yiyi-st" id="yiyi-163">IIS可以配置为传递正确的<code class="docutils literal"><span class="pre">PATH_INFO</span></code>，但这会导致<code class="docutils literal"><span class="pre">PATH_TRANSLATED</span></code>错误的另一个错误。</span><span class="yiyi-st" id="yiyi-164">幸运的是，这个变量很少使用，不能由WSGI保证。</span><span class="yiyi-st" id="yiyi-165">On IIS&lt;7, though, the setting can only be made on a vhost level, affecting all other script mappings, many of which break when exposed to the <code class="docutils literal"><span class="pre">PATH_TRANSLATED</span></code> bug. </span><span class="yiyi-st" id="yiyi-166">出于这个原因IIS</span><span class="yiyi-st" id="yiyi-167">（即使IIS7很少使用它，因为它仍然没有UI。）</span></p><p><span class="yiyi-st" id="yiyi-168">CGI代码无法告诉是否设置了该选项，因此提供了一个单独的处理程序类。</span><span class="yiyi-st" id="yiyi-169">它以与<a class="reference internal" href="#wsgiref.handlers.CGIHandler" title="wsgiref.handlers.CGIHandler"><code class="xref py py-class docutils literal"><span class="pre">CGIHandler</span></code></a>相同的方式使用，即通过调用<code class="docutils literal"><span class="pre">IISCGIHandler().run(app)</span></code>，其中<code class="docutils literal"><span class="pre">app</span></code>是WSGI应用程序对象。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-170"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="class"><dt id="wsgiref.handlers.BaseCGIHandler"><span class="yiyi-st" id="yiyi-171"> <em class="property">class </em><code class="descclassname">wsgiref.handlers.</code><code class="descname">BaseCGIHandler</code><span class="sig-paren">(</span><em>stdin</em>, <em>stdout</em>, <em>stderr</em>, <em>environ</em>, <em>multithread=True</em>, <em>multiprocess=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-172">与<a class="reference internal" href="#wsgiref.handlers.CGIHandler" title="wsgiref.handlers.CGIHandler"><code class="xref py py-class docutils literal"><span class="pre">CGIHandler</span></code></a>类似，但是不是使用<a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a>和<a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a>模块，而是明确指定CGI环境和I / O流。</span><span class="yiyi-st" id="yiyi-173"><em>多线程</em>和<em>多进程</em>值用于为任何应用程序运行设置<code class="docutils literal"><span class="pre">wsgi.multithread</span></code>和<code class="docutils literal"><span class="pre">wsgi.multiprocess</span></code>标志由处理程序实例。</span></p><p><span class="yiyi-st" id="yiyi-174">此类是<a class="reference internal" href="#wsgiref.handlers.SimpleHandler" title="wsgiref.handlers.SimpleHandler"><code class="xref py py-class docutils literal"><span class="pre">SimpleHandler</span></code></a>的子类，旨在与HTTP“源服务器”以外的软件一起使用。</span><span class="yiyi-st" id="yiyi-175">如果您正在编写网关协议实现（如CGI，FastCGI，SCGI等）</span><span class="yiyi-st" id="yiyi-176">使用<code class="docutils literal"><span class="pre">Status:</span></code>标头发送HTTP状态，您可能希望将其子类化，而不是<a class="reference internal" href="#wsgiref.handlers.SimpleHandler" title="wsgiref.handlers.SimpleHandler"><code class="xref py py-class docutils literal"><span class="pre">SimpleHandler</span></code></a>。</span></p></dd></dl><dl class="class"><dt id="wsgiref.handlers.SimpleHandler"><span class="yiyi-st" id="yiyi-177"> <em class="property">class </em><code class="descclassname">wsgiref.handlers.</code><code class="descname">SimpleHandler</code><span class="sig-paren">(</span><em>stdin</em>, <em>stdout</em>, <em>stderr</em>, <em>environ</em>, <em>multithread=True</em>, <em>multiprocess=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-178">类似于<a class="reference internal" href="#wsgiref.handlers.BaseCGIHandler" title="wsgiref.handlers.BaseCGIHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseCGIHandler</span></code></a>，但设计为与HTTP源服务器一起使用。</span><span class="yiyi-st" id="yiyi-179">如果您正在编写HTTP服务器实现，您可能希望将其子类化，而不是<a class="reference internal" href="#wsgiref.handlers.BaseCGIHandler" title="wsgiref.handlers.BaseCGIHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseCGIHandler</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-180">此类是<a class="reference internal" href="#wsgiref.handlers.BaseHandler" title="wsgiref.handlers.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a>的子类。</span><span class="yiyi-st" id="yiyi-181">It overrides the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">get_stdin()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">get_stderr()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">add_cgi_vars()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">_write()</span></code>, and <code class="xref py py-meth docutils literal"><span class="pre">_flush()</span></code> methods to support explicitly setting the environment and streams via the constructor. </span><span class="yiyi-st" id="yiyi-182">提供的环境和流存储在<code class="xref py py-attr docutils literal"><span class="pre">stdin</span></code>，<code class="xref py py-attr docutils literal"><span class="pre">stdout</span></code>，<code class="xref py py-attr docutils literal"><span class="pre">stderr</span></code>和<code class="xref py py-attr docutils literal"><span class="pre">environ</span></code>属性中。</span></p><p><span class="yiyi-st" id="yiyi-183"><em>stdout</em>的<a class="reference internal" href="io.html#io.BufferedIOBase.write" title="io.BufferedIOBase.write"><code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></a>方法应该完全写入每个块，如<a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.BufferedIOBase</span></code></a>。</span></p></dd></dl><dl class="class"><dt id="wsgiref.handlers.BaseHandler"><span class="yiyi-st" id="yiyi-184"> <em class="property">class </em><code class="descclassname">wsgiref.handlers.</code><code class="descname">BaseHandler</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-185">这是运行WSGI应用程序的抽象基类。</span><span class="yiyi-st" id="yiyi-186">每个实例将处理单个HTTP请求，虽然原则上您可以创建一个可重用于多个请求的子类。</span></p><p><span class="yiyi-st" id="yiyi-187"><a class="reference internal" href="#wsgiref.handlers.BaseHandler" title="wsgiref.handlers.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a>实例只有一种方法供外部使用：</span></p><dl class="method"><dt id="wsgiref.handlers.BaseHandler.run"><span class="yiyi-st" id="yiyi-188"> <code class="descname">run</code><span class="sig-paren">(</span><em>app</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-189">运行指定的WSGI应用程序<em>app</em>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-190">所有其他<a class="reference internal" href="#wsgiref.handlers.BaseHandler" title="wsgiref.handlers.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a>方法在运行应用程序的过程中由此方法调用，因此主要存在以允许自定义过程。</span></p><p><span class="yiyi-st" id="yiyi-191">以下方法必须在子类中重写：</span></p><dl class="method"><dt id="wsgiref.handlers.BaseHandler._write"><span class="yiyi-st" id="yiyi-192"> <code class="descname">_write</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-193">缓冲字节<em>data</em>以传输到客户端。</span><span class="yiyi-st" id="yiyi-194">没关系，如果这个方法实际上传输数据； <a class="reference internal" href="#wsgiref.handlers.BaseHandler" title="wsgiref.handlers.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a>只是分离写入和刷新操作，以便在底层系统实际上有这样的区别时提高效率。</span></p></dd></dl><dl class="method"><dt id="wsgiref.handlers.BaseHandler._flush"><span class="yiyi-st" id="yiyi-195"> <code class="descname">_flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-196">强制缓冲数据传输到客户端。</span><span class="yiyi-st" id="yiyi-197">没关系，如果这个方法是一个无操作（即，如果<a class="reference internal" href="#wsgiref.handlers.BaseHandler._write" title="wsgiref.handlers.BaseHandler._write"><code class="xref py py-meth docutils literal"><span class="pre">_write()</span></code></a>实际发送数据）。</span></p></dd></dl><dl class="method"><dt id="wsgiref.handlers.BaseHandler.get_stdin"><span class="yiyi-st" id="yiyi-198"> <code class="descname">get_stdin</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-199">返回适合用作当前正在处理的请求的<code class="docutils literal"><span class="pre">wsgi.input</span></code>的输入流对象。</span></p></dd></dl><dl class="method"><dt id="wsgiref.handlers.BaseHandler.get_stderr"><span class="yiyi-st" id="yiyi-200"> <code class="descname">get_stderr</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-201">返回适合用作当前正在处理的请求的<code class="docutils literal"><span class="pre">wsgi.errors</span></code>的输出流对象。</span></p></dd></dl><dl class="method"><dt id="wsgiref.handlers.BaseHandler.add_cgi_vars"><span class="yiyi-st" id="yiyi-202"> <code class="descname">add_cgi_vars</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-203">将当前请求的CGI变量插入到<code class="xref py py-attr docutils literal"><span class="pre">environ</span></code>属性中。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-204">这里有一些其他方法和属性，你可能希望覆盖。</span><span class="yiyi-st" id="yiyi-205">此列表仅为摘要，但不包括可以覆盖的每个方法。</span><span class="yiyi-st" id="yiyi-206">在尝试创建自定义的<a class="reference internal" href="#wsgiref.handlers.BaseHandler" title="wsgiref.handlers.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a>子类之前，请查阅docstrings和源代码以获取其他信息。</span></p><p><span class="yiyi-st" id="yiyi-207">自定义WSGI环境的属性和方法：</span></p><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.wsgi_multithread"><span class="yiyi-st" id="yiyi-208"> <code class="descname">wsgi_multithread</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-209">用于<code class="docutils literal"><span class="pre">wsgi.multithread</span></code>环境变量的值。</span><span class="yiyi-st" id="yiyi-210">它在<a class="reference internal" href="#wsgiref.handlers.BaseHandler" title="wsgiref.handlers.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a>中默认为true，但在其他子类中可能有不同的默认值（或由构造函数设置）。</span></p></dd></dl><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.wsgi_multiprocess"><span class="yiyi-st" id="yiyi-211"> <code class="descname">wsgi_multiprocess</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-212">用于<code class="docutils literal"><span class="pre">wsgi.multiprocess</span></code>环境变量的值。</span><span class="yiyi-st" id="yiyi-213">它在<a class="reference internal" href="#wsgiref.handlers.BaseHandler" title="wsgiref.handlers.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a>中默认为true，但在其他子类中可能有不同的默认值（或由构造函数设置）。</span></p></dd></dl><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.wsgi_run_once"><span class="yiyi-st" id="yiyi-214"> <code class="descname">wsgi_run_once</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-215">用于<code class="docutils literal"><span class="pre">wsgi.run_once</span></code>环境变量的值。</span><span class="yiyi-st" id="yiyi-216">它在<a class="reference internal" href="#wsgiref.handlers.BaseHandler" title="wsgiref.handlers.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a>中默认为false，但是<a class="reference internal" href="#wsgiref.handlers.CGIHandler" title="wsgiref.handlers.CGIHandler"><code class="xref py py-class docutils literal"><span class="pre">CGIHandler</span></code></a>默认设置为true。</span></p></dd></dl><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.os_environ"><span class="yiyi-st" id="yiyi-217"> <code class="descname">os_environ</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-218">要包含在每个请求的WSGI环境中的默认环境变量。</span><span class="yiyi-st" id="yiyi-219">默认情况下，这是导入<a class="reference internal" href="#module-wsgiref.handlers" title="wsgiref.handlers: WSGI server/gateway base classes."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.handlers</span></code></a>时<code class="docutils literal"><span class="pre">os.environ</span></code>的副本，但子类可以在类或实例级别创建自己的副本。</span><span class="yiyi-st" id="yiyi-220">请注意，字典应该被视为只读，因为默认值在多个类和实例之间共享。</span></p></dd></dl><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.server_software"><span class="yiyi-st" id="yiyi-221"> <code class="descname">server_software</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-222">如果设置了<a class="reference internal" href="#wsgiref.handlers.BaseHandler.origin_server" title="wsgiref.handlers.BaseHandler.origin_server"><code class="xref py py-attr docutils literal"><span class="pre">origin_server</span></code></a>属性，则此属性的值用于设置默认的<code class="docutils literal"><span class="pre">SERVER_SOFTWARE</span></code> WSGI环境变量，并设置默认的<code class="docutils literal"><span class="pre">Server:</span></code> HTTP响应中的标头。</span><span class="yiyi-st" id="yiyi-223">对于不是HTTP源服务器的处理程序（例如<a class="reference internal" href="#wsgiref.handlers.BaseCGIHandler" title="wsgiref.handlers.BaseCGIHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseCGIHandler</span></code></a>和<a class="reference internal" href="#wsgiref.handlers.CGIHandler" title="wsgiref.handlers.CGIHandler"><code class="xref py py-class docutils literal"><span class="pre">CGIHandler</span></code></a>）将被忽略。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-224"><span class="versionmodified">在版本3.3中更改：</span>术语“Python”替换为实现特定术语，如“CPython”，“Jython”等。</span></p></div></dd></dl><dl class="method"><dt id="wsgiref.handlers.BaseHandler.get_scheme"><span class="yiyi-st" id="yiyi-225"> <code class="descname">get_scheme</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-226">返回用于当前请求的URL方案。</span><span class="yiyi-st" id="yiyi-227">默认实现使用来自<a class="reference internal" href="#module-wsgiref.util" title="wsgiref.util: WSGI environment utilities."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref.util</span></code></a>的<code class="xref py py-func docutils literal"><span class="pre">guess_scheme()</span></code>函数，根据当前请求的<code class="xref py py-attr docutils literal"><span class="pre">environ</span></code>变量。</span></p></dd></dl><dl class="method"><dt id="wsgiref.handlers.BaseHandler.setup_environ"><span class="yiyi-st" id="yiyi-228"> <code class="descname">setup_environ</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-229">将<code class="xref py py-attr docutils literal"><span class="pre">environ</span></code>属性设置为完全填充的WSGI环境。</span><span class="yiyi-st" id="yiyi-230">默认实现使用所有上述方法和属性，以及<a class="reference internal" href="#wsgiref.handlers.BaseHandler.get_stdin" title="wsgiref.handlers.BaseHandler.get_stdin"><code class="xref py py-meth docutils literal"><span class="pre">get_stdin()</span></code></a>，<a class="reference internal" href="#wsgiref.handlers.BaseHandler.get_stderr" title="wsgiref.handlers.BaseHandler.get_stderr"><code class="xref py py-meth docutils literal"><span class="pre">get_stderr()</span></code></a>和<a class="reference internal" href="#wsgiref.handlers.BaseHandler.add_cgi_vars" title="wsgiref.handlers.BaseHandler.add_cgi_vars"><code class="xref py py-meth docutils literal"><span class="pre">add_cgi_vars()</span></code></a>方法和<a class="reference internal" href="#wsgiref.handlers.BaseHandler.wsgi_file_wrapper" title="wsgiref.handlers.BaseHandler.wsgi_file_wrapper"><code class="xref py py-attr docutils literal"><span class="pre">wsgi_file_wrapper</span></code></a>属性。</span><span class="yiyi-st" id="yiyi-231">如果不存在，还会插入<code class="docutils literal"><span class="pre">SERVER_SOFTWARE</span></code>键，只要<a class="reference internal" href="#wsgiref.handlers.BaseHandler.origin_server" title="wsgiref.handlers.BaseHandler.origin_server"><code class="xref py py-attr docutils literal"><span class="pre">origin_server</span></code></a>属性是真值，并且设置了<a class="reference internal" href="#wsgiref.handlers.BaseHandler.server_software" title="wsgiref.handlers.BaseHandler.server_software"><code class="xref py py-attr docutils literal"><span class="pre">server_software</span></code></a>属性。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-232">自定义异常处理的方法和属性：</span></p><dl class="method"><dt id="wsgiref.handlers.BaseHandler.log_exception"><span class="yiyi-st" id="yiyi-233"> <code class="descname">log_exception</code><span class="sig-paren">(</span><em>exc_info</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-234">记录服务器日志中的<em>exc_info</em>元组。</span><span class="yiyi-st" id="yiyi-235"><em>exc_info</em>是<code class="docutils literal"><span class="pre">（类型，</span> <span class="pre">值，</span> <span class="pre">追逆）</span></code>元组。</span><span class="yiyi-st" id="yiyi-236">默认实现只是将追溯写入请求的<code class="docutils literal"><span class="pre">wsgi.errors</span></code>流并清空它。</span><span class="yiyi-st" id="yiyi-237">子类可以覆盖此方法以更改格式或重新定位输出，将追溯邮件发送给管理员或任何其他可能被认为合适的操作。</span></p></dd></dl><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.traceback_limit"><span class="yiyi-st" id="yiyi-238"> <code class="descname">traceback_limit</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-239">默认<a class="reference internal" href="#wsgiref.handlers.BaseHandler.log_exception" title="wsgiref.handlers.BaseHandler.log_exception"><code class="xref py py-meth docutils literal"><span class="pre">log_exception()</span></code></a>方法输出的跟踪回调中要包括的最大帧数。</span><span class="yiyi-st" id="yiyi-240">如果<code class="docutils literal"><span class="pre">None</span></code>，则包括所有帧。</span></p></dd></dl><dl class="method"><dt id="wsgiref.handlers.BaseHandler.error_output"><span class="yiyi-st" id="yiyi-241"> <code class="descname">error_output</code><span class="sig-paren">(</span><em>environ</em>, <em>start_response</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-242">此方法是一个WSGI应用程序，用于为用户生成错误页面。</span><span class="yiyi-st" id="yiyi-243">只有在将标头发送到客户端之前发生错误时才会调用此方法。</span></p><p><span class="yiyi-st" id="yiyi-244">此方法可以使用<code class="docutils literal"><span class="pre">sys.exc_info()</span></code>访问当前错误信息，并应在调用时将该信息传递到<em>start_response</em>（如“错误处理” <span class="target" id="index-11"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>）。</span></p><p><span class="yiyi-st" id="yiyi-245">默认实现仅使用<a class="reference internal" href="#wsgiref.handlers.BaseHandler.error_status" title="wsgiref.handlers.BaseHandler.error_status"><code class="xref py py-attr docutils literal"><span class="pre">error_status</span></code></a>，<a class="reference internal" href="#wsgiref.handlers.BaseHandler.error_headers" title="wsgiref.handlers.BaseHandler.error_headers"><code class="xref py py-attr docutils literal"><span class="pre">error_headers</span></code></a>和<a class="reference internal" href="#wsgiref.handlers.BaseHandler.error_body" title="wsgiref.handlers.BaseHandler.error_body"><code class="xref py py-attr docutils literal"><span class="pre">error_body</span></code></a>属性来生成输出页面。</span><span class="yiyi-st" id="yiyi-246">子类可以覆盖此，以产生更多的动态错误输出。</span></p><p><span class="yiyi-st" id="yiyi-247">但是，请注意，从安全角度来看不建议将诊断信息泄露给任何旧用户；理想情况下，您应该做一些特殊的事情来启用诊断输出，这就是为什么默认实现不包括任何。</span></p></dd></dl><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.error_status"><span class="yiyi-st" id="yiyi-248"> <code class="descname">error_status</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-249">用于错误响应的HTTP状态。</span><span class="yiyi-st" id="yiyi-250">这应该是<span class="target" id="index-12"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>中定义的状态字符串；它默认为500代码和消息。</span></p></dd></dl><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.error_headers"><span class="yiyi-st" id="yiyi-251"> <code class="descname">error_headers</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-252">用于错误响应的HTTP标头。</span><span class="yiyi-st" id="yiyi-253">This should be a list of WSGI response headers (<code class="docutils literal"><span class="pre">(name,</span> <span class="pre">value)</span></code> tuples), as described in <span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>. </span><span class="yiyi-st" id="yiyi-254">默认列表只是将内容类型设置为<code class="docutils literal"><span class="pre">text/plain</span></code>。</span></p></dd></dl><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.error_body"><span class="yiyi-st" id="yiyi-255"> <code class="descname">error_body</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-256">错误响应体。</span><span class="yiyi-st" id="yiyi-257">这应该是一个HTTP响应主体bytestring。</span><span class="yiyi-st" id="yiyi-258">它默认为纯文本“发生服务器错误。</span><span class="yiyi-st" id="yiyi-259">请与管理员联系。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-260"><span class="target" id="index-14"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3333"><strong>PEP 3333</strong></a>的方法和属性“可选的平台特定文件处理”功能：</span></p><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.wsgi_file_wrapper"><span class="yiyi-st" id="yiyi-261"> <code class="descname">wsgi_file_wrapper</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-262">A <code class="docutils literal"><span class="pre">wsgi.file_wrapper</span></code>工厂，或<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-263">此属性的默认值为<a class="reference internal" href="#wsgiref.util.FileWrapper" title="wsgiref.util.FileWrapper"><code class="xref py py-class docutils literal"><span class="pre">wsgiref.util.FileWrapper</span></code></a>类。</span></p></dd></dl><dl class="method"><dt id="wsgiref.handlers.BaseHandler.sendfile"><span class="yiyi-st" id="yiyi-264"> <code class="descname">sendfile</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-265">覆盖以实现平台特定的文件传输。</span><span class="yiyi-st" id="yiyi-266">仅当应用程序的返回值是由<a class="reference internal" href="#wsgiref.handlers.BaseHandler.wsgi_file_wrapper" title="wsgiref.handlers.BaseHandler.wsgi_file_wrapper"><code class="xref py py-attr docutils literal"><span class="pre">wsgi_file_wrapper</span></code></a>属性指定的类的实例时，才调用此方法。</span><span class="yiyi-st" id="yiyi-267">如果它能够成功传输文件，它应该返回一个真值，以便不会执行默认传输代码。</span><span class="yiyi-st" id="yiyi-268">此方法的默认实现仅返回false值。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-269">其他方法和属性：</span></p><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.origin_server"><span class="yiyi-st" id="yiyi-270"> <code class="descname">origin_server</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-271">如果处理程序的<a class="reference internal" href="#wsgiref.handlers.BaseHandler._write" title="wsgiref.handlers.BaseHandler._write"><code class="xref py py-meth docutils literal"><span class="pre">_write()</span></code></a>和<a class="reference internal" href="#wsgiref.handlers.BaseHandler._flush" title="wsgiref.handlers.BaseHandler._flush"><code class="xref py py-meth docutils literal"><span class="pre">_flush()</span></code></a>正在用于直接与客户端通信，而不是通过CGI类似的方式，则此属性应设置为true网关协议，其希望HTTP状态在特殊的<code class="docutils literal"><span class="pre">Status:</span></code>头中。</span></p><p><span class="yiyi-st" id="yiyi-272">此属性的默认值在<a class="reference internal" href="#wsgiref.handlers.BaseHandler" title="wsgiref.handlers.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a>中为true，但在<a class="reference internal" href="#wsgiref.handlers.BaseCGIHandler" title="wsgiref.handlers.BaseCGIHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseCGIHandler</span></code></a>和<a class="reference internal" href="#wsgiref.handlers.CGIHandler" title="wsgiref.handlers.CGIHandler"><code class="xref py py-class docutils literal"><span class="pre">CGIHandler</span></code></a>中为false。</span></p></dd></dl><dl class="attribute"><dt id="wsgiref.handlers.BaseHandler.http_version"><span class="yiyi-st" id="yiyi-273"> <code class="descname">http_version</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-274">如果<a class="reference internal" href="#wsgiref.handlers.BaseHandler.origin_server" title="wsgiref.handlers.BaseHandler.origin_server"><code class="xref py py-attr docutils literal"><span class="pre">origin_server</span></code></a>为true，则此字符串属性用于将响应集的HTTP版本设置为客户端。</span><span class="yiyi-st" id="yiyi-275">它默认为<code class="docutils literal"><span class="pre">"1.0"</span></code>。</span></p></dd></dl></dd></dl><dl class="function"><dt id="wsgiref.handlers.read_environ"><span class="yiyi-st" id="yiyi-276"> <code class="descclassname">wsgiref.handlers.</code><code class="descname">read_environ</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-277">将<code class="docutils literal"><span class="pre">os.environ</span></code>中的CGI变量转换为PEP 3333“unicode”字符串中的字节，返回一个新字典。</span><span class="yiyi-st" id="yiyi-278">此函数由<a class="reference internal" href="#wsgiref.handlers.CGIHandler" title="wsgiref.handlers.CGIHandler"><code class="xref py py-class docutils literal"><span class="pre">CGIHandler</span></code></a>和<a class="reference internal" href="#wsgiref.handlers.IISCGIHandler" title="wsgiref.handlers.IISCGIHandler"><code class="xref py py-class docutils literal"><span class="pre">IISCGIHandler</span></code></a>使用，而不是直接使用<code class="docutils literal"><span class="pre">os.environ</span></code>，这在所有平台和Web上不一定符合WSGI服务器使用Python 3  - 特别是，其中操作系统的实际环境是Unicode（即</span><span class="yiyi-st" id="yiyi-279">Windows），或者环境是字节的，但是Python使用的解码它的系统编码是除ISO-8859-1之外的任何编码。</span><span class="yiyi-st" id="yiyi-280">使用UTF-8的Unix系统）。</span></p><p><span class="yiyi-st" id="yiyi-281">如果您正在实现自己的基于CGI的处理程序，您可能希望使用此例程，而不是直接复制<code class="docutils literal"><span class="pre">os.environ</span></code>中的值。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-282"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="examples"><h2><span class="yiyi-st" id="yiyi-283">21.4.6. </span><span class="yiyi-st" id="yiyi-284">Examples</span></h2><p><span class="yiyi-st" id="yiyi-285">这是一个工作的“Hello World”WSGI应用程序：</span></p><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="k">import</span> <span class="n">make_server</span>

<span class="c1"># Every WSGI application must have an application object - a callable</span>
<span class="c1"># object that accepts two arguments. For that purpose, we're going to</span>
<span class="c1"># use a function (note that you're not limited to a function, you can</span>
<span class="c1"># use a class for example). The first argument passed to the function</span>
<span class="c1"># is a dictionary containing CGI-style environment variables and the</span>
<span class="c1"># second variable is the callable object (see PEP 333).</span>
<span class="k">def</span> <span class="nf">hello_world_app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s1">'200 OK'</span>  <span class="c1"># HTTP Status</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'Content-type'</span><span class="p">,</span> <span class="s1">'text/plain; charset=utf-8'</span><span class="p">)]</span>  <span class="c1"># HTTP Headers</span>
    <span class="n">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>

    <span class="c1"># The returned object is going to be printed</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">b</span><span class="s2">"Hello World"</span><span class="p">]</span>

<span class="n">httpd</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">''</span><span class="p">,</span> <span class="mi">8000</span><span class="p">,</span> <span class="n">hello_world_app</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Serving on port 8000..."</span><span class="p">)</span>

<span class="c1"># Serve until process is killed</span>
<span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</code></pre></div></div></div>