<div class="body" role="main"><div class="section" id="module-smtplib"><h1><span class="yiyi-st" id="yiyi-10">21.17. <a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">smtplib</span></code></a>  -  SMTP协议客户端</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/smtplib.py">Lib / smtplib.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">smtplib</span></code></a>模块定义了一个SMTP客户端会话对象，可用于使用SMTP或ESMTP侦听器守护程序向任何Internet计算机发送邮件。</span><span class="yiyi-st" id="yiyi-13">有关SMTP和ESMTP操作的详细信息，请参阅<span class="target" id="index-1"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc821.html"><strong>RFC 821</strong></a>（简单邮件传输协议）和<span class="target" id="index-2"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1869.html"><strong>RFC 1869</strong></a>服务扩展）。</span></p><dl class="class"><dt id="smtplib.SMTP"><span class="yiyi-st" id="yiyi-14"> <em class="property">class </em><code class="descclassname">smtplib.</code><code class="descname">SMTP</code><span class="sig-paren">(</span><em>host=''</em>, <em>port=0</em>, <em>local_hostname=None</em>, <span class="optional">[</span><em>timeout</em>, <span class="optional">]</span><em>source_address=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-15"><a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal"><span class="pre">SMTP</span></code></a>实例封装了SMTP连接。</span><span class="yiyi-st" id="yiyi-16">它具有支持SMTP和ESMTP操作的完整系列的方法。</span><span class="yiyi-st" id="yiyi-17">如果给出了可选的主机和端口参数，则在初始化期间使用这些参数调用SMTP <a class="reference internal" href="#smtplib.SMTP.connect" title="smtplib.SMTP.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a>方法。</span><span class="yiyi-st" id="yiyi-18">如果指定，则在HELO / EHLO命令中将<em>local_hostname</em>用作本地主机的FQDN。</span><span class="yiyi-st" id="yiyi-19">否则，使用<a class="reference internal" href="socket.html#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal"><span class="pre">socket.getfqdn()</span></code></a>找到本地主机名。</span><span class="yiyi-st" id="yiyi-20">如果<a class="reference internal" href="#smtplib.SMTP.connect" title="smtplib.SMTP.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a>调用返回除成功代码以外的任何内容，则会引发<a class="reference internal" href="#smtplib.SMTPConnectError" title="smtplib.SMTPConnectError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPConnectError</span></code></a>。</span><span class="yiyi-st" id="yiyi-21">可选的<em>timeout</em>参数指定阻塞操作（如连接尝试）的超时（以秒为单位）（如果未指定，将使用全局默认超时设置）。</span><span class="yiyi-st" id="yiyi-22">如果超时到期，则会引发<a class="reference internal" href="socket.html#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal"><span class="pre">socket.timeout</span></code></a>。</span><span class="yiyi-st" id="yiyi-23">可选的source_address参数允许绑定到具有多个网络接口和/或某个特定源TCP端口的机器中的某个特定源地址。</span><span class="yiyi-st" id="yiyi-24">它需要一个2元组（主机，端口），套接字绑定为其源地址，然后连接。</span><span class="yiyi-st" id="yiyi-25">如果省略（或者如果主机或端口分别为<code class="docutils literal"><span class="pre">''</span></code>和/或0），则将使用操作系统默认行为。</span></p><p><span class="yiyi-st" id="yiyi-26">对于正常使用，您只需要初始化/ connect，<a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal"><span class="pre">sendmail()</span></code></a>和<code class="xref py py-meth docutils literal"><span class="pre">quit()</span></code>方法。</span><span class="yiyi-st" id="yiyi-27">下面包含一个例子。</span></p><p><span class="yiyi-st" id="yiyi-28"><a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal"><span class="pre">SMTP</span></code></a>类支持<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句。</span><span class="yiyi-st" id="yiyi-29">当这样使用时，当<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句退出时，会自动发出SMTP <code class="docutils literal"><span class="pre">QUIT</span></code>命令。</span><span class="yiyi-st" id="yiyi-30">例如。</span><span class="yiyi-st" id="yiyi-31">：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">smtplib</span> <span class="k">import</span> <span class="n">SMTP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">SMTP</span><span class="p">(</span><span class="s2">"domain.org"</span><span class="p">)</span> <span class="k">as</span> <span class="n">smtp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">smtp</span><span class="o">.</span><span class="n">noop</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">(250, b'Ok')</span>
<span class="go">&gt;&gt;&gt;</span>
</code></pre><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-32"><span class="versionmodified">在版本3.3中已更改：</span>添加了对<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句的支持。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-33"><span class="versionmodified">在版本3.3中更改：</span>添加了source_address参数。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-34"><span class="versionmodified">版本3.5中的新功能：</span>现在支持SMTPUTF8扩展（<span class="target" id="index-3"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>）。</span></p></div></dd></dl><dl class="class"><dt id="smtplib.SMTP_SSL"><span class="yiyi-st" id="yiyi-35"> <em class="property">class </em><code class="descclassname">smtplib.</code><code class="descname">SMTP_SSL</code><span class="sig-paren">(</span><em>host=''</em>, <em>port=0</em>, <em>local_hostname=None</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <span class="optional">[</span><em>timeout</em>, <span class="optional">]</span><em>context=None</em>, <em>source_address=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-36"><a class="reference internal" href="#smtplib.SMTP_SSL" title="smtplib.SMTP_SSL"><code class="xref py py-class docutils literal"><span class="pre">SMTP_SSL</span></code></a>实例的行为与<a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal"><span class="pre">SMTP</span></code></a>的实例完全相同。</span><span class="yiyi-st" id="yiyi-37"><a class="reference internal" href="#smtplib.SMTP_SSL" title="smtplib.SMTP_SSL"><code class="xref py py-class docutils literal"><span class="pre">SMTP_SSL</span></code></a>应用于从连接开始需要SSL且使用<code class="xref py py-meth docutils literal"><span class="pre">starttls()</span></code>不合适的情况。</span><span class="yiyi-st" id="yiyi-38">如果未指定<em>host</em>，则使用本地主机。</span><span class="yiyi-st" id="yiyi-39">如果<em>port</em>为零，则使用标准的SMTP over SSL端口（465）。</span><span class="yiyi-st" id="yiyi-40">可选参数<em>local_hostname</em>，<em>超时</em>和<em>source_address</em>的含义与在<a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal"><span class="pre">SMTP</span></code></a>类中的含义相同。</span><span class="yiyi-st" id="yiyi-41"><em>上下文</em>也是可选的，可以包含<a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a>并允许配置安全连接的各个方面。</span><span class="yiyi-st" id="yiyi-42">有关最佳做法，请参阅<a class="reference internal" href="ssl.html#ssl-security"><span>Security considerations</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-43"><em>键文件</em>和<em>certfile</em>是<em>上下文</em>的旧式替代，可指向用于SSL连接的PEM格式的私钥和证书链文件。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-44"><span class="versionmodified">Changed in version 3.3: </span><em>context</em> was added.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-45"><span class="versionmodified">在版本3.3中更改：</span>添加了source_address参数。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-46"><span class="versionmodified">在版本3.4中更改：</span>此类现在支持使用<a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal"><span class="pre">ssl.SSLContext.check_hostname</span></code></a>和<em>服务器名称指示</em>（请参阅<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal"><span class="pre">ssl.HAS_SNI</span></code></a>）。</span></p></div></dd></dl><dl class="class"><dt id="smtplib.LMTP"><span class="yiyi-st" id="yiyi-47"> <em class="property">class </em><code class="descclassname">smtplib.</code><code class="descname">LMTP</code><span class="sig-paren">(</span><em>host=''</em>, <em>port=LMTP_PORT</em>, <em>local_hostname=None</em>, <em>source_address=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-48">LMTP协议非常类似于ESMTP，主要基于标准的SMTP客户端。</span><span class="yiyi-st" id="yiyi-49">对于LMTP使用Unix套接字是很常见的，所以我们的<code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code>方法必须支持常规主机：port server。</span><span class="yiyi-st" id="yiyi-50">可选参数local_hostname和source_address的含义与在<a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal"><span class="pre">SMTP</span></code></a>类中的含义相同。</span><span class="yiyi-st" id="yiyi-51">要指定Unix套接字，必须使用<em>host</em>的绝对路径，以'/'开头。</span></p><p><span class="yiyi-st" id="yiyi-52">支持使用常规SMTP机制的认证。</span><span class="yiyi-st" id="yiyi-53">当使用Unix套接字时，LMTP通常不支持或需要任何身份验证，但您的里程可能会有所不同。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-54">一个很好的异常选择也被定义：</span></p><dl class="exception"><dt id="smtplib.SMTPException"><span class="yiyi-st" id="yiyi-55"> <em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPException</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-56"><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>的子类，它是此模块提供的所有其他异常的基本异常类。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-57"><span class="versionmodified">在版本3.4中更改：</span> SMTPException成为<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>的子类</span></p></div></dd></dl><dl class="exception"><dt id="smtplib.SMTPServerDisconnected"><span class="yiyi-st" id="yiyi-58"> <em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPServerDisconnected</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-59">当服务器意外断开连接或尝试在将其连接到服务器之前尝试使用<a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal"><span class="pre">SMTP</span></code></a>实例时，会引发此异常。</span></p></dd></dl><dl class="exception"><dt id="smtplib.SMTPResponseException"><span class="yiyi-st" id="yiyi-60"> <em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPResponseException</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-61">包含SMTP错误代码的所有异常的基类。</span><span class="yiyi-st" id="yiyi-62">在某些情况下，当SMTP服务器返回错误代码时，会生成这些异常。</span><span class="yiyi-st" id="yiyi-63">错误代码存储在错误的<code class="xref py py-attr docutils literal"><span class="pre">smtp_code</span></code>属性中，并且<code class="xref py py-attr docutils literal"><span class="pre">smtp_error</span></code>属性设置为错误消息。</span></p></dd></dl><dl class="exception"><dt id="smtplib.SMTPSenderRefused"><span class="yiyi-st" id="yiyi-64"> <em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPSenderRefused</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-65">发件人地址被拒绝。</span><span class="yiyi-st" id="yiyi-66">除了在所有<a class="reference internal" href="#smtplib.SMTPResponseException" title="smtplib.SMTPResponseException"><code class="xref py py-exc docutils literal"><span class="pre">SMTPResponseException</span></code></a>异常上设置的属性，这会将“sender”设置为SMTP服务器拒绝的字符串。</span></p></dd></dl><dl class="exception"><dt id="smtplib.SMTPRecipientsRefused"><span class="yiyi-st" id="yiyi-67"> <em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPRecipientsRefused</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-68">拒绝所有收件人地址。</span><span class="yiyi-st" id="yiyi-69">每个收件人的错误都可以通过属性<code class="xref py py-attr docutils literal"><span class="pre">recipients</span></code>访问，该属性是与<a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal"><span class="pre">SMTP.sendmail()</span></code></a>完全相同类型的字典返回。</span></p></dd></dl><dl class="exception"><dt id="smtplib.SMTPDataError"><span class="yiyi-st" id="yiyi-70"> <em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPDataError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-71">SMTP服务器拒绝接受邮件数据。</span></p></dd></dl><dl class="exception"><dt id="smtplib.SMTPConnectError"><span class="yiyi-st" id="yiyi-72"> <em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPConnectError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-73">在与服务器建立连接期间发生错误。</span></p></dd></dl><dl class="exception"><dt id="smtplib.SMTPHeloError"><span class="yiyi-st" id="yiyi-74"> <em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPHeloError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-75">服务器拒绝了我们的<code class="docutils literal"><span class="pre">HELO</span></code>消息。</span></p></dd></dl><dl class="exception"><dt id="smtplib.SMTPNotSupportedError"><span class="yiyi-st" id="yiyi-76"> <em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPNotSupportedError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-77">尝试的命令或选项不受服务器支持。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-78"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="exception"><dt id="smtplib.SMTPAuthenticationError"><span class="yiyi-st" id="yiyi-79"> <em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPAuthenticationError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-80">SMTP验证失败。</span><span class="yiyi-st" id="yiyi-81">很可能服务器不接受提供的用户名/密码组合。</span></p></dd></dl><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-82">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-83"><span class="target" id="index-4"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc821.html"><strong>RFC 821</strong></a>  - 简单邮件传输协议</span></dt><dd><span class="yiyi-st" id="yiyi-84">SMTP的协议定义。</span><span class="yiyi-st" id="yiyi-85">本文档涵盖了SMTP的型号，操作过程和协议详细信息。</span></dd><dt><span class="yiyi-st" id="yiyi-86"><span class="target" id="index-5"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1869.html"><strong>RFC 1869</strong></a>  -  SMTP服务扩展</span></dt><dd><span class="yiyi-st" id="yiyi-87">SMTP的ESMTP扩展名的定义。</span><span class="yiyi-st" id="yiyi-88">这描述了一个框架，用新的命令扩展SMTP，支持服务器提供的命令的动态发现，并定义了一些附加的命令。</span></dd></dl></div><div class="section" id="smtp-objects"><h2><span class="yiyi-st" id="yiyi-89">21.17.1. </span><span class="yiyi-st" id="yiyi-90">SMTP Objects</span></h2><p><span class="yiyi-st" id="yiyi-91"><a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal"><span class="pre">SMTP</span></code></a>实例具有以下方法：</span></p><dl class="method"><dt id="smtplib.SMTP.set_debuglevel"><span class="yiyi-st" id="yiyi-92"> <code class="descclassname">SMTP.</code><code class="descname">set_debuglevel</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-93">设置调试输出电平。</span><span class="yiyi-st" id="yiyi-94">对于<em>级别</em>，值为1或<code class="docutils literal"><span class="pre">True</span></code>会导致连接的调试消息以及发送到服务器和从服务器接收的所有消息。</span><span class="yiyi-st" id="yiyi-95"><em>级别</em>的值为2会导致这些消息带有时间戳。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-96"><span class="versionmodified">在版本3.5中已更改：</span>添加了调试级别2。</span></p></div></dd></dl><dl class="method"><dt id="smtplib.SMTP.docmd"><span class="yiyi-st" id="yiyi-97"> <code class="descclassname">SMTP.</code><code class="descname">docmd</code><span class="sig-paren">(</span><em>cmd</em>, <em>args=''</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-98">向服务器发送命令<em>cmd</em>。</span><span class="yiyi-st" id="yiyi-99">可选参数<em>args</em>简单地连接到命令，用空格分隔。</span></p><p><span class="yiyi-st" id="yiyi-100">这将返回由数字响应代码和实际响应行组成的2元组（多行响应合并为一个长行。）</span></p><p><span class="yiyi-st" id="yiyi-101">在正常操作中，不必显式调用此方法。</span><span class="yiyi-st" id="yiyi-102">它用于实现其他方法，可能对测试专用扩展有用。</span></p><p><span class="yiyi-st" id="yiyi-103">如果在等待回复时失去与服务器的连接，则会引发<a class="reference internal" href="#smtplib.SMTPServerDisconnected" title="smtplib.SMTPServerDisconnected"><code class="xref py py-exc docutils literal"><span class="pre">SMTPServerDisconnected</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="smtplib.SMTP.connect"><span class="yiyi-st" id="yiyi-104"> <code class="descclassname">SMTP.</code><code class="descname">connect</code><span class="sig-paren">(</span><em>host='localhost'</em>, <em>port=0</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-105">连接到给定端口上的主机。</span><span class="yiyi-st" id="yiyi-106">默认值是在标准SMTP端口（25）连接到本地主机。</span><span class="yiyi-st" id="yiyi-107">如果主机名以冒号（<code class="docutils literal"><span class="pre">':'</span></code>）结尾，后跟一个数字，则该后缀将被删除，并将该数字解释为要使用的端口号。</span><span class="yiyi-st" id="yiyi-108">如果在实例化期间指定了主机，则此方法由构造函数自动调用。</span><span class="yiyi-st" id="yiyi-109">返回服务器在其连接响应中发送的响应代码和消息的2元组。</span></p></dd></dl><dl class="method"><dt id="smtplib.SMTP.helo"><span class="yiyi-st" id="yiyi-110"> <code class="descclassname">SMTP.</code><code class="descname">helo</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">使用<code class="docutils literal"><span class="pre">HELO</span></code>向SMTP服务器标识自己。</span><span class="yiyi-st" id="yiyi-112">hostname参数默认为本地主机的完全限定域名。</span><span class="yiyi-st" id="yiyi-113">服务器返回的消息存储为对象的<code class="xref py py-attr docutils literal"><span class="pre">helo_resp</span></code>属性。</span></p><p><span class="yiyi-st" id="yiyi-114">在正常操作中，不必显式调用此方法。</span><span class="yiyi-st" id="yiyi-115">在必要时，它将由<a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal"><span class="pre">sendmail()</span></code></a>隐式调用。</span></p></dd></dl><dl class="method"><dt id="smtplib.SMTP.ehlo"><span class="yiyi-st" id="yiyi-116"> <code class="descclassname">SMTP.</code><code class="descname">ehlo</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-117">使用<code class="docutils literal"><span class="pre">EHLO</span></code>向ESMTP服务器标识自己。</span><span class="yiyi-st" id="yiyi-118">hostname参数默认为本地主机的完全限定域名。</span><span class="yiyi-st" id="yiyi-119">检查ESMTP选项的响应，并将其存储以供<a class="reference internal" href="#smtplib.SMTP.has_extn" title="smtplib.SMTP.has_extn"><code class="xref py py-meth docutils literal"><span class="pre">has_extn()</span></code></a>使用。</span><span class="yiyi-st" id="yiyi-120">Also sets several informational attributes: the message returned by the server is stored as the <code class="xref py py-attr docutils literal"><span class="pre">ehlo_resp</span></code> attribute, <code class="xref py py-attr docutils literal"><span class="pre">does_esmtp</span></code> is set to true or false depending on whether the server supports ESMTP, and <code class="xref py py-attr docutils literal"><span class="pre">esmtp_features</span></code> will be a dictionary containing the names of the SMTP service extensions this server supports, and their parameters (if any).</span></p><p><span class="yiyi-st" id="yiyi-121">除非您希望在发送邮件之前使用<a class="reference internal" href="#smtplib.SMTP.has_extn" title="smtplib.SMTP.has_extn"><code class="xref py py-meth docutils literal"><span class="pre">has_extn()</span></code></a>，否则不需要明确调用此方法。</span><span class="yiyi-st" id="yiyi-122">在必要时，它将由<a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal"><span class="pre">sendmail()</span></code></a>隐式调用。</span></p></dd></dl><dl class="method"><dt id="smtplib.SMTP.ehlo_or_helo_if_needed"><span class="yiyi-st" id="yiyi-123"> <code class="descclassname">SMTP.</code><code class="descname">ehlo_or_helo_if_needed</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-124">如果之前没有先前的<code class="docutils literal"><span class="pre">EHLO</span></code>或<code class="docutils literal"><span class="pre">HELO</span></code>命令，则此方法调用<a class="reference internal" href="#smtplib.SMTP.ehlo" title="smtplib.SMTP.ehlo"><code class="xref py py-meth docutils literal"><span class="pre">ehlo()</span></code></a>和或<a class="reference internal" href="#smtplib.SMTP.helo" title="smtplib.SMTP.helo"><code class="xref py py-meth docutils literal"><span class="pre">helo()</span></code></a></span><span class="yiyi-st" id="yiyi-125">它首先尝试ESMTP <code class="docutils literal"><span class="pre">EHLO</span></code>。</span></p><dl class="docutils"><dt><span class="yiyi-st" id="yiyi-126"><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPHeloError</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-127">服务器未正确回复<code class="docutils literal"><span class="pre">HELO</span></code>问候语。</span></dd></dl></dd></dl><dl class="method"><dt id="smtplib.SMTP.has_extn"><span class="yiyi-st" id="yiyi-128"> <code class="descclassname">SMTP.</code><code class="descname">has_extn</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-129">如果<em>名称</em>位于服务器返回的SMTP服务扩展集中，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>，否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span><span class="yiyi-st" id="yiyi-130">大小写被忽略。</span></p></dd></dl><dl class="method"><dt id="smtplib.SMTP.verify"><span class="yiyi-st" id="yiyi-131"> <code class="descclassname">SMTP.</code><code class="descname">verify</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-132">使用SMTP <code class="docutils literal"><span class="pre">VRFY</span></code>检查此服务器上地址的有效性。</span><span class="yiyi-st" id="yiyi-133">如果用户地址有效，则返回由代码250和完整的<span class="target" id="index-6"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a>地址（包括人名）组成的元组。</span><span class="yiyi-st" id="yiyi-134">否则返回400或更大的SMTP错误代码和错误字符串。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-135">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-136">许多网站禁用SMTP <code class="docutils literal"><span class="pre">VRFY</span></code>以剔除垃圾邮件制造者。</span></p></div></dd></dl><dl class="method"><dt id="smtplib.SMTP.login"><span class="yiyi-st" id="yiyi-137"> <code class="descclassname">SMTP.</code><code class="descname">login</code><span class="sig-paren">(</span><em>user</em>, <em>password</em>, <em>*</em>, <em>initial_response_ok=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-138">登录需要验证的SMTP服务器。</span><span class="yiyi-st" id="yiyi-139">参数是要认证的用户名和密码。</span><span class="yiyi-st" id="yiyi-140">如果先前没有先前<code class="docutils literal"><span class="pre">EHLO</span></code>或<code class="docutils literal"><span class="pre">HELO</span></code>命令此会话，则此方法首先尝试ESMTP <code class="docutils literal"><span class="pre">EHLO</span></code>。</span><span class="yiyi-st" id="yiyi-141">如果身份验证成功，此方法将正常返回，或可能引发以下异常：</span></p><dl class="docutils"><dt><span class="yiyi-st" id="yiyi-142"><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPHeloError</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-143">服务器未正确回复<code class="docutils literal"><span class="pre">HELO</span></code>问候语。</span></dd><dt><span class="yiyi-st" id="yiyi-144"><a class="reference internal" href="#smtplib.SMTPAuthenticationError" title="smtplib.SMTPAuthenticationError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPAuthenticationError</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-145">服务器不接受用户名/密码组合。</span></dd><dt><span class="yiyi-st" id="yiyi-146"><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPNotSupportedError</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-147">服务器不支持<code class="docutils literal"><span class="pre">AUTH</span></code>命令。</span></dd><dt><span class="yiyi-st" id="yiyi-148"><a class="reference internal" href="#smtplib.SMTPException" title="smtplib.SMTPException"><code class="xref py py-exc docutils literal"><span class="pre">SMTPException</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-149">未找到合适的身份验证方法。</span></dd></dl><p><span class="yiyi-st" id="yiyi-150"><a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">smtplib</span></code></a>支持的每种身份验证方法如果按服务器支持的方式发布，则依次尝试。</span><span class="yiyi-st" id="yiyi-151">有关支持的身份验证方法的列表，请参见<a class="reference internal" href="#smtplib.SMTP.auth" title="smtplib.SMTP.auth"><code class="xref py py-meth docutils literal"><span class="pre">auth()</span></code></a>。</span><span class="yiyi-st" id="yiyi-152"><em>initial_response_ok</em>传递到<a class="reference internal" href="#smtplib.SMTP.auth" title="smtplib.SMTP.auth"><code class="xref py py-meth docutils literal"><span class="pre">auth()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-153">可选的关键字参数<em>initial_response_ok</em>指定对于支持它的身份验证方法，如<span class="target" id="index-7"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc4954.html"><strong>RFC 4954</strong></a>中指定的“初始响应” <code class="docutils literal"><span class="pre">AUTH</span></code>命令，而不是要求挑战/响应。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-154"><span class="versionmodified">在版本3.5中更改：</span> <a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPNotSupportedError</span></code></a>可能会引发，并且添加了<em>initial_response_ok</em>参数。</span></p></div></dd></dl><dl class="method"><dt id="smtplib.SMTP.auth"><span class="yiyi-st" id="yiyi-155"> <code class="descclassname">SMTP.</code><code class="descname">auth</code><span class="sig-paren">(</span><em>mechanism</em>, <em>authobject</em>, <em>*</em>, <em>initial_response_ok=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156">针对指定的认证<em>机制发出<code class="docutils literal"><span class="pre">SMTP</span></code> <code class="docutils literal"><span class="pre">AUTH</span></code>命令</em>，并通过<em>authobject</em>处理质询响应。</span></p><p><span class="yiyi-st" id="yiyi-157"><em>机制</em>指定要将哪个认证机制用作<code class="docutils literal"><span class="pre">AUTH</span></code>命令的参数；有效值是在<code class="xref py py-attr docutils literal"><span class="pre">esmtp_features</span></code>的<code class="docutils literal"><span class="pre">auth</span></code>元素中列出的有效值。</span></p><p><span class="yiyi-st" id="yiyi-158"><em>authobject</em>必须是采用可选单参数的可调用对象：</span></p><span class="yiyi-st" id="yiyi-171"> <blockquote> <div>data = authobject(challenge=None)</div></blockquote></span><p><span class="yiyi-st" id="yiyi-159">如果可选的关键字参数<em>initial_response_ok</em>为true，则将首先调用无参数的<code class="docutils literal"><span class="pre">authobject()</span></code>。</span><span class="yiyi-st" id="yiyi-160">它可以返回将被编码并与<code class="docutils literal"><span class="pre">AUTH</span></code>命令一起发送的<span class="target" id="index-8"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc4954.html"><strong>RFC 4954</strong></a>“初始响应”字节，如下所示。</span><span class="yiyi-st" id="yiyi-161">如果<code class="docutils literal"><span class="pre">authobject()</span></code>不支持初始响应（例如，</span><span class="yiyi-st" id="yiyi-162">因为它需要一个挑战），当使用<code class="docutils literal"><span class="pre">challenge=None</span></code>调用时应该返回None。</span><span class="yiyi-st" id="yiyi-163">如果<em>initial_response_ok</em>为false，则<code class="docutils literal"><span class="pre">authobject()</span></code>不会先调用None。</span></p><p><span class="yiyi-st" id="yiyi-164">如果初始响应检查返回None，或者<em>initial_response_ok</em>为false，则将调用<code class="docutils literal"><span class="pre">authobject()</span></code>来处理服务器的质询响应；传递的<em>挑战</em>参数将是<code class="docutils literal"><span class="pre">bytes</span></code>。</span><span class="yiyi-st" id="yiyi-165">它应该返回<code class="docutils literal"><span class="pre">bytes</span></code> <em>data</em>，将被base64编码并发送到服务器。</span></p><p><span class="yiyi-st" id="yiyi-166"><code class="docutils literal"><span class="pre">SMTP</span></code>类为<code class="docutils literal"><span class="pre">CRAM-MD5</span></code>，<code class="docutils literal"><span class="pre">PLAIN</span></code>和<code class="docutils literal"><span class="pre">LOGIN</span></code>提供<code class="docutils literal"><span class="pre">authobjects</span></code>机制；它们分别命名为<code class="docutils literal"><span class="pre">SMTP.auth_cram_md5</span></code>，<code class="docutils literal"><span class="pre">SMTP.auth_plain</span></code>和<code class="docutils literal"><span class="pre">SMTP.auth_login</span></code>。</span><span class="yiyi-st" id="yiyi-167">它们都要求将<code class="docutils literal"><span class="pre">SMTP</span></code>实例的<code class="docutils literal"><span class="pre">user</span></code>和<code class="docutils literal"><span class="pre">password</span></code>属性设置为适当的值。</span></p><p><span class="yiyi-st" id="yiyi-168">用户代码通常不需要直接调用<code class="docutils literal"><span class="pre">auth</span></code>，而是可以调用<a class="reference internal" href="#smtplib.SMTP.login" title="smtplib.SMTP.login"><code class="xref py py-meth docutils literal"><span class="pre">login()</span></code></a>方法，它将按照列出的顺序依次尝试上述每个机制。</span><span class="yiyi-st" id="yiyi-169"><code class="docutils literal"><span class="pre">auth</span></code>是为了方便实现尚未（或尚未）由<a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">smtplib</span></code></a>直接支持的身份验证方法。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-170"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="smtplib.SMTP.starttls"><span class="yiyi-st" id="yiyi-172"> <code class="descclassname">SMTP.</code><code class="descname">starttls</code><span class="sig-paren">(</span><em>keyfile=None</em>, <em>certfile=None</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-173">将SMTP连接设置为TLS（传输层安全）模式。</span><span class="yiyi-st" id="yiyi-174">随后的所有SMTP命令将被加密。</span><span class="yiyi-st" id="yiyi-175">然后，您应再次调用<a class="reference internal" href="#smtplib.SMTP.ehlo" title="smtplib.SMTP.ehlo"><code class="xref py py-meth docutils literal"><span class="pre">ehlo()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-176">如果提供<em>密钥文件</em>和<em>certfile</em>，则将它们传递给<a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a>模块的<a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-func docutils literal"><span class="pre">ssl()</span></code></a>函数。</span></p><p><span class="yiyi-st" id="yiyi-177">可选的<em>上下文</em>参数是<a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></code></a>对象；这是使用密钥文件和certfile的替代方法，如果指定<em>keyfile</em>和<em>certfile</em>应为None。</span></p><p><span class="yiyi-st" id="yiyi-178">如果先前没有先前<code class="docutils literal"><span class="pre">EHLO</span></code>或<code class="docutils literal"><span class="pre">HELO</span></code>命令此会话，则此方法首先尝试ESMTP <code class="docutils literal"><span class="pre">EHLO</span></code>。</span></p><dl class="docutils"><dt><span class="yiyi-st" id="yiyi-179"><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPHeloError</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-180">服务器未正确回复<code class="docutils literal"><span class="pre">HELO</span></code>问候语。</span></dd><dt><span class="yiyi-st" id="yiyi-181"><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPNotSupportedError</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-182">服务器不支持STARTTLS扩展。</span></dd><dt><span class="yiyi-st" id="yiyi-183"><a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-184">SSL / TLS支持不适用于您的Python解释器。</span></dd></dl><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-185"><span class="versionmodified">改变在3.3版本：加入 T0&gt; <em>背景 T1&gt;。</em></span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-186"><span class="versionmodified">在版本3.4中更改：</span>此方法现在支持使用<code class="xref py py-attr docutils literal"><span class="pre">SSLContext.check_hostname</span></code>和<em>服务器名称指示符</em>进行主机名检查（请参阅<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal"><span class="pre">HAS_SNI</span></code></a> ）。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-187"><span class="versionmodified">在3.5版本中已更改：</span>由于缺少STARTTLS支持而引发的错误现在是<a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPNotSupportedError</span></code></a>子类，而不是基本<a class="reference internal" href="#smtplib.SMTPException" title="smtplib.SMTPException"><code class="xref py py-exc docutils literal"><span class="pre">SMTPException</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="smtplib.SMTP.sendmail"><span class="yiyi-st" id="yiyi-188"> <code class="descclassname">SMTP.</code><code class="descname">sendmail</code><span class="sig-paren">(</span><em>from_addr</em>, <em>to_addrs</em>, <em>msg</em>, <em>mail_options=[]</em>, <em>rcpt_options=[]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-189">发送邮件。</span><span class="yiyi-st" id="yiyi-190">所需的参数是<span class="target" id="index-9"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a>从地址字符串，<span class="target" id="index-10"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a>裸字符串将被视为具有1个地址的列表）和消息字符串。</span><span class="yiyi-st" id="yiyi-191">呼叫者可以传递在<code class="docutils literal"><span class="pre">MAIL</span> <span class="pre">FROM</span></code>命令中使用的ESMTP选项列表（例如<code class="docutils literal"><span class="pre">8bitmime</span></code>） <em>mail_options</em>。</span><span class="yiyi-st" id="yiyi-192">应该与所有<code class="docutils literal"><span class="pre">RCPT</span></code>命令一起使用的ESMTP选项（例如<code class="docutils literal"><span class="pre">DSN</span></code>命令）可以作为<em>rcpt_options</em>传递。</span><span class="yiyi-st" id="yiyi-193">（如果您需要对不同的收件人使用不同的ESMTP选项，则必须使用低级方法，例如<code class="xref py py-meth docutils literal"><span class="pre">mail()</span></code>，<code class="xref py py-meth docutils literal"><span class="pre">rcpt()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">data()</span></code>发送消息。）</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-194">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-195"><em>from_addr</em>和<em>to_addrs</em>参数用于构造传输代理使用的消息包络。</span><span class="yiyi-st" id="yiyi-196"><code class="docutils literal"><span class="pre">sendmail</span></code>不以任何方式修改邮件标头。</span></p></div><p><span class="yiyi-st" id="yiyi-197"><em>msg</em>可以是包含ASCII范围中的字符的字符串，也可以是字节字符串。</span><span class="yiyi-st" id="yiyi-198">使用ascii编解码器将字符串编码为字节，并将单个<code class="docutils literal"><span class="pre">\r</span></code>和<code class="docutils literal"><span class="pre">\n</span></code>字符转换为<code class="docutils literal"><span class="pre">\r\n</span></code>字符。</span><span class="yiyi-st" id="yiyi-199">不修改字节字符串。</span></p><p><span class="yiyi-st" id="yiyi-200">如果先前没有先前<code class="docutils literal"><span class="pre">EHLO</span></code>或<code class="docutils literal"><span class="pre">HELO</span></code>命令此会话，则此方法首先尝试ESMTP <code class="docutils literal"><span class="pre">EHLO</span></code>。</span><span class="yiyi-st" id="yiyi-201">如果服务器执行ESMTP，消息大小和每个指定的选项将被传递给它（如果该选项在服务器发布的功能集中）。</span><span class="yiyi-st" id="yiyi-202">如果<code class="docutils literal"><span class="pre">EHLO</span></code>失败，将尝试<code class="docutils literal"><span class="pre">HELO</span></code>并禁止ESMTP选项。</span></p><p><span class="yiyi-st" id="yiyi-203">如果至少有一个收件人接受邮件，此方法将正常返回。</span><span class="yiyi-st" id="yiyi-204">否则会引发异常。</span><span class="yiyi-st" id="yiyi-205">也就是说，如果这个方法不引发异常，那么有人应该得到你的邮件。</span><span class="yiyi-st" id="yiyi-206">如果此方法没有引发异常，它会返回一个字典，每个收件人被拒绝一个条目。</span><span class="yiyi-st" id="yiyi-207">每个条目包含SMTP错误代码的元组和服务器发送的附带错误消息。</span></p><p><span class="yiyi-st" id="yiyi-208">如果<code class="docutils literal"><span class="pre">SMTPUTF8</span></code>包含在<em>mail_options</em>中，并且服务器支持它，<em>from_addr</em>和<em>to_addr</em>可能包含非ASCII字符。</span></p><p><span class="yiyi-st" id="yiyi-209">该方法可以引入以下例外：</span></p><dl class="docutils"><dt><span class="yiyi-st" id="yiyi-210"><a class="reference internal" href="#smtplib.SMTPRecipientsRefused" title="smtplib.SMTPRecipientsRefused"><code class="xref py py-exc docutils literal"><span class="pre">SMTPRecipientsRefused</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-211">所有收件人都被拒绝。</span><span class="yiyi-st" id="yiyi-212">没有人收到邮件。</span><span class="yiyi-st" id="yiyi-213">异常对象的<code class="xref py py-attr docutils literal"><span class="pre">recipients</span></code>属性是包含有关被拒绝的收件人（如至少一个收件人被接受时返回的收件人）的信息的字典。</span></dd><dt><span class="yiyi-st" id="yiyi-214"><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPHeloError</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-215">服务器未正确回复<code class="docutils literal"><span class="pre">HELO</span></code>问候语。</span></dd><dt><span class="yiyi-st" id="yiyi-216"><a class="reference internal" href="#smtplib.SMTPSenderRefused" title="smtplib.SMTPSenderRefused"><code class="xref py py-exc docutils literal"><span class="pre">SMTPSenderRefused</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-217">服务器不接受<em>from_addr</em>。</span></dd><dt><span class="yiyi-st" id="yiyi-218"><a class="reference internal" href="#smtplib.SMTPDataError" title="smtplib.SMTPDataError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPDataError</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-219">服务器回复了意外的错误代码（除了收件人拒绝）。</span></dd><dt><span class="yiyi-st" id="yiyi-220"><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPNotSupportedError</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-221"><code class="docutils literal"><span class="pre">SMTPUTF8</span></code>在<em>mail_options</em>中给出，但服务器不支持。</span></dd></dl><p><span class="yiyi-st" id="yiyi-222">除非另有说明，否则即使在引发异常后，连接也将打开。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-223"><span class="versionmodified">在版本3.2中更改：</span> <em>msg</em>可能是字节字符串。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-224"><span class="versionmodified">在已指定<code class="docutils literal"><span class="pre">SMTPUTF8</span></code>的情况下，在版本3.5中更改了</span> <code class="docutils literal"><span class="pre">SMTPUTF8</span></code>支持，并且可能会出现<a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal"><span class="pre">SMTPNotSupportedError</span></code></a>不支持它。</span></p></div></dd></dl><dl class="method"><dt id="smtplib.SMTP.send_message"><span class="yiyi-st" id="yiyi-225"> <code class="descclassname">SMTP.</code><code class="descname">send_message</code><span class="sig-paren">(</span><em>msg</em>, <em>from_addr=None</em>, <em>to_addrs=None</em>, <em>mail_options=[]</em>, <em>rcpt_options=[]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-226">这是一种方便的方法，用于调用<a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal"><span class="pre">sendmail()</span></code></a>和由<a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal"><span class="pre">email.message.Message</span></code></a>对象表示的消息。</span><span class="yiyi-st" id="yiyi-227">参数具有与<a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal"><span class="pre">sendmail()</span></code></a>相同的含义，除了<em>msg</em>是<code class="docutils literal"><span class="pre">Message</span></code>对象。</span></p><p><span class="yiyi-st" id="yiyi-228">If <em>from_addr</em> is <code class="docutils literal"><span class="pre">None</span></code> or <em>to_addrs</em> is <code class="docutils literal"><span class="pre">None</span></code>, <code class="docutils literal"><span class="pre">send_message</span></code> fills those arguments with addresses extracted from the headers of <em>msg</em> as specified in <span class="target" id="index-11"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>: <em>from_addr</em> is set to the <em class="mailheader">Sender</em> field if it is present, and otherwise to the <em class="mailheader">From</em> field. </span><span class="yiyi-st" id="yiyi-229"><em>to_adresses</em>组合来自<em>msg的<em class="mailheader">至</em>，<em class="mailheader">Cc</em>和<em class="mailheader">Bcc</em>字段的值</em>。</span><span class="yiyi-st" id="yiyi-230">如果消息中只出现一组<em class="mailheader">Resent  -  *</em>标头，则会忽略常规标头，而改用<em class="mailheader">Resent  -  *</em>标头。</span><span class="yiyi-st" id="yiyi-231">如果消息包含多个<em class="mailheader">Resent  -  *</em>头，则会引发一个<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>，因为没有办法明确检测最近的<em class="mailheader">Resent - </em>标头。</span></p><p><span class="yiyi-st" id="yiyi-232"><code class="docutils literal"><span class="pre">send_message</span></code>使用<a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal"><span class="pre">BytesGenerator</span></code></a>以<code class="docutils literal"><span class="pre">\r\n</span></code>作为<em>linesep</em>来序列化<em>msg</em>调用<a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal"><span class="pre">sendmail()</span></code></a>发送生成的消息。</span><span class="yiyi-st" id="yiyi-233">无论<em>from_addr</em>和<em>to_addrs</em>的值，<code class="docutils literal"><span class="pre">send_message</span></code>不传送任何<em class="mailheader">Bcc</em>或<em class="mailheader">Resent-Bcc </em>可能会出现在<em>msg</em>中的标头。</span><span class="yiyi-st" id="yiyi-234">如果<em>from_addr</em>和<em>to_addrs</em>中的任何地址包含非ASCII字符，并且服务器不通告<code class="docutils literal"><span class="pre">SMTPUTF8</span></code>支持，则<code class="xref py py-exc docutils literal"><span class="pre">SMTPNotSupported</span></code></span><span class="yiyi-st" id="yiyi-235">Otherwise the <code class="docutils literal"><span class="pre">Message</span></code> is serialized with a clone of its <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal"><span class="pre">policy</span></code></a> with the <a class="reference internal" href="email.policy.html#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal"><span class="pre">utf8</span></code></a> attribute set to <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">SMTPUTF8</span></code> and <code class="docutils literal"><span class="pre">BODY=8BITMIME</span></code> are added to <em>mail_options</em>.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-236"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-237"><span class="versionmodified">版本3.5中的新功能：</span>支持国际化地址（<code class="docutils literal"><span class="pre">SMTPUTF8</span></code>）。</span></p></div></dd></dl><dl class="method"><dt id="smtplib.SMTP.quit"><span class="yiyi-st" id="yiyi-238"> <code class="descclassname">SMTP.</code><code class="descname">quit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-239">终止SMTP会话并关闭连接。</span><span class="yiyi-st" id="yiyi-240">返回SMTP <code class="docutils literal"><span class="pre">QUIT</span></code>命令的结果。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-241">对应于标准SMTP / ESMTP命令<code class="docutils literal"><span class="pre">HELP</span></code>，<code class="docutils literal"><span class="pre">RSET</span></code>，<code class="docutils literal"><span class="pre">NOOP</span></code>，<code class="docutils literal"><span class="pre">MAIL</span></code>，<code class="docutils literal"><span class="pre">RCPT</span></code>和<code class="docutils literal"><span class="pre">DATA</span></code>。</span><span class="yiyi-st" id="yiyi-242">通常这些不需要直接调用，因此在这里没有记录。</span><span class="yiyi-st" id="yiyi-243">有关详细信息，请参阅模块代码。</span></p></div><div class="section" id="smtp-example"><h2><span class="yiyi-st" id="yiyi-244">21.17.2. </span><span class="yiyi-st" id="yiyi-245">SMTP Example</span></h2><p><span class="yiyi-st" id="yiyi-246">此示例提示用户消息包络（“To”和“From”地址）中所需的地址以及要传递的消息。</span><span class="yiyi-st" id="yiyi-247">请注意，消息中包含的标头必须包含在输入的消息中；此示例不对<span class="target" id="index-12"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a>头进行任何处理。</span><span class="yiyi-st" id="yiyi-248">特别地，“To”和“From”地址必须明确包含在消息头中。</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">smtplib</span>

<span class="k">def</span> <span class="nf">prompt</span><span class="p">(</span><span class="n">prompt</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<span class="n">fromaddr</span> <span class="o">=</span> <span class="n">prompt</span><span class="p">(</span><span class="s2">"From: "</span><span class="p">)</span>
<span class="n">toaddrs</span>  <span class="o">=</span> <span class="n">prompt</span><span class="p">(</span><span class="s2">"To: "</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Enter message, end with ^D (Unix) or ^Z (Windows):"</span><span class="p">)</span>

<span class="c1"># Add the From: and To: headers at the start!</span>
<span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"From: </span><span class="si">%s</span><span class="se">\r\n</span><span class="s2">To: </span><span class="si">%s</span><span class="se">\r\n\r\n</span><span class="s2">"</span>
       <span class="o">%</span> <span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">toaddrs</span><span class="p">)))</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">+</span> <span class="n">line</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Message length is"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s1">'localhost'</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">set_debuglevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">sendmail</span><span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="n">toaddrs</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-249">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-250">一般来说，您会想要使用<a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><code class="xref py py-mod docutils literal"><span class="pre">email</span></code></a>套件的功能来构建电子邮件，然后您可以通过<a class="reference internal" href="#smtplib.SMTP.send_message" title="smtplib.SMTP.send_message"><code class="xref py py-meth docutils literal"><span class="pre">send_message()</span></code></a>发送电子邮件；请参阅<a class="reference internal" href="email-examples.html#email-examples"><span>email: Examples</span></a>。</span></p></div></div></div></div>