<div class="section" id="beautiful-soup-4-4-0">
    <h1>Beautiful Soup 4.4.0 文档<a class="headerlink" href="#beautiful-soup-4-4-0" title="永久链接至标题"></a></h1>
    <img alt="http://www.crummy.com/software/BeautifulSoup/bs4/doc/_images/6.1.jpg" class="align-right" src="http://www.crummy.com/software/BeautifulSoup/bs4/doc/_images/6.1.jpg">
    <p><a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.</p>
    <p>这篇文档介绍了BeautifulSoup4中所有主要特性,并且有小例子.让我来向你展示它适合做什么,如何工作,怎样使用,如何达到你想要的效果,和处理异常情况.</p>
    <p>文档中出现的例子在Python2.7和Python3.2中的执行结果相同</p>
    <p>你可能在寻找 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">Beautiful Soup3</a> 的文档,Beautiful Soup 3 目前已经停止开发,我们推荐在现在的项目中使用Beautiful Soup 4, <a class="reference external" href="http://www.baidu.com">移植到BS4</a></p>
    <p>这篇帮助文档已经被翻译成了其它语言:</p>
    <ul class="simple">
    <li><a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.cn.html">这篇文档当然还有中文版.</a></li>
    <li>このページは日本語で利用できます(<a class="reference external" href="http://kondou.com/BS4/">外部リンク</a>)</li>
    <li>이 문서는 한국어 번역도 가능합니다. (<a class="reference external" href="http://coreapython.hosting.paran.com/etc/beautifulsoup4.html">외부 링크</a>)</li>
    </ul>
    <div class="section" id="id4">
    <h2>寻求帮助<a class="headerlink" href="#id4" title="永久链接至标题"></a></h2>
    <p>如果你有关于BeautifulSoup的问题,可以发送邮件到 <a class="reference external" href="https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup">讨论组</a> .如果你的问题包含了一段需要转换的HTML代码,那么确保你提的问题描述中附带这段HTML文档的 <a class="reference internal" href="#id66">代码诊断</a> <a class="footnote-reference" href="#id88" id="id6">[1]</a></p>
    </div>
    </div>
    <div class="section" id="id7">
    <h1>快速开始<a class="headerlink" href="#id7" title="永久链接至标题"></a></h1>
    <p>下面的一段HTML代码将作为例子被多次用到.这是 <em>爱丽丝梦游仙境的</em> 的一段内容(以后内容中简称为 <em>爱丽丝</em> 的文档):</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">"""</span>
    <span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span>
    <span class="s2">&lt;body&gt;</span>
    <span class="s2">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span>
    
    <span class="s2">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span>
    <span class="s2">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="s2">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span>
    <span class="s2">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span>
    <span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>
    
    <span class="s2">&lt;p class="story"&gt;...&lt;/p&gt;</span>
    <span class="s2">"""</span>
    </code></pre></div>
    </div>
    <p>使用BeautifulSoup解析这段代码,能够得到一个 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 的对象,并能按照标准的缩进格式的结构输出:</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">'html.parser'</span><span class="p">)</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
    <span class="c1"># &lt;html&gt;</span>
    <span class="c1">#  &lt;head&gt;</span>
    <span class="c1">#   &lt;title&gt;</span>
    <span class="c1">#    The Dormouse's story</span>
    <span class="c1">#   &lt;/title&gt;</span>
    <span class="c1">#  &lt;/head&gt;</span>
    <span class="c1">#  &lt;body&gt;</span>
    <span class="c1">#   &lt;p class="title"&gt;</span>
    <span class="c1">#    &lt;b&gt;</span>
    <span class="c1">#     The Dormouse's story</span>
    <span class="c1">#    &lt;/b&gt;</span>
    <span class="c1">#   &lt;/p&gt;</span>
    <span class="c1">#   &lt;p class="story"&gt;</span>
    <span class="c1">#    Once upon a time there were three little sisters; and their names were</span>
    <span class="c1">#    &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;</span>
    <span class="c1">#     Elsie</span>
    <span class="c1">#    &lt;/a&gt;</span>
    <span class="c1">#    ,</span>
    <span class="c1">#    &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;</span>
    <span class="c1">#     Lacie</span>
    <span class="c1">#    &lt;/a&gt;</span>
    <span class="c1">#    and</span>
    <span class="c1">#    &lt;a class="sister" href="http://example.com/tillie" id="link2"&gt;</span>
    <span class="c1">#     Tillie</span>
    <span class="c1">#    &lt;/a&gt;</span>
    <span class="c1">#    ; and they lived at the bottom of a well.</span>
    <span class="c1">#   &lt;/p&gt;</span>
    <span class="c1">#   &lt;p class="story"&gt;</span>
    <span class="c1">#    ...</span>
    <span class="c1">#   &lt;/p&gt;</span>
    <span class="c1">#  &lt;/body&gt;</span>
    <span class="c1"># &lt;/html&gt;</span>
    </code></pre></div>
    </div>
    <p>几个简单的浏览结构化数据的方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">title</span>
    <span class="c1"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">name</span>
    <span class="c1"># u'title'</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">string</span>
    <span class="c1"># u'The Dormouse's story'</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>
    <span class="c1"># u'head'</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">p</span>
    <span class="c1"># &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">'class'</span><span class="p">]</span>
    <span class="c1"># u'title'</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">"link3"</span><span class="p">)</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    <p>从文档中找到所有&lt;a&gt;标签的链接:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">'a'</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'href'</span><span class="p">))</span>
        <span class="c1"># http://example.com/elsie</span>
        <span class="c1"># http://example.com/lacie</span>
        <span class="c1"># http://example.com/tillie</span>
    </code></pre></div>
    </div>
    <p>从文档中获取所有文字内容:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">get_text</span><span class="p">())</span>
    <span class="c1"># The Dormouse's story</span>
    <span class="c1">#</span>
    <span class="c1"># The Dormouse's story</span>
    <span class="c1">#</span>
    <span class="c1"># Once upon a time there were three little sisters; and their names were</span>
    <span class="c1"># Elsie,</span>
    <span class="c1"># Lacie and</span>
    <span class="c1"># Tillie;</span>
    <span class="c1"># and they lived at the bottom of a well.</span>
    <span class="c1">#</span>
    <span class="c1"># ...</span>
    </code></pre></div>
    </div>
    <p>这是你想要的吗?别着急,还有更好用的</p>
    </div>
    <div class="section" id="id8">
    <h1>安装 Beautiful Soup<a class="headerlink" href="#id8" title="永久链接至标题"></a></h1>
    <p>如果你用的是新版的Debain或ubuntu,那么可以通过系统的软件包管理来安装:</p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">Python-bs4</span></code></p>
    <p>Beautiful Soup 4 通过PyPi发布,所以如果你无法使用系统包管理安装,那么也可以通过 <code class="docutils literal"><span class="pre">easy_install</span></code> 或 <code class="docutils literal"><span class="pre">pip</span></code> 来安装.包的名字是 <code class="docutils literal"><span class="pre">beautifulsoup4</span></code> ,这个包兼容Python2和Python3.</p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">easy_install</span> <span class="pre">beautifulsoup4</span></code></p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">beautifulsoup4</span></code></p>
    <p>(在PyPi中还有一个名字是 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 的包,但那可能不是你想要的,那是 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">Beautiful Soup3</a> 的发布版本,因为很多项目还在使用BS3, 所以 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 包依然有效.但是如果你在编写新项目,那么你应该安装的 <code class="docutils literal"><span class="pre">beautifulsoup4</span></code> )</p>
    <p>如果你没有安装 <code class="docutils literal"><span class="pre">easy_install</span></code> 或 <code class="docutils literal"><span class="pre">pip</span></code> ,那你也可以 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/download/4.x/">下载BS4的源码</a> ,然后通过setup.py来安装.</p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">Python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code></p>
    <p>如果上述安装方法都行不通,Beautiful Soup的发布协议允许你将BS4的代码打包在你的项目中,这样无须安装即可使用.</p>
    <p>作者在Python2.7和Python3.2的版本下开发Beautiful Soup, 理论上Beautiful Soup应该在所有当前的Python版本中正常工作</p>
    <div class="section" id="id11">
    <h2>安装完成后的问题<a class="headerlink" href="#id11" title="永久链接至标题"></a></h2>
    <p>Beautiful Soup发布时打包成Python2版本的代码,在Python3环境下安装时,会自动转换成Python3的代码,如果没有一个安装的过程,那么代码就不会被转换.</p>
    <p>如果代码抛出了 <code class="docutils literal"><span class="pre">ImportError</span></code> 的异常: “No module named HTMLParser”, 这是因为你在Python3版本中执行Python2版本的代码.</p>
    <p>如果代码抛出了 <code class="docutils literal"><span class="pre">ImportError</span></code> 的异常: “No module named html.parser”, 这是因为你在Python2版本中执行Python3版本的代码.</p>
    <p>如果遇到上述2种情况,最好的解决方法是重新安装BeautifulSoup4.</p>
    <p>如果在ROOT_TAG_NAME = u’[document]’代码处遇到 <code class="docutils literal"><span class="pre">SyntaxError</span></code> “Invalid syntax”错误,需要将把BS4的Python代码版本从Python2转换到Python3. 可以重新安装BS4:</p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">Python3</span> <span class="pre">setup.py</span> <span class="pre">install</span></code></p>
    <p>或在bs4的目录中执行Python代码版本转换脚本</p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">2to3-3.2</span> <span class="pre">-w</span> <span class="pre">bs4</span></code></p>
    </div>
    <div class="section" id="id12">
    <h2>安装解析器<a class="headerlink" href="#id12" title="永久链接至标题"></a></h2>
    <p>Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 <a class="reference external" href="http://lxml.de/">lxml</a> .根据操作系统不同,可以选择下列方法来安装lxml:</p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">Python-lxml</span></code></p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">easy_install</span> <span class="pre">lxml</span></code></p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">lxml</span></code></p>
    <p>另一个可供选择的解析器是纯Python实现的 <a class="reference external" href="http://code.google.com/p/html5lib/">html5lib</a> , html5lib的解析方式与浏览器相同,可以选择下列方法来安装html5lib:</p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">Python-html5lib</span></code></p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">easy_install</span> <span class="pre">html5lib</span></code></p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">html5lib</span></code></p>
    <p>下表列出了主要的解析器,以及它们的优缺点:</p>
    <div class="wy-table-responsive"><table border="1" class="docutils">
    <colgroup>
    <col width="22%">
    <col width="26%">
    <col width="26%">
    <col width="26%">
    </colgroup>
    <thead valign="bottom">
    <tr class="row-odd"><th class="head">解析器</th>
    <th class="head">使用方法</th>
    <th class="head">优势</th>
    <th class="head">劣势</th>
    </tr>
    </thead>
    <tbody valign="top">
    <tr class="row-even"><td>Python标准库</td>
    <td><code class="docutils literal"><span class="pre">BeautifulSoup(markup,</span>
    <span class="pre">"html.parser")</span></code></td>
    <td><ul class="first last simple">
    <li>Python的内置标准库</li>
    <li>执行速度适中</li>
    <li>文档容错能力强</li>
    </ul>
    </td>
    <td><ul class="first last simple">
    <li>Python 2.7.3 or 3.2.2)前
    的版本中文档容错能力差</li>
    </ul>
    </td>
    </tr>
    <tr class="row-odd"><td>lxml HTML 解析器</td>
    <td><code class="docutils literal"><span class="pre">BeautifulSoup(markup,</span>
    <span class="pre">"lxml")</span></code></td>
    <td><ul class="first last simple">
    <li>速度快</li>
    <li>文档容错能力强</li>
    </ul>
    </td>
    <td><ul class="first last simple">
    <li>需要安装C语言库</li>
    </ul>
    </td>
    </tr>
    <tr class="row-even"><td>lxml XML 解析器</td>
    <td><p class="first"><code class="docutils literal"><span class="pre">BeautifulSoup(markup,</span>
    <span class="pre">["lxml-xml"])</span></code></p>
    <p class="last"><code class="docutils literal"><span class="pre">BeautifulSoup(markup,</span>
    <span class="pre">"xml")</span></code></p>
    </td>
    <td><ul class="first last simple">
    <li>速度快</li>
    <li>唯一支持XML的解析器</li>
    </ul>
    </td>
    <td><ul class="first last simple">
    <li>需要安装C语言库</li>
    </ul>
    </td>
    </tr>
    <tr class="row-odd"><td>html5lib</td>
    <td><code class="docutils literal"><span class="pre">BeautifulSoup(markup,</span>
    <span class="pre">"html5lib")</span></code></td>
    <td><ul class="first last simple">
    <li>最好的容错性</li>
    <li>以浏览器的方式解析文档</li>
    <li>生成HTML5格式的文档</li>
    </ul>
    </td>
    <td><ul class="first last simple">
    <li>速度慢</li>
    <li>不依赖外部扩展</li>
    </ul>
    </td>
    </tr>
    </tbody>
    </table></div>
    <p>推荐使用lxml作为解析器,因为效率更高. 在Python2.7.3之前的版本和Python3中3.2.2之前的版本,必须安装lxml或html5lib, 因为那些Python版本的标准库中内置的HTML解析方法不够稳定.</p>
    <p>提示: 如果一段HTML或XML文档格式不正确的话,那么在不同的解析器中返回的结果可能是不一样的,查看 <a class="reference internal" href="#id53">解析器之间的区别</a>  了解更多细节</p>
    </div>
    </div>
    <div class="section" id="id13">
    <h1>如何使用<a class="headerlink" href="#id13" title="永久链接至标题"></a></h1>
    <p>将一段文档传入BeautifulSoup 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄.</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
    
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s2">"index.html"</span><span class="p">))</span>
    
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;html&gt;data&lt;/html&gt;"</span><span class="p">)</span>
    </code></pre></div>
    </div>
    <p>首先,文档被转换成Unicode,并且HTML的实例都被转换成Unicode编码</p>
    <div><div><pre><code class="language-python"><span></span>BeautifulSoup("Sacr&amp;eacute; bleu!")
    &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Sacré bleu!&lt;/body&gt;&lt;/html&gt;
    </code></pre></div>
    </div>
    <p>然后,Beautiful Soup选择最合适的解析器来解析这段文档,如果手动指定解析器那么Beautiful Soup会选择指定的解析器来解析文档.(参考 <a class="reference internal" href="#xml">解析成XML</a> ).</p>
    </div>
    <div class="section" id="id14">
    <h1>对象的种类<a class="headerlink" href="#id14" title="永久链接至标题"></a></h1>
    <p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种:
    <code class="docutils literal"><span class="pre">Tag</span></code> , <code class="docutils literal"><span class="pre">NavigableString</span></code> , <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> , <code class="docutils literal"><span class="pre">Comment</span></code> .</p>
    <div class="section" id="tag">
    <h2>Tag<a class="headerlink" href="#tag" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">Tag</span></code> 对象与XML或HTML原生文档中的tag相同:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">'&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;'</span><span class="p">)</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
    <span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
    <span class="c1"># &lt;class 'bs4.element.Tag'&gt;</span>
    </code></pre></div>
    </div>
    <p>Tag有很多方法和属性,在 <a class="reference internal" href="#id18">遍历文档树</a> 和 <a class="reference internal" href="#id27">搜索文档树</a> 中有详细解释.现在介绍一下tag中最重要的属性: name和attributes</p>
    <div class="section" id="name">
    <h3>Name<a class="headerlink" href="#name" title="永久链接至标题"></a></h3>
    <p>每个tag都有自己的名字,通过 <code class="docutils literal"><span class="pre">.name</span></code> 来获取:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">tag</span><span class="o">.</span><span class="n">name</span>
    <span class="c1"># u'b'</span>
    </code></pre></div>
    </div>
    <p>如果改变了tag的name,那将影响所有通过当前Beautiful Soup对象生成的HTML文档:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">tag</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"blockquote"</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;blockquote class="boldest"&gt;Extremely bold&lt;/blockquote&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="attributes">
    <h3>Attributes<a class="headerlink" href="#attributes" title="永久链接至标题"></a></h3>
    <p>一个tag可能有很多个属性. tag <code class="docutils literal"><span class="pre">&lt;b</span> <span class="pre">class="boldest"&gt;</span></code> 有一个 “class” 的属性,值为 “boldest” . tag的属性的操作方法与字典相同:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">tag</span><span class="p">[</span><span class="s1">'class'</span><span class="p">]</span>
    <span class="c1"># u'boldest'</span>
    </code></pre></div>
    </div>
    <p>也可以直接”点”取属性, 比如: <code class="docutils literal"><span class="pre">.attrs</span></code> :</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">tag</span><span class="o">.</span><span class="n">attrs</span>
    <span class="c1"># {u'class': u'boldest'}</span>
    </code></pre></div>
    </div>
    <p>tag的属性可以被添加,删除或修改. 再说一次, tag的属性操作方法与字典一样</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">tag</span><span class="p">[</span><span class="s1">'class'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'verybold'</span>
    <span class="n">tag</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;blockquote class="verybold" id="1"&gt;Extremely bold&lt;/blockquote&gt;</span>
    
    <span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">'class'</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span>
    
    <span class="n">tag</span><span class="p">[</span><span class="s1">'class'</span><span class="p">]</span>
    <span class="c1"># KeyError: 'class'</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'class'</span><span class="p">))</span>
    <span class="c1"># None</span>
    </code></pre></div>
    </div>
    <div class="section" id="id15">
    <h4>多值属性<a class="headerlink" href="#id15" title="永久链接至标题"></a></h4>
    <p>HTML 4定义了一系列可以包含多个值的属性.在HTML5中移除了一些,却增加更多.最常见的多值的属性是 class (一个tag可以有多个CSS的class). 还有一些属性 <code class="docutils literal"><span class="pre">rel</span></code> , <code class="docutils literal"><span class="pre">rev</span></code> , <code class="docutils literal"><span class="pre">accept-charset</span></code> , <code class="docutils literal"><span class="pre">headers</span></code> , <code class="docutils literal"><span class="pre">accesskey</span></code> . 在Beautiful Soup中多值属性的返回类型是list:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">'&lt;p class="body strikeout"&gt;&lt;/p&gt;'</span><span class="p">)</span>
    <span class="n">css_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">'class'</span><span class="p">]</span>
    <span class="c1"># ["body", "strikeout"]</span>
    
    <span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">'&lt;p class="body"&gt;&lt;/p&gt;'</span><span class="p">)</span>
    <span class="n">css_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">'class'</span><span class="p">]</span>
    <span class="c1"># ["body"]</span>
    </code></pre></div>
    </div>
    <p>如果某个属性看起来好像有多个值,但在任何版本的HTML定义中都没有被定义为多值属性,那么Beautiful Soup会将这个属性作为字符串返回</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">id_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">'&lt;p id="my id"&gt;&lt;/p&gt;'</span><span class="p">)</span>
    <span class="n">id_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span>
    <span class="c1"># 'my id'</span>
    </code></pre></div>
    </div>
    <p>将tag转换成字符串时,多值属性会合并为一个值</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">rel_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">'&lt;p&gt;Back to the &lt;a rel="index"&gt;homepage&lt;/a&gt;&lt;/p&gt;'</span><span class="p">)</span>
    <span class="n">rel_soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">'rel'</span><span class="p">]</span>
    <span class="c1"># ['index']</span>
    <span class="n">rel_soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">'rel'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'index'</span><span class="p">,</span> <span class="s1">'contents'</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">rel_soup</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
    <span class="c1"># &lt;p&gt;Back to the &lt;a rel="index contents"&gt;homepage&lt;/a&gt;&lt;/p&gt;</span>
    </code></pre></div>
    </div>
    <p>如果转换的文档是XML格式,那么tag中不包含多值属性</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">xml_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">'&lt;p class="body strikeout"&gt;&lt;/p&gt;'</span><span class="p">,</span> <span class="s1">'xml'</span><span class="p">)</span>
    <span class="n">xml_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">'class'</span><span class="p">]</span>
    <span class="c1"># u'body strikeout'</span>
    </code></pre></div>
    </div>
    </div>
    </div>
    </div>
    <div class="section" id="id16">
    <h2>可以遍历的字符串<a class="headerlink" href="#id16" title="永久链接至标题"></a></h2>
    <p>字符串常被包含在tag内.Beautiful Soup用 <code class="docutils literal"><span class="pre">NavigableString</span></code> 类来包装tag中的字符串:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">tag</span><span class="o">.</span><span class="n">string</span>
    <span class="c1"># u'Extremely bold'</span>
    <span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
    <span class="c1"># &lt;class 'bs4.element.NavigableString'&gt;</span>
    </code></pre></div>
    </div>
    <p>一个 <code class="docutils literal"><span class="pre">NavigableString</span></code> 字符串与Python中的Unicode字符串相同,并且还支持包含在 <a class="reference internal" href="#id18">遍历文档树</a> 和 <a class="reference internal" href="#id27">搜索文档树</a> 中的一些特性. 通过 <code class="docutils literal"><span class="pre">unicode()</span></code> 方法可以直接将 <code class="docutils literal"><span class="pre">NavigableString</span></code> 对象转换成Unicode字符串:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">unicode_string</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
    <span class="n">unicode_string</span>
    <span class="c1"># u'Extremely bold'</span>
    <span class="nb">type</span><span class="p">(</span><span class="n">unicode_string</span><span class="p">)</span>
    <span class="c1"># &lt;type 'unicode'&gt;</span>
    </code></pre></div>
    </div>
    <p>tag中包含的字符串不能编辑,但是可以被替换成其它的字符串,用 <a class="reference internal" href="#replace-with">replace_with()</a> 方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="s2">"No longer bold"</span><span class="p">)</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;blockquote&gt;No longer bold&lt;/blockquote&gt;</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">NavigableString</span></code> 对象支持 <a class="reference internal" href="#id18">遍历文档树</a> 和 <a class="reference internal" href="#id27">搜索文档树</a> 中定义的大部分属性, 并非全部.尤其是,一个字符串不能包含其它内容(tag能够包含字符串或是其它tag),字符串不支持 <code class="docutils literal"><span class="pre">.contents</span></code> 或 <code class="docutils literal"><span class="pre">.string</span></code> 属性或 <code class="docutils literal"><span class="pre">find()</span></code> 方法.</p>
    <p>如果想在Beautiful Soup之外使用 <code class="docutils literal"><span class="pre">NavigableString</span></code> 对象,需要调用 <code class="docutils literal"><span class="pre">unicode()</span></code> 方法,将该对象转换成普通的Unicode字符串,否则就算Beautiful Soup已方法已经执行结束,该对象的输出也会带有对象的引用地址.这样会浪费内存.</p>
    </div>
    <div class="section" id="beautifulsoup">
    <h2>BeautifulSoup<a class="headerlink" href="#beautifulsoup" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象表示的是一个文档的全部内容.大部分时候,可以把它当作 <code class="docutils literal"><span class="pre">Tag</span></code> 对象,它支持 <a class="reference internal" href="#id18">遍历文档树</a> 和 <a class="reference internal" href="#id27">搜索文档树</a> 中描述的大部分的方法.</p>
    <p>因为 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 <code class="docutils literal"><span class="pre">.name</span></code> 属性是很方便的,所以 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象包含了一个值为 “[document]” 的特殊属性 <code class="docutils literal"><span class="pre">.name</span></code></p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">name</span>
    <span class="c1"># u'[document]'</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="id17">
    <h2>注释及特殊字符串<a class="headerlink" href="#id17" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">Tag</span></code> , <code class="docutils literal"><span class="pre">NavigableString</span></code> , <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 几乎覆盖了html和xml中的所有内容,但是还有一些特殊对象.容易让人担心的内容是文档的注释部分:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">"&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;"</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="n">comment</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span>
    <span class="nb">type</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
    <span class="c1"># &lt;class 'bs4.element.Comment'&gt;</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">Comment</span></code> 对象是一个特殊类型的 <code class="docutils literal"><span class="pre">NavigableString</span></code> 对象:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">comment</span>
    <span class="c1"># u'Hey, buddy. Want to buy a used parser'</span>
    </code></pre></div>
    </div>
    <p>但是当它出现在HTML文档中时, <code class="docutils literal"><span class="pre">Comment</span></code> 对象会使用特殊的格式输出:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
    <span class="c1"># &lt;b&gt;</span>
    <span class="c1">#  &lt;!--Hey, buddy. Want to buy a used parser?--&gt;</span>
    <span class="c1"># &lt;/b&gt;</span>
    </code></pre></div>
    </div>
    <p>Beautiful Soup中定义的其它类型都可能会出现在XML的文档中: <code class="docutils literal"><span class="pre">CData</span></code> , <code class="docutils literal"><span class="pre">ProcessingInstruction</span></code> , <code class="docutils literal"><span class="pre">Declaration</span></code> , <code class="docutils literal"><span class="pre">Doctype</span></code> .与 <code class="docutils literal"><span class="pre">Comment</span></code> 对象类似,这些类都是 <code class="docutils literal"><span class="pre">NavigableString</span></code> 的子类,只是添加了一些额外的方法的字符串独享.下面是用CDATA来替代注释的例子:</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">CData</span>
    <span class="n">cdata</span> <span class="o">=</span> <span class="n">CData</span><span class="p">(</span><span class="s2">"A CDATA block"</span><span class="p">)</span>
    <span class="n">comment</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">cdata</span><span class="p">)</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
    <span class="c1"># &lt;b&gt;</span>
    <span class="c1">#  &lt;![CDATA[A CDATA block]]&gt;</span>
    <span class="c1"># &lt;/b&gt;</span>
    </code></pre></div>
    </div>
    </div>
    </div>
    <div class="section" id="id18">
    <h1>遍历文档树<a class="headerlink" href="#id18" title="永久链接至标题"></a></h1>
    <p>还拿”爱丽丝梦游仙境”的文档来做例子:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">"""</span>
    <span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span>
    <span class="s2">    &lt;body&gt;</span>
    <span class="s2">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span>
    
    <span class="s2">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span>
    <span class="s2">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="s2">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span>
    <span class="s2">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span>
    <span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>
    
    <span class="s2">&lt;p class="story"&gt;...&lt;/p&gt;</span>
    <span class="s2">"""</span>
    
    <span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">'html.parser'</span><span class="p">)</span>
    </code></pre></div>
    </div>
    <p>通过这段例子来演示怎样从文档的一段内容找到另一段内容</p>
    <div class="section" id="id19">
    <h2>子节点<a class="headerlink" href="#id19" title="永久链接至标题"></a></h2>
    <p>一个Tag可能包含多个字符串或其它的Tag,这些都是这个Tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性.</p>
    <p>注意: Beautiful Soup中字符串节点不支持这些属性,因为字符串没有子节点</p>
    <div class="section" id="id20">
    <h3>tag的名字<a class="headerlink" href="#id20" title="永久链接至标题"></a></h3>
    <p>操作文档树最简单的方法就是告诉它你想获取的tag的name.如果想获取 &lt;head&gt; 标签,只要用 <code class="docutils literal"><span class="pre">soup.head</span></code> :</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">head</span>
    <span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">title</span>
    <span class="c1"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span>
    </code></pre></div>
    </div>
    <p>这是个获取tag的小窍门,可以在文档树的tag中多次调用这个方法.下面的代码可以获取&lt;body&gt;标签中的第一个&lt;b&gt;标签:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">b</span>
    <span class="c1"># &lt;b&gt;The Dormouse's story&lt;/b&gt;</span>
    </code></pre></div>
    </div>
    <p>通过点取属性的方式只能获得当前名字的第一个tag:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    <p>如果想要得到所有的&lt;a&gt;标签,或是通过名字得到比一个tag更多的内容的时候,就需要用到 <cite>Searching the tree</cite> 中描述的方法,比如: find_all()</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="contents-children">
    <h3>.contents 和 .children<a class="headerlink" href="#contents-children" title="永久链接至标题"></a></h3>
    <p>tag的 <code class="docutils literal"><span class="pre">.contents</span></code> 属性可以将tag的子节点以列表的方式输出:</p>
    <div><div><pre><code class="language-python"><span></span>head_tag = soup.head
    head_tag
    # &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;
    
    head_tag.contents
    [&lt;title&gt;The Dormouse's story&lt;/title&gt;]
    
    title_tag = head_tag.contents[0]
    title_tag
    # &lt;title&gt;The Dormouse's story&lt;/title&gt;
    title_tag.contents
    # [u'The Dormouse's story']
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象本身一定会包含子节点,也就是说&lt;html&gt;标签也是 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象的子节点:</p>
    <div><div><pre><code class="language-python"><span></span><span class="nb">len</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">contents</span><span class="p">)</span>
    <span class="c1"># 1</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
    <span class="c1"># u'html'</span>
    </code></pre></div>
    </div>
    <p>字符串没有 <code class="docutils literal"><span class="pre">.contents</span></code> 属性,因为字符串没有子节点:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">text</span> <span class="o">=</span> <span class="n">title_tag</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">text</span><span class="o">.</span><span class="n">contents</span>
    <span class="c1"># AttributeError: 'NavigableString' object has no attribute 'contents'</span>
    </code></pre></div>
    </div>
    <p>通过tag的 <code class="docutils literal"><span class="pre">.children</span></code> 生成器,可以对tag的子节点进行循环:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">title_tag</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="c1"># The Dormouse's story</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="descendants">
    <h3>.descendants<a class="headerlink" href="#descendants" title="永久链接至标题"></a></h3>
    <p><code class="docutils literal"><span class="pre">.contents</span></code> 和 <code class="docutils literal"><span class="pre">.children</span></code> 属性仅包含tag的直接子节点.例如,&lt;head&gt;标签只有一个直接子节点&lt;title&gt;</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
    <span class="c1"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span>
    </code></pre></div>
    </div>
    <p>但是&lt;title&gt;标签也包含一个子节点:字符串 “The Dormouse’s story”,这种情况下字符串 “The Dormouse’s story”也属于&lt;head&gt;标签的子孙节点. <code class="docutils literal"><span class="pre">.descendants</span></code> 属性可以对所有tag的子孙节点进行递归循环 <a class="footnote-reference" href="#id92" id="id21">[5]</a> :</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">head_tag</span><span class="o">.</span><span class="n">descendants</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="c1"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span>
        <span class="c1"># The Dormouse's story</span>
    </code></pre></div>
    </div>
    <p>上面的例子中, &lt;head&gt;标签只有一个子节点,但是有2个子孙节点:&lt;head&gt;节点和&lt;head&gt;的子节点, <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 有一个直接子节点(&lt;html&gt;节点),却有很多子孙节点:</p>
    <div><div><pre><code class="language-python"><span></span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
    <span class="c1"># 1</span>
    <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">descendants</span><span class="p">))</span>
    <span class="c1"># 25</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="string">
    <h3>.string<a class="headerlink" href="#string" title="永久链接至标题"></a></h3>
    <p>如果tag只有一个 <code class="docutils literal"><span class="pre">NavigableString</span></code> 类型子节点,那么这个tag可以使用 <code class="docutils literal"><span class="pre">.string</span></code> 得到子节点:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">title_tag</span><span class="o">.</span><span class="n">string</span>
    <span class="c1"># u'The Dormouse's story'</span>
    </code></pre></div>
    </div>
    <p>如果一个tag仅有一个子节点,那么这个tag也可以使用 <code class="docutils literal"><span class="pre">.string</span></code> 方法,输出结果与当前唯一子节点的 <code class="docutils literal"><span class="pre">.string</span></code> 结果相同:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
    <span class="c1"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span>
    
    <span class="n">head_tag</span><span class="o">.</span><span class="n">string</span>
    <span class="c1"># u'The Dormouse's story'</span>
    </code></pre></div>
    </div>
    <p>如果tag包含了多个子节点,tag就无法确定 <code class="docutils literal"><span class="pre">.string</span></code> 方法应该调用哪个子节点的内容, <code class="docutils literal"><span class="pre">.string</span></code> 的输出结果是 <code class="docutils literal"><span class="pre">None</span></code> :</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
    <span class="c1"># None</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="strings-stripped-strings">
    <h3>.strings 和 stripped_strings<a class="headerlink" href="#strings-stripped-strings" title="永久链接至标题"></a></h3>
    <p>如果tag中包含多个字符串 <a class="footnote-reference" href="#id89" id="id22">[2]</a> ,可以使用 <code class="docutils literal"><span class="pre">.strings</span></code> 来循环获取:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">strings</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
        <span class="c1"># u"The Dormouse's story"</span>
        <span class="c1"># u'\n\n'</span>
        <span class="c1"># u"The Dormouse's story"</span>
        <span class="c1"># u'\n\n'</span>
        <span class="c1"># u'Once upon a time there were three little sisters; and their names were\n'</span>
        <span class="c1"># u'Elsie'</span>
        <span class="c1"># u',\n'</span>
        <span class="c1"># u'Lacie'</span>
        <span class="c1"># u' and\n'</span>
        <span class="c1"># u'Tillie'</span>
        <span class="c1"># u';\nand they lived at the bottom of a well.'</span>
        <span class="c1"># u'\n\n'</span>
        <span class="c1"># u'...'</span>
        <span class="c1"># u'\n'</span>
    </code></pre></div>
    </div>
    <p>输出的字符串中可能包含了很多空格或空行,使用 <code class="docutils literal"><span class="pre">.stripped_strings</span></code> 可以去除多余空白内容:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">stripped_strings</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
        <span class="c1"># u"The Dormouse's story"</span>
        <span class="c1"># u"The Dormouse's story"</span>
        <span class="c1"># u'Once upon a time there were three little sisters; and their names were'</span>
        <span class="c1"># u'Elsie'</span>
        <span class="c1"># u','</span>
        <span class="c1"># u'Lacie'</span>
        <span class="c1"># u'and'</span>
        <span class="c1"># u'Tillie'</span>
        <span class="c1"># u';\nand they lived at the bottom of a well.'</span>
        <span class="c1"># u'...'</span>
    </code></pre></div>
    </div>
    <p>全部是空格的行会被忽略掉,段首和段末的空白会被删除</p>
    </div>
    </div>
    <div class="section" id="id23">
    <h2>父节点<a class="headerlink" href="#id23" title="永久链接至标题"></a></h2>
    <p>继续分析文档树,每个tag或字符串都有父节点:被包含在某个tag中</p>
    <div class="section" id="parent">
    <h3>.parent<a class="headerlink" href="#parent" title="永久链接至标题"></a></h3>
    <p>通过 <code class="docutils literal"><span class="pre">.parent</span></code> 属性来获取某个元素的父节点.在例子“爱丽丝”的文档中,&lt;head&gt;标签是&lt;title&gt;标签的父节点:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">title_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">title</span>
    <span class="n">title_tag</span>
    <span class="c1"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span>
    <span class="n">title_tag</span><span class="o">.</span><span class="n">parent</span>
    <span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span>
    </code></pre></div>
    </div>
    <p>文档title的字符串也有父节点:&lt;title&gt;标签</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">title_tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">parent</span>
    <span class="c1"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span>
    </code></pre></div>
    </div>
    <p>文档的顶层节点比如&lt;html&gt;的父节点是 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">html_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">html</span>
    <span class="nb">type</span><span class="p">(</span><span class="n">html_tag</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
    <span class="c1"># &lt;class 'bs4.BeautifulSoup'&gt;</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象的 <code class="docutils literal"><span class="pre">.parent</span></code> 是None:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
    <span class="c1"># None</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="parents">
    <h3>.parents<a class="headerlink" href="#parents" title="永久链接至标题"></a></h3>
    <p>通过元素的 <code class="docutils literal"><span class="pre">.parents</span></code> 属性可以递归得到元素的所有父辈节点,下面的例子使用了 <code class="docutils literal"><span class="pre">.parents</span></code> 方法遍历了&lt;a&gt;标签到根节点的所有节点.</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    <span class="n">link</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span>
    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">link</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="c1"># p</span>
    <span class="c1"># body</span>
    <span class="c1"># html</span>
    <span class="c1"># [document]</span>
    <span class="c1"># None</span>
    </code></pre></div>
    </div>
    </div>
    </div>
    <div class="section" id="id24">
    <h2>兄弟节点<a class="headerlink" href="#id24" title="永久链接至标题"></a></h2>
    <p>看一段简单的例子:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">sibling_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
    <span class="c1"># &lt;html&gt;</span>
    <span class="c1">#  &lt;body&gt;</span>
    <span class="c1">#   &lt;a&gt;</span>
    <span class="c1">#    &lt;b&gt;</span>
    <span class="c1">#     text1</span>
    <span class="c1">#    &lt;/b&gt;</span>
    <span class="c1">#    &lt;c&gt;</span>
    <span class="c1">#     text2</span>
    <span class="c1">#    &lt;/c&gt;</span>
    <span class="c1">#   &lt;/a&gt;</span>
    <span class="c1">#  &lt;/body&gt;</span>
    <span class="c1"># &lt;/html&gt;</span>
    </code></pre></div>
    </div>
    <p>因为&lt;b&gt;标签和&lt;c&gt;标签是同一层:他们是同一个元素的子节点,所以&lt;b&gt;和&lt;c&gt;可以被称为兄弟节点.一段文档以标准格式输出时,兄弟节点有相同的缩进级别.在代码中也可以使用这种关系.</p>
    <div class="section" id="next-sibling-previous-sibling">
    <h3>.next_sibling 和 .previous_sibling<a class="headerlink" href="#next-sibling-previous-sibling" title="永久链接至标题"></a></h3>
    <p>在文档树中,使用 <code class="docutils literal"><span class="pre">.next_sibling</span></code> 和 <code class="docutils literal"><span class="pre">.previous_sibling</span></code> 属性来查询兄弟节点:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">next_sibling</span>
    <span class="c1"># &lt;c&gt;text2&lt;/c&gt;</span>
    
    <span class="n">sibling_soup</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">previous_sibling</span>
    <span class="c1"># &lt;b&gt;text1&lt;/b&gt;</span>
    </code></pre></div>
    </div>
    <p>&lt;b&gt;标签有 <code class="docutils literal"><span class="pre">.next_sibling</span></code> 属性,但是没有 <code class="docutils literal"><span class="pre">.previous_sibling</span></code> 属性,因为&lt;b&gt;标签在同级节点中是第一个.同理,&lt;c&gt;标签有 <code class="docutils literal"><span class="pre">.previous_sibling</span></code> 属性,却没有 <code class="docutils literal"><span class="pre">.next_sibling</span></code> 属性:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">previous_sibling</span><span class="p">)</span>
    <span class="c1"># None</span>
    <span class="k">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
    <span class="c1"># None</span>
    </code></pre></div>
    </div>
    <p>例子中的字符串“text1”和“text2”不是兄弟节点,因为它们的父节点不同:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span>
    <span class="c1"># u'text1'</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
    <span class="c1"># None</span>
    </code></pre></div>
    </div>
    <p>实际文档中的tag的 <code class="docutils literal"><span class="pre">.next_sibling</span></code> 和 <code class="docutils literal"><span class="pre">.previous_sibling</span></code> 属性通常是字符串或空白. 看看“爱丽丝”文档:</p>
    <div><div><pre><code class="language-python"><span></span>&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;
    &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt;
    &lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;
    </code></pre></div>
    </div>
    <p>如果以为第一个&lt;a&gt;标签的 <code class="docutils literal"><span class="pre">.next_sibling</span></code> 结果是第二个&lt;a&gt;标签,那就错了,真实结果是第一个&lt;a&gt;标签和第二个&lt;a&gt;标签之间的顿号和换行符:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    <span class="n">link</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span>
    
    <span class="n">link</span><span class="o">.</span><span class="n">next_sibling</span>
    <span class="c1"># u',\n'</span>
    </code></pre></div>
    </div>
    <p>第二个&lt;a&gt;标签是顿号的 <code class="docutils literal"><span class="pre">.next_sibling</span></code> 属性:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">link</span><span class="o">.</span><span class="n">next_sibling</span><span class="o">.</span><span class="n">next_sibling</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="next-siblings-previous-siblings">
    <h3>.next_siblings 和 .previous_siblings<a class="headerlink" href="#next-siblings-previous-siblings" title="永久链接至标题"></a></h3>
    <p>通过 <code class="docutils literal"><span class="pre">.next_siblings</span></code> 和 <code class="docutils literal"><span class="pre">.previous_siblings</span></code> 属性可以对当前节点的兄弟节点迭代输出:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">next_siblings</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
        <span class="c1"># u',\n'</span>
        <span class="c1"># &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;</span>
        <span class="c1"># u' and\n'</span>
        <span class="c1"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span>
        <span class="c1"># u'; and they lived at the bottom of a well.'</span>
        <span class="c1"># None</span>
    
    <span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">"link3"</span><span class="p">)</span><span class="o">.</span><span class="n">previous_siblings</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
        <span class="c1"># ' and\n'</span>
        <span class="c1"># &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;</span>
        <span class="c1"># u',\n'</span>
        <span class="c1"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span>
        <span class="c1"># u'Once upon a time there were three little sisters; and their names were\n'</span>
        <span class="c1"># None</span>
    </code></pre></div>
    </div>
    </div>
    </div>
    <div class="section" id="id25">
    <h2>回退和前进<a class="headerlink" href="#id25" title="永久链接至标题"></a></h2>
    <p>看一下“爱丽丝” 文档:</p>
    <div><div><pre><code class="language-python"><span></span>&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;
    &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;
    </code></pre></div>
    </div>
    <p>HTML解析器把这段字符串转换成一连串的事件: “打开&lt;html&gt;标签”,”打开一个&lt;head&gt;标签”,”打开一个&lt;title&gt;标签”,”添加一段字符串”,”关闭&lt;title&gt;标签”,”打开&lt;p&gt;标签”,等等.Beautiful Soup提供了重现解析器初始化过程的方法.</p>
    <div class="section" id="next-element-previous-element">
    <h3>.next_element 和 .previous_element<a class="headerlink" href="#next-element-previous-element" title="永久链接至标题"></a></h3>
    <p><code class="docutils literal"><span class="pre">.next_element</span></code> 属性指向解析过程中下一个被解析的对象(字符串或tag),结果可能与 <code class="docutils literal"><span class="pre">.next_sibling</span></code> 相同,但通常是不一样的.</p>
    <p>这是“爱丽丝”文档中最后一个&lt;a&gt;标签,它的 <code class="docutils literal"><span class="pre">.next_sibling</span></code> 结果是一个字符串,因为当前的解析过程 <a class="footnote-reference" href="#id89" id="id26">[2]</a> 因为当前的解析过程因为遇到了&lt;a&gt;标签而中断了:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">last_a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">"a"</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">"link3"</span><span class="p">)</span>
    <span class="n">last_a_tag</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span>
    
    <span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_sibling</span>
    <span class="c1"># '; and they lived at the bottom of a well.'</span>
    </code></pre></div>
    </div>
    <p>但这个&lt;a&gt;标签的 <code class="docutils literal"><span class="pre">.next_element</span></code> 属性结果是在&lt;a&gt;标签被解析之后的解析内容,不是&lt;a&gt;标签后的句子部分,应该是字符串”Tillie”:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_element</span>
    <span class="c1"># u'Tillie'</span>
    </code></pre></div>
    </div>
    <p>这是因为在原始文档中,字符串“Tillie” 在分号前出现,解析器先进入&lt;a&gt;标签,然后是字符串“Tillie”,然后关闭&lt;/a&gt;标签,然后是分号和剩余部分.分号与&lt;a&gt;标签在同一层级,但是字符串“Tillie”会被先解析.</p>
    <p><code class="docutils literal"><span class="pre">.previous_element</span></code> 属性刚好与 <code class="docutils literal"><span class="pre">.next_element</span></code> 相反,它指向当前被解析的对象的前一个解析对象:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">last_a_tag</span><span class="o">.</span><span class="n">previous_element</span>
    <span class="c1"># u' and\n'</span>
    <span class="n">last_a_tag</span><span class="o">.</span><span class="n">previous_element</span><span class="o">.</span><span class="n">next_element</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="next-elements-previous-elements">
    <h3>.next_elements 和 .previous_elements<a class="headerlink" href="#next-elements-previous-elements" title="永久链接至标题"></a></h3>
    <p>通过 <code class="docutils literal"><span class="pre">.next_elements</span></code> 和 <code class="docutils literal"><span class="pre">.previous_elements</span></code> 的迭代器就可以向前或向后访问文档的解析内容,就好像文档正在被解析一样:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_elements</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
    <span class="c1"># u'Tillie'</span>
    <span class="c1"># u';\nand they lived at the bottom of a well.'</span>
    <span class="c1"># u'\n\n'</span>
    <span class="c1"># &lt;p class="story"&gt;...&lt;/p&gt;</span>
    <span class="c1"># u'...'</span>
    <span class="c1"># u'\n'</span>
    <span class="c1"># None</span>
    </code></pre></div>
    </div>
    </div>
    </div>
    </div>
    <div class="section" id="id27">
    <h1>搜索文档树<a class="headerlink" href="#id27" title="永久链接至标题"></a></h1>
    <p>Beautiful Soup定义了很多搜索方法,这里着重介绍2个: <code class="docutils literal"><span class="pre">find()</span></code> 和 <code class="docutils literal"><span class="pre">find_all()</span></code> .其它方法的参数和用法类似,请读者举一反三.</p>
    <p>再以“爱丽丝”文档作为例子:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">"""</span>
    <span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span>
    <span class="s2">&lt;body&gt;</span>
    <span class="s2">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span>
    
    <span class="s2">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span>
    <span class="s2">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="s2">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span>
    <span class="s2">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span>
    <span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>
    
    <span class="s2">&lt;p class="story"&gt;...&lt;/p&gt;</span>
    <span class="s2">"""</span>
    
    <span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">'html.parser'</span><span class="p">)</span>
    </code></pre></div>
    </div>
    <p>使用 <code class="docutils literal"><span class="pre">find_all()</span></code> 类似的方法可以查找到想要查找的文档内容</p>
    <div class="section" id="id28">
    <h2>过滤器<a class="headerlink" href="#id28" title="永久链接至标题"></a></h2>
    <p>介绍 <code class="docutils literal"><span class="pre">find_all()</span></code> 方法前,先介绍一下过滤器的类型 <a class="footnote-reference" href="#id90" id="id29">[3]</a> ,这些过滤器贯穿整个搜索的API.过滤器可以被用在tag的name中,节点的属性中,字符串中或他们的混合中.</p>
    <div class="section" id="id30">
    <h3>字符串<a class="headerlink" href="#id30" title="永久链接至标题"></a></h3>
    <p>最简单的过滤器是字符串.在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容,下面的例子用于查找文档中所有的&lt;b&gt;标签:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
    <span class="c1"># [&lt;b&gt;The Dormouse's story&lt;/b&gt;]</span>
    </code></pre></div>
    </div>
    <p>如果传入字节码参数,Beautiful Soup会当作UTF-8编码,可以传入一段Unicode 编码来避免Beautiful Soup解析编码出错</p>
    </div>
    <div class="section" id="id31">
    <h3>正则表达式<a class="headerlink" href="#id31" title="永久链接至标题"></a></h3>
    <p>如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 <code class="docutils literal"><span class="pre">match()</span></code> 来匹配内容.下面例子中找出所有以b开头的标签,这表示&lt;body&gt;和&lt;b&gt;标签都应该被找到:</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">re</span>
    <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">"^b"</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="c1"># body</span>
    <span class="c1"># b</span>
    </code></pre></div>
    </div>
    <p>下面代码找出所有名字中包含”t”的标签:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">"t"</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="c1"># html</span>
    <span class="c1"># title</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="id32">
    <h3>列表<a class="headerlink" href="#id32" title="永久链接至标题"></a></h3>
    <p>如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&lt;a&gt;标签和&lt;b&gt;标签:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">([</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">])</span>
    <span class="c1"># [&lt;b&gt;The Dormouse's story&lt;/b&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="true">
    <h3>True<a class="headerlink" href="#true" title="永久链接至标题"></a></h3>
    <p><code class="docutils literal"><span class="pre">True</span></code> 可以匹配任何值,下面代码查找到所有的tag,但是不会返回字符串节点</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="c1"># html</span>
    <span class="c1"># head</span>
    <span class="c1"># title</span>
    <span class="c1"># body</span>
    <span class="c1"># p</span>
    <span class="c1"># b</span>
    <span class="c1"># p</span>
    <span class="c1"># a</span>
    <span class="c1"># a</span>
    <span class="c1"># a</span>
    <span class="c1"># p</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="id33">
    <h3>方法<a class="headerlink" href="#id33" title="永久链接至标题"></a></h3>
    <p>如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数 <a class="footnote-reference" href="#id91" id="id34">[4]</a> ,如果这个方法返回 <code class="docutils literal"><span class="pre">True</span></code> 表示当前元素匹配并且被找到,如果不是则反回 <code class="docutils literal"><span class="pre">False</span></code></p>
    <p>下面方法校验了当前元素,如果包含 <code class="docutils literal"><span class="pre">class</span></code> 属性却不包含 <code class="docutils literal"><span class="pre">id</span></code> 属性,那么将返回 <code class="docutils literal"><span class="pre">True</span></code>:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">has_class_but_no_id</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s1">'class'</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s1">'id'</span><span class="p">)</span>
    </code></pre></div>
    </div>
    <p>将这个方法作为参数传入 <code class="docutils literal"><span class="pre">find_all()</span></code> 方法,将得到所有&lt;p&gt;标签:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">has_class_but_no_id</span><span class="p">)</span>
    <span class="c1"># [&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;,</span>
    <span class="c1">#  &lt;p class="story"&gt;Once upon a time there were...&lt;/p&gt;,</span>
    <span class="c1">#  &lt;p class="story"&gt;...&lt;/p&gt;]</span>
    </code></pre></div>
    </div>
    <p>返回结果中只有&lt;p&gt;标签没有&lt;a&gt;标签,因为&lt;a&gt;标签还定义了”id”,没有返回&lt;html&gt;和&lt;head&gt;,因为&lt;html&gt;和&lt;head&gt;中没有定义”class”属性.</p>
    <p>通过一个方法来过滤一类标签属性的时候, 这个方法的参数是要被过滤的属性的值, 而不是这个标签.
    下面的例子是找出 <code class="docutils literal"><span class="pre">href</span></code> 属性不符合指定正则的 <code class="docutils literal"><span class="pre">a</span></code> 标签.</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">not_lacie</span><span class="p">(</span><span class="n">href</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">href</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">"lacie"</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">href</span><span class="p">)</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">not_lacie</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>标签过滤方法可以使用复杂方法. 下面的例子可以过滤出前后都有文字的标签.</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">NavigableString</span>
    <span class="k">def</span> <span class="nf">surrounded_by_strings</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">next_element</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">previous_element</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">surrounded_by_strings</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">tag</span><span class="o">.</span><span class="n">name</span>
    <span class="c1"># p</span>
    <span class="c1"># a</span>
    <span class="c1"># a</span>
    <span class="c1"># a</span>
    <span class="c1"># p</span>
    </code></pre></div>
    </div>
    <p>现在来了解一下搜索方法的细节</p>
    </div>
    </div>
    <div class="section" id="find-all">
    <h2>find_all()<a class="headerlink" href="#find-all" title="永久链接至标题"></a></h2>
    <p>find_all( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p><code class="docutils literal"><span class="pre">find_all()</span></code> 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件.这里有几个例子:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"title"</span><span class="p">)</span>
    <span class="c1"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"p"</span><span class="p">,</span> <span class="s2">"title"</span><span class="p">)</span>
    <span class="c1"># [&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">"link2"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span>
    
    <span class="kn">import</span> <span class="nn">re</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">"sisters"</span><span class="p">))</span>
    <span class="c1"># u'Once upon a time there were three little sisters; and their names were\n'</span>
    </code></pre></div>
    </div>
    <p>有几个方法很相似,还有几个方法是新的,参数中的 <code class="docutils literal"><span class="pre">string</span></code> 和 <code class="docutils literal"><span class="pre">id</span></code> 是什么含义? 为什么 <code class="docutils literal"><span class="pre">find_all("p",</span> <span class="pre">"title")</span></code> 返回的是CSS Class为”title”的&lt;p&gt;标签? 我们来仔细看一下 <code class="docutils literal"><span class="pre">find_all()</span></code> 的参数</p>
    <div class="section" id="id35">
    <h3>name 参数<a class="headerlink" href="#id35" title="永久链接至标题"></a></h3>
    <p><code class="docutils literal"><span class="pre">name</span></code> 参数可以查找所有名字为 <code class="docutils literal"><span class="pre">name</span></code> 的tag,字符串对象会被自动忽略掉.</p>
    <p>简单的用法如下:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"title"</span><span class="p">)</span>
    <span class="c1"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span>
    </code></pre></div>
    </div>
    <p>重申: 搜索 <code class="docutils literal"><span class="pre">name</span></code> 参数的值可以使任一类型的 <a class="reference internal" href="#id28">过滤器</a> ,字符窜,正则表达式,列表,方法或是 <code class="docutils literal"><span class="pre">True</span></code> .</p>
    </div>
    <div class="section" id="keyword">
    <h3>keyword 参数<a class="headerlink" href="#keyword" title="永久链接至标题"></a></h3>
    <p>如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索,如果包含一个名字为 <code class="docutils literal"><span class="pre">id</span></code> 的参数,Beautiful Soup会搜索每个tag的”id”属性.</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">'link2'</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>如果传入 <code class="docutils literal"><span class="pre">href</span></code> 参数,Beautiful Soup会搜索每个tag的”href”属性:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">"elsie"</span><span class="p">))</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>搜索指定名字的属性时可以使用的参数值包括 <a class="reference internal" href="#id30">字符串</a> , <a class="reference internal" href="#id31">正则表达式</a> , <a class="reference internal" href="#id32">列表</a>, <a class="reference internal" href="#true">True</a> .</p>
    <p>下面的例子在文档树中查找所有包含 <code class="docutils literal"><span class="pre">id</span></code> 属性的tag,无论 <code class="docutils literal"><span class="pre">id</span></code> 的值是什么:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>使用多个指定名字的参数可以同时过滤tag的多个属性:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">"elsie"</span><span class="p">),</span> <span class="nb">id</span><span class="o">=</span><span class="s1">'link1'</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;three&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">data_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">'&lt;div data-foo="value"&gt;foo!&lt;/div&gt;'</span><span class="p">)</span>
    <span class="n">data_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">data</span><span class="o">-</span><span class="n">foo</span><span class="o">=</span><span class="s2">"value"</span><span class="p">)</span>
    <span class="c1"># SyntaxError: keyword can't be an expression</span>
    </code></pre></div>
    </div>
    <p>但是可以通过 <code class="docutils literal"><span class="pre">find_all()</span></code> 方法的 <code class="docutils literal"><span class="pre">attrs</span></code> 参数定义一个字典参数来搜索包含特殊属性的tag:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">data_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">"data-foo"</span><span class="p">:</span> <span class="s2">"value"</span><span class="p">})</span>
    <span class="c1"># [&lt;div data-foo="value"&gt;foo!&lt;/div&gt;]</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="css">
    <h3>按CSS搜索<a class="headerlink" href="#css" title="永久链接至标题"></a></h3>
    <p>按照CSS类名搜索tag的功能非常实用,但标识CSS类名的关键字 <code class="docutils literal"><span class="pre">class</span></code> 在Python中是保留字,使用 <code class="docutils literal"><span class="pre">class</span></code> 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 <code class="docutils literal"><span class="pre">class_</span></code> 参数搜索有指定CSS类名的tag:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"a"</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">"sister"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">class_</span></code> 参数同样接受不同类型的 <code class="docutils literal"><span class="pre">过滤器</span></code> ,字符串,正则表达式,方法或 <code class="docutils literal"><span class="pre">True</span></code> :</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">"itl"</span><span class="p">))</span>
    <span class="c1"># [&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;]</span>
    
    <span class="k">def</span> <span class="nf">has_six_characters</span><span class="p">(</span><span class="n">css_class</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">css_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">css_class</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="n">has_six_characters</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>tag的 <code class="docutils literal"><span class="pre">class</span></code> 属性是 <a class="reference internal" href="#id15">多值属性</a> .按照CSS类名搜索tag时,可以分别搜索tag中的每个CSS类名:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">'&lt;p class="body strikeout"&gt;&lt;/p&gt;'</span><span class="p">)</span>
    <span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"p"</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">"strikeout"</span><span class="p">)</span>
    <span class="c1"># [&lt;p class="body strikeout"&gt;&lt;/p&gt;]</span>
    
    <span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"p"</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">"body"</span><span class="p">)</span>
    <span class="c1"># [&lt;p class="body strikeout"&gt;&lt;/p&gt;]</span>
    </code></pre></div>
    </div>
    <p>搜索 <code class="docutils literal"><span class="pre">class</span></code> 属性时也可以通过CSS值完全匹配:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"p"</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">"body strikeout"</span><span class="p">)</span>
    <span class="c1"># [&lt;p class="body strikeout"&gt;&lt;/p&gt;]</span>
    </code></pre></div>
    </div>
    <p>完全匹配 <code class="docutils literal"><span class="pre">class</span></code> 的值时,如果CSS类名的顺序与实际不符,将搜索不到结果:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"a"</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">"class"</span><span class="p">:</span> <span class="s2">"sister"</span><span class="p">})</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="id36">
    <h3><code class="docutils literal"><span class="pre">string</span></code> 参数<a class="headerlink" href="#id36" title="永久链接至标题"></a></h3>
    <p>通过 <code class="docutils literal"><span class="pre">string</span></code> 参数可以搜搜文档中的字符串内容.与 <code class="docutils literal"><span class="pre">name</span></code> 参数的可选值一样, <code class="docutils literal"><span class="pre">string</span></code> 参数接受 <a class="reference internal" href="#id30">字符串</a> , <a class="reference internal" href="#id31">正则表达式</a> , <a class="reference internal" href="#id32">列表</a>, <a class="reference internal" href="#true">True</a> . 看例子:</p>
    <div><div><pre><code class="language-python"><span></span>soup.find_all(string="Elsie")
    # [u'Elsie']
    
    soup.find_all(string=["Tillie", "Elsie", "Lacie"])
    # [u'Elsie', u'Lacie', u'Tillie']
    
    soup.find_all(string=re.compile("Dormouse"))
    [u"The Dormouse's story", u"The Dormouse's story"]
    
    def is_the_only_string_within_a_tag(s):
        ""Return True if this string is the only child of its parent tag.""
        return (s == s.parent.string)
    
    soup.find_all(string=is_the_only_string_within_a_tag)
    # [u"The Dormouse's story", u"The Dormouse's story", u'Elsie', u'Lacie', u'Tillie', u'...']
    </code></pre></div>
    </div>
    <p>虽然 <code class="docutils literal"><span class="pre">string</span></code> 参数用于搜索字符串,还可以与其它参数混合使用来过滤tag.Beautiful Soup会找到 <code class="docutils literal"><span class="pre">.string</span></code> 方法与 <code class="docutils literal"><span class="pre">string</span></code> 参数值相符的tag.下面代码用来搜索内容里面包含“Elsie”的&lt;a&gt;标签:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"a"</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s2">"Elsie"</span><span class="p">)</span>
    <span class="c1"># [&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="limit">
    <h3><code class="docutils literal"><span class="pre">limit</span></code> 参数<a class="headerlink" href="#limit" title="永久链接至标题"></a></h3>
    <p><code class="docutils literal"><span class="pre">find_all()</span></code> 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 <code class="docutils literal"><span class="pre">limit</span></code> 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 <code class="docutils literal"><span class="pre">limit</span></code> 的限制时,就停止搜索返回结果.</p>
    <p>文档树中有3个tag符合搜索条件,但结果只返回了2个,因为我们限制了返回数量:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"a"</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="recursive">
    <h3><code class="docutils literal"><span class="pre">recursive</span></code> 参数<a class="headerlink" href="#recursive" title="永久链接至标题"></a></h3>
    <p>调用tag的 <code class="docutils literal"><span class="pre">find_all()</span></code> 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 <code class="docutils literal"><span class="pre">recursive=False</span></code> .</p>
    <p>一段简单的文档:</p>
    <div><div><pre><code class="language-python"><span></span>&lt;html&gt;
     &lt;head&gt;
      &lt;title&gt;
       The Dormouse's story
      &lt;/title&gt;
     &lt;/head&gt;
    ...
    </code></pre></div>
    </div>
    <p>是否使用 <code class="docutils literal"><span class="pre">recursive</span></code> 参数的搜索结果:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"title"</span><span class="p">)</span>
    <span class="c1"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"title"</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="c1"># []</span>
    </code></pre></div>
    </div>
    <p>这是文档片段</p>
    <div><div><pre><code class="language-python"><span></span>&lt;html&gt;
            &lt;head&gt;
            &lt;title&gt;
            The Dormouse's story
        &lt;/title&gt;
            &lt;/head&gt;
            ...
    </code></pre></div>
    </div>
    <p>&lt;title&gt;标签在 &lt;html&gt; 标签下, 但并不是直接子节点, &lt;head&gt; 标签才是直接子节点.
    在允许查询所有后代节点时 Beautiful Soup 能够查找到 &lt;title&gt; 标签.
    但是使用了 <code class="docutils literal"><span class="pre">recursive=False</span></code>  参数之后,只能查找直接子节点,这样就查不到 &lt;title&gt; 标签了.</p>
    <p>Beautiful Soup 提供了多种DOM树搜索方法. 这些方法都使用了类似的参数定义.
    比如这些方法: <code class="docutils literal"><span class="pre">find_all()</span></code>: <code class="docutils literal"><span class="pre">name</span></code>, <code class="docutils literal"><span class="pre">attrs</span></code>, <code class="docutils literal"><span class="pre">text</span></code>, <code class="docutils literal"><span class="pre">limit</span></code>.
    但是只有 <code class="docutils literal"><span class="pre">find_all()</span></code> 和 <code class="docutils literal"><span class="pre">find()</span></code> 支持 <code class="docutils literal"><span class="pre">recursive</span></code> 参数.</p>
    </div>
    </div>
    <div class="section" id="find-all-tag">
    <h2>像调用 <code class="docutils literal"><span class="pre">find_all()</span></code> 一样调用tag<a class="headerlink" href="#find-all-tag" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">find_all()</span></code> 几乎是Beautiful Soup中最常用的搜索方法,所以我们定义了它的简写方法. <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象和 <code class="docutils literal"><span class="pre">tag</span></code> 对象可以被当作一个方法来使用,这个方法的执行结果与调用这个对象的 <code class="docutils literal"><span class="pre">find_all()</span></code> 方法相同,下面两行代码是等价的:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
    <span class="n">soup</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
    </code></pre></div>
    </div>
    <p>这两行代码也是等价的:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="find">
    <h2>find()<a class="headerlink" href="#find" title="永久链接至标题"></a></h2>
    <p>find( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p><code class="docutils literal"><span class="pre">find_all()</span></code> 方法将返回文档中符合条件的所有tag,尽管有时候我们只想得到一个结果.比如文档中只有一个&lt;body&gt;标签,那么使用 <code class="docutils literal"><span class="pre">find_all()</span></code> 方法来查找&lt;body&gt;标签就不太合适, 使用 <code class="docutils literal"><span class="pre">find_all</span></code> 方法并设置 <code class="docutils literal"><span class="pre">limit=1</span></code> 参数不如直接使用  <code class="docutils literal"><span class="pre">find()</span></code> 方法.下面两行代码是等价的:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">'title'</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">'title'</span><span class="p">)</span>
    <span class="c1"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span>
    </code></pre></div>
    </div>
    <p>唯一的区别是 <code class="docutils literal"><span class="pre">find_all()</span></code> 方法的返回结果是值包含一个元素的列表,而 <code class="docutils literal"><span class="pre">find()</span></code> 方法直接返回结果.</p>
    <p><code class="docutils literal"><span class="pre">find_all()</span></code> 方法没有找到目标是返回空列表, <code class="docutils literal"><span class="pre">find()</span></code> 方法找不到目标时,返回 <code class="docutils literal"><span class="pre">None</span></code> .</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">"nosuchtag"</span><span class="p">))</span>
    <span class="c1"># None</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">soup.head.title</span></code> 是 <a class="reference internal" href="#id20">tag的名字</a> 方法的简写.这个简写的原理就是多次调用当前tag的 <code class="docutils literal"><span class="pre">find()</span></code> 方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">title</span>
    <span class="c1"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">"head"</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">"title"</span><span class="p">)</span>
    <span class="c1"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="find-parents-find-parent">
    <h2>find_parents() 和 find_parent()<a class="headerlink" href="#find-parents-find-parent" title="永久链接至标题"></a></h2>
    <p>find_parents( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p>find_parent( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p>我们已经用了很大篇幅来介绍 <code class="docutils literal"><span class="pre">find_all()</span></code> 和 <code class="docutils literal"><span class="pre">find()</span></code> 方法,Beautiful Soup中还有10个用于搜索的API.它们中的五个用的是与 <code class="docutils literal"><span class="pre">find_all()</span></code> 相同的搜索参数,另外5个与 <code class="docutils literal"><span class="pre">find()</span></code> 方法的搜索参数类似.区别仅是它们搜索文档的不同部分.</p>
    <p>记住: <code class="docutils literal"><span class="pre">find_all()</span></code> 和 <code class="docutils literal"><span class="pre">find()</span></code> 只搜索当前节点的所有子节点,孙子节点等. <code class="docutils literal"><span class="pre">find_parents()</span></code> 和 <code class="docutils literal"><span class="pre">find_parent()</span></code> 用来搜索当前节点的父辈节点,搜索方法与普通tag的搜索方法相同,搜索文档搜索文档包含的内容. 我们从一个文档中的一个叶子节点开始:</p>
    <div><div><pre><code class="language-python"><span></span>a_string = soup.find(string="Lacie")
    a_string
    # u'Lacie'
    
    a_string.find_parents("a")
    # [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]
    
    a_string.find_parent("p")
    # &lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were
    #  &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,
    #  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt; and
    #  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;;
    #  and they lived at the bottom of a well.&lt;/p&gt;
    
    a_string.find_parents("p", class="title")
    # []
    </code></pre></div>
    </div>
    <p>文档中的一个&lt;a&gt;标签是是当前叶子节点的直接父节点,所以可以被找到.还有一个&lt;p&gt;标签,是目标叶子节点的间接父辈节点,所以也可以被找到.包含class值为”title”的&lt;p&gt;标签不是不是目标叶子节点的父辈节点,所以通过 <code class="docutils literal"><span class="pre">find_parents()</span></code> 方法搜索不到.</p>
    <p><code class="docutils literal"><span class="pre">find_parent()</span></code> 和 <code class="docutils literal"><span class="pre">find_parents()</span></code> 方法会让人联想到 <a class="reference internal" href="#parent">.parent</a> 和 <a class="reference internal" href="#parents">.parents</a> 属性.它们之间的联系非常紧密.搜索父辈节点的方法实际上就是对 <code class="docutils literal"><span class="pre">.parents</span></code> 属性的迭代搜索.</p>
    </div>
    <div class="section" id="find-next-siblings-find-next-sibling">
    <h2>find_next_siblings() 和 find_next_sibling()<a class="headerlink" href="#find-next-siblings-find-next-sibling" title="永久链接至标题"></a></h2>
    <p>find_next_siblings( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p>find_next_sibling( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p>这2个方法通过 <a class="reference internal" href="#next-siblings-previous-siblings">.next_siblings</a> 属性对当tag的所有后面解析 <a class="footnote-reference" href="#id92" id="id37">[5]</a> 的兄弟tag节点进行迭代, <code class="docutils literal"><span class="pre">find_next_siblings()</span></code> 方法返回所有符合条件的后面的兄弟节点, <code class="docutils literal"><span class="pre">find_next_sibling()</span></code> 只返回符合条件的后面的第一个tag节点.</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    <span class="n">first_link</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span>
    
    <span class="n">first_link</span><span class="o">.</span><span class="n">find_next_siblings</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    
    <span class="n">first_story_paragraph</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">"p"</span><span class="p">,</span> <span class="s2">"story"</span><span class="p">)</span>
    <span class="n">first_story_paragraph</span><span class="o">.</span><span class="n">find_next_sibling</span><span class="p">(</span><span class="s2">"p"</span><span class="p">)</span>
    <span class="c1"># &lt;p class="story"&gt;...&lt;/p&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="find-previous-siblings-find-previous-sibling">
    <h2>find_previous_siblings() 和 find_previous_sibling()<a class="headerlink" href="#find-previous-siblings-find-previous-sibling" title="永久链接至标题"></a></h2>
    <p>find_previous_siblings( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p>find_previous_sibling( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p>这2个方法通过 <a class="reference internal" href="#next-siblings-previous-siblings">.previous_siblings</a> 属性对当前tag的前面解析 <a class="footnote-reference" href="#id92" id="id38">[5]</a> 的兄弟tag节点进行迭代, <code class="docutils literal"><span class="pre">find_previous_siblings()</span></code> 方法返回所有符合条件的前面的兄弟节点, <code class="docutils literal"><span class="pre">find_previous_sibling()</span></code> 方法返回第一个符合条件的前面的兄弟节点:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">last_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">"a"</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">"link3"</span><span class="p">)</span>
    <span class="n">last_link</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span>
    
    <span class="n">last_link</span><span class="o">.</span><span class="n">find_previous_siblings</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span>
    
    <span class="n">first_story_paragraph</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">"p"</span><span class="p">,</span> <span class="s2">"story"</span><span class="p">)</span>
    <span class="n">first_story_paragraph</span><span class="o">.</span><span class="n">find_previous_sibling</span><span class="p">(</span><span class="s2">"p"</span><span class="p">)</span>
    <span class="c1"># &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="find-all-next-find-next">
    <h2>find_all_next() 和 find_next()<a class="headerlink" href="#find-all-next-find-next" title="永久链接至标题"></a></h2>
    <p>find_all_next( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p>find_next( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p>这2个方法通过 <a class="reference internal" href="#next-elements-previous-elements">.next_elements</a> 属性对当前tag的之后的 <a class="footnote-reference" href="#id92" id="id39">[5]</a> tag和字符串进行迭代, <code class="docutils literal"><span class="pre">find_all_next()</span></code> 方法返回所有符合条件的节点, <code class="docutils literal"><span class="pre">find_next()</span></code> 方法返回第一个符合条件的节点:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    <span class="n">first_link</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span>
    
    <span class="n">first_link</span><span class="o">.</span><span class="n">find_all_next</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c1"># [u'Elsie', u',\n', u'Lacie', u' and\n', u'Tillie',</span>
    <span class="c1">#  u';\nand they lived at the bottom of a well.', u'\n\n', u'...', u'\n']</span>
    
    <span class="n">first_link</span><span class="o">.</span><span class="n">find_next</span><span class="p">(</span><span class="s2">"p"</span><span class="p">)</span>
    <span class="c1"># &lt;p class="story"&gt;...&lt;/p&gt;</span>
    </code></pre></div>
    </div>
    <p>第一个例子中,字符串 “Elsie”也被显示出来,尽管它被包含在我们开始查找的&lt;a&gt;标签的里面.第二个例子中,最后一个&lt;p&gt;标签也被显示出来,尽管它与我们开始查找位置的&lt;a&gt;标签不属于同一部分.例子中,搜索的重点是要匹配过滤器的条件,并且在文档中出现的顺序而不是开始查找的元素的位置.</p>
    </div>
    <div class="section" id="find-all-previous-find-previous">
    <h2>find_all_previous() 和 find_previous()<a class="headerlink" href="#find-all-previous-find-previous" title="永久链接至标题"></a></h2>
    <p>find_all_previous( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p>find_previous( <a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> )</p>
    <p>这2个方法通过 <a class="reference internal" href="#next-elements-previous-elements">.previous_elements</a> 属性对当前节点前面 <a class="footnote-reference" href="#id92" id="id40">[5]</a> 的tag和字符串进行迭代, <code class="docutils literal"><span class="pre">find_all_previous()</span></code> 方法返回所有符合条件的节点, <code class="docutils literal"><span class="pre">find_previous()</span></code> 方法返回第一个符合条件的节点.</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    <span class="n">first_link</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span>
    
    <span class="n">first_link</span><span class="o">.</span><span class="n">find_all_previous</span><span class="p">(</span><span class="s2">"p"</span><span class="p">)</span>
    <span class="c1"># [&lt;p class="story"&gt;Once upon a time there were three little sisters; ...&lt;/p&gt;,</span>
    <span class="c1">#  &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;]</span>
    
    <span class="n">first_link</span><span class="o">.</span><span class="n">find_previous</span><span class="p">(</span><span class="s2">"title"</span><span class="p">)</span>
    <span class="c1"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">find_all_previous("p")</span></code> 返回了文档中的第一段(class=”title”的那段),但还返回了第二段,&lt;p&gt;标签包含了我们开始查找的&lt;a&gt;标签.不要惊讶,这段代码的功能是查找所有出现在指定&lt;a&gt;标签之前的&lt;p&gt;标签,因为这个&lt;p&gt;标签包含了开始的&lt;a&gt;标签,所以&lt;p&gt;标签一定是在&lt;a&gt;之前出现的.</p>
    </div>
    <div class="section" id="id41">
    <h2>CSS选择器<a class="headerlink" href="#id41" title="永久链接至标题"></a></h2>
    <p>Beautiful Soup支持大部分的CSS选择器 <a class="reference external" href="http://www.w3.org/TR/CSS2/selector.html">http://www.w3.org/TR/CSS2/selector.html</a> <a class="footnote-reference" href="#id93" id="id42">[6]</a> ,
    在 <code class="docutils literal"><span class="pre">Tag</span></code> 或 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象的 <code class="docutils literal"><span class="pre">.select()</span></code> 方法中传入字符串参数,
    即可使用CSS选择器的语法找到tag:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"title"</span><span class="p">)</span>
    <span class="c1"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"p nth-of-type(3)"</span><span class="p">)</span>
    <span class="c1"># [&lt;p class="story"&gt;...&lt;/p&gt;]</span>
    </code></pre></div>
    </div>
    <p>通过tag标签逐层查找:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"body a"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie"  id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"html head title"</span><span class="p">)</span>
    <span class="c1"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span>
    </code></pre></div>
    </div>
    <p>找到某个tag标签下的直接子标签 <a class="footnote-reference" href="#id93" id="id43">[6]</a> :</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"head &gt; title"</span><span class="p">)</span>
    <span class="c1"># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"p &gt; a"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie"  id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"p &gt; a:nth-of-type(2)"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"p &gt; #link1"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"body &gt; a"</span><span class="p">)</span>
    <span class="c1"># []</span>
    </code></pre></div>
    </div>
    <p>找到兄弟节点标签:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"#link1 ~ .sister"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie"  id="link3"&gt;Tillie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"#link1 + .sister"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>通过CSS的类名查找:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">".sister"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"[class~=sister]"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>通过tag的id查找:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"#link1"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"a#link2"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>同时用多种CSS选择器查询元素:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">"#link1,#link2"</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>通过是否存在某个属性来查找:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">'a[href]'</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>通过属性的值来查找:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">'a[href="http://example.com/elsie"]'</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">'a[href^="http://example.com/"]'</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span>
    <span class="c1">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">'a[href$="tillie"]'</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">'a[href*=".com/el"]'</span><span class="p">)</span>
    <span class="c1"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]</span>
    </code></pre></div>
    </div>
    <p>通过语言设置来查找:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">multilingual_markup</span> <span class="o">=</span> <span class="s2">"""</span>
    <span class="s2"> &lt;p lang="en"&gt;Hello&lt;/p&gt;</span>
    <span class="s2"> &lt;p lang="en-us"&gt;Howdy, y'all&lt;/p&gt;</span>
    <span class="s2"> &lt;p lang="en-gb"&gt;Pip-pip, old fruit&lt;/p&gt;</span>
    <span class="s2"> &lt;p lang="fr"&gt;Bonjour mes amis&lt;/p&gt;</span>
    <span class="s2">"""</span>
    <span class="n">multilingual_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">multilingual_markup</span><span class="p">)</span>
    <span class="n">multilingual_soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">'p[lang|=en]'</span><span class="p">)</span>
    <span class="c1"># [&lt;p lang="en"&gt;Hello&lt;/p&gt;,</span>
    <span class="c1">#  &lt;p lang="en-us"&gt;Howdy, y'all&lt;/p&gt;,</span>
    <span class="c1">#  &lt;p lang="en-gb"&gt;Pip-pip, old fruit&lt;/p&gt;]</span>
    </code></pre></div>
    </div>
    <p>返回查找到的元素的第一个</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select_one</span><span class="p">(</span><span class="s2">".sister"</span><span class="p">)</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    <p>对于熟悉CSS选择器语法的人来说这是个非常方便的方法.Beautiful Soup也支持CSS选择器API,
    如果你仅仅需要CSS选择器的功能,那么直接使用 <code class="docutils literal"><span class="pre">lxml</span></code> 也可以,
    而且速度更快,支持更多的CSS选择器语法,但Beautiful Soup整合了CSS选择器的语法和自身方便使用API.</p>
    </div>
    </div>
    <div class="section" id="id44">
    <h1>修改文档树<a class="headerlink" href="#id44" title="永久链接至标题"></a></h1>
    <p>Beautiful Soup的强项是文档树的搜索,但同时也可以方便的修改文档树</p>
    <div class="section" id="id45">
    <h2>修改tag的名称和属性<a class="headerlink" href="#id45" title="永久链接至标题"></a></h2>
    <p>在 <a class="reference internal" href="#attributes">Attributes</a> 的章节中已经介绍过这个功能,但是再看一遍也无妨. 重命名一个tag,改变属性的值,添加或删除属性:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">'&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;'</span><span class="p">)</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
    
    <span class="n">tag</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"blockquote"</span>
    <span class="n">tag</span><span class="p">[</span><span class="s1">'class'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'verybold'</span>
    <span class="n">tag</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;blockquote class="verybold" id="1"&gt;Extremely bold&lt;/blockquote&gt;</span>
    
    <span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">'class'</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="id46">
    <h2>修改 .string<a class="headerlink" href="#id46" title="永久链接至标题"></a></h2>
    <p>给tag的 <code class="docutils literal"><span class="pre">.string</span></code> 属性赋值,就相当于用当前的内容替代了原来的内容:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    
    <span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    <span class="n">tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">"New link text."</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;a href="http://example.com/"&gt;New link text.&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    <p>注意: 如果当前的tag包含了其它tag,那么给它的 <code class="docutils literal"><span class="pre">.string</span></code> 属性赋值会覆盖掉原有的所有内容包括子tag</p>
    </div>
    <div class="section" id="append">
    <h2>append()<a class="headerlink" href="#append" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">Tag.append()</span></code> 方法想tag中添加内容,就好像Python的列表的 <code class="docutils literal"><span class="pre">.append()</span></code> 方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;a&gt;Foo&lt;/a&gt;"</span><span class="p">)</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"Bar"</span><span class="p">)</span>
    
    <span class="n">soup</span>
    <span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;FooBar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">contents</span>
    <span class="c1"># [u'Foo', u'Bar']</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="navigablestring-new-tag">
    <h2>NavigableString() 和 .new_tag()<a class="headerlink" href="#navigablestring-new-tag" title="永久链接至标题"></a></h2>
    <p>如果想添加一段文本内容到文档中也没问题,可以调用Python的 <code class="docutils literal"><span class="pre">append()</span></code> 方法
    或调用 <code class="docutils literal"><span class="pre">NavigableString</span></code> 的构造方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;b&gt;&lt;/b&gt;"</span><span class="p">)</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
    <span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"Hello"</span><span class="p">)</span>
    <span class="n">new_string</span> <span class="o">=</span> <span class="n">NavigableString</span><span class="p">(</span><span class="s2">" there"</span><span class="p">)</span>
    <span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_string</span><span class="p">)</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;b&gt;Hello there.&lt;/b&gt;</span>
    <span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
    <span class="c1"># [u'Hello', u' there']</span>
    </code></pre></div>
    </div>
    <p>如果想要创建一段注释,或 <code class="docutils literal"><span class="pre">NavigableString</span></code> 的任何子类, 只要调用 NavigableString 的构造方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">Comment</span>
    <span class="n">new_comment</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_string</span><span class="p">(</span><span class="s2">"Nice to see you."</span><span class="p">,</span> <span class="n">Comment</span><span class="p">)</span>
    <span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_comment</span><span class="p">)</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;b&gt;Hello there&lt;!--Nice to see you.--&gt;&lt;/b&gt;</span>
    <span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
    <span class="c1"># [u'Hello', u' there', u'Nice to see you.']</span>
    </code></pre></div>
    </div>
    <p># 这是Beautiful Soup 4.2.1 中新增的方法</p>
    <p>创建一个tag最好的方法是调用工厂方法 <code class="docutils literal"><span class="pre">BeautifulSoup.new_tag()</span></code> :</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;b&gt;&lt;/b&gt;"</span><span class="p">)</span>
    <span class="n">original_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
    
    <span class="n">new_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">"a"</span><span class="p">,</span> <span class="n">href</span><span class="o">=</span><span class="s2">"http://www.example.com"</span><span class="p">)</span>
    <span class="n">original_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>
    <span class="n">original_tag</span>
    <span class="c1"># &lt;b&gt;&lt;a href="http://www.example.com"&gt;&lt;/a&gt;&lt;/b&gt;</span>
    
    <span class="n">new_tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">"Link text."</span>
    <span class="n">original_tag</span>
    <span class="c1"># &lt;b&gt;&lt;a href="http://www.example.com"&gt;Link text.&lt;/a&gt;&lt;/b&gt;</span>
    </code></pre></div>
    </div>
    <p>第一个参数作为tag的name,是必填,其它参数选填</p>
    </div>
    <div class="section" id="insert">
    <h2>insert()<a class="headerlink" href="#insert" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">Tag.insert()</span></code> 方法与 <code class="docutils literal"><span class="pre">Tag.append()</span></code> 方法类似,区别是不会把新元素添加到父节点 <code class="docutils literal"><span class="pre">.contents</span></code> 属性的最后,而是把元素插入到指定的位置.与Python列表总的 <code class="docutils literal"><span class="pre">.insert()</span></code> 方法的用法下同:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    
    <span class="n">tag</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"but did not endorse "</span><span class="p">)</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;a href="http://example.com/"&gt;I linked to but did not endorse &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;</span>
    <span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
    <span class="c1"># [u'I linked to ', u'but did not endorse', &lt;i&gt;example.com&lt;/i&gt;]</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="insert-before-insert-after">
    <h2>insert_before() 和 insert_after()<a class="headerlink" href="#insert-before-insert-after" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">insert_before()</span></code> 方法在当前tag或文本节点前插入内容:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;b&gt;stop&lt;/b&gt;"</span><span class="p">)</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">"i"</span><span class="p">)</span>
    <span class="n">tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">"Don't"</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">insert_before</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
    <span class="c1"># &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt;stop&lt;/b&gt;</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">insert_after()</span></code> 方法在当前tag或文本节点后插入内容:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">insert_after</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">new_string</span><span class="p">(</span><span class="s2">" ever "</span><span class="p">))</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
    <span class="c1"># &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt; ever stop&lt;/b&gt;</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">contents</span>
    <span class="c1"># [&lt;i&gt;Don't&lt;/i&gt;, u' ever ', u'stop']</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="clear">
    <h2>clear()<a class="headerlink" href="#clear" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">Tag.clear()</span></code> 方法移除当前tag的内容:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    
    <span class="n">tag</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">tag</span>
    <span class="c1"># &lt;a href="http://example.com/"&gt;&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="extract">
    <h2>extract()<a class="headerlink" href="#extract" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">PageElement.extract()</span></code> 方法将当前tag移除文档树,并作为方法结果返回:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    
    <span class="n">i_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>
    
    <span class="n">a_tag</span>
    <span class="c1"># &lt;a href="http://example.com/"&gt;I linked to&lt;/a&gt;</span>
    
    <span class="n">i_tag</span>
    <span class="c1"># &lt;i&gt;example.com&lt;/i&gt;</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">i_tag</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
    <span class="bp">None</span>
    </code></pre></div>
    </div>
    <p>这个方法实际上产生了2个文档树: 一个是用来解析原始文档的 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象,另一个是被移除并且返回的tag.被移除并返回的tag可以继续调用 <code class="docutils literal"><span class="pre">extract</span></code> 方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">my_string</span> <span class="o">=</span> <span class="n">i_tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>
    <span class="n">my_string</span>
    <span class="c1"># u'example.com'</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">my_string</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
    <span class="c1"># None</span>
    <span class="n">i_tag</span>
    <span class="c1"># &lt;i&gt;&lt;/i&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="decompose">
    <h2>decompose()<a class="headerlink" href="#decompose" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">Tag.decompose()</span></code> 方法将当前节点移除文档树并完全销毁:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span>
    
    <span class="n">a_tag</span>
    <span class="c1"># &lt;a href="http://example.com/"&gt;I linked to&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="replace-with">
    <h2>replace_with()<a class="headerlink" href="#replace-with" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">PageElement.replace_with()</span></code> 方法移除文档树中的某段内容,并用新tag或文本节点替代它:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    
    <span class="n">new_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">"b"</span><span class="p">)</span>
    <span class="n">new_tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">"example.net"</span>
    <span class="n">a_tag</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>
    
    <span class="n">a_tag</span>
    <span class="c1"># &lt;a href="http://example.com/"&gt;I linked to &lt;b&gt;example.net&lt;/b&gt;&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">replace_with()</span></code> 方法返回被替代的tag或文本节点,可以用来浏览或添加到文档树其它地方</p>
    </div>
    <div class="section" id="wrap">
    <h2>wrap()<a class="headerlink" href="#wrap" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">PageElement.wrap()</span></code> 方法可以对指定的tag元素进行包装 <a class="footnote-reference" href="#id95" id="id47">[8]</a> ,并返回包装后的结果:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;p&gt;I wish I was bold.&lt;/p&gt;"</span><span class="p">)</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">"b"</span><span class="p">))</span>
    <span class="c1"># &lt;b&gt;I wish I was bold.&lt;/b&gt;</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">"div"</span><span class="p">))</span>
    <span class="c1"># &lt;div&gt;&lt;p&gt;&lt;b&gt;I wish I was bold.&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;</span>
    </code></pre></div>
    </div>
    <p>该方法在 Beautiful Soup 4.0.5 中添加</p>
    </div>
    <div class="section" id="unwrap">
    <h2>unwrap()<a class="headerlink" href="#unwrap" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">Tag.unwrap()</span></code> 方法与 <code class="docutils literal"><span class="pre">wrap()</span></code> 方法相反.将移除tag内的所有tag标签,该方法常被用来进行标记的解包:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
    
    <span class="n">a_tag</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">unwrap</span><span class="p">()</span>
    <span class="n">a_tag</span>
    <span class="c1"># &lt;a href="http://example.com/"&gt;I linked to example.com&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    <p>与 <code class="docutils literal"><span class="pre">replace_with()</span></code> 方法相同, <code class="docutils literal"><span class="pre">unwrap()</span></code> 方法返回被移除的tag</p>
    </div>
    </div>
    <div class="section" id="id48">
    <h1>输出<a class="headerlink" href="#id48" title="永久链接至标题"></a></h1>
    <div class="section" id="id49">
    <h2>格式化输出<a class="headerlink" href="#id49" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">prettify()</span></code> 方法将Beautiful Soup的文档树格式化后以Unicode编码输出,每个XML/HTML标签都独占一行</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">()</span>
    <span class="c1"># '&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;a href="http://example.com/"&gt;\n...'</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
    <span class="c1"># &lt;html&gt;</span>
    <span class="c1">#  &lt;head&gt;</span>
    <span class="c1">#  &lt;/head&gt;</span>
    <span class="c1">#  &lt;body&gt;</span>
    <span class="c1">#   &lt;a href="http://example.com/"&gt;</span>
    <span class="c1">#    I linked to</span>
    <span class="c1">#    &lt;i&gt;</span>
    <span class="c1">#     example.com</span>
    <span class="c1">#    &lt;/i&gt;</span>
    <span class="c1">#   &lt;/a&gt;</span>
    <span class="c1">#  &lt;/body&gt;</span>
    <span class="c1"># &lt;/html&gt;</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象和它的tag节点都可以调用 <code class="docutils literal"><span class="pre">prettify()</span></code> 方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
    <span class="c1"># &lt;a href="http://example.com/"&gt;</span>
    <span class="c1">#  I linked to</span>
    <span class="c1">#  &lt;i&gt;</span>
    <span class="c1">#   example.com</span>
    <span class="c1">#  &lt;/i&gt;</span>
    <span class="c1"># &lt;/a&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="id50">
    <h2>压缩输出<a class="headerlink" href="#id50" title="永久链接至标题"></a></h2>
    <p>如果只想得到结果字符串,不重视格式,那么可以对一个 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象或 <code class="docutils literal"><span class="pre">Tag</span></code> 对象使用Python的 <code class="docutils literal"><span class="pre">unicode()</span></code> 或 <code class="docutils literal"><span class="pre">str()</span></code> 方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="nb">str</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
    <span class="c1"># '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'</span>
    
    <span class="nb">unicode</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># u'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">str()</span></code> 方法返回UTF-8编码的字符串,可以指定 <a class="reference internal" href="#id55">编码</a> 的设置.</p>
    <p>还可以调用 <code class="docutils literal"><span class="pre">encode()</span></code> 方法获得字节码或调用 <code class="docutils literal"><span class="pre">decode()</span></code> 方法获得Unicode.</p>
    </div>
    <div class="section" id="id51">
    <h2>输出格式<a class="headerlink" href="#id51" title="永久链接至标题"></a></h2>
    <p>Beautiful Soup输出是会将HTML中的特殊字符转换成Unicode,比如“&amp;lquot;”:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&amp;ldquo;Dammit!&amp;rdquo; he said."</span><span class="p">)</span>
    <span class="nb">unicode</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
    <span class="c1"># u'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\u201cDammit!\u201d he said.&lt;/body&gt;&lt;/html&gt;'</span>
    </code></pre></div>
    </div>
    <p>如果将文档转换成字符串,Unicode编码会被编码成UTF-8.这样就无法正确显示HTML特殊字符了:</p>
    <div><div><pre><code class="language-python"><span></span><span class="nb">str</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
    <span class="c1"># '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\xe2\x80\x9cDammit!\xe2\x80\x9d he said.&lt;/body&gt;&lt;/html&gt;'</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="get-text">
    <h2>get_text()<a class="headerlink" href="#get-text" title="永久链接至标题"></a></h2>
    <p>如果只想得到tag中包含的文本内容,那么可以嗲用 <code class="docutils literal"><span class="pre">get_text()</span></code> 方法,这个方法获取到tag中包含的所有文版内容包括子孙tag中的内容,并将结果作为Unicode字符串返回:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">'&lt;a href="http://example.com/"&gt;</span><span class="se">\n</span><span class="s1">I linked to &lt;i&gt;example.com&lt;/i&gt;</span><span class="se">\n</span><span class="s1">&lt;/a&gt;'</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
    <span class="s1">u'</span><span class="se">\n</span><span class="s1">I linked to example.com</span><span class="se">\n</span><span class="s1">'</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
    <span class="s1">u'example.com'</span>
    </code></pre></div>
    </div>
    <p>可以通过参数指定tag的文本内容的分隔符:</p>
    <div><div><pre><code class="language-python"><span></span><span class="c1"># soup.get_text("|")</span>
    <span class="s1">u'</span><span class="se">\n</span><span class="s1">I linked to |example.com|</span><span class="se">\n</span><span class="s1">'</span>
    </code></pre></div>
    </div>
    <p>还可以去除获得文本内容的前后空白:</p>
    <div><div><pre><code class="language-python"><span></span><span class="c1"># soup.get_text("|", strip=True)</span>
    <span class="s1">u'I linked to|example.com'</span>
    </code></pre></div>
    </div>
    <p>或者使用 <a class="reference internal" href="#strings-stripped-strings">.stripped_strings</a> 生成器,获得文本列表后手动处理列表:</p>
    <div><div><pre><code class="language-python"><span></span><span class="p">[</span><span class="n">text</span> <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">stripped_strings</span><span class="p">]</span>
    <span class="c1"># [u'I linked to', u'example.com']</span>
    </code></pre></div>
    </div>
    </div>
    </div>
    <div class="section" id="id52">
    <h1>指定文档解析器<a class="headerlink" href="#id52" title="永久链接至标题"></a></h1>
    <p>如果仅是想要解析HTML文档,只要用文档创建 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象就可以了.Beautiful Soup会自动选择一个解析器来解析文档.但是还可以通过参数指定使用那种解析器来解析当前文档.</p>
    <p><code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 第一个参数应该是要被解析的文档字符串或是文件句柄,第二个参数用来标识怎样解析文档.如果第二个参数为空,那么Beautiful Soup根据当前系统安装的库自动选择解析器,解析器的优先数序: lxml, html5lib, Python标准库.在下面两种条件下解析器优先顺序会变化:</p>
    <blockquote>
    <div><ul class="simple">
    <li>要解析的文档是什么类型: 目前支持,  “html”, “xml”, 和 “html5”</li>
    <li>指定使用哪种解析器: 目前支持, “lxml”, “html5lib”, 和 “html.parser”</li>
    </ul>
    </div></blockquote>
    <p><a class="reference internal" href="#id12">安装解析器</a> 章节介绍了可以使用哪种解析器,以及如何安装.</p>
    <p>如果指定的解析器没有安装,Beautiful Soup会自动选择其它方案.目前只有 lxml 解析器支持XML文档的解析,在没有安装lxml库的情况下,创建 <code class="docutils literal"><span class="pre">beautifulsoup</span></code> 对象时无论是否指定使用lxml,都无法得到解析后的对象</p>
    <div class="section" id="id53">
    <h2>解析器之间的区别<a class="headerlink" href="#id53" title="永久链接至标题"></a></h2>
    <p>Beautiful Soup为不同的解析器提供了相同的接口,但解析器本身时有区别的.同一篇文档被不同的解析器解析后可能会生成不同结构的树型文档.区别最大的是HTML解析器和XML解析器,看下面片段被解析成HTML结构:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;a&gt;&lt;b /&gt;&lt;/a&gt;"</span><span class="p">)</span>
    <span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
    </code></pre></div>
    </div>
    <p>因为空标签&lt;b /&gt;不符合HTML标准,所以解析器把它解析成&lt;b&gt;&lt;/b&gt;</p>
    <p>同样的文档使用XML解析如下(解析XML需要安装lxml库).注意,空标签&lt;b /&gt;依然被保留,并且文档前添加了XML头,而不是被包含在&lt;html&gt;标签内:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;a&gt;&lt;b /&gt;&lt;/a&gt;"</span><span class="p">,</span> <span class="s2">"xml"</span><span class="p">)</span>
    <span class="c1"># &lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
    <span class="c1"># &lt;a&gt;&lt;b/&gt;&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    <p>HTML解析器之间也有区别,如果被解析的HTML文档是标准格式,那么解析器之间没有任何差别,只是解析速度不同,结果都会返回正确的文档树.</p>
    <p>但是如果被解析文档不是标准格式,那么不同的解析器返回结果可能不同.下面例子中,使用lxml解析错误格式的文档,结果&lt;/p&gt;标签被直接忽略掉了:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;a&gt;&lt;/p&gt;"</span><span class="p">,</span> <span class="s2">"lxml"</span><span class="p">)</span>
    <span class="c1"># &lt;html&gt;&lt;body&gt;&lt;a&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
    </code></pre></div>
    </div>
    <p>使用html5lib库解析相同文档会得到不同的结果:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;a&gt;&lt;/p&gt;"</span><span class="p">,</span> <span class="s2">"html5lib"</span><span class="p">)</span>
    <span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;p&gt;&lt;/p&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
    </code></pre></div>
    </div>
    <p>html5lib库没有忽略掉&lt;/p&gt;标签,而是自动补全了标签,还给文档树添加了&lt;head&gt;标签.</p>
    <p>使用pyhton内置库解析结果如下:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">"&lt;a&gt;&lt;/p&gt;"</span><span class="p">,</span> <span class="s2">"html.parser"</span><span class="p">)</span>
    <span class="c1"># &lt;a&gt;&lt;/a&gt;</span>
    </code></pre></div>
    </div>
    <p>与lxml <a class="footnote-reference" href="#id94" id="id54">[7]</a> 库类似的,Python内置库忽略掉了&lt;/p&gt;标签,与html5lib库不同的是标准库没有尝试创建符合标准的文档格式或将文档片段包含在&lt;body&gt;标签内,与lxml不同的是标准库甚至连&lt;html&gt;标签都没有尝试去添加.</p>
    <p>因为文档片段“&lt;a&gt;&lt;/p&gt;”是错误格式,所以以上解析方式都能算作”正确”,html5lib库使用的是HTML5的部分标准,所以最接近”正确”.不过所有解析器的结构都能够被认为是”正常”的.</p>
    <p>不同的解析器可能影响代码执行结果,如果在分发给别人的代码中使用了 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> ,那么最好注明使用了哪种解析器,以减少不必要的麻烦.</p>
    </div>
    </div>
    <div class="section" id="id55">
    <h1>编码<a class="headerlink" href="#id55" title="永久链接至标题"></a></h1>
    <p>任何HTML或XML文档都有自己的编码方式,比如ASCII 或 UTF-8,但是使用Beautiful Soup解析后,文档都被转换成了Unicode:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">"&lt;h1&gt;Sacr</span><span class="se">\xc3\xa9</span><span class="s2"> bleu!&lt;/h1&gt;"</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">h1</span>
    <span class="c1"># &lt;h1&gt;Sacré bleu!&lt;/h1&gt;</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">string</span>
    <span class="c1"># u'Sacr\xe9 bleu!'</span>
    </code></pre></div>
    </div>
    <p>这不是魔术(但很神奇),Beautiful Soup用了 <a href="#id98"><span class="problematic" id="id99">`编码自动检测`_</span></a> 子库来识别当前文档编码并转换成Unicode编码. <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象的 <code class="docutils literal"><span class="pre">.original_encoding</span></code> 属性记录了自动识别编码的结果:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span>
    <span class="s1">'utf-8'</span>
    </code></pre></div>
    </div>
    <p><a href="#id98"><span class="problematic" id="id100">`编码自动检测`_</span></a> 功能大部分时候都能猜对编码格式,但有时候也会出错.有时候即使猜测正确,也是在逐个字节的遍历整个文档后才猜对的,这样很慢.如果预先知道文档编码,可以设置编码参数来减少自动检查编码出错的概率并且提高文档解析速度.在创建 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象的时候设置 <code class="docutils literal"><span class="pre">from_encoding</span></code> 参数.</p>
    <p>下面一段文档用了ISO-8859-8编码方式,这段文档太短,结果Beautiful Soup以为文档是用ISO-8859-7编码:</p>
    <div><div><pre><code class="language-python"><span></span>markup = b"&lt;h1&gt;\xed\xe5\xec\xf9&lt;/h1&gt;"
    soup = BeautifulSoup(markup)
    soup.h1
    &lt;h1&gt;νεμω&lt;/h1&gt;
    soup.original_encoding
    'ISO-8859-7'
    </code></pre></div>
    </div>
    <p>通过传入 <code class="docutils literal"><span class="pre">from_encoding</span></code> 参数来指定编码方式:</p>
    <div><div><pre><code class="language-python"><span></span>soup = BeautifulSoup(markup, from_encoding="iso-8859-8")
    soup.h1
    &lt;h1&gt;םולש&lt;/h1&gt;
    soup.original_encoding
    'iso8859-8'
    </code></pre></div>
    </div>
    <p>如果仅知道文档采用了Unicode编码, 但不知道具体编码. 可以先自己猜测, 猜测错误(依旧是乱码)时,
    可以把错误编码作为 <code class="docutils literal"><span class="pre">exclude_encodings</span></code> 参数, 这样文档就不会尝试使用这种编码了解码了.
    译者备注: 在没有指定编码的情况下, BS会自己猜测编码, 把不正确的编码排除掉, BS就更容易猜到正确编码.</p>
    <div><div><pre><code class="language-python"><span></span>soup = BeautifulSoup(markup, exclude_encodings=["ISO-8859-7"])
    soup.h1
    &lt;h1&gt;םולש&lt;/h1&gt;
    soup.original_encoding
    'WINDOWS-1255'
    </code></pre></div>
    </div>
    <p>猜测结果是 Windows-1255 编码, 猜测结果可能不够准确, 但是 Windows-1255 编码是 ISO-8859-8 的扩展集,
    所以猜测结果已经十分接近了, 并且不影响使用. (<code class="docutils literal"><span class="pre">exclude_encodings</span></code> 参数是 4.4.0版本的新功能)</p>
    <p>少数情况下(通常是UTF-8编码的文档中包含了其它编码格式的文件),想获得正确的Unicode编码就不得不将文档中少数特殊编码字符替换成特殊Unicode编码,“REPLACEMENT CHARACTER” (U+FFFD, �) <a class="footnote-reference" href="#id96" id="id56">[9]</a> . 如果Beautifu Soup猜测文档编码时作了特殊字符的替换,那么Beautiful Soup会把 <code class="docutils literal"><span class="pre">UnicodeDammit</span></code> 或 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象的 <code class="docutils literal"><span class="pre">.contains_replacement_characters</span></code> 属性标记为 <code class="docutils literal"><span class="pre">True</span></code> .这样就可以知道当前文档进行Unicode编码后丢失了一部分特殊内容字符.如果文档中包含�而 <code class="docutils literal"><span class="pre">.contains_replacement_characters</span></code> 属性是 <code class="docutils literal"><span class="pre">False</span></code> ,则表示�就是文档中原来的字符,不是转码失败.</p>
    <div class="section" id="id57">
    <h2>输出编码<a class="headerlink" href="#id57" title="永久链接至标题"></a></h2>
    <p>通过Beautiful Soup输出文档时,不管输入文档是什么编码方式,输出编码均为UTF-8编码,下面例子输入文档是Latin-1编码:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="n">b</span><span class="s1">'''</span>
    <span class="s1">&lt;html&gt;</span>
    <span class="s1">  &lt;head&gt;</span>
    <span class="s1">    &lt;meta content="text/html; charset=ISO-Latin-1" http-equiv="Content-type" /&gt;</span>
    <span class="s1">  &lt;/head&gt;</span>
    <span class="s1">  &lt;body&gt;</span>
    <span class="s1">    &lt;p&gt;Sacr</span><span class="se">\xe9</span><span class="s1"> bleu!&lt;/p&gt;</span>
    <span class="s1">  &lt;/body&gt;</span>
    <span class="s1">&lt;/html&gt;</span>
    <span class="s1">'''</span>
    
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
    <span class="c1"># &lt;html&gt;</span>
    <span class="c1">#  &lt;head&gt;</span>
    <span class="c1">#   &lt;meta content="text/html; charset=utf-8" http-equiv="Content-type" /&gt;</span>
    <span class="c1">#  &lt;/head&gt;</span>
    <span class="c1">#  &lt;body&gt;</span>
    <span class="c1">#   &lt;p&gt;</span>
    <span class="c1">#    Sacré bleu!</span>
    <span class="c1">#   &lt;/p&gt;</span>
    <span class="c1">#  &lt;/body&gt;</span>
    <span class="c1"># &lt;/html&gt;</span>
    </code></pre></div>
    </div>
    <p>注意,输出文档中的&lt;meta&gt;标签的编码设置已经修改成了与输出编码一致的UTF-8.</p>
    <p>如果不想用UTF-8编码输出,可以将编码方式传入 <code class="docutils literal"><span class="pre">prettify()</span></code> 方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="s2">"latin-1"</span><span class="p">))</span>
    <span class="c1"># &lt;html&gt;</span>
    <span class="c1">#  &lt;head&gt;</span>
    <span class="c1">#   &lt;meta content="text/html; charset=latin-1" http-equiv="Content-type" /&gt;</span>
    <span class="c1"># ...</span>
    </code></pre></div>
    </div>
    <p>还可以调用 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象或任意节点的 <code class="docutils literal"><span class="pre">encode()</span></code> 方法,就像Python的字符串调用 <code class="docutils literal"><span class="pre">encode()</span></code> 方法一样:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"latin-1"</span><span class="p">)</span>
    <span class="c1"># '&lt;p&gt;Sacr\xe9 bleu!&lt;/p&gt;'</span>
    
    <span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"utf-8"</span><span class="p">)</span>
    <span class="c1"># '&lt;p&gt;Sacr\xc3\xa9 bleu!&lt;/p&gt;'</span>
    </code></pre></div>
    </div>
    <p>如果文档中包含当前编码不支持的字符,那么这些字符将呗转换成一系列XML特殊字符引用,下面例子中包含了Unicode编码字符SNOWMAN:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">u"&lt;b&gt;</span><span class="se">\N{SNOWMAN}</span><span class="s2">&lt;/b&gt;"</span>
    <span class="n">snowman_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">snowman_soup</span><span class="o">.</span><span class="n">b</span>
    </code></pre></div>
    </div>
    <p>SNOWMAN字符在UTF-8编码中可以正常显示(看上去像是☃),但有些编码不支持SNOWMAN字符,比如ISO-Latin-1或ASCII,那么在这些编码中SNOWMAN字符会被转换成“&amp;#9731”:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"utf-8"</span><span class="p">))</span>
    <span class="c1"># &lt;b&gt;☃&lt;/b&gt;</span>
    
    <span class="k">print</span> <span class="n">tag</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"latin-1"</span><span class="p">)</span>
    <span class="c1"># &lt;b&gt;&amp;#9731;&lt;/b&gt;</span>
    
    <span class="k">print</span> <span class="n">tag</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"ascii"</span><span class="p">)</span>
    <span class="c1"># &lt;b&gt;&amp;#9731;&lt;/b&gt;</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="unicode-dammit">
    <h2>Unicode, Dammit! (乱码, 靠!)<a class="headerlink" href="#unicode-dammit" title="永久链接至标题"></a></h2>
    <p>译者备注: UnicodeDammit 是BS内置库, 主要用来猜测文档编码.</p>
    <p><a href="#id98"><span class="problematic" id="id101">`编码自动检测`_</span></a> 功能可以在Beautiful Soup以外使用,检测某段未知编码时,可以使用这个方法:</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">UnicodeDammit</span>
    <span class="n">dammit</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="p">(</span><span class="s2">"Sacr</span><span class="se">\xc3\xa9</span><span class="s2"> bleu!"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">dammit</span><span class="o">.</span><span class="n">unicode_markup</span><span class="p">)</span>
    <span class="c1"># Sacré bleu!</span>
    <span class="n">dammit</span><span class="o">.</span><span class="n">original_encoding</span>
    <span class="c1"># 'utf-8'</span>
    </code></pre></div>
    </div>
    <p>如果Python中安装了 <code class="docutils literal"><span class="pre">chardet</span></code> 或 <code class="docutils literal"><span class="pre">cchardet</span></code> 那么编码检测功能的准确率将大大提高.
    输入的字符越多,检测结果越精确,如果事先猜测到一些可能编码,
    那么可以将猜测的编码作为参数,这样将优先检测这些编码:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">dammit</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="p">(</span><span class="s2">"Sacr</span><span class="se">\xe9</span><span class="s2"> bleu!"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"latin-1"</span><span class="p">,</span> <span class="s2">"iso-8859-1"</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="n">dammit</span><span class="o">.</span><span class="n">unicode_markup</span><span class="p">)</span>
    <span class="c1"># Sacré bleu!</span>
    <span class="n">dammit</span><span class="o">.</span><span class="n">original_encoding</span>
    <span class="c1"># 'latin-1'</span>
    </code></pre></div>
    </div>
    <p><a href="#id98"><span class="problematic" id="id102">`编码自动检测`_</span></a> 功能中有2项功能是Beautiful Soup库中用不到的</p>
    <div class="section" id="id58">
    <h3>智能引号<a class="headerlink" href="#id58" title="永久链接至标题"></a></h3>
    <p>使用Unicode时,Beautiful Soup还会智能的把引号 <a class="footnote-reference" href="#id97" id="id59">[10]</a> 转换成HTML或XML中的特殊字符:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="n">b</span><span class="s2">"&lt;p&gt;I just </span><span class="se">\x93</span><span class="s2">love</span><span class="se">\x94</span><span class="s2"> Microsoft Word</span><span class="se">\x92</span><span class="s2">s smart quotes&lt;/p&gt;"</span>
    
    <span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">"windows-1252"</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">"html"</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
    <span class="c1"># u'&lt;p&gt;I just &amp;ldquo;love&amp;rdquo; Microsoft Word&amp;rsquo;s smart quotes&lt;/p&gt;'</span>
    
    <span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">"windows-1252"</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">"xml"</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
    <span class="c1"># u'&lt;p&gt;I just &amp;#x201C;love&amp;#x201D; Microsoft Word&amp;#x2019;s smart quotes&lt;/p&gt;'</span>
    </code></pre></div>
    </div>
    <p>也可以把引号转换为ASCII码:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">"windows-1252"</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">"ascii"</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
    <span class="c1"># u'&lt;p&gt;I just "love" Microsoft Word\'s smart quotes&lt;/p&gt;'</span>
    </code></pre></div>
    </div>
    <p>很有用的功能,但是Beautiful Soup没有使用这种方式.默认情况下,Beautiful Soup把引号转换成Unicode:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">"windows-1252"</span><span class="p">])</span><span class="o">.</span><span class="n">unicode_markup</span>
    <span class="c1"># u'&lt;p&gt;I just \u201clove\u201d Microsoft Word\u2019s smart quotes&lt;/p&gt;'</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="id60">
    <h3>矛盾的编码<a class="headerlink" href="#id60" title="永久链接至标题"></a></h3>
    <p>有时文档的大部分都是用UTF-8,但同时还包含了Windows-1252编码的字符,就像微软的智能引号 <a class="footnote-reference" href="#id97" id="id61">[10]</a> 一样.
    一些包含多个信息的来源网站容易出现这种情况. <code class="docutils literal"><span class="pre">UnicodeDammit.detwingle()</span></code>
    方法可以把这类文档转换成纯UTF-8编码格式,看个简单的例子:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">snowmen</span> <span class="o">=</span> <span class="p">(</span><span class="s2">u"</span><span class="se">\N{SNOWMAN}</span><span class="s2">"</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">quote</span> <span class="o">=</span> <span class="p">(</span><span class="s2">u"</span><span class="se">\N{LEFT DOUBLE QUOTATION MARK}</span><span class="s2">I like snowmen!</span><span class="se">\N{RIGHT DOUBLE QUOTATION MARK}</span><span class="s2">"</span><span class="p">)</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">snowmen</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"utf8"</span><span class="p">)</span> <span class="o">+</span> <span class="n">quote</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"windows_1252"</span><span class="p">)</span>
    </code></pre></div>
    </div>
    <p>这段文档很杂乱,snowmen是UTF-8编码,引号是Windows-1252编码,直接输出时不能同时显示snowmen和引号,因为它们编码不同:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="c1"># ☃☃☃�I like snowmen!�</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">"windows-1252"</span><span class="p">))</span>
    <span class="c1"># â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”</span>
    </code></pre></div>
    </div>
    <p>如果对这段文档用UTF-8解码就会得到 <code class="docutils literal"><span class="pre">UnicodeDecodeError</span></code> 异常,如果用Windows-1252解码就回得到一堆乱码.
    幸好, <code class="docutils literal"><span class="pre">UnicodeDammit.detwingle()</span></code> 方法会吧这段字符串转换成UTF-8编码,允许我们同时显示出文档中的snowmen和引号:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">new_doc</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="o">.</span><span class="n">detwingle</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">new_doc</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">"utf8"</span><span class="p">))</span>
    <span class="c1"># ☃☃☃“I like snowmen!”</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">UnicodeDammit.detwingle()</span></code> 方法只能解码包含在UTF-8编码中的Windows-1252编码内容,但这解决了最常见的一类问题.</p>
    <p>在创建 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 或 <code class="docutils literal"><span class="pre">UnicodeDammit</span></code> 对象前一定要先对文档调用 <code class="docutils literal"><span class="pre">UnicodeDammit.detwingle()</span></code> 确保文档的编码方式正确.如果尝试去解析一段包含Windows-1252编码的UTF-8文档,就会得到一堆乱码,比如: â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”.</p>
    <p><code class="docutils literal"><span class="pre">UnicodeDammit.detwingle()</span></code> 方法在Beautiful Soup 4.1.0版本中新增</p>
    </div>
    </div>
    </div>
    <div class="section" id="id62">
    <h1>比较对象是否相同<a class="headerlink" href="#id62" title="永久链接至标题"></a></h1>
    <p>两个 <code class="docutils literal"><span class="pre">NavigableString</span></code> 或 <code class="docutils literal"><span class="pre">Tag</span></code> 对象具有相同的HTML或XML结构时,
    Beautiful Soup就判断这两个对象相同. 这个例子中, 2个 &lt;b&gt; 标签在 BS 中是相同的,
    尽管他们在文档树的不同位置, 但是具有相同的表象: “&lt;b&gt;pizza&lt;/b&gt;”</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">"&lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;"</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">'html.parser'</span><span class="p">)</span>
    <span class="n">first_b</span><span class="p">,</span> <span class="n">second_b</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">first_b</span> <span class="o">==</span> <span class="n">second_b</span>
    <span class="c1"># True</span>
    
    <span class="k">print</span> <span class="n">first_b</span><span class="o">.</span><span class="n">previous_element</span> <span class="o">==</span> <span class="n">second_b</span><span class="o">.</span><span class="n">previous_element</span>
    <span class="c1"># False</span>
    </code></pre></div>
    </div>
    <p>如果想判断两个对象是否严格的指向同一个对象可以通过 <code class="docutils literal"><span class="pre">is</span></code> 来判断</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span> <span class="n">first_b</span> <span class="ow">is</span> <span class="n">second_b</span>
    <span class="c1"># False</span>
    </code></pre></div>
    </div>
    </div>
    <div class="section" id="id63">
    <h1>复制Beautiful Soup对象<a class="headerlink" href="#id63" title="永久链接至标题"></a></h1>
    <p><code class="docutils literal"><span class="pre">copy.copy()</span></code> 方法可以复制任意 <code class="docutils literal"><span class="pre">Tag</span></code> 或 <code class="docutils literal"><span class="pre">NavigableString</span></code> 对象</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">copy</span>
    <span class="n">p_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">p_copy</span>
    <span class="c1"># &lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;</span>
    </code></pre></div>
    </div>
    <p>复制后的对象跟与对象是相等的, 但指向不同的内存地址</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span> <span class="n">soup</span><span class="o">.</span><span class="n">p</span> <span class="o">==</span> <span class="n">p_copy</span>
    <span class="c1"># True</span>
    
    <span class="k">print</span> <span class="n">soup</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="n">p_copy</span>
    <span class="c1"># False</span>
    </code></pre></div>
    </div>
    <p>源对象和复制对象的区别是源对象在文档树中, 而复制后的对象是独立的还没有添加到文档树中.
    复制后对象的效果跟调用了 <code class="docutils literal"><span class="pre">extract()</span></code> 方法相同.</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">print</span> <span class="n">p_copy</span><span class="o">.</span><span class="n">parent</span>
    <span class="c1"># None</span>
    </code></pre></div>
    </div>
    <p>这是因为相等的对象不能同时插入相同的位置</p>
    </div>
    <div class="section" id="id64">
    <h1>解析部分文档<a class="headerlink" href="#id64" title="永久链接至标题"></a></h1>
    <p>如果仅仅因为想要查找文档中的&lt;a&gt;标签而将整片文档进行解析,实在是浪费内存和时间.最快的方法是从一开始就把&lt;a&gt;标签以外的东西都忽略掉. <code class="docutils literal"><span class="pre">SoupStrainer</span></code> 类可以定义文档的某段内容,这样搜索文档时就不必先解析整篇文档,只会解析在 <code class="docutils literal"><span class="pre">SoupStrainer</span></code> 中定义过的文档. 创建一个 <code class="docutils literal"><span class="pre">SoupStrainer</span></code> 对象并作为 <code class="docutils literal"><span class="pre">parse_only</span></code> 参数给 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 的构造方法即可.</p>
    <div class="section" id="soupstrainer">
    <h2>SoupStrainer<a class="headerlink" href="#soupstrainer" title="永久链接至标题"></a></h2>
    <p><code class="docutils literal"><span class="pre">SoupStrainer</span></code> 类接受与典型搜索方法相同的参数：<a class="reference internal" href="#id35">name</a> , <a class="reference internal" href="#css">attrs</a> , <a class="reference internal" href="#recursive">recursive</a> , <a class="reference internal" href="#id36">string</a> , <a class="reference internal" href="#keyword">**kwargs</a> 。下面举例说明三种 <code class="docutils literal"><span class="pre">SoupStrainer</span></code> 对象：</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">SoupStrainer</span>
    
    <span class="n">only_a_tags</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
    
    <span class="n">only_tags_with_id_link2</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">"link2"</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">is_short_string</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span>
    
    <span class="n">only_short_strings</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">is_short_string</span><span class="p">)</span>
    </code></pre></div>
    </div>
    <p>再拿“爱丽丝”文档来举例，来看看使用三种 <code class="docutils literal"><span class="pre">SoupStrainer</span></code> 对象做参数会有什么不同:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">"""</span>
    <span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span>
    <span class="s2">    &lt;body&gt;</span>
    <span class="s2">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span>
    
    <span class="s2">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span>
    <span class="s2">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span>
    <span class="s2">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span>
    <span class="s2">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span>
    <span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>
    
    <span class="s2">&lt;p class="story"&gt;...&lt;/p&gt;</span>
    <span class="s2">"""</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">"html.parser"</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_a_tags</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;</span>
    <span class="c1">#  Elsie</span>
    <span class="c1"># &lt;/a&gt;</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;</span>
    <span class="c1">#  Lacie</span>
    <span class="c1"># &lt;/a&gt;</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;</span>
    <span class="c1">#  Tillie</span>
    <span class="c1"># &lt;/a&gt;</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">"html.parser"</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_tags_with_id_link2</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
    <span class="c1"># &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;</span>
    <span class="c1">#  Lacie</span>
    <span class="c1"># &lt;/a&gt;</span>
    
    <span class="k">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">"html.parser"</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_short_strings</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
    <span class="c1"># Elsie</span>
    <span class="c1"># ,</span>
    <span class="c1"># Lacie</span>
    <span class="c1"># and</span>
    <span class="c1"># Tillie</span>
    <span class="c1"># ...</span>
    <span class="c1">#</span>
    </code></pre></div>
    </div>
    <p>还可以将 <code class="docutils literal"><span class="pre">SoupStrainer</span></code> 作为参数传入 <a class="reference internal" href="#id27">搜索文档树</a> 中提到的方法.这可能不是个常用用法,所以还是提一下:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">)</span>
    <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">only_short_strings</span><span class="p">)</span>
    <span class="c1"># [u'\n\n', u'\n\n', u'Elsie', u',\n', u'Lacie', u' and\n', u'Tillie',</span>
    <span class="c1">#  u'\n\n', u'...', u'\n']</span>
    </code></pre></div>
    </div>
    </div>
    </div>
    <div class="section" id="id65">
    <h1>常见问题<a class="headerlink" href="#id65" title="永久链接至标题"></a></h1>
    <div class="section" id="id66">
    <h2>代码诊断<a class="headerlink" href="#id66" title="永久链接至标题"></a></h2>
    <p>如果想知道Beautiful Soup到底怎样处理一份文档,可以将文档传入 <code class="docutils literal"><span class="pre">diagnose()</span></code> 方法(Beautiful Soup 4.2.0中新增),Beautiful Soup会输出一份报告,说明不同的解析器会怎样处理这段文档,并标出当前的解析过程会使用哪种解析器:</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">bs4.diagnose</span> <span class="kn">import</span> <span class="n">diagnose</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"bad.html"</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">diagnose</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="c1"># Diagnostic running on Beautiful Soup 4.2.0</span>
    <span class="c1"># Python version 2.7.3 (default, Aug  1 2012, 05:16:07)</span>
    <span class="c1"># I noticed that html5lib is not installed. Installing it may help.</span>
    <span class="c1"># Found lxml version 2.3.2.0</span>
    <span class="c1">#</span>
    <span class="c1"># Trying to parse your data with html.parser</span>
    <span class="c1"># Here's what html.parser did with the document:</span>
    <span class="c1"># ...</span>
    </code></pre></div>
    </div>
    <p><code class="docutils literal"><span class="pre">diagnose()</span></code> 方法的输出结果可能帮助你找到问题的原因,如果不行,还可以把结果复制出来以便寻求他人的帮助</p>
    </div>
    <div class="section" id="id67">
    <h2>文档解析错误<a class="headerlink" href="#id67" title="永久链接至标题"></a></h2>
    <p>文档解析错误有两种.一种是崩溃,Beautiful Soup尝试解析一段文档结果却抛除了异常,通常是 <code class="docutils literal"><span class="pre">HTMLParser.HTMLParseError</span></code> .还有一种异常情况,是Beautiful Soup解析后的文档树看起来与原来的内容相差很多.</p>
    <p>这些错误几乎都不是Beautiful Soup的原因,这不会是因为Beautiful Soup得代码写的太优秀,而是因为Beautiful Soup没有包含任何文档解析代码.异常产生自被依赖的解析器,如果解析器不能很好的解析出当前的文档,那么最好的办法是换一个解析器.更多细节查看 <a class="reference internal" href="#id12">安装解析器</a> 章节.</p>
    <p>最常见的解析错误是 <code class="docutils literal"><span class="pre">HTMLParser.HTMLParseError:</span> <span class="pre">malformed</span> <span class="pre">start</span> <span class="pre">tag</span></code> 和 <code class="docutils literal"><span class="pre">HTMLParser.HTMLParseError:</span> <span class="pre">bad</span> <span class="pre">end</span> <span class="pre">tag</span></code> .这都是由Python内置的解析器引起的,解决方法是 <a class="reference internal" href="#id12">安装lxml或html5lib</a></p>
    <p>最常见的异常现象是当前文档找不到指定的Tag,而这个Tag光是用眼睛就足够发现的了. <code class="docutils literal"><span class="pre">find_all()</span></code> 方法返回 [] ,而 <code class="docutils literal"><span class="pre">find()</span></code> 方法返回 None .这是Python内置解析器的又一个问题: 解析器会跳过那些它不知道的tag.解决方法还是 <a class="reference internal" href="#id12">安装lxml或html5lib</a></p>
    </div>
    <div class="section" id="id68">
    <h2>版本错误<a class="headerlink" href="#id68" title="永久链接至标题"></a></h2>
    <ul class="simple">
    <li><code class="docutils literal"><span class="pre">SyntaxError:</span> <span class="pre">Invalid</span> <span class="pre">syntax</span></code> (异常位置在代码行: <code class="docutils literal"><span class="pre">ROOT_TAG_NAME</span> <span class="pre">=</span> <span class="pre">u'[document]'</span></code> ),因为Python2版本的代码没有经过迁移就在Python3中窒息感</li>
    <li><code class="docutils literal"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">HTMLParser</span></code> 因为在Python3中执行Python2版本的Beautiful Soup</li>
    <li><code class="docutils literal"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">html.parser</span></code> 因为在Python2中执行Python3版本的Beautiful Soup</li>
    <li><code class="docutils literal"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">BeautifulSoup</span></code> 因为在没有安装BeautifulSoup3库的Python环境下执行代码,或忘记了BeautifulSoup4的代码需要从 <code class="docutils literal"><span class="pre">bs4</span></code> 包中引入</li>
    <li><code class="docutils literal"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">bs4</span></code> 因为当前Python环境下还没有安装BeautifulSoup4</li>
    </ul>
    </div>
    <div class="section" id="xml">
    <h2>解析成XML<a class="headerlink" href="#xml" title="永久链接至标题"></a></h2>
    <p>默认情况下,Beautiful Soup会将当前文档作为HTML格式解析,如果要解析XML文档,要在 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 构造方法中加入第二个参数 “xml”:</p>
    <div><div><pre><code class="language-python"><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s2">"xml"</span><span class="p">)</span>
    </code></pre></div>
    </div>
    <p>当然,还需要 <a class="reference internal" href="#id12">安装lxml</a></p>
    </div>
    <div class="section" id="id69">
    <h2>解析器的错误<a class="headerlink" href="#id69" title="永久链接至标题"></a></h2>
    <ul class="simple">
    <li>如果同样的代码在不同环境下结果不同,可能是因为两个环境下使用不同的解析器造成的.例如这个环境中安装了lxml,而另一个环境中只有html5lib, <a class="reference internal" href="#id53">解析器之间的区别</a> 中说明了原因.修复方法是在 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 的构造方法中中指定解析器</li>
    <li>因为HTML标签是 <a class="reference external" href="http://www.w3.org/TR/html5/syntax.html#syntax">大小写敏感</a> 的,所以3种解析器再出来文档时都将tag和属性转换成小写.例如文档中的 &lt;TAG&gt;&lt;/TAG&gt; 会被转换为 &lt;tag&gt;&lt;/tag&gt; .如果想要保留tag的大写的话,那么应该将文档 <a class="reference internal" href="#xml">解析成XML</a> .</li>
    </ul>
    </div>
    <div class="section" id="id71">
    <h2>杂项错误<a class="headerlink" href="#id71" title="永久链接至标题"></a></h2>
    <ul class="simple">
    <li><code class="docutils literal"><span class="pre">UnicodeEncodeError:</span> <span class="pre">'charmap'</span> <span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span> <span class="pre">u'\xfoo'</span> <span class="pre">in</span> <span class="pre">position</span> <span class="pre">bar</span></code> (或其它类型的 <code class="docutils literal"><span class="pre">UnicodeEncodeError</span></code> )的错误,主要是两方面的错误(都不是Beautiful Soup的原因),第一种是正在使用的终端(console)无法显示部分Unicode,参考 <a class="reference external" href="http://wiki.Python.org/moin/PrintFails">Python wiki</a> ,第二种是向文件写入时,被写入文件不支持部分Unicode,这时只要用 <code class="docutils literal"><span class="pre">u.encode("utf8")</span></code> 方法将编码转换为UTF-8.</li>
    <li><code class="docutils literal"><span class="pre">KeyError:</span> <span class="pre">[attr]</span></code> 因为调用 <code class="docutils literal"><span class="pre">tag['attr']</span></code> 方法而引起,因为这个tag没有定义该属性.出错最多的是 <code class="docutils literal"><span class="pre">KeyError:</span> <span class="pre">'href'</span></code> 和 <code class="docutils literal"><span class="pre">KeyError:</span> <span class="pre">'class'</span></code> .如果不确定某个属性是否存在时,用 <code class="docutils literal"><span class="pre">tag.get('attr')</span></code> 方法去获取它,跟获取Python字典的key一样</li>
    <li><code class="docutils literal"><span class="pre">AttributeError:</span> <span class="pre">'ResultSet'</span> <span class="pre">object</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'foo'</span></code> 错误通常是因为把 <code class="docutils literal"><span class="pre">find_all()</span></code> 的返回结果当作一个tag或文本节点使用,实际上返回结果是一个列表或 <code class="docutils literal"><span class="pre">ResultSet</span></code> 对象的字符串,需要对结果进行循环才能得到每个节点的 <code class="docutils literal"><span class="pre">.foo</span></code> 属性.或者使用 <code class="docutils literal"><span class="pre">find()</span></code> 方法仅获取到一个节点</li>
    <li><code class="docutils literal"><span class="pre">AttributeError:</span> <span class="pre">'NoneType'</span> <span class="pre">object</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'foo'</span></code> 这个错误通常是在调用了 <code class="docutils literal"><span class="pre">find()</span></code> 方法后直节点取某个属性 .foo 但是 <code class="docutils literal"><span class="pre">find()</span></code> 方法并没有找到任何结果,所以它的返回值是 <code class="docutils literal"><span class="pre">None</span></code> .需要找出为什么 <code class="docutils literal"><span class="pre">find()</span></code> 的返回值是 <code class="docutils literal"><span class="pre">None</span></code> .</li>
    </ul>
    </div>
    <div class="section" id="id72">
    <h2>如何提高效率<a class="headerlink" href="#id72" title="永久链接至标题"></a></h2>
    <p>Beautiful Soup对文档的解析速度不会比它所依赖的解析器更快,如果对计算时间要求很高或者计算机的时间比程序员的时间更值钱,那么就应该直接使用 <a class="reference external" href="http://lxml.de/">lxml</a> .</p>
    <p>换句话说,还有提高Beautiful Soup效率的办法,使用lxml作为解析器.Beautiful Soup用lxml做解析器比用html5lib或Python内置解析器速度快很多.</p>
    <p>安装 <a class="reference external" href="http://pypi.Python.org/pypi/cchardet/">cchardet</a> 后文档的解码的编码检测会速度更快</p>
    <p><a class="reference internal" href="#id64">解析部分文档</a> 不会节省多少解析时间,但是会节省很多内存,并且搜索时也会变得更快.</p>
    </div>
    </div>
    <div class="section" id="beautiful-soup-3">
    <h1>Beautiful Soup 3<a class="headerlink" href="#beautiful-soup-3" title="永久链接至标题"></a></h1>
    <p>Beautiful Soup 3是上一个发布版本,目前已经停止维护.Beautiful Soup 3库目前已经被几个主要的linux平台添加到源里:</p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">Python-beautifulsoup</span></code></p>
    <p>在PyPi中分发的包名字是 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> :</p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">easy_install</span> <span class="pre">BeautifulSoup</span></code></p>
    <p><code class="docutils literal"><span class="pre">$</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">BeautifulSoup</span></code></p>
    <p>或通过 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/download/3.x/BeautifulSoup-3.2.0.tar.gz">Beautiful Soup 3.2.0源码包</a> 安装</p>
    <p>Beautiful Soup 3的在线文档查看 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">这里</a> .</p>
    <div class="section" id="id75">
    <h2>迁移到BS4<a class="headerlink" href="#id75" title="永久链接至标题"></a></h2>
    <p>只要一个小变动就能让大部分的Beautiful Soup 3代码使用Beautiful Soup 4的库和方法—-修改 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 对象的引入方式:</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">BeautifulSoup</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
    </code></pre></div>
    </div>
    <p>修改为:</p>
    <div><div><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
    </code></pre></div>
    </div>
    <ul class="simple">
    <li>如果代码抛出 <code class="docutils literal"><span class="pre">ImportError</span></code> 异常“No module named BeautifulSoup”,原因可能是尝试执行Beautiful Soup 3,但环境中只安装了Beautiful Soup 4库</li>
    <li>如果代码跑出 <code class="docutils literal"><span class="pre">ImportError</span></code> 异常“No module named bs4”,原因可能是尝试运行Beautiful Soup 4的代码,但环境中只安装了Beautiful Soup 3.</li>
    </ul>
    <p>虽然BS4兼容绝大部分BS3的功能,但BS3中的大部分方法已经不推荐使用了,就方法按照 <a class="reference external" href="http://www.Python.org/dev/peps/pep-0008/">PEP8标准</a> 重新定义了方法名.很多方法都重新定义了方法名,但只有少数几个方法没有向下兼容.</p>
    <p>上述内容就是BS3迁移到BS4的注意事项</p>
    <div class="section" id="id76">
    <h3>需要的解析器<a class="headerlink" href="#id76" title="永久链接至标题"></a></h3>
    <p>Beautiful Soup 3曾使用Python的 <code class="docutils literal"><span class="pre">SGMLParser</span></code> 解析器,这个模块在Python3中已经被移除了.Beautiful Soup 4默认使用系统的 <code class="docutils literal"><span class="pre">html.parser</span></code> ,也可以使用lxml或html5lib扩展库代替.查看 <a class="reference internal" href="#id12">安装解析器</a> 章节</p>
    <p>因为解析器 <code class="docutils literal"><span class="pre">html.parser</span></code> 与 <code class="docutils literal"><span class="pre">SGMLParser</span></code> 不同. BS4 和 BS3 处理相同的文档会产生不同的对象结构. 使用lxml或html5lib解析文档的时候, 如果添加了 <code class="docutils literal"><span class="pre">html.parser</span></code> 参数, 解析的对象又回发生变化. 如果发生了这种情况, 只能修改对应的处文档结果处理代码了.</p>
    </div>
    <div class="section" id="id77">
    <h3>方法名的变化<a class="headerlink" href="#id77" title="永久链接至标题"></a></h3>
    <ul class="simple">
    <li><code class="docutils literal"><span class="pre">renderContents</span></code> -&gt; <code class="docutils literal"><span class="pre">encode_contents</span></code></li>
    <li><code class="docutils literal"><span class="pre">replaceWith</span></code> -&gt; <code class="docutils literal"><span class="pre">replace_with</span></code></li>
    <li><code class="docutils literal"><span class="pre">replaceWithChildren</span></code> -&gt; <code class="docutils literal"><span class="pre">unwrap</span></code></li>
    <li><code class="docutils literal"><span class="pre">findAll</span></code> -&gt; <code class="docutils literal"><span class="pre">find_all</span></code></li>
    <li><code class="docutils literal"><span class="pre">findAllNext</span></code> -&gt; <code class="docutils literal"><span class="pre">find_all_next</span></code></li>
    <li><code class="docutils literal"><span class="pre">findAllPrevious</span></code> -&gt; <code class="docutils literal"><span class="pre">find_all_previous</span></code></li>
    <li><code class="docutils literal"><span class="pre">findNext</span></code> -&gt; <code class="docutils literal"><span class="pre">find_next</span></code></li>
    <li><code class="docutils literal"><span class="pre">findNextSibling</span></code> -&gt; <code class="docutils literal"><span class="pre">find_next_sibling</span></code></li>
    <li><code class="docutils literal"><span class="pre">findNextSiblings</span></code> -&gt; <code class="docutils literal"><span class="pre">find_next_siblings</span></code></li>
    <li><code class="docutils literal"><span class="pre">findParent</span></code> -&gt; <code class="docutils literal"><span class="pre">find_parent</span></code></li>
    <li><code class="docutils literal"><span class="pre">findParents</span></code> -&gt; <code class="docutils literal"><span class="pre">find_parents</span></code></li>
    <li><code class="docutils literal"><span class="pre">findPrevious</span></code> -&gt; <code class="docutils literal"><span class="pre">find_previous</span></code></li>
    <li><code class="docutils literal"><span class="pre">findPreviousSibling</span></code> -&gt; <code class="docutils literal"><span class="pre">find_previous_sibling</span></code></li>
    <li><code class="docutils literal"><span class="pre">findPreviousSiblings</span></code> -&gt; <code class="docutils literal"><span class="pre">find_previous_siblings</span></code></li>
    <li><code class="docutils literal"><span class="pre">nextSibling</span></code> -&gt; <code class="docutils literal"><span class="pre">next_sibling</span></code></li>
    <li><code class="docutils literal"><span class="pre">previousSibling</span></code> -&gt; <code class="docutils literal"><span class="pre">previous_sibling</span></code></li>
    </ul>
    <p>Beautiful Soup构造方法的参数部分也有名字变化:</p>
    <ul class="simple">
    <li><code class="docutils literal"><span class="pre">BeautifulSoup(parseOnlyThese=...)</span></code> -&gt; <code class="docutils literal"><span class="pre">BeautifulSoup(parse_only=...)</span></code></li>
    <li><code class="docutils literal"><span class="pre">BeautifulSoup(fromEncoding=...)</span></code> -&gt; <code class="docutils literal"><span class="pre">BeautifulSoup(from_encoding=...)</span></code></li>
    </ul>
    <p>为了适配Python3,修改了一个方法名:</p>
    <ul class="simple">
    <li><code class="docutils literal"><span class="pre">Tag.has_key()</span></code> -&gt; <code class="docutils literal"><span class="pre">Tag.has_attr()</span></code></li>
    </ul>
    <p>修改了一个属性名,让它看起来更专业点:</p>
    <ul class="simple">
    <li><code class="docutils literal"><span class="pre">Tag.isSelfClosing</span></code> -&gt; <code class="docutils literal"><span class="pre">Tag.is_empty_element</span></code></li>
    </ul>
    <p>修改了下面3个属性的名字,以免雨Python保留字冲突.这些变动不是向下兼容的,如果在BS3中使用了这些属性,那么在BS4中这些代码无法执行.</p>
    <ul class="simple">
    <li>UnicodeDammit.Unicode -&gt; UnicodeDammit.Unicode_markup``</li>
    <li><code class="docutils literal"><span class="pre">Tag.next</span></code> -&gt; <code class="docutils literal"><span class="pre">Tag.next_element</span></code></li>
    <li><code class="docutils literal"><span class="pre">Tag.previous</span></code> -&gt; <code class="docutils literal"><span class="pre">Tag.previous_element</span></code></li>
    </ul>
    </div>
    <div class="section" id="id78">
    <h3>生成器<a class="headerlink" href="#id78" title="永久链接至标题"></a></h3>
    <p>将下列生成器按照PEP8标准重新命名,并转换成对象的属性:</p>
    <ul class="simple">
    <li><code class="docutils literal"><span class="pre">childGenerator()</span></code> -&gt; <code class="docutils literal"><span class="pre">children</span></code></li>
    <li><code class="docutils literal"><span class="pre">nextGenerator()</span></code> -&gt; <code class="docutils literal"><span class="pre">next_elements</span></code></li>
    <li><code class="docutils literal"><span class="pre">nextSiblingGenerator()</span></code> -&gt; <code class="docutils literal"><span class="pre">next_siblings</span></code></li>
    <li><code class="docutils literal"><span class="pre">previousGenerator()</span></code> -&gt; <code class="docutils literal"><span class="pre">previous_elements</span></code></li>
    <li><code class="docutils literal"><span class="pre">previousSiblingGenerator()</span></code> -&gt; <code class="docutils literal"><span class="pre">previous_siblings</span></code></li>
    <li><code class="docutils literal"><span class="pre">recursiveChildGenerator()</span></code> -&gt; <code class="docutils literal"><span class="pre">descendants</span></code></li>
    <li><code class="docutils literal"><span class="pre">parentGenerator()</span></code> -&gt; <code class="docutils literal"><span class="pre">parents</span></code></li>
    </ul>
    <p>所以迁移到BS4版本时要替换这些代码:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">parentGenerator</span><span class="p">():</span>
        <span class="o">...</span>
    </code></pre></div>
    </div>
    <p>替换为:</p>
    <div><div><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
        <span class="o">...</span>
    </code></pre></div>
    </div>
    <p>(两种调用方法现在都能使用)</p>
    <p>BS3中有的生成器循环结束后会返回 <code class="docutils literal"><span class="pre">None</span></code> 然后结束.这是个bug.新版生成器不再返回 <code class="docutils literal"><span class="pre">None</span></code> .</p>
    <p>BS4中增加了2个新的生成器, <a class="reference internal" href="#strings-stripped-strings">.strings 和 stripped_strings</a> . <code class="docutils literal"><span class="pre">.strings</span></code> 生成器返回NavigableString对象, <code class="docutils literal"><span class="pre">.stripped_strings</span></code> 方法返回去除前后空白的Python的string对象.</p>
    </div>
    <div class="section" id="id79">
    <h3>XML<a class="headerlink" href="#id79" title="永久链接至标题"></a></h3>
    <p>BS4中移除了解析XML的 <code class="docutils literal"><span class="pre">BeautifulStoneSoup</span></code> 类.如果要解析一段XML文档,使用 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 构造方法并在第二个参数设置为“xml”.同时 <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 构造方法也不再识别 <code class="docutils literal"><span class="pre">isHTML</span></code> 参数.</p>
    <p>Beautiful Soup处理XML空标签的方法升级了.旧版本中解析XML时必须指明哪个标签是空标签. 构造方法的 <code class="docutils literal"><span class="pre">selfClosingTags</span></code> 参数已经不再使用.新版Beautiful Soup将所有空标签解析为空元素,如果向空元素中添加子节点,那么这个元素就不再是空元素了.</p>
    </div>
    <div class="section" id="id80">
    <h3>实体<a class="headerlink" href="#id80" title="永久链接至标题"></a></h3>
    <p>HTML或XML实体都会被解析成Unicode字符,Beautiful Soup 3版本中有很多处理实体的方法,在新版中都被移除了. <code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 构造方法也不再接受 <code class="docutils literal"><span class="pre">smartQuotesTo</span></code> 或 <code class="docutils literal"><span class="pre">convertEntities</span></code> 参数. <a href="#id98"><span class="problematic" id="id103">`编码自动检测`_</span></a> 方法依然有 <code class="docutils literal"><span class="pre">smart_quotes_to</span></code> 参数,但是默认会将引号转换成Unicode.内容配置项 <code class="docutils literal"><span class="pre">HTML_ENTITIES</span></code> , <code class="docutils literal"><span class="pre">XML_ENTITIES</span></code> 和 <code class="docutils literal"><span class="pre">XHTML_ENTITIES</span></code> 在新版中被移除.因为它们代表的特性已经不再被支持.</p>
    <p>如果在输出文档时想把Unicode字符转换成HTML实体,而不是输出成UTF-8编码,那就需要用到 <a class="reference internal" href="#id51">输出格式</a> 的方法.</p>
    </div>
    <div class="section" id="id81">
    <h3>迁移杂项<a class="headerlink" href="#id81" title="永久链接至标题"></a></h3>
    <p><a class="reference internal" href="#string">Tag.string</a> 属性现在是一个递归操作.如果A标签只包含了一个B标签,那么A标签的.string属性值与B标签的.string属性值相同.</p>
    <p><a class="reference internal" href="#id15">多值属性</a> 比如 <code class="docutils literal"><span class="pre">class</span></code> 属性包含一个他们的值的列表,而不是一个字符串.这可能会影响到如何按照CSS类名哦搜索tag.</p>
    <p>如果使用 <code class="docutils literal"><span class="pre">find*</span></code> 方法时同时传入了 <a href="#id104"><span class="problematic" id="id105">`text 参数`_</span></a> 和 <a class="reference internal" href="#id35">name 参数</a> .Beautiful Soup会搜索指定name的tag,并且这个tag的 <a class="reference internal" href="#string">Tag.string</a> 属性包含text参数的内容.结果中不会包含字符串本身.旧版本中Beautiful Soup会忽略掉tag参数,只搜索text参数.</p>
    <p><code class="docutils literal"><span class="pre">BeautifulSoup</span></code> 构造方法不再支持 markupMassage 参数.现在由解析器负责文档的解析正确性.</p>
    <p>很少被用到的几个解析器方法在新版中被移除,比如 <code class="docutils literal"><span class="pre">ICantBelieveItsBeautifulSoup</span></code> 和 <code class="docutils literal"><span class="pre">BeautifulSOAP</span></code> .现在由解析器完全负责如何解释模糊不清的文档标记.</p>
    <p><code class="docutils literal"><span class="pre">prettify()</span></code> 方法在新版中返回Unicode字符串,不再返回字节流.</p>
    </div>
    </div>
    </div>
    <div class="section" id="id82">
    <h1>附录<a class="headerlink" href="#id82" title="永久链接至标题"></a></h1>
    <div class="wy-table-responsive footnote"><table class="docutils footnote" frame="void" id="id88" rules="none">
    <colgroup><col class="label"><col></colgroup>
    <tbody valign="top">
    <tr><td class="label"><a class="fn-backref" href="#id6">[1]</a></td><td>BeautifulSoup的google讨论组不是很活跃,可能是因为库已经比较完善了吧,但是作者还是会很热心的尽量帮你解决问题的.</td></tr>
    </tbody>
    </table></div>
    <div class="wy-table-responsive footnote"><table class="docutils footnote" frame="void" id="id89" rules="none">
    <colgroup><col class="label"><col></colgroup>
    <tbody valign="top">
    <tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id22">1</a>, <a class="fn-backref" href="#id26">2</a>)</em> 文档被解析成树形结构,所以下一步解析过程应该是当前节点的子节点</td></tr>
    </tbody>
    </table></div>
    <div class="wy-table-responsive footnote"><table class="docutils footnote" frame="void" id="id90" rules="none">
    <colgroup><col class="label"><col></colgroup>
    <tbody valign="top">
    <tr><td class="label"><a class="fn-backref" href="#id29">[3]</a></td><td>过滤器只能作为搜索文档的参数,或者说应该叫参数类型更为贴切,原文中用了 <code class="docutils literal"><span class="pre">filter</span></code> 因此翻译为过滤器</td></tr>
    </tbody>
    </table></div>
    <div class="wy-table-responsive footnote"><table class="docutils footnote" frame="void" id="id91" rules="none">
    <colgroup><col class="label"><col></colgroup>
    <tbody valign="top">
    <tr><td class="label"><a class="fn-backref" href="#id34">[4]</a></td><td>元素参数,HTML文档中的一个tag节点,不能是文本节点</td></tr>
    </tbody>
    </table></div>
    <div class="wy-table-responsive footnote"><table class="docutils footnote" frame="void" id="id92" rules="none">
    <colgroup><col class="label"><col></colgroup>
    <tbody valign="top">
    <tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id21">1</a>, <a class="fn-backref" href="#id37">2</a>, <a class="fn-backref" href="#id38">3</a>, <a class="fn-backref" href="#id39">4</a>, <a class="fn-backref" href="#id40">5</a>)</em> 采用先序遍历方式</td></tr>
    </tbody>
    </table></div>
    <div class="wy-table-responsive footnote"><table class="docutils footnote" frame="void" id="id93" rules="none">
    <colgroup><col class="label"><col></colgroup>
    <tbody valign="top">
    <tr><td class="label">[6]</td><td><em>(<a class="fn-backref" href="#id42">1</a>, <a class="fn-backref" href="#id43">2</a>)</em> CSS选择器是一种单独的文档搜索语法, 参考 <a class="reference external" href="http://www.w3school.com.cn/css/css_selector_type.asp">http://www.w3school.com.cn/css/css_selector_type.asp</a></td></tr>
    </tbody>
    </table></div>
    <div class="wy-table-responsive footnote"><table class="docutils footnote" frame="void" id="id94" rules="none">
    <colgroup><col class="label"><col></colgroup>
    <tbody valign="top">
    <tr><td class="label"><a class="fn-backref" href="#id54">[7]</a></td><td>原文写的是 html5lib, 译者觉得这是原文档的一个笔误</td></tr>
    </tbody>
    </table></div>
    <div class="wy-table-responsive footnote"><table class="docutils footnote" frame="void" id="id95" rules="none">
    <colgroup><col class="label"><col></colgroup>
    <tbody valign="top">
    <tr><td class="label"><a class="fn-backref" href="#id47">[8]</a></td><td>wrap含有包装,打包的意思,但是这里的包装不是在外部包装而是将当前tag的内部内容包装在一个tag里.包装原来内容的新tag依然在执行 <a class="reference internal" href="#wrap">wrap()</a> 方法的tag内</td></tr>
    </tbody>
    </table></div>
    <div class="wy-table-responsive footnote"><table class="docutils footnote" frame="void" id="id96" rules="none">
    <colgroup><col class="label"><col></colgroup>
    <tbody valign="top">
    <tr><td class="label"><a class="fn-backref" href="#id56">[9]</a></td><td>文档中特殊编码字符被替换成特殊字符(通常是�)的过程是Beautful Soup自动实现的,如果想要多种编码格式的文档被完全转换正确,那么,只好,预先手动处理,统一编码格式</td></tr>
    </tbody>
    </table></div>
    <div class="wy-table-responsive footnote"><table class="docutils footnote" frame="void" id="id97" rules="none">
    <colgroup><col class="label"><col></colgroup>
    <tbody valign="top">
    <tr><td class="label">[10]</td><td><em>(<a class="fn-backref" href="#id59">1</a>, <a class="fn-backref" href="#id61">2</a>)</em> 智能引号,常出现在microsoft的word软件中,即在某一段落中按引号出现的顺序每个引号都被自动转换为左引号,或右引号.</td></tr>
    </tbody>
    </table></div>
    <p>原文: <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/">http://www.crummy.com/software/BeautifulSoup/bs4/doc/</a></p>
    <p>翻译: delong</p>
    <p>查看 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.zh.html">BeautifulSoup3 文档</a></p>
    </div>   