<div class="body" role="main"><div class="section" id="module-smtpd"><h1><span class="yiyi-st" id="yiyi-10">21.18. <a class="reference internal" href="#module-smtpd" title="smtpd: A SMTP server implementation in Python."><code class="xref py py-mod docutils literal"><span class="pre">smtpd</span></code></a>  -  SMTP服务器</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong><a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/smtpd.py">Lib/smtpd.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">此模块提供了几个类来实现SMTP（电子邮件）服务器。</span></p><p><span class="yiyi-st" id="yiyi-13">存在几个服务器实现；一个是通用的无用的实现，可以被覆盖，而另外两个提供特定的邮件发送策略。</span></p><p><span class="yiyi-st" id="yiyi-14">此外，SMTPChannel可以扩展为实现与SMTP客户端的非常具体的交互行为。</span></p><p><span class="yiyi-st" id="yiyi-15">代码支持<span class="target" id="index-0"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc5321.html"><strong>RFC 5321</strong></a>以及<span class="target" id="index-1"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1870.html"><strong>RFC 1870</strong></a> SIZE和<span class="target" id="index-2"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a> SMTPUTF8扩展。</span></p><div class="section" id="smtpserver-objects"><h2><span class="yiyi-st" id="yiyi-16">21.18.1. </span><span class="yiyi-st" id="yiyi-17">SMTPServer对象</span></h2><dl class="class"><dt id="smtpd.SMTPServer"><span class="yiyi-st" id="yiyi-18"> <em class="property">class </em><code class="descclassname">smtpd.</code><code class="descname">SMTPServer</code><span class="sig-paren">(</span><em>localaddr</em>, <em>remoteaddr</em>, <em>data_size_limit=33554432</em>, <em>map=None</em>, <em>enable_SMTPUTF8=False</em>, <em>decode_data=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-19">创建一个新的<a class="reference internal" href="#smtpd.SMTPServer" title="smtpd.SMTPServer"><code class="xref py py-class docutils literal"><span class="pre">SMTPServer</span></code></a>对象，并绑定到本地地址<em>localaddr</em>。</span><span class="yiyi-st" id="yiyi-20">它将<em>remoteadd</em>作为上游的SMTP中继。</span><span class="yiyi-st" id="yiyi-21">它继承自<a class="reference internal" href="asyncore.html#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal"><span class="pre">asyncore.dispatcher</span></code></a>，并在实例化时将自身插入到<a class="reference internal" href="asyncore.html#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services."><code class="xref py py-mod docutils literal"><span class="pre">asyncore</span></code></a>的事件循环。</span></p><p><span class="yiyi-st" id="yiyi-22"><em>data_size_limit</em>指定将在<code class="docutils literal"><span class="pre">DATA</span></code>命令中接受的最大字节数。</span><span class="yiyi-st" id="yiyi-23"><code class="docutils literal"><span class="pre">None</span></code>或<code class="docutils literal"><span class="pre">0</span></code>的值表示无限制。</span></p><p><span class="yiyi-st" id="yiyi-24"><em>map</em>是用于连接的套接字映射（最初为空的字典是一个合适的值）。</span><span class="yiyi-st" id="yiyi-25">如果未指定，则使用<a class="reference internal" href="asyncore.html#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services."><code class="xref py py-mod docutils literal"><span class="pre">asyncore</span></code></a>全局套接字映射。</span></p><p><span class="yiyi-st" id="yiyi-26"><em>enable_SMTPUTF8</em>确定是否应启用<code class="docutils literal"><span class="pre">SMTPUTF8</span></code>扩展（如<span class="target" id="index-3"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>中定义）。</span><span class="yiyi-st" id="yiyi-27">默认值为<code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-28">如果设置为<code class="docutils literal"><span class="pre">True</span></code>，则<em>decode_data</em>必须为<code class="docutils literal"><span class="pre">False</span></code>（否则会引发错误）。</span><span class="yiyi-st" id="yiyi-29">当<code class="docutils literal"><span class="pre">True</span></code>时，<code class="docutils literal"><span class="pre">SMTPUTF8</span></code>被接受作为<code class="docutils literal"><span class="pre">MAIL</span></code>命令的参数，并且当存在时传递到<a class="reference internal" href="#smtpd.SMTPServer.process_message" title="smtpd.SMTPServer.process_message"><code class="xref py py-meth docutils literal"><span class="pre">process_message()</span></code></a>在<code class="docutils literal"><span class="pre">kwargs['mail_options']</span></code>列表中。</span></p><p><span class="yiyi-st" id="yiyi-30"><em>decode_data</em>指定是否应使用UTF-8解码SMTP事务的数据部分。</span><span class="yiyi-st" id="yiyi-31">出于向后兼容性的原因，默认值为<code class="docutils literal"><span class="pre">True</span></code>，但在Python 3.6中将更改为<code class="docutils literal"><span class="pre">False</span></code>；明确指定关键字值以避免<a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal"><span class="pre">DeprecationWarning</span></code></a>。</span><span class="yiyi-st" id="yiyi-32">When <em>decode_data</em> is set to <code class="docutils literal"><span class="pre">False</span></code> the server advertises the <code class="docutils literal"><span class="pre">8BITMIME</span></code> extension (<span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6152.html"><strong>RFC 6152</strong></a>), accepts the <code class="docutils literal"><span class="pre">BODY=8BITMIME</span></code> parameter to the <code class="docutils literal"><span class="pre">MAIL</span></code> command, and when present passes it to <a class="reference internal" href="#smtpd.SMTPServer.process_message" title="smtpd.SMTPServer.process_message"><code class="xref py py-meth docutils literal"><span class="pre">process_message()</span></code></a> in the <code class="docutils literal"><span class="pre">kwargs['mail_options']</span></code> list.</span></p><dl class="method"><dt id="smtpd.SMTPServer.process_message"><span class="yiyi-st" id="yiyi-33"> <code class="descname">process_message</code><span class="sig-paren">(</span><em>peer</em>, <em>mailfrom</em>, <em>rcpttos</em>, <em>data</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-34">引发<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-35">在子类中重写此方法以对邮件做一些有用的事情。</span><span class="yiyi-st" id="yiyi-36">无论传递给构造函数的是什么<em>remoteaddr</em>，它将作为<code class="xref py py-attr docutils literal"><span class="pre">_remoteaddr</span></code>属性提供。</span><span class="yiyi-st" id="yiyi-37"><em>peer</em>是远程主机的地址，<em>mailfrom</em>是信封发件人，<em>rcpttos</em>是信封收件人，<em>data</em>包含电子邮件内容的字符串（应为<span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5321.html"><strong>RFC 5321</strong></a>格式）。</span></p><p><span class="yiyi-st" id="yiyi-38">如果<em>decode_data</em>构造函数关键字设置为<code class="docutils literal"><span class="pre">True</span></code>，则<em>data</em>参数将是Unicode字符串。</span><span class="yiyi-st" id="yiyi-39">如果设置为<code class="docutils literal"><span class="pre">False</span></code>，它将是一个字节对象。</span></p><p><span class="yiyi-st" id="yiyi-40"><em>kwargs</em>是包含附加信息的字典。</span><span class="yiyi-st" id="yiyi-41">除非将<code class="docutils literal"><span class="pre">decode_data=False</span></code>或<code class="docutils literal"><span class="pre">enable_SMTPUTF8=True</span></code>中的至少一个作为init参数给出，否则它为空，在这种情况下，它包含以下键：</span></p><span class="yiyi-st" id="yiyi-44"> <blockquote> <div><dl class="docutils"> <dt><em>mail_options</em>:</dt> <dd>a list of all received parameters to the <code class="docutils literal"><span class="pre">MAIL</span></code> command (the elements are uppercase strings; example: <code class="docutils literal"><span class="pre">['BODY=8BITMIME',</span> <span class="pre">'SMTPUTF8']</span></code>).</dd> <dt><em>rcpt_options</em>:</dt> <dd>same as <em>mail_options</em> but for the <code class="docutils literal"><span class="pre">RCPT</span></code> command. Currently no <code class="docutils literal"><span class="pre">RCPT</span> <span class="pre">TO</span></code> options are supported, so for now this will always be an empty list.</dd> </dl> </div></blockquote></span><p><span class="yiyi-st" id="yiyi-42"><code class="docutils literal"><span class="pre">process_message</span></code>的实现应使用<code class="docutils literal"><span class="pre">**kwargs</span></code>声明接受任意关键字参数，因为未来的功能增强可能会向kwargs字典添加键。</span></p><p><span class="yiyi-st" id="yiyi-43">返回<code class="docutils literal"><span class="pre">None</span></code>以请求正常的<code class="docutils literal"><span class="pre">250</span> <span class="pre">OK</span></code>响应；否则返回要求的<span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5321.html"><strong>RFC 5321</strong></a>格式的响应字符串。</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPServer.channel_class"><span class="yiyi-st" id="yiyi-45"> <code class="descname">channel_class</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-46">在子类中覆盖此项，以使用自定义<a class="reference internal" href="#smtpd.SMTPChannel" title="smtpd.SMTPChannel"><code class="xref py py-class docutils literal"><span class="pre">SMTPChannel</span></code></a>来管理SMTP客户端。</span></p></dd></dl><div class="versionadded"><p><span class="yiyi-st" id="yiyi-47"><span class="versionmodified">版本3.4中的新功能：</span> <em>映射</em>构造函数参数。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-48"><span class="versionmodified">在3.5版本中更改：</span> <em>localaddr</em>和<em>remoteaddr</em>现在可以包含IPv6地址。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-49"><span class="versionmodified">New in version 3.5: </span>the <em>decode_data</em> and <em>enable_SMTPUTF8</em> constructor arguments, and the <em>kwargs</em> argument to <a class="reference internal" href="#smtpd.SMTPServer.process_message" title="smtpd.SMTPServer.process_message"><code class="xref py py-meth docutils literal"><span class="pre">process_message()</span></code></a> when one or more of these is specified.</span></p></div></dd></dl></div><div class="section" id="debuggingserver-objects"><h2><span class="yiyi-st" id="yiyi-50">21.18.2. </span><span class="yiyi-st" id="yiyi-51">DebuggingServer Objects</span></h2><dl class="class"><dt id="smtpd.DebuggingServer"><span class="yiyi-st" id="yiyi-52"> <em class="property">class </em><code class="descclassname">smtpd.</code><code class="descname">DebuggingServer</code><span class="sig-paren">(</span><em>localaddr</em>, <em>remoteaddr</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-53">创建一个新的调试服务器。</span><span class="yiyi-st" id="yiyi-54">参数与<a class="reference internal" href="#smtpd.SMTPServer" title="smtpd.SMTPServer"><code class="xref py py-class docutils literal"><span class="pre">SMTPServer</span></code></a>相同。</span><span class="yiyi-st" id="yiyi-55">邮件将被丢弃，并打印到标准输出。</span></p></dd></dl></div><div class="section" id="pureproxy-objects"><h2><span class="yiyi-st" id="yiyi-56">21.18.3. </span><span class="yiyi-st" id="yiyi-57">PureProxy Objects</span></h2><dl class="class"><dt id="smtpd.PureProxy"><span class="yiyi-st" id="yiyi-58"> <em class="property">class </em><code class="descclassname">smtpd.</code><code class="descname">PureProxy</code><span class="sig-paren">(</span><em>localaddr</em>, <em>remoteaddr</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-59">创建一个新的纯代理服务器。</span><span class="yiyi-st" id="yiyi-60">参数与<a class="reference internal" href="#smtpd.SMTPServer" title="smtpd.SMTPServer"><code class="xref py py-class docutils literal"><span class="pre">SMTPServer</span></code></a>相同。</span><span class="yiyi-st" id="yiyi-61">一切都将传送到<em>remoteaddr</em>。</span><span class="yiyi-st" id="yiyi-62">注意运行该对象和容易令你变成一个开放中继，所以请小心。</span></p></dd></dl></div><div class="section" id="mailmanproxy-objects"><h2><span class="yiyi-st" id="yiyi-63">21.18.4. </span><span class="yiyi-st" id="yiyi-64">MailmanProxy Objects</span></h2><dl class="class"><dt id="smtpd.MailmanProxy"><span class="yiyi-st" id="yiyi-65"> <em class="property">class </em><code class="descclassname">smtpd.</code><code class="descname">MailmanProxy</code><span class="sig-paren">(</span><em>localaddr</em>, <em>remoteaddr</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-66">创建一个新的纯代理服务器。</span><span class="yiyi-st" id="yiyi-67">参数与<a class="reference internal" href="#smtpd.SMTPServer" title="smtpd.SMTPServer"><code class="xref py py-class docutils literal"><span class="pre">SMTPServer</span></code></a>相同。</span><span class="yiyi-st" id="yiyi-68">一切都将传送到<em>remoteaddr</em>，除非当地邮差配置知道一个地址，在这种情况下它将通过邮递员处理。</span><span class="yiyi-st" id="yiyi-69">注意运行该对象和容易令你变成一个开放中继，所以请小心。</span></p></dd></dl></div><div class="section" id="smtpchannel-objects"><h2><span class="yiyi-st" id="yiyi-70">21.18.5. </span><span class="yiyi-st" id="yiyi-71">SMTPChannel Objects</span></h2><dl class="class"><dt id="smtpd.SMTPChannel"><span class="yiyi-st" id="yiyi-72"> <em class="property">class </em><code class="descclassname">smtpd.</code><code class="descname">SMTPChannel</code><span class="sig-paren">(</span><em>server</em>, <em>conn</em>, <em>addr</em>, <em>data_size_limit=33554432</em>, <em>map=None</em>, <em>enable_SMTPUTF8=False</em>, <em>decode_data=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-73">创建一个新的<a class="reference internal" href="#smtpd.SMTPChannel" title="smtpd.SMTPChannel"><code class="xref py py-class docutils literal"><span class="pre">SMTPChannel</span></code></a>对象，用于管理服务器和单个SMTP客户端之间的通信。</span></p><p><span class="yiyi-st" id="yiyi-74"><em>conn</em>和<em>addr</em>是根据下面描述的实际变量。</span></p><p><span class="yiyi-st" id="yiyi-75"><em>data_size_limit</em>指定将在<code class="docutils literal"><span class="pre">DATA</span></code>命令中接受的最大字节数。</span><span class="yiyi-st" id="yiyi-76"><code class="docutils literal"><span class="pre">None</span></code>或<code class="docutils literal"><span class="pre">0</span></code>的值表示无限制。</span></p><p><span class="yiyi-st" id="yiyi-77"><em>enable_SMTPUTF8</em>确定是否应启用<code class="docutils literal"><span class="pre">SMTPUTF8</span></code>扩展（如<span class="target" id="index-7"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>中定义）。</span><span class="yiyi-st" id="yiyi-78">默认值为<code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-79">如果<em>enable_SMTPUTF8</em>和<em>decode_data</em>同时设置为<code class="docutils literal"><span class="pre">True</span></code>，则会产生<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-80">可以在<em>map</em>中指定字典，以避免使用全局套接字映射。</span></p><p><span class="yiyi-st" id="yiyi-81"><em>decode_data</em>指定是否应使用UTF-8解码SMTP事务的数据部分。</span><span class="yiyi-st" id="yiyi-82">出于向后兼容性的原因，默认值为<code class="docutils literal"><span class="pre">True</span></code>，但会在Python 3.6中更改为<code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-83">明确指定关键字值，以避免<a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal"><span class="pre">DeprecationWarning</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-84">要使用自定义SMTPChannel实现，您需要覆盖<a class="reference internal" href="#smtpd.SMTPServer" title="smtpd.SMTPServer"><code class="xref py py-class docutils literal"><span class="pre">SMTPServer</span></code></a>的<a class="reference internal" href="#smtpd.SMTPServer.channel_class" title="smtpd.SMTPServer.channel_class"><code class="xref py py-attr docutils literal"><span class="pre">SMTPServer.channel_class</span></code></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-85"><span class="versionmodified">在版本3.5中已更改：</span>添加了<em>decode_data</em>和<em>enable_SMTPUTF8</em>参数。</span></p></div><p><span class="yiyi-st" id="yiyi-86"><a class="reference internal" href="#smtpd.SMTPChannel" title="smtpd.SMTPChannel"><code class="xref py py-class docutils literal"><span class="pre">SMTPChannel</span></code></a>具有以下实例变量：</span></p><dl class="attribute"><dt id="smtpd.SMTPChannel.smtp_server"><span class="yiyi-st" id="yiyi-87"> <code class="descname">smtp_server</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-88">保留产生此频道的<a class="reference internal" href="#smtpd.SMTPServer" title="smtpd.SMTPServer"><code class="xref py py-class docutils literal"><span class="pre">SMTPServer</span></code></a>。</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPChannel.conn"><span class="yiyi-st" id="yiyi-89"> <code class="descname">conn</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">保存连接到客户端的套接字对象。</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPChannel.addr"><span class="yiyi-st" id="yiyi-91"> <code class="descname">addr</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-92">保存客户端的地址，<a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-func docutils literal"><span class="pre">socket.accept</span></code></a>返回的第二个值</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPChannel.received_lines"><span class="yiyi-st" id="yiyi-93"> <code class="descname">received_lines</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">保存从客户端接收的行字符串（使用UTF-8解码）的列表。</span><span class="yiyi-st" id="yiyi-95">这些线将它们的<code class="docutils literal"><span class="pre">"\r\n"</span></code>线结束翻译为<code class="docutils literal"><span class="pre">"\n"</span></code>。</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPChannel.smtp_state"><span class="yiyi-st" id="yiyi-96"> <code class="descname">smtp_state</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-97">保持通道的当前状态。</span><span class="yiyi-st" id="yiyi-98">This will be either <code class="xref py py-attr docutils literal"><span class="pre">COMMAND</span></code> initially and then <code class="xref py py-attr docutils literal"><span class="pre">DATA</span></code> after the client sends a “DATA” line.</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPChannel.seen_greeting"><span class="yiyi-st" id="yiyi-99"> <code class="descname">seen_greeting</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-100">保存客户端在其“HELO”中发送的包含问候语的字符串。</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPChannel.mailfrom"><span class="yiyi-st" id="yiyi-101"> <code class="descname">mailfrom</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-102">保留一个字符串，其中包含来自客户端的“MAIL FROM：”行中标识的地址。</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPChannel.rcpttos"><span class="yiyi-st" id="yiyi-103"> <code class="descname">rcpttos</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">保存来自客户端的包含在“RCPT TO：”行中标识的地址的字符串列表。</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPChannel.received_data"><span class="yiyi-st" id="yiyi-105"> <code class="descname">received_data</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-106">保存包含客户端在DATA状态期间发送的所有数据的字符串，但不包括终止<code class="docutils literal"><span class="pre">"\r\n.\r\n"</span></code>。</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPChannel.fqdn"><span class="yiyi-st" id="yiyi-107"> <code class="descname">fqdn</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-108">保存由<a class="reference internal" href="socket.html#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal"><span class="pre">socket.getfqdn()</span></code></a>返回的服务器的完全限定域名。</span></p></dd></dl><dl class="attribute"><dt id="smtpd.SMTPChannel.peer"><span class="yiyi-st" id="yiyi-109"> <code class="descname">peer</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-110">保留<code class="docutils literal"><span class="pre">conn.getpeername()</span></code>返回的客户端对等体的名称，其中<code class="docutils literal"><span class="pre">conn</span></code>是<a class="reference internal" href="#smtpd.SMTPChannel.conn" title="smtpd.SMTPChannel.conn"><code class="xref py py-attr docutils literal"><span class="pre">conn</span></code></a>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-111"><a class="reference internal" href="#smtpd.SMTPChannel" title="smtpd.SMTPChannel"><code class="xref py py-class docutils literal"><span class="pre">SMTPChannel</span></code></a>通过在从客户端接收到命令行时调用名为<code class="docutils literal"><span class="pre">smtp_&lt;command&gt;</span></code>的方法来操作。</span><span class="yiyi-st" id="yiyi-112">内置在<a class="reference internal" href="#smtpd.SMTPChannel" title="smtpd.SMTPChannel"><code class="xref py py-class docutils literal"><span class="pre">SMTPChannel</span></code></a>类中的是处理以下命令（并适当地响应它们）的方法：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-113">命令</span></th><th class="head"><span class="yiyi-st" id="yiyi-114">所采取的行动</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-115">HELO</span></td><td><span class="yiyi-st" id="yiyi-116">接受来自客户端的问候语，并将其存储在<a class="reference internal" href="#smtpd.SMTPChannel.seen_greeting" title="smtpd.SMTPChannel.seen_greeting"><code class="xref py py-attr docutils literal"><span class="pre">seen_greeting</span></code></a>中。</span><span class="yiyi-st" id="yiyi-117">将服务器设置为基本命令模式。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-118">EHLO</span></td><td><span class="yiyi-st" id="yiyi-119">接受来自客户端的问候语，并将其存储在<a class="reference internal" href="#smtpd.SMTPChannel.seen_greeting" title="smtpd.SMTPChannel.seen_greeting"><code class="xref py py-attr docutils literal"><span class="pre">seen_greeting</span></code></a>中。</span><span class="yiyi-st" id="yiyi-120">将服务器设置为扩展命令模式。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-121">NOOP</span></td><td><span class="yiyi-st" id="yiyi-122">不采取任何行动。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-123">QUIT</span></td><td><span class="yiyi-st" id="yiyi-124">干净地关闭连接。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-125">MAIL</span></td><td><span class="yiyi-st" id="yiyi-126">接受“MAIL FROM：”语法，并将提供的地址存储为<a class="reference internal" href="#smtpd.SMTPChannel.mailfrom" title="smtpd.SMTPChannel.mailfrom"><code class="xref py py-attr docutils literal"><span class="pre">mailfrom</span></code></a>。</span><span class="yiyi-st" id="yiyi-127">在扩展命令模式下，接受<span class="target" id="index-8"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1870.html"><strong>RFC 1870</strong></a> SIZE属性，并根据<em>data_size_limit</em>的值进行适当响应。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-128">RCPT</span></td><td><span class="yiyi-st" id="yiyi-129">接受“RCPT TO：”语法，并将提供的地址存储在<a class="reference internal" href="#smtpd.SMTPChannel.rcpttos" title="smtpd.SMTPChannel.rcpttos"><code class="xref py py-attr docutils literal"><span class="pre">rcpttos</span></code></a>列表中。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-130">RSET</span></td><td><span class="yiyi-st" id="yiyi-131">重置<a class="reference internal" href="#smtpd.SMTPChannel.mailfrom" title="smtpd.SMTPChannel.mailfrom"><code class="xref py py-attr docutils literal"><span class="pre">mailfrom</span></code></a>，<a class="reference internal" href="#smtpd.SMTPChannel.rcpttos" title="smtpd.SMTPChannel.rcpttos"><code class="xref py py-attr docutils literal"><span class="pre">rcpttos</span></code></a>和<a class="reference internal" href="#smtpd.SMTPChannel.received_data" title="smtpd.SMTPChannel.received_data"><code class="xref py py-attr docutils literal"><span class="pre">received_data</span></code></a>，但不是问候语。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-132">DATA</span></td><td><span class="yiyi-st" id="yiyi-133">将内部状态设置为<code class="xref py py-attr docutils literal"><span class="pre">DATA</span></code>，并在<a class="reference internal" href="#smtpd.SMTPChannel.received_data" title="smtpd.SMTPChannel.received_data"><code class="xref py py-attr docutils literal"><span class="pre">received_data</span></code></a>中存储来自客户端的剩余行，直到终止符<code class="docutils literal"><span class="pre">"\r\n.\r\n"</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-134">HELP</span></td><td><span class="yiyi-st" id="yiyi-135">返回有关命令语法的最少信息</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-136">VRFY</span></td><td><span class="yiyi-st" id="yiyi-137">返回代码252（服务器不知道地址是否有效）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-138">EXPN</span></td><td><span class="yiyi-st" id="yiyi-139">报告命令未实现。</span></td></tr></tbody></table></dd></dl></div></div></div>