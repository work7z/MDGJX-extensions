<div class="body" role="main"><div class="section" id="module-gc"><h1><span class="yiyi-st" id="yiyi-10">29.11. <a class="reference internal" href="#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal"><span class="pre">gc</span></code></a> - 垃圾收集器接口</span></h1><p><span class="yiyi-st" id="yiyi-11">此模块提供了到可选垃圾回收器的接口。</span><span class="yiyi-st" id="yiyi-12">它提供了禁用收集器，调整容器频率和设置调试选项的功能。</span><span class="yiyi-st" id="yiyi-13">它还提供对收集器发现但不能释放的无法访问的对象的访问。</span><span class="yiyi-st" id="yiyi-14">由于收集器补充了在Python中已经使用的引用计数，如果确定程序不创建引用循环，则可以禁用收集器。</span><span class="yiyi-st" id="yiyi-15">可以通过调用<code class="docutils literal"><span class="pre">gc.disable()</span></code>禁用自动容器。</span><span class="yiyi-st" id="yiyi-16">要调试泄漏程序调用<code class="docutils literal"><span class="pre">gc.set_debug(gc.DEBUG_LEAK)</span></code>。</span><span class="yiyi-st" id="yiyi-17">请注意，这包括<code class="docutils literal"><span class="pre">gc.DEBUG_SAVEALL</span></code>，导致垃圾收集的对象保存在gc.garbage中进行检查。</span></p><p><span class="yiyi-st" id="yiyi-18"><a class="reference internal" href="#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal"><span class="pre">gc</span></code></a>模块提供以下功能：</span></p><dl class="function"><dt id="gc.enable"><span class="yiyi-st" id="yiyi-19"> <code class="descclassname">gc.</code><code class="descname">enable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-20">启用自动垃圾容器。</span></p></dd></dl><dl class="function"><dt id="gc.disable"><span class="yiyi-st" id="yiyi-21"> <code class="descclassname">gc.</code><code class="descname">disable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-22">禁用自动垃圾容器。</span></p></dd></dl><dl class="function"><dt id="gc.isenabled"><span class="yiyi-st" id="yiyi-23"> <code class="descclassname">gc.</code><code class="descname">isenabled</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-24">如果启用了自动容器，则返回true。</span></p></dd></dl><dl class="function"><dt id="gc.collect"><span class="yiyi-st" id="yiyi-25"> <code class="descclassname">gc.</code><code class="descname">collect</code><span class="sig-paren">(</span><em>generations=2</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-26">没有参数，运行一个完整的容器。</span><span class="yiyi-st" id="yiyi-27">可选参数<em>生成</em>可以是指定要收集哪个生成（从0到2）的整数。</span><span class="yiyi-st" id="yiyi-28">如果代数无效，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span><span class="yiyi-st" id="yiyi-29">返回找到的不可达对象的数量。</span></p><p><span class="yiyi-st" id="yiyi-30">每当运行最高代（2）的完整容器或容器时，将清除为多个内建类型维护的空闲列表。</span><span class="yiyi-st" id="yiyi-31">由于特定实现，特别是<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>，某些空闲列表中的所有项目都可能被释放。</span></p></dd></dl><dl class="function"><dt id="gc.set_debug"><span class="yiyi-st" id="yiyi-32"> <code class="descclassname">gc.</code><code class="descname">set_debug</code><span class="sig-paren">(</span><em>flags</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-33">设置垃圾容器调试标志。</span><span class="yiyi-st" id="yiyi-34">调试信息将写入<code class="docutils literal"><span class="pre">sys.stderr</span></code>。</span><span class="yiyi-st" id="yiyi-35">请参见下面的调试标志列表，可以使用位操作来组合使用控制调试。</span></p></dd></dl><dl class="function"><dt id="gc.get_debug"><span class="yiyi-st" id="yiyi-36"> <code class="descclassname">gc.</code><code class="descname">get_debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-37">返回当前设置的调试标志。</span></p></dd></dl><dl class="function"><dt id="gc.get_objects"><span class="yiyi-st" id="yiyi-38"> <code class="descclassname">gc.</code><code class="descname">get_objects</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-39">返回收集器跟踪的所有对象的列表，不包括返回的列表。</span></p></dd></dl><dl class="function"><dt id="gc.get_stats"><span class="yiyi-st" id="yiyi-40"> <code class="descclassname">gc.</code><code class="descname">get_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-41">从解释器启动后，返回包含容器统计信息的三个每代字典的列表。</span><span class="yiyi-st" id="yiyi-42">键的数量可能会在将来更改，但目前每个字典将包含以下项目：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-43"><code class="docutils literal"><span class="pre">collections</span></code>是此代的收集次数；</span></li><li><span class="yiyi-st" id="yiyi-44"><code class="docutils literal"><span class="pre">collected</span></code>是在此世代内收集的对象的总数；</span></li><li><span class="yiyi-st" id="yiyi-45"><code class="docutils literal"><span class="pre">uncollectable</span></code>是在这一代内发现无法收集（并因此移动到<a class="reference internal" href="#gc.garbage" title="gc.garbage"><code class="xref py py-data docutils literal"><span class="pre">garbage</span></code></a>列表）的对象的总数。</span></li></ul><div class="versionadded"><p><span class="yiyi-st" id="yiyi-46"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="gc.set_threshold"><span class="yiyi-st" id="yiyi-47"> <code class="descclassname">gc.</code><code class="descname">set_threshold</code><span class="sig-paren">(</span><em>threshold0</em><span class="optional">[</span>, <em>threshold1</em><span class="optional">[</span>, <em>threshold2</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-48">设置垃圾容器阈值（容器频率）。</span><span class="yiyi-st" id="yiyi-49">将<em>threshold0</em>设置为零将禁用容器。</span></p><p><span class="yiyi-st" id="yiyi-50">GC根据它们存活了多少容器扫描将对象分为三代。</span><span class="yiyi-st" id="yiyi-51">新对象放置在最新一代（生成<code class="docutils literal"><span class="pre">0</span></code>）中。</span><span class="yiyi-st" id="yiyi-52">如果一个对象存在一个容器，它会被移动到下一个老一代。</span><span class="yiyi-st" id="yiyi-53">由于生成<code class="docutils literal"><span class="pre">2</span></code>是最旧的一代，该生成中的对象在容器之后仍保留在那里。</span><span class="yiyi-st" id="yiyi-54">为了决定何时运行，收集器跟踪自上一个容器以来的数字对象分配和释放。</span><span class="yiyi-st" id="yiyi-55">当分配数量减去解除分配数量超过<em>threshold0</em>时，容器开始。</span><span class="yiyi-st" id="yiyi-56">最初仅检查生成<code class="docutils literal"><span class="pre">0</span></code>。</span><span class="yiyi-st" id="yiyi-57">如果已经检查了生成<code class="docutils literal"><span class="pre">0</span></code>多于从生成<code class="docutils literal"><span class="pre">1</span></code>开始的<em>threshold1</em>时间，则检查生成<code class="docutils literal"><span class="pre">1</span></code>以及。</span><span class="yiyi-st" id="yiyi-58">类似地，在收集生成<code class="docutils literal"><span class="pre">2</span></code>之前，<em>threshold2</em>控制生成<code class="docutils literal"><span class="pre">1</span></code>的容器的数量。</span></p></dd></dl><dl class="function"><dt id="gc.get_count"><span class="yiyi-st" id="yiyi-59"> <code class="descclassname">gc.</code><code class="descname">get_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-60">将当前容器计数返回为<code class="docutils literal"><span class="pre">（count0，</span> <span class="pre">count1，</span> <span class="pre">count2）</span></code>的元组。</span></p></dd></dl><dl class="function"><dt id="gc.get_threshold"><span class="yiyi-st" id="yiyi-61"> <code class="descclassname">gc.</code><code class="descname">get_threshold</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-62">将当前容器阈值作为<code class="docutils literal"><span class="pre">（threshold0，</span> <span class="pre">threshold1，</span> <span class="pre">threshold2）</span></code>的元组返回。</span></p></dd></dl><dl class="function"><dt id="gc.get_referrers"><span class="yiyi-st" id="yiyi-63"> <code class="descclassname">gc.</code><code class="descname">get_referrers</code><span class="sig-paren">(</span><em>*objs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-64">返回直接引用任何obj的对象列表。</span><span class="yiyi-st" id="yiyi-65">这个函数只会定位那些支持垃圾容器的容器。不指向其他对象但不支持垃圾容器的扩展类型将不会被找到。</span></p><p><span class="yiyi-st" id="yiyi-66">注意，可以在结果引用中列出已经被解引用但是已经被循环生存并且尚未被垃圾收集器收集的对象。</span><span class="yiyi-st" id="yiyi-67">要仅获取当前活动对象，请在调用<a class="reference internal" href="#gc.get_referrers" title="gc.get_referrers"><code class="xref py py-func docutils literal"><span class="pre">get_referrers()</span></code></a>之前调用<a class="reference internal" href="#gc.collect" title="gc.collect"><code class="xref py py-func docutils literal"><span class="pre">collect()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-68">当使用由<a class="reference internal" href="#gc.get_referrers" title="gc.get_referrers"><code class="xref py py-func docutils literal"><span class="pre">get_referrers()</span></code></a>返回的对象时，必须小心，因为它们中的一些可能仍在构建中，因此处于临时无效状态。</span><span class="yiyi-st" id="yiyi-69">避免使用<a class="reference internal" href="#gc.get_referrers" title="gc.get_referrers"><code class="xref py py-func docutils literal"><span class="pre">get_referrers()</span></code></a>用于除调试之外的任何用途。</span></p></dd></dl><dl class="function"><dt id="gc.get_referents"><span class="yiyi-st" id="yiyi-70"> <code class="descclassname">gc.</code><code class="descname">get_referents</code><span class="sig-paren">(</span><em>*objs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-71">返回由任何参数直接引用的对象列表。</span><span class="yiyi-st" id="yiyi-72">返回的对象是参数'C-level <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a>方法访问的那些对象（如果有的话），并且可能不是所有实际上可直接到达的对象。</span><span class="yiyi-st" id="yiyi-73"><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a>方法仅由支持垃圾容器的对象支持，并且只需要访问可能涉及循环的对象。</span><span class="yiyi-st" id="yiyi-74">因此，例如，如果一个整数可以从一个参数直接到达，则该整数对象可以或可以不出现在结果列表中。</span></p></dd></dl><dl class="function"><dt id="gc.is_tracked"><span class="yiyi-st" id="yiyi-75"> <code class="descclassname">gc.</code><code class="descname">is_tracked</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-76">如果对象当前由垃圾收集器跟踪，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-77">作为一般规则，原子类型的实例不被跟踪，并且非原子类型的实例（容器，用户定义的对象...）是。</span><span class="yiyi-st" id="yiyi-78">然而，可以存在一些类型特定的优化，以便抑制简单实例的垃圾收集器覆盖区（footprint）。</span><span class="yiyi-st" id="yiyi-79">只包含原子键和值的dicts）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">([])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">({})</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:</span> <span class="p">[]})</span>
<span class="go">True</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-80"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-81">为只读访问提供了以下变量（您可以改变值，但不应重新绑定它们）：</span></p><dl class="data"><dt id="gc.garbage"><span class="yiyi-st" id="yiyi-82"> <code class="descclassname">gc.</code><code class="descname">garbage</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">收集器发现无法访问但无法释放的对象列表（无法收集的对象）。</span><span class="yiyi-st" id="yiyi-84">从Python 3.4开始，这个列表在大多数时候应该是空的，除非使用具有非NULL <code class="docutils literal"><span class="pre">tp_del</span></code>插槽的C扩展类型的实例。</span></p><p><span class="yiyi-st" id="yiyi-85">如果设置了<a class="reference internal" href="#gc.DEBUG_SAVEALL" title="gc.DEBUG_SAVEALL"><code class="xref py py-const docutils literal"><span class="pre">DEBUG_SAVEALL</span></code></a>，则所有无法访问的对象将被添加到此列表，而不是释放。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-86"><span class="versionmodified">在版本3.2中更改：</span>如果此列表在<a class="reference internal" href="../glossary.html#term-interpreter-shutdown"><span class="xref std std-term">interpreter shutdown</span></a>时为非空，则会发出一个<a class="reference internal" href="exceptions.html#ResourceWarning" title="ResourceWarning"><code class="xref py py-exc docutils literal"><span class="pre">ResourceWarning</span></code></a></span><span class="yiyi-st" id="yiyi-87">如果设置了<a class="reference internal" href="#gc.DEBUG_UNCOLLECTABLE" title="gc.DEBUG_UNCOLLECTABLE"><code class="xref py py-const docutils literal"><span class="pre">DEBUG_UNCOLLECTABLE</span></code></a>，则还会打印所有无法收集的对象。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-88"><span class="versionmodified">版本3.4中改变：</span>在<span class="target" id="index-0"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0442"><strong>PEP 442</strong></a>之后，具有<a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a>方法的对象不会以<a class="reference internal" href="#gc.garbage" title="gc.garbage"><code class="xref py py-attr docutils literal"><span class="pre">gc.garbage</span></code></a>了。</span></p></div></dd></dl><dl class="data"><dt id="gc.callbacks"><span class="yiyi-st" id="yiyi-89"> <code class="descclassname">gc.</code><code class="descname">callbacks</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">将由容器之前和之后的垃圾收集器调用的回调列表。</span><span class="yiyi-st" id="yiyi-91">将使用两个参数（<em>phase</em>和<em>info</em>）调用回调。</span></p><p><span class="yiyi-st" id="yiyi-92"><em>phase</em>可以是以下两个值之一：</span></p><span class="yiyi-st" id="yiyi-98"> <blockquote> <div><p>“start”: The garbage collection is about to start.</p> <p>“stop”: The garbage collection has finished.</p> </div></blockquote></span><p><span class="yiyi-st" id="yiyi-93"><em>info</em>是为回调提供更多信息的dict。</span><span class="yiyi-st" id="yiyi-94">以下键目前已定义：</span></p><span class="yiyi-st" id="yiyi-99"> <blockquote> <div><p>“generation”: The oldest generation being collected.</p> <p>“collected”: When <em>phase</em> is “stop”, the number of objects successfully collected.</p> <p>“uncollectable”: When <em>phase</em> is “stop”, the number of objects that could not be collected and were put in <a class="reference internal" href="#gc.garbage" title="gc.garbage"><code class="xref py py-data docutils literal"><span class="pre">garbage</span></code></a>.</p> </div></blockquote></span><p><span class="yiyi-st" id="yiyi-95">应用程序可以将自己的回调添加到此列表。</span><span class="yiyi-st" id="yiyi-96">主要用例是：</span></p><span class="yiyi-st" id="yiyi-100"> <blockquote> <div><p>Gathering statistics about garbage collection, such as how often various generations are collected, and how long the collection takes.</p> <p>Allowing applications to identify and clear their own uncollectable types when they appear in <a class="reference internal" href="#gc.garbage" title="gc.garbage"><code class="xref py py-data docutils literal"><span class="pre">garbage</span></code></a>.</p> </div></blockquote></span><div class="versionadded"><p><span class="yiyi-st" id="yiyi-97"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-101">提供以下常量以与<a class="reference internal" href="#gc.set_debug" title="gc.set_debug"><code class="xref py py-func docutils literal"><span class="pre">set_debug()</span></code></a>配合使用：</span></p><dl class="data"><dt id="gc.DEBUG_STATS"><span class="yiyi-st" id="yiyi-102"> <code class="descclassname">gc.</code><code class="descname">DEBUG_STATS</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-103">容器期间打印统计信息。</span><span class="yiyi-st" id="yiyi-104">在调整容器频率时，此信息可能很有用。</span></p></dd></dl><dl class="data"><dt id="gc.DEBUG_COLLECTABLE"><span class="yiyi-st" id="yiyi-105"> <code class="descclassname">gc.</code><code class="descname">DEBUG_COLLECTABLE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-106">打印有关可找到的可收集对象的信息。</span></p></dd></dl><dl class="data"><dt id="gc.DEBUG_UNCOLLECTABLE"><span class="yiyi-st" id="yiyi-107"> <code class="descclassname">gc.</code><code class="descname">DEBUG_UNCOLLECTABLE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-108">打印找到的不可收集对象的信息（收集器不能访问但不能释放的对象）。</span><span class="yiyi-st" id="yiyi-109">这些对象将添加到<code class="docutils literal"><span class="pre">garbage</span></code>列表中。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-110"><span class="versionmodified">在版本3.2中更改：</span>如果不为空，还打印<a class="reference internal" href="../glossary.html#term-interpreter-shutdown"><span class="xref std std-term">interpreter shutdown</span></a>中的<a class="reference internal" href="#gc.garbage" title="gc.garbage"><code class="xref py py-data docutils literal"><span class="pre">garbage</span></code></a>列表的内容。</span></p></div></dd></dl><dl class="data"><dt id="gc.DEBUG_SAVEALL"><span class="yiyi-st" id="yiyi-111"> <code class="descclassname">gc.</code><code class="descname">DEBUG_SAVEALL</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-112">设置时，找到的所有无法访问的对象将被附加到<em>垃圾</em>，而不是被释放。</span><span class="yiyi-st" id="yiyi-113">这对于调试泄漏程序很有用。</span></p></dd></dl><dl class="data"><dt id="gc.DEBUG_LEAK"><span class="yiyi-st" id="yiyi-114"> <code class="descclassname">gc.</code><code class="descname">DEBUG_LEAK</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-115">收集器打印有关泄漏程序的信息（等于<code class="docutils literal"><span class="pre">DEBUG_COLLECTABLE</span> <span class="pre">|</span> <span class="pre">DEBUG_UNCOLLECTABLE</span> <span class="pre">|  <span class="pre">DEBUG_SAVEALL</span></span></code>）。</span></p></dd></dl></div></div>