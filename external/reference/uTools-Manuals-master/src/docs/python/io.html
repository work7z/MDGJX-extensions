<div class="body" role="main"><div class="section" id="module-io"><h1><span class="yiyi-st" id="yiyi-10">16.2. <a class="reference internal" href="#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a>  - 使用流的核心工具</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/io.py">Lib/io.py</a></span></p><div class="section" id="overview"><h2><span class="yiyi-st" id="yiyi-12">16.2.1. </span><span class="yiyi-st" id="yiyi-13">概览</span></h2><p id="index-0"><span class="yiyi-st" id="yiyi-14"><a class="reference internal" href="#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a>模块提供了Python处理各种类型I / O的主要工具。</span><span class="yiyi-st" id="yiyi-15">有三种主要类型的I / O：<em>文本I / O</em>，<em>二进制I / O</em>和<em>原始I / O</em>。</span><span class="yiyi-st" id="yiyi-16">这些是通用类别，并且可以为它们中的每一个使用各种后备存储。</span><span class="yiyi-st" id="yiyi-17">属于这些类别中的任何一个的具体对象称为<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>。</span><span class="yiyi-st" id="yiyi-18">其他常见术语是<em>流</em>和<em>类文件对象</em>。</span></p><p><span class="yiyi-st" id="yiyi-19">独立于其类别，每个具体的流对象也将具有各种能力：它可以是只读的，只写的或读写的。</span><span class="yiyi-st" id="yiyi-20">它还可以允许任意随机存取（寻找向前或向后到任何位置），或只允许顺序存取（例如在套接字或管道的情况下）。</span></p><p><span class="yiyi-st" id="yiyi-21">所有流都仔细考虑您给他们的数据类型。</span><span class="yiyi-st" id="yiyi-22">例如，给二进制流的<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>对象<code class="docutils literal"><span class="pre">write()</span></code>方法将报<code class="docutils literal"><span class="pre">TypeError</span></code>错。</span><span class="yiyi-st" id="yiyi-23">因此，将向文本流的<code class="docutils literal"><span class="pre">write()</span></code>方法提供<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>对象。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-24"><span class="versionmodified">在版本3.3中已更改：</span>由于<a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a>现在是一个别名，因此用于引发<a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a>的操作现已引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></div><div class="section" id="text-i-o"><h3><span class="yiyi-st" id="yiyi-25">16.2.1.1. </span><span class="yiyi-st" id="yiyi-26">文本 I/O</span></h3><p><span class="yiyi-st" id="yiyi-27">文本I / O期望并生成<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-28">这意味着每当后台存储器本身由字节（例如在文件的情况下）时，数据的编码和解码被透明地以及平台特定的换行字符的可选转换。</span></p><p><span class="yiyi-st" id="yiyi-29">创建文本流的最简单方法是使用<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal"><span class="pre">open()</span></code></a>，可选择指定编码：</span></p><pre><code class="language-python"><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"myfile.txt"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">"utf-8"</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-30">内存中的文本流也可用作<a class="reference internal" href="#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">StringIO</span></code></a>对象：</span></p><pre><code class="language-python"><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="s2">"some initial text data"</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-31">文本流API在<a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a>的文档中有详细描述。</span></p></div><div class="section" id="binary-i-o"><h3><span class="yiyi-st" id="yiyi-32">16.2.1.2. </span><span class="yiyi-st" id="yiyi-33">二进制I / O </span></h3><p><span class="yiyi-st" id="yiyi-34">二进制I / O（也称为<em>缓冲I / O</em>）期望<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节状对象</span></a>并产生<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-35">不执行编码，解码或换行。</span><span class="yiyi-st" id="yiyi-36">这种类别的流可以用于所有种类的非文本数据，并且当需要对文本数据的处理的手动控制时。</span></p><p><span class="yiyi-st" id="yiyi-37">创建二进制流的最简单方法是在模式字符串中使用<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal"><span class="pre">open()</span></code></a>和<code class="docutils literal"><span class="pre">'b'</span></code></span></p><pre><code class="language-python"><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"myfile.jpg"</span><span class="p">,</span> <span class="s2">"rb"</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-38">内存中的二进制流也可用作<a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>对象：</span></p><pre><code class="language-python"><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">b</span><span class="s2">"some initial binary data: </span><span class="se">\x00\x01</span><span class="s2">"</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-39">二进制流API在<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>的文档中有详细描述。</span></p><p><span class="yiyi-st" id="yiyi-40">其他库模块可以提供用于创建文本或二进制流的附加方式。</span><span class="yiyi-st" id="yiyi-41">例如，请参见<a class="reference internal" href="socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.makefile()</span></code></a>。</span></p></div><div class="section" id="raw-i-o"><h3><span class="yiyi-st" id="yiyi-42">16.2.1.3. </span><span class="yiyi-st" id="yiyi-43">原始I/O</span></h3><p><span class="yiyi-st" id="yiyi-44">原始I / O（也称为<em>无缓冲I / O</em>）通常用作二进制和文本流的低级构建块；它很少用于直接操作来自用户代码的原始流。</span><span class="yiyi-st" id="yiyi-45">不过，您可以通过在禁用缓冲的情况下以二进制模式打开文件来创建原始流：</span></p><pre><code class="language-python"><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"myfile.jpg"</span><span class="p">,</span> <span class="s2">"rb"</span><span class="p">,</span> <span class="n">buffering</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-46">原始流API在<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>的文档中有详细描述。</span></p></div></div><div class="section" id="high-level-module-interface"><h2><span class="yiyi-st" id="yiyi-47">16.2.2. </span><span class="yiyi-st" id="yiyi-48">高级模块接口</span></h2><dl class="data"><dt id="io.DEFAULT_BUFFER_SIZE"><span class="yiyi-st" id="yiyi-49"> <code class="descclassname">io.</code><code class="descname">DEFAULT_BUFFER_SIZE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-50">包含由模块的缓冲I / O类使用的默认缓冲区大小的int。</span><span class="yiyi-st" id="yiyi-51"><a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>使用文件的blksize（由<a class="reference internal" href="os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>获得）。</span></p></dd></dl><dl class="function"><dt id="io.open"><span class="yiyi-st" id="yiyi-52"> <code class="descclassname">io.</code><code class="descname">open</code><span class="sig-paren">(</span><em>file</em>, <em>mode='r'</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-53">这是内置<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>函数的别名。</span></p></dd></dl><dl class="exception"><dt id="io.BlockingIOError"><span class="yiyi-st" id="yiyi-54"> <em class="property">exception </em><code class="descclassname">io.</code><code class="descname">BlockingIOError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-55">这是内置<a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal"><span class="pre">BlockingIOError</span></code></a>异常的兼容性别名。</span></p></dd></dl><dl class="exception"><dt id="io.UnsupportedOperation"><span class="yiyi-st" id="yiyi-56"> <em class="property">exception </em><code class="descclassname">io.</code><code class="descname">UnsupportedOperation</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-57">在流上调用不受支持的操作时引发的异常,继承了<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>和<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p></dd></dl><div class="section" id="in-memory-streams"><h3><span class="yiyi-st" id="yiyi-58">16.2.2.1. </span><span class="yiyi-st" id="yiyi-59">内存中的流</span></h3><p><span class="yiyi-st" id="yiyi-60">也可以使用<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>或<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>作为读和写的文件。</span><span class="yiyi-st" id="yiyi-61">对于字符串<a class="reference internal" href="#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">StringIO</span></code></a>可以像在文本模式下打开的文件一样使用。</span><span class="yiyi-st" id="yiyi-62"><a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>可以像在二进制模式下打开的文件一样使用。</span><span class="yiyi-st" id="yiyi-63">两者都提供了随机存取的完全读写能力。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-64">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-65"><a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-66">包含标准IO流：<a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal"><span class="pre">sys.stdin</span></code></a>，<a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a>和<a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a>。</span></dd></dl></div></div></div><div class="section" id="class-hierarchy"><h2><span class="yiyi-st" id="yiyi-67">16.2.3. </span><span class="yiyi-st" id="yiyi-68">类的层次</span></h2><p><span class="yiyi-st" id="yiyi-69">I / O流的实现被组织为类的层次结构。</span><span class="yiyi-st" id="yiyi-70">第一个<a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">抽象基础类/abstract base classes</span></a>（ABCs），用于指定流的各种类别，然后是提供标准流实现的具体类。</span></p><span class="yiyi-st" id="yiyi-446"> <blockquote><div><div class="admonition note"><p class="first admonition-title">注意</p> <p class="last">抽象基础类也提供某些方法的默认实现为了有助于实现具体流类. 例如, <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>提供非优化的实现<code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code> 和<a class="reference internal" href="#io.IOBase.readline" title="io.IOBase.readline"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a>.</p></div></div></blockquote></span><p><span class="yiyi-st" id="yiyi-71">在I / O层次结构的顶部是抽象基类<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>。</span><span class="yiyi-st" id="yiyi-72">它定义了流的基本接口。</span><span class="yiyi-st" id="yiyi-73">但是，请注意，读取和写入流之间没有分离；如果实现不支持给定的操作，则允许引用<a class="reference internal" href="#io.UnsupportedOperation" title="io.UnsupportedOperation"><code class="xref py py-exc docutils literal"><span class="pre">UnsupportedOperation</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-74"><a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a> ABC扩展了<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>。</span><span class="yiyi-st" id="yiyi-75">它处理字节读取和写入流。</span><span class="yiyi-st" id="yiyi-76"><a class="reference internal" href="#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal"><span class="pre">FileIO</span></code></a>子类<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>为机器文件系统中的文件提供接口。</span></p><p><span class="yiyi-st" id="yiyi-77"><a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a> ABC处理原始字节流（<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>）上的缓冲。</span><span class="yiyi-st" id="yiyi-78">其子类，可读，可写，可读可写的<a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">BufferedWriter</span></code></a>，<a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal"><span class="pre">BufferedReader</span></code></a>和<a class="reference internal" href="#io.BufferedRWPair" title="io.BufferedRWPair"><code class="xref py py-class docutils literal"><span class="pre">BufferedRWPair</span></code></a></span><span class="yiyi-st" id="yiyi-79"><a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal"><span class="pre">BufferedRandom</span></code></a>为随机存取流提供缓冲接口。</span><span class="yiyi-st" id="yiyi-80">另一个<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>子类，<a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>是一个内存中字节流。</span></p><p><span class="yiyi-st" id="yiyi-81"><a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a> ABC是<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>的另一个子类，它处理字节代表文本的流，并处理字符串的编码和解码。</span><span class="yiyi-st" id="yiyi-82"><a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal"><span class="pre">TextIOWrapper</span></code></a>（扩展它）是缓冲的原始流的缓冲文本接口（<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>）。</span><span class="yiyi-st" id="yiyi-83">最后，<a class="reference internal" href="#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">StringIO</span></code></a>是文本的内存流。</span></p><p><span class="yiyi-st" id="yiyi-84">参数名称不是规范的一部分，只有<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>的参数用作关键字参数。</span></p><p><span class="yiyi-st" id="yiyi-85">下表总结了由<a class="reference internal" href="#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a>模块提供的ABC：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-86">抽象基类</span></th><th class="head"><span class="yiyi-st" id="yiyi-87">继承</span></th><th class="head"><span class="yiyi-st" id="yiyi-88">存根方法</span></th><th class="head"><span class="yiyi-st" id="yiyi-89">Mixin方法和属性</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-90"><a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a></span></td><td></td><td><span class="yiyi-st" id="yiyi-91"><code class="docutils literal"><span class="pre">fileno</span></code>，<code class="docutils literal"><span class="pre">seek</span></code>和<code class="docutils literal"><span class="pre">truncate</span></code></span></td><td><span class="yiyi-st" id="yiyi-92"><code class="docutils literal"><span class="pre">close</span></code>, <code class="docutils literal"><span class="pre">closed</span></code>, <code class="docutils literal"><span class="pre">__enter__</span></code>, <code class="docutils literal"><span class="pre">__exit__</span></code>, <code class="docutils literal"><span class="pre">flush</span></code>, <code class="docutils literal"><span class="pre">isatty</span></code>, <code class="docutils literal"><span class="pre">__iter__</span></code>, <code class="docutils literal"><span class="pre">__next__</span></code>, <code class="docutils literal"><span class="pre">readable</span></code>, <code class="docutils literal"><span class="pre">readline</span></code>, <code class="docutils literal"><span class="pre">readlines</span></code>, <code class="docutils literal"><span class="pre">seekable</span></code>, <code class="docutils literal"><span class="pre">tell</span></code>, <code class="docutils literal"><span class="pre">writable</span></code>, and <code class="docutils literal"><span class="pre">writelines</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-93"><a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-94"><a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-95"><code class="docutils literal"><span class="pre">readinto</span></code>和<code class="docutils literal"><span class="pre">write</span></code></span></td><td><span class="yiyi-st" id="yiyi-96">继承<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>方法，<code class="docutils literal"><span class="pre">read</span></code>和<code class="docutils literal"><span class="pre">readall</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-97"><a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-98"><a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-99"><code class="docutils literal"><span class="pre">detach</span></code>，<code class="docutils literal"><span class="pre">read</span></code>，<code class="docutils literal"><span class="pre">read1</span></code>和<code class="docutils literal"><span class="pre">write</span></code></span></td><td><span class="yiyi-st" id="yiyi-100">继承<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>方法，<code class="docutils literal"><span class="pre">readinto</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-101"><a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-102"><a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-103"><code class="docutils literal"><span class="pre">detach</span></code>，<code class="docutils literal"><span class="pre">read</span></code>，<code class="docutils literal"><span class="pre">readline</span></code>和<code class="docutils literal"><span class="pre">write</span></code></span></td><td><span class="yiyi-st" id="yiyi-104">继承了<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>方法，<code class="docutils literal"><span class="pre">encoding</span></code>，<code class="docutils literal"><span class="pre">errors</span></code>和<code class="docutils literal"><span class="pre">newlines</span></code></span></td></tr></tbody></table><div class="section" id="i-o-base-classes"><h3><span class="yiyi-st" id="yiyi-105">16.2.3.1. </span><span class="yiyi-st" id="yiyi-106">I/O基础类</span></h3><dl class="class"><dt id="io.IOBase"><span class="yiyi-st" id="yiyi-107"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">IOBase</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-108">所有I / O类的抽象基类，作用于字节流。</span><span class="yiyi-st" id="yiyi-109">没有公共构造函数。</span></p><p><span class="yiyi-st" id="yiyi-110">这个类为许多方法提供了空的抽象实现，派生类可以有选择地重写；默认实现表示不能读取，写入或查找的文件。</span></p><p><span class="yiyi-st" id="yiyi-111">即使<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>未声明<code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>，<code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code>或<code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></span><span class="yiyi-st" id="yiyi-112">此外，当调用不支持的操作时，实现可以引入<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>（或<a class="reference internal" href="#io.UnsupportedOperation" title="io.UnsupportedOperation"><code class="xref py py-exc docutils literal"><span class="pre">UnsupportedOperation</span></code></a>）。</span></p><p><span class="yiyi-st" id="yiyi-113">用于从文件读取或写入文件的二进制数据的基本类型为<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span><span class="yiyi-st" id="yiyi-114">其他<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>也被接受为方法参数。</span><span class="yiyi-st" id="yiyi-115">在某些情况下，例如<a class="reference internal" href="#io.RawIOBase.readinto" title="io.RawIOBase.readinto"><code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code></a>，需要可写对象（例如<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>）。</span><span class="yiyi-st" id="yiyi-116">文本I / O类使用<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>数据。</span></p><p><span class="yiyi-st" id="yiyi-117">请注意，在封闭流上调用任何方法（甚至查询）都是未定义的。</span><span class="yiyi-st" id="yiyi-118">在这种情况下，实现可能会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-119"><a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>（及其子类）支持迭代器协议，这意味着可以迭代一个<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>对象，以生成流中的行。</span><span class="yiyi-st" id="yiyi-120">根据流是二进制流（产生字节）还是文本流（产生字符串），行定义稍有不同。</span><span class="yiyi-st" id="yiyi-121">请参阅下面的<a class="reference internal" href="#io.IOBase.readline" title="io.IOBase.readline"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-122"><a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>也是一个上下文管理器，因此支持<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句。</span><span class="yiyi-st" id="yiyi-123">在此示例中，<em>文件</em>在<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句的套件完成后关闭 - 即使发生异常：</span></p><pre><code class="language-python"><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'spam.txt'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
    <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'Spam and eggs!'</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-124"><a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>提供这些数据属性和方法：</span></p><dl class="method"><dt id="io.IOBase.close"><span class="yiyi-st" id="yiyi-125"> <code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-126">刷新并关闭此流。</span><span class="yiyi-st" id="yiyi-127">如果文件已关闭，此方法不起作用。</span><span class="yiyi-st" id="yiyi-128">一旦文件关闭，文件上的任何操作（例如，</span><span class="yiyi-st" id="yiyi-129">读取或写入）将引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-130">为方便起见，允许多次调用此方法；只有第一个调用，但是，将有一个效果。</span></p></dd></dl><dl class="attribute"><dt id="io.IOBase.closed"><span class="yiyi-st" id="yiyi-131"> <code class="descname">closed</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-132"><code class="docutils literal"><span class="pre">True</span></code>如果流已关闭。</span></p></dd></dl><dl class="method"><dt id="io.IOBase.fileno"><span class="yiyi-st" id="yiyi-133"> <code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-134">返回底层文件描述如果存在流，则描述流（一个整数）。</span><span class="yiyi-st" id="yiyi-135">如果IO对象不使用文件描述器，则会引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="io.IOBase.flush"><span class="yiyi-st" id="yiyi-136"> <code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-137">如果适用，刷新流的写缓冲区。</span><span class="yiyi-st" id="yiyi-138">这对只读和非阻塞流不做任何操作。</span></p></dd></dl><dl class="method"><dt id="io.IOBase.isatty"><span class="yiyi-st" id="yiyi-139"> <code class="descname">isatty</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-140">如果流是交互式的（即，连接到终端/ tty设备），则返回<code class="docutils literal"><span class="pre">True</span></code>。</span></p></dd></dl><dl class="method"><dt id="io.IOBase.readable"><span class="yiyi-st" id="yiyi-141"> <code class="descname">readable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-142">如果可以从中读取流，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-143">如果<code class="docutils literal"><span class="pre">False</span></code>，<code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>将引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="io.IOBase.readline"><span class="yiyi-st" id="yiyi-144"> <code class="descname">readline</code><span class="sig-paren">(</span><em>size=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-145">从流中读取并返回一行。</span><span class="yiyi-st" id="yiyi-146">如果指定<em>size</em>，则将读取最多<em>size</em>个字节。</span></p><p><span class="yiyi-st" id="yiyi-147">对于二进制文件，行终止符始终为<code class="docutils literal"><span class="pre">b'\n'</span></code>；对于文本文件，<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>的<em>换行符</em>参数可用于选择识别的行终止符。</span></p></dd></dl><dl class="method"><dt id="io.IOBase.readlines"><span class="yiyi-st" id="yiyi-148"> <code class="descname">readlines</code><span class="sig-paren">(</span><em>hint=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-149">读取并返回流中的行列表。</span><span class="yiyi-st" id="yiyi-150">可以指定<em>提示</em>以控制读取的行数：如果所有行的总大小（以字节/字符）超过<em>hint</em>，则不会再读取行。</span></p><p><span class="yiyi-st" id="yiyi-151">请注意，已经可以在 <span class="pre">文件中使用<code class="docutils literal"><span class="pre">来为</span> <span class="pre">行</span> <span class="pre">迭代文件对象：</span></code></span> <span class="pre">...</span>，而无需调用<code class="docutils literal"><span class="pre">file.readlines()</span></code>。</span></p></dd></dl><dl class="method"><dt id="io.IOBase.seek"><span class="yiyi-st" id="yiyi-152"> <code class="descname">seek</code><span class="sig-paren">(</span><em>offset</em><span class="optional">[</span>, <em>whence</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-153">将流位置更改为给定字节<em>偏移量</em>。</span><span class="yiyi-st" id="yiyi-154"><em>偏移</em>相对于由<em>whence</em>指示的位置进行解释。</span><span class="yiyi-st" id="yiyi-155"><em>whence</em>的默认值为<code class="xref py py-data docutils literal"><span class="pre">SEEK_SET</span></code>。</span><span class="yiyi-st" id="yiyi-156"><em>whence</em>的值为：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-157"><code class="xref py py-data docutils literal"><span class="pre">SEEK_SET</span></code>或<code class="docutils literal"><span class="pre">0</span></code>  - 流的开始（默认）； <em>offset</em>应为零或正数</span></li><li><span class="yiyi-st" id="yiyi-158"><code class="xref py py-data docutils literal"><span class="pre">SEEK_CUR</span></code>或<code class="docutils literal"><span class="pre">1</span></code>  - 当前流位置； <em>offset</em>可能为负值</span></li><li><span class="yiyi-st" id="yiyi-159"><code class="xref py py-data docutils literal"><span class="pre">SEEK_END</span></code>或<code class="docutils literal"><span class="pre">2</span></code>  - 流的结束； <em>offset</em>通常为负数</span></li></ul><p><span class="yiyi-st" id="yiyi-160">返回新的绝对位置。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-161"><span class="versionmodified">版本3.1中的新功能：</span> <code class="docutils literal"><span class="pre">SEEK_*</span></code>常数。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-162"><span class="versionmodified">版本3.3中的新功能：</span>某些操作系统可能支持其他值，例如<code class="xref py py-data docutils literal"><span class="pre">os.SEEK_HOLE</span></code>或<code class="xref py py-data docutils literal"><span class="pre">os.SEEK_DATA</span></code>。</span><span class="yiyi-st" id="yiyi-163">文件的有效值可能取决于它是以文本还是二进制模式打开。</span></p></div></dd></dl><dl class="method"><dt id="io.IOBase.seekable"><span class="yiyi-st" id="yiyi-164"> <code class="descname">seekable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-165">如果流支持随机访问，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-166">If <code class="docutils literal"><span class="pre">False</span></code>, <a class="reference internal" href="#io.IOBase.seek" title="io.IOBase.seek"><code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code></a>, <a class="reference internal" href="#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal"><span class="pre">tell()</span></code></a> and <a class="reference internal" href="#io.IOBase.truncate" title="io.IOBase.truncate"><code class="xref py py-meth docutils literal"><span class="pre">truncate()</span></code></a> will raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>.</span></p></dd></dl><dl class="method"><dt id="io.IOBase.tell"><span class="yiyi-st" id="yiyi-167"> <code class="descname">tell</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-168">返回当前流位置。</span></p></dd></dl><dl class="method"><dt id="io.IOBase.truncate"><span class="yiyi-st" id="yiyi-169"> <code class="descname">truncate</code><span class="sig-paren">(</span><em>size=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-170">将流大小调整为给定的<em>大小</em>（如果未指定<em>大小</em>，则为当前位置）。</span><span class="yiyi-st" id="yiyi-171">当前流位置不更改。</span><span class="yiyi-st" id="yiyi-172">此调整大小可以扩展或减小当前文件大小。</span><span class="yiyi-st" id="yiyi-173">在扩展的情况下，新文件区域的内容取决于平台（在大多数系统上，附加字节为零填充）。</span><span class="yiyi-st" id="yiyi-174">返回新文件大小。</span></p></dd></dl><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-175"><span class="versionmodified">在3.5版本中已更改：</span> Windows将在扩展时将零填充文件。</span></p></div><dl class="method"><dt id="io.IOBase.writable"><span class="yiyi-st" id="yiyi-176"> <code class="descname">writable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-177">如果流支持写入，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-178">如果<code class="docutils literal"><span class="pre">False</span></code>，<code class="xref py py-meth docutils literal"><span class="pre">write()</span></code>和<a class="reference internal" href="#io.IOBase.truncate" title="io.IOBase.truncate"><code class="xref py py-meth docutils literal"><span class="pre">truncate()</span></code></a>将引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="io.IOBase.writelines"><span class="yiyi-st" id="yiyi-179"> <code class="descname">writelines</code><span class="sig-paren">(</span><em>lines</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-180">向流中写入一行列表。</span><span class="yiyi-st" id="yiyi-181">不添加行分隔符，因此通常是每行在末尾提供行分隔符。</span></p></dd></dl><dl class="method"><dt id="io.IOBase.__del__"><span class="yiyi-st" id="yiyi-182"> <code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-183">准备对象销毁。</span><span class="yiyi-st" id="yiyi-184"><a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>提供了调用实例的<a class="reference internal" href="#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a>方法的默认实现。</span></p></dd></dl></dd></dl><dl class="class"><dt id="io.RawIOBase"><span class="yiyi-st" id="yiyi-185"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">RawIOBase</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-186">原始二进制I / O的基类。</span><span class="yiyi-st" id="yiyi-187">它继承<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>。</span><span class="yiyi-st" id="yiyi-188">没有公共构造函数。</span></p><p><span class="yiyi-st" id="yiyi-189">原始二进制I / O通常提供对底层操作系统设备或API的低级访问，并且不尝试将其封装在高级原语中（这留给缓冲I / O和文本I / O，将在本文后面描述页）。</span></p><p><span class="yiyi-st" id="yiyi-190">除了来自<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>的属性和方法，<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>提供以下方法：</span></p><dl class="method"><dt id="io.RawIOBase.read"><span class="yiyi-st" id="yiyi-191"> <code class="descname">read</code><span class="sig-paren">(</span><em>size=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-192">从对象中读取<em>size</em>字节并返回它们。</span><span class="yiyi-st" id="yiyi-193">为方便起见，如果<em>size</em>未指定或-1，则调用<a class="reference internal" href="#io.RawIOBase.readall" title="io.RawIOBase.readall"><code class="xref py py-meth docutils literal"><span class="pre">readall()</span></code></a>。</span><span class="yiyi-st" id="yiyi-194">否则，只有一个系统调用。</span><span class="yiyi-st" id="yiyi-195">如果操作系统调用返回的小于<em>大小</em>字节，则可能会返回小于<em>大小</em>的字节。</span></p><p><span class="yiyi-st" id="yiyi-196">如果返回0字节，并且<em>size</em>不为0，则表示文件结束。</span><span class="yiyi-st" id="yiyi-197">如果对象处于非阻塞模式并且没有字节可用，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="method"><dt id="io.RawIOBase.readall"><span class="yiyi-st" id="yiyi-198"> <code class="descname">readall</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-199">读取并返回流中的所有字节，直到EOF，如果必要，使用多个调用流。</span></p></dd></dl><dl class="method"><dt id="io.RawIOBase.readinto"><span class="yiyi-st" id="yiyi-200"> <code class="descname">readinto</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-201">将字节读入预分配的可写入<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>b</em>，并返回读取的字节数。</span><span class="yiyi-st" id="yiyi-202">如果对象处于非阻塞模式并且没有字节可用，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="method"><dt id="io.RawIOBase.write"><span class="yiyi-st" id="yiyi-203"> <code class="descname">write</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-204">将给定的<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>，<em>b</em>写入基础原始流，并返回写入的字节数。</span><span class="yiyi-st" id="yiyi-205">这可以小于以字节为单位的<em>b</em>的长度，这取决于基本原始流的细节，特别是如果它处于非阻塞模式。</span><span class="yiyi-st" id="yiyi-206">如果原始流设置为不阻塞，并且没有单个字节可以轻松写入，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-207">在此方法返回后，调用者可以释放或改变<em>b</em>，因此实现应该只在方法调用期间访问<em>b</em>。</span></p></dd></dl></dd></dl><dl class="class"><dt id="io.BufferedIOBase"><span class="yiyi-st" id="yiyi-208"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">BufferedIOBase</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-209">支持某种缓冲的二进制流的基类。</span><span class="yiyi-st" id="yiyi-210">它继承<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>。</span><span class="yiyi-st" id="yiyi-211">没有公共构造函数。</span></p><p><span class="yiyi-st" id="yiyi-212">与<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>的主要区别在于方法<a class="reference internal" href="#io.BufferedIOBase.read" title="io.BufferedIOBase.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>，<a class="reference internal" href="#io.BufferedIOBase.readinto" title="io.BufferedIOBase.readinto"><code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code></a>和<a class="reference internal" href="#io.BufferedIOBase.write" title="io.BufferedIOBase.write"><code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-213">此外，如果底层原始流处于非阻塞模式并且无法获取或提供足够的数据，那么这些方法可以引发<a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal"><span class="pre">BlockingIOError</span></code></a>；与他们的<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>不同，他们永远不会返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-214">此外，<a class="reference internal" href="#io.BufferedIOBase.read" title="io.BufferedIOBase.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>方法没有延迟到<a class="reference internal" href="#io.BufferedIOBase.readinto" title="io.BufferedIOBase.readinto"><code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code></a>的默认实现。</span></p><p><span class="yiyi-st" id="yiyi-215">典型的<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>实现不应继承自<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>实现，而是像第一个<a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">BufferedWriter</span></code></a>和<a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal"><span class="pre">BufferedReader</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-216"><a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>除了来自<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>的方法和属性，还提供或覆盖这些方法和属性：</span></p><dl class="attribute"><dt id="io.BufferedIOBase.raw"><span class="yiyi-st" id="yiyi-217"> <code class="descname">raw</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-218"><a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>处理的基本原始流（<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>实例）。</span><span class="yiyi-st" id="yiyi-219">这不是<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a> API的一部分，在某些实现上可能不存在。</span></p></dd></dl><dl class="method"><dt id="io.BufferedIOBase.detach"><span class="yiyi-st" id="yiyi-220"> <code class="descname">detach</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-221">从缓冲区分离下层原始流并返回它。</span></p><p><span class="yiyi-st" id="yiyi-222">在原始流已经分离之后，缓冲器处于不可用状态。</span></p><p><span class="yiyi-st" id="yiyi-223">一些缓冲区，如<a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>，没有从此方法返回的单个原始流的概念。</span><span class="yiyi-st" id="yiyi-224">他们引发<a class="reference internal" href="#io.UnsupportedOperation" title="io.UnsupportedOperation"><code class="xref py py-exc docutils literal"><span class="pre">UnsupportedOperation</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-225"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="io.BufferedIOBase.read"><span class="yiyi-st" id="yiyi-226"> <code class="descname">read</code><span class="sig-paren">(</span><em>size=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-227">读取并返回大小<em>大小</em>字节。</span><span class="yiyi-st" id="yiyi-228">如果省略参数，则<code class="docutils literal"><span class="pre">None</span></code>或负数，读取并返回数据，直到到达EOF。</span><span class="yiyi-st" id="yiyi-229">如果流已经处于EOF，则返回一个空的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>对象。</span></p><p><span class="yiyi-st" id="yiyi-230">如果参数是正的，并且基本的原始流不是交互式的，则可以发出多个原始读取以满足字节计数（除非首先达到EOF）。</span><span class="yiyi-st" id="yiyi-231">但是对于交互式原始流，最多只会发出一次原始读取，而较短的结果并不意味着EOF即将来临。</span></p><p><span class="yiyi-st" id="yiyi-232">如果基础原始流处于非阻塞模式，并且此时没有可用数据，则会引发<a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal"><span class="pre">BlockingIOError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="io.BufferedIOBase.read1"><span class="yiyi-st" id="yiyi-233"> <code class="descname">read1</code><span class="sig-paren">(</span><em>size=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-234">读取并返回最多<em>size</em>字节，最多只能调用基础原始流的<a class="reference internal" href="#io.RawIOBase.read" title="io.RawIOBase.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>（或<a class="reference internal" href="#io.RawIOBase.readinto" title="io.RawIOBase.readinto"><code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code></a>）方法。</span><span class="yiyi-st" id="yiyi-235">如果您在<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>对象的顶部实现自己的缓冲，这可能很有用。</span></p></dd></dl><dl class="method"><dt id="io.BufferedIOBase.readinto"><span class="yiyi-st" id="yiyi-236"> <code class="descname">readinto</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-237">将字节读入预分配的可写入<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>b</em>并返回读取的字节数。</span></p><p><span class="yiyi-st" id="yiyi-238">像<a class="reference internal" href="#io.BufferedIOBase.read" title="io.BufferedIOBase.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>，可以向底层原始流发出多个读取，除非后者是交互式的。</span></p><p><span class="yiyi-st" id="yiyi-239">如果基础原始流处于非阻塞模式，并且此时没有可用数据，则会引发<a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal"><span class="pre">BlockingIOError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="io.BufferedIOBase.readinto1"><span class="yiyi-st" id="yiyi-240"> <code class="descname">readinto1</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-241">使用至多一次调用基础原始流的<a class="reference internal" href="#io.RawIOBase.read" title="io.RawIOBase.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>()函数将字节读入预分配的可写<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>b</em>或<a class="reference internal" href="#io.RawIOBase.readinto" title="io.RawIOBase.readinto"><code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code></a>）方法。</span><span class="yiyi-st" id="yiyi-242">返回读取的字节数。</span></p><p><span class="yiyi-st" id="yiyi-243">如果基础原始流处于非阻塞模式，并且此时没有可用数据，则会引发<a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal"><span class="pre">BlockingIOError</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-244"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="io.BufferedIOBase.write"><span class="yiyi-st" id="yiyi-245"> <code class="descname">write</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-246">写入给定的<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>，<em>b</em>，并返回写入的字节数（总是等于<em>b</em>如果写操作失败，则会出现<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>）。</span><span class="yiyi-st" id="yiyi-247">根据实际实现，这些字节可以容易地写入底层流，或者由于性能和等待时间的原因保持在缓冲器中。</span></p><p><span class="yiyi-st" id="yiyi-248">当处于非阻塞模式时，如果数据需要写入原始流，但不能接受所有数据而不阻塞，则会引发<a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal"><span class="pre">BlockingIOError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-249">在此方法返回后，调用者可以释放或改变<em>b</em>，因此实现应该只在方法调用期间访问<em>b</em>。</span></p></dd></dl></dd></dl></div><div class="section" id="raw-file-i-o"><h3><span class="yiyi-st" id="yiyi-250">16.2.3.2. </span><span class="yiyi-st" id="yiyi-251">原始文件I/O</span></h3><dl class="class"><dt id="io.FileIO"><span class="yiyi-st" id="yiyi-252"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">FileIO</code><span class="sig-paren">(</span><em>name</em>, <em>mode='r'</em>, <em>closefd=True</em>, <em>opener=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-253"><a class="reference internal" href="#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal"><span class="pre">FileIO</span></code></a>表示包含字节数据的操作系统级文件。</span><span class="yiyi-st" id="yiyi-254">它实现<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>接口（因此也实现<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>接口）。</span></p><p><span class="yiyi-st" id="yiyi-255"><em>名称</em>可以是以下两种情况之一：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-256">一个字符串或<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>对象，表示要打开的文件的路径。</span><span class="yiyi-st" id="yiyi-257">在这种情况下，closefd必须为True（默认值），否则会引发错误。</span></li><li><span class="yiyi-st" id="yiyi-258">一个表示现有OS级别文件的编号的整数，由此产生的<a class="reference internal" href="#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal"><span class="pre">FileIO</span></code></a>对象将赋予访问权限。</span><span class="yiyi-st" id="yiyi-259">当FileIO对象关闭时，fd也将关闭，除非<em>closefd</em>设置为<code class="docutils literal"><span class="pre">False</span></code>。</span></li></ul><p><span class="yiyi-st" id="yiyi-260"><em>模式</em>可以是<code class="docutils literal"><span class="pre">'r'</span></code>，<code class="docutils literal"><span class="pre">'w'</span></code>，<code class="docutils literal"><span class="pre">'x'</span></code>或<code class="docutils literal"><span class="pre">'a'</span></code>用于阅读（默认），书写，独家创作或追加。</span><span class="yiyi-st" id="yiyi-261">该文件将被创建，如果它不存在时打开进行写或附加；它会在打开时被截断。</span><span class="yiyi-st" id="yiyi-262"><a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a>将会被提出，如果它在打开时已经存在。</span><span class="yiyi-st" id="yiyi-263">打开用于创建的文件意味着写入，因此此模式的行为方式类似于<code class="docutils literal"><span class="pre">'w'</span></code>。</span><span class="yiyi-st" id="yiyi-264">将<code class="docutils literal"><span class="pre">'+'</span></code>添加到模式以允许同时读取和写入。</span></p><p><span class="yiyi-st" id="yiyi-265"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>（当使用正参数调用时），此类的<code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></span></p><p><span class="yiyi-st" id="yiyi-266">通过传递可调用对象<em>opener</em>可以使用自定义开启器。</span><span class="yiyi-st" id="yiyi-267">然后通过使用（<em>名称</em>，<em>标志</em>）调用<em>opener</em>获得文件对象的基础文件描述器。</span><span class="yiyi-st" id="yiyi-268"><em>opener</em>必须返回一个打开的文件描述器（传递<a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-mod docutils literal"><span class="pre">os.open</span></code></a>为<em>opener</em> 结果类似的功能 <code class="docutils literal"><span class="pre">None</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-269">新创建的文件为<a class="reference internal" href="os.html#fd-inheritance"><span>non-inheritable</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-270">有关使用<em>开启</em>参数的示例，请参见<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>内建函数。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-271"><span class="versionmodified">在版本3.3中已更改：</span>添加了<em>开启程序</em>参数。</span><span class="yiyi-st" id="yiyi-272">添加了<code class="docutils literal"><span class="pre">'x'</span></code>模式。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-273"><span class="versionmodified">在版本3.4中更改：</span>此文件现在是不可继承的。</span></p></div><p><span class="yiyi-st" id="yiyi-274">除了<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>和<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>的属性和方法，<a class="reference internal" href="#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal"><span class="pre">FileIO</span></code></a>提供以下数据属性：</span></p><dl class="attribute"><dt id="io.FileIO.mode"><span class="yiyi-st" id="yiyi-275"> <code class="descname">mode</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-276">在构造函数中给出的模式。</span></p></dd></dl><dl class="attribute"><dt id="io.FileIO.name"><span class="yiyi-st" id="yiyi-277"> <code class="descname">name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-278">文件名。</span><span class="yiyi-st" id="yiyi-279">这是当在构造函数中没有给出名称时文件的描述器。</span></p></dd></dl></dd></dl></div><div class="section" id="buffered-streams"><h3><span class="yiyi-st" id="yiyi-280">16.2.3.3. </span><span class="yiyi-st" id="yiyi-281">缓冲流 </span></h3><p><span class="yiyi-st" id="yiyi-282">缓冲I / O流为I / O设备提供了比原始I / O更高级别的接口。</span></p><dl class="class"><dt id="io.BytesIO"><span class="yiyi-st" id="yiyi-283"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">BytesIO</code><span class="sig-paren">(</span><span class="optional">[</span><em>initial_bytes</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-284">使用内存中字节缓冲区的流实现。</span><span class="yiyi-st" id="yiyi-285">它继承<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>。</span><span class="yiyi-st" id="yiyi-286">当调用<a class="reference internal" href="#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a>方法时，缓冲区将被丢弃。</span></p><p><span class="yiyi-st" id="yiyi-287">可选参数<em>initial_bytes</em>是包含初始数据的<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-288">除了来自<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>和<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>的<a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>提供或覆盖这些方法：</span></p><dl class="method"><dt id="io.BytesIO.getbuffer"><span class="yiyi-st" id="yiyi-289"> <code class="descname">getbuffer</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-290">对缓冲区的内容返回可读写的视图，而不复制它们。</span><span class="yiyi-st" id="yiyi-291">另外，改变视图将透明地更新缓冲区的内容：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">b</span><span class="s2">"abcdef"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getbuffer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="s2">"56"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">b'ab56ef'</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-292">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-293">只要视图存在，<a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>对象就无法调整大小或关闭。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-294"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="io.BytesIO.getvalue"><span class="yiyi-st" id="yiyi-295"> <code class="descname">getvalue</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-296">返回<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>，其中包含缓冲区的全部内容。</span></p></dd></dl><dl class="method"><dt id="io.BytesIO.read1"><span class="yiyi-st" id="yiyi-297"> <code class="descname">read1</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-298">在<a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>中，这与<code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>相同。</span></p></dd></dl><dl class="method"><dt id="io.BytesIO.readinto1"><span class="yiyi-st" id="yiyi-299"> <code class="descname">readinto1</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-300">在<a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>中，这与<code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code>相同。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-301"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl></dd></dl><dl class="class"><dt id="io.BufferedReader"><span class="yiyi-st" id="yiyi-302"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">BufferedReader</code><span class="sig-paren">(</span><em>raw</em>, <em>buffer_size=DEFAULT_BUFFER_SIZE</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-303">一个提供对可读，顺序<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>对象的高级访问的缓冲区。</span><span class="yiyi-st" id="yiyi-304">它继承<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>。</span><span class="yiyi-st" id="yiyi-305">当从该对象读取数据时，可以从底层原始流请求更大量的数据，并保存在内部缓冲器中。</span><span class="yiyi-st" id="yiyi-306">然后可以在后续读取时直接返回缓冲的数据。</span></p><p><span class="yiyi-st" id="yiyi-307">构造函数为给定可读的<em>raw</em>流和<em>buffer_size</em>创建<a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal"><span class="pre">BufferedReader</span></code></a>。</span><span class="yiyi-st" id="yiyi-308">如果省略<em>buffer_size</em>，则使用<a class="reference internal" href="#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT_BUFFER_SIZE</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-309"><a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal"><span class="pre">BufferedReader</span></code></a>除了来自<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>和<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>的方法，还提供或覆盖这些方法：</span></p><dl class="method"><dt id="io.BufferedReader.peek"><span class="yiyi-st" id="yiyi-310"> <code class="descname">peek</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-311">从流中返回字节，但不推进位置。</span><span class="yiyi-st" id="yiyi-312">对原始流最多只能进行一次读取以满足调用。</span><span class="yiyi-st" id="yiyi-313">返回的字节数可以小于或大于请求的字节数。</span></p></dd></dl><dl class="method"><dt id="io.BufferedReader.read"><span class="yiyi-st" id="yiyi-314"> <code class="descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-315">读取并返回<em>大小</em>字节，或者如果<em>大小</em>没有给出或为负，直到EOF或读取调用在非阻塞模式下阻塞。</span></p></dd></dl><dl class="method"><dt id="io.BufferedReader.read1"><span class="yiyi-st" id="yiyi-316"> <code class="descname">read1</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-317">读取并返回最多<em>size</em>字节，原始流只有一个调用。</span><span class="yiyi-st" id="yiyi-318">如果至少一个字节被缓冲，则仅返回被缓冲的字节。</span><span class="yiyi-st" id="yiyi-319">否则，进行一个原始流读取调用。</span></p></dd></dl></dd></dl><dl class="class"><dt id="io.BufferedWriter"><span class="yiyi-st" id="yiyi-320"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">BufferedWriter</code><span class="sig-paren">(</span><em>raw</em>, <em>buffer_size=DEFAULT_BUFFER_SIZE</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-321">一个缓冲区，提供对可写入的顺序<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>对象的高级访问。</span><span class="yiyi-st" id="yiyi-322">它继承<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>。</span><span class="yiyi-st" id="yiyi-323">写入此对象时，通常将数据放入内部缓冲区。</span><span class="yiyi-st" id="yiyi-324">缓冲区将在各种条件下写入到基础的<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>对象，包括：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-325">当缓冲器对于所有未决数据变得太小时；</span></li><li><span class="yiyi-st" id="yiyi-326">当调用<a class="reference internal" href="#io.BufferedWriter.flush" title="io.BufferedWriter.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a>时；</span></li><li><span class="yiyi-st" id="yiyi-327">当请求<code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code>时（对于<a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal"><span class="pre">BufferedRandom</span></code></a>对象）；</span></li><li><span class="yiyi-st" id="yiyi-328">当<a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">BufferedWriter</span></code></a>对象被关闭或销毁时。</span></li></ul><p><span class="yiyi-st" id="yiyi-329">构造函数为给定的可写入<em>raw</em>流创建<a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">BufferedWriter</span></code></a>。</span><span class="yiyi-st" id="yiyi-330">如果未指定<em>buffer_size</em>，则默认为<a class="reference internal" href="#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT_BUFFER_SIZE</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-331"><a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">BufferedWriter</span></code></a>除了提供或覆盖来自<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>和<a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>的方法：</span></p><dl class="method"><dt id="io.BufferedWriter.flush"><span class="yiyi-st" id="yiyi-332"> <code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-333">将缓冲区中保存的字节强制为原始流。</span><span class="yiyi-st" id="yiyi-334">如果原始流被阻塞，应该引发<a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal"><span class="pre">BlockingIOError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="io.BufferedWriter.write"><span class="yiyi-st" id="yiyi-335"> <code class="descname">write</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-336">写入<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>，<em>b</em>，并返回写入的字节数。</span><span class="yiyi-st" id="yiyi-337">当处于非阻塞模式时，如果缓冲区需要被写出而原始流被阻塞，则会引发<a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal"><span class="pre">BlockingIOError</span></code></a>。</span></p></dd></dl></dd></dl><dl class="class"><dt id="io.BufferedRandom"><span class="yiyi-st" id="yiyi-338"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">BufferedRandom</code><span class="sig-paren">(</span><em>raw</em>, <em>buffer_size=DEFAULT_BUFFER_SIZE</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-339">缓冲接口，用于随机访问流。</span><span class="yiyi-st" id="yiyi-340">它继承<a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal"><span class="pre">BufferedReader</span></code></a>和<a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">BufferedWriter</span></code></a>，并进一步支持<code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">tell()</span></code>功能。</span></p><p><span class="yiyi-st" id="yiyi-341">构造函数为第一个参数中给出的可寻找的原始流创建一个读取器和写入器。</span><span class="yiyi-st" id="yiyi-342">如果省略<em>buffer_size</em>，它默认为<a class="reference internal" href="#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT_BUFFER_SIZE</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-343"><a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal"><span class="pre">BufferedRandom</span></code></a>能够处理任何<a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal"><span class="pre">BufferedReader</span></code></a>或<a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">BufferedWriter</span></code></a>。</span></p></dd></dl><dl class="class"><dt id="io.BufferedRWPair"><span class="yiyi-st" id="yiyi-344"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">BufferedRWPair</code><span class="sig-paren">(</span><em>reader</em>, <em>writer</em>, <em>buffer_size=DEFAULT_BUFFER_SIZE</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-345">缓冲I / O对象将两个单向<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>对象（一个可读，另一个可写）组合到单个双向端点中。</span><span class="yiyi-st" id="yiyi-346">它继承<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-347"><em>读取器</em>和<em>写入器</em>是分别可读和可写的<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-348">如果省略<em>buffer_size</em>，它默认为<a class="reference internal" href="#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-data docutils literal"><span class="pre">DEFAULT_BUFFER_SIZE</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-349"><a class="reference internal" href="#io.BufferedRWPair" title="io.BufferedRWPair"><code class="xref py py-class docutils literal"><span class="pre">BufferedRWPair</span></code></a>实施除了<a class="reference internal" href="#io.BufferedIOBase.detach" title="io.BufferedIOBase.detach"><code class="xref py py-meth docutils literal"><span class="pre">detach()</span></code></a>之外的所有<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>方法，其引发<a class="reference internal" href="#io.UnsupportedOperation" title="io.UnsupportedOperation"><code class="xref py py-exc docutils literal"><span class="pre">UnsupportedOperation</span></code></a>。</span></p><div class="admonition warning"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-350">警告</span></p><p class="last"><span class="yiyi-st" id="yiyi-351"><a class="reference internal" href="#io.BufferedRWPair" title="io.BufferedRWPair"><code class="xref py py-class docutils literal"><span class="pre">BufferedRWPair</span></code></a>不会尝试同步对其基础原始流的访问。</span><span class="yiyi-st" id="yiyi-352">你不应该把它作为读者和作家的同一个对象；请改用<a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal"><span class="pre">BufferedRandom</span></code></a>。</span></p></div></dd></dl></div><div class="section" id="id1"><h3><span class="yiyi-st" id="yiyi-353">16.2.3.4. </span><span class="yiyi-st" id="yiyi-354">文本 I/O </span></h3><dl class="class"><dt id="io.TextIOBase"><span class="yiyi-st" id="yiyi-355"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">TextIOBase</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-356">文本流的的基类。</span><span class="yiyi-st" id="yiyi-357">此类提供一个字符和网格线的基于的界面流 i/o。</span><span class="yiyi-st" id="yiyi-358">这里没有 <code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code> 的方法，因为 Python 的字符串是不可变的。</span><span class="yiyi-st" id="yiyi-359">它继承了 <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>。</span><span class="yiyi-st" id="yiyi-360">这里没有公共构造函数。</span></p><p><span class="yiyi-st" id="yiyi-361"><a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a> 提供或重写这些数据的属性和方法除了那些从 <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code class="xref py py-class docutils literal"><span class="pre">IOBase</span></code></a>:</span></p><dl class="attribute"><dt id="io.TextIOBase.encoding"><span class="yiyi-st" id="yiyi-362"> <code class="descname">encoding</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-363">用来解码流的字节转换为字符串，并将字符串编码为字节编码的名称。</span></p></dd></dl><dl class="attribute"><dt id="io.TextIOBase.errors"><span class="yiyi-st" id="yiyi-364"> <code class="descname">errors</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-365">解码器或编码器的错误设置。</span></p></dd></dl><dl class="attribute"><dt id="io.TextIOBase.newlines"><span class="yiyi-st" id="yiyi-366"> <code class="descname">newlines</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-367">一个字符串，字符串，或 <code class="docutils literal"><span class="pre">无</span></code> 指示换行符的元组翻译到目前为止。</span><span class="yiyi-st" id="yiyi-368">根据实现和初始构造函数标志，这可能不可用。</span></p></dd></dl><dl class="attribute"><dt id="io.TextIOBase.buffer"><span class="yiyi-st" id="yiyi-369"> <code class="descname">buffer</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-370"><a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a>处理的基本二进制缓冲区（<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a>实例）。</span><span class="yiyi-st" id="yiyi-371">这不是<a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a> API的一部分，在某些实现中可能不存在。</span></p></dd></dl><dl class="method"><dt id="io.TextIOBase.detach"><span class="yiyi-st" id="yiyi-372"> <code class="descname">detach</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-373">将底层的二进制缓冲区与<a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a>分开并返回。</span></p><p><span class="yiyi-st" id="yiyi-374">分离下层缓冲区后，<a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a>处于不可用状态。</span></p><p><span class="yiyi-st" id="yiyi-375">一些<a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a>实现，如<a class="reference internal" href="#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">StringIO</span></code></a>，可能没有底层缓冲区的概念，并调用此方法将引发<a class="reference internal" href="#io.UnsupportedOperation" title="io.UnsupportedOperation"><code class="xref py py-exc docutils literal"><span class="pre">UnsupportedOperation</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-376"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="io.TextIOBase.read"><span class="yiyi-st" id="yiyi-377"> <code class="descname">read</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-378">从流中读取并最多返回<em>大小</em>字符，作为单个<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>。</span><span class="yiyi-st" id="yiyi-379">如果<em>size</em>为负数或<code class="docutils literal"><span class="pre">None</span></code>，则一直读取到EOF。</span></p></dd></dl><dl class="method"><dt id="io.TextIOBase.readline"><span class="yiyi-st" id="yiyi-380"> <code class="descname">readline</code><span class="sig-paren">(</span><em>size=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-381">一直读取到换行符或EOF并返回单个<code class="docutils literal"><span class="pre">str</span></code>。</span><span class="yiyi-st" id="yiyi-382">如果流已经到EOF，则返回一个空字符串。</span></p><p><span class="yiyi-st" id="yiyi-383">如果指定<em>size</em>，则最多只能读取<em>size</em>个字符。</span></p></dd></dl><dl class="method"><dt id="io.TextIOBase.seek"><span class="yiyi-st" id="yiyi-384"> <code class="descname">seek</code><span class="sig-paren">(</span><em>offset</em><span class="optional">[</span>, <em>whence</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-385">将流位置更改为给定的<em>偏移</em>。</span><span class="yiyi-st" id="yiyi-386">行为取决于<em>whence</em>参数。</span><span class="yiyi-st" id="yiyi-387"><em>whence</em>的默认值为<code class="xref py py-data docutils literal"><span class="pre">SEEK_SET</span></code>。</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-388"><code class="xref py py-data docutils literal"><span class="pre">SEEK_SET</span></code>或<code class="docutils literal"><span class="pre">0</span></code>：从流的开始寻找（默认）； <em>offset</em>必须是由<a class="reference internal" href="#io.TextIOBase.tell" title="io.TextIOBase.tell"><code class="xref py py-meth docutils literal"><span class="pre">TextIOBase.tell()</span></code></a>返回的数字，或零。</span><span class="yiyi-st" id="yiyi-389">任何其他<em>偏移</em>值会产生未定义的行为。</span></li><li><span class="yiyi-st" id="yiyi-390"><code class="xref py py-data docutils literal"><span class="pre">SEEK_CUR</span></code>或<code class="docutils literal"><span class="pre">1</span></code>：“seek”到当前位置； <em>offset</em>必须为零，这是一个无操作（所有其他值都不受支持）。</span></li><li><span class="yiyi-st" id="yiyi-391"><code class="xref py py-data docutils literal"><span class="pre">SEEK_END</span></code>或<code class="docutils literal"><span class="pre">2</span></code>：寻找流的结尾； <em>offset</em>必须为零（所有其他值都不受支持）。</span></li></ul><p><span class="yiyi-st" id="yiyi-392">将新的绝对位置返回为不透明数字。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-393"><span class="versionmodified">版本3.1中的新功能：</span> <code class="docutils literal"><span class="pre">SEEK_*</span></code>常数。</span></p></div></dd></dl><dl class="method"><dt id="io.TextIOBase.tell"><span class="yiyi-st" id="yiyi-394"> <code class="descname">tell</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-395">将当前流位置返回为不透明数字。</span><span class="yiyi-st" id="yiyi-396">该数字通常不表示底层二进制存储中的字节数。</span></p></dd></dl><dl class="method"><dt id="io.TextIOBase.write"><span class="yiyi-st" id="yiyi-397"> <code class="descname">write</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-398">将字符串<em>s</em>写入流，并返回写入的字符数。</span></p></dd></dl></dd></dl><dl class="class"><dt id="io.TextIOWrapper"><span class="yiyi-st" id="yiyi-399"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">TextIOWrapper</code><span class="sig-paren">(</span><em>buffer</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>line_buffering=False</em>, <em>write_through=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-400">在 <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code></a> 二进制流缓冲的文本流。</span><span class="yiyi-st" id="yiyi-401">它继承<a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-402"><em>encoding</em>给出流将被解码或编码的编码的名称。</span><span class="yiyi-st" id="yiyi-403">它默认为<a class="reference internal" href="locale.html#locale.getpreferredencoding" title="locale.getpreferredencoding"><code class="xref py py-func docutils literal"><span class="pre">locale.getpreferredencoding(False)</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-404"><em>errors</em>是一个可选字符串，用于指定如何处理编码和解码错误。</span><span class="yiyi-st" id="yiyi-405">Pass <code class="docutils literal"><span class="pre">'strict'</span></code> to raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> exception if there is an encoding error (the default of <code class="docutils literal"><span class="pre">None</span></code> has the same effect), or pass <code class="docutils literal"><span class="pre">'ignore'</span></code> to ignore errors. </span><span class="yiyi-st" id="yiyi-406">（请注意，忽略编码错误可能会导致数据丢失。）</span><span class="yiyi-st" id="yiyi-407"><code class="docutils literal"><span class="pre">'replace'</span></code>会导致替换标记（例如<code class="docutils literal"><span class="pre">'?'</span></code>）插入到存在格式错误的数据的位置。</span><span class="yiyi-st" id="yiyi-408"><code class="docutils literal"><span class="pre">'backslashreplace'</span></code>导致格式错误的数据被反斜杠转义序列替换。</span><span class="yiyi-st" id="yiyi-409">写入时，<code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code>（替换为相应的XML字符引用）或<code class="docutils literal"><span class="pre">'namereplace'</span></code>（替换为<code class="docutils literal"><span class="pre">\N{...}</span></code></span><span class="yiyi-st" id="yiyi-410">已使用<a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a>注册的任何其他错误处理名称也有效。</span></p><p id="index-1"><span class="yiyi-st" id="yiyi-411"><em>换行符</em>控制如何处理行尾。</span><span class="yiyi-st" id="yiyi-412">它可以是<code class="docutils literal"><span class="pre">None</span></code>、<code class="docutils literal"><span class="pre">''</span></code>、<code class="docutils literal"><span class="pre">'\n'</span></code>、<code class="docutils literal"><span class="pre">'\r'</span></code>、<code class="docutils literal"><span class="pre">'\r\n'</span></code>。</span><span class="yiyi-st" id="yiyi-413">它的工作原理如下：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-414">从流读取输入时，如果<em>换行符</em>为<code class="docutils literal"><span class="pre">None</span></code>，则启用<a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>模式。</span><span class="yiyi-st" id="yiyi-415">输入中的行可以以<code class="docutils literal"><span class="pre">'\n'</span></code>，<code class="docutils literal"><span class="pre">'\r'</span></code>或<code class="docutils literal"><span class="pre">'\r\n'</span></code>结尾，在<code class="docutils literal"><span class="pre">'\n'</span></code>中，然后返回给调用者。</span><span class="yiyi-st" id="yiyi-416">如果它是<code class="docutils literal"><span class="pre">''</span></code>，则启用通用换行符模式，但行结尾将返回给未转换的调用者。</span><span class="yiyi-st" id="yiyi-417">如果它具有任何其他合法值，则输入行仅由给定字符串终止，并且行结尾被返回给未经翻译的调用者。</span></li><li><span class="yiyi-st" id="yiyi-418">将输出写入流时，如果<em>newline</em>为<code class="docutils literal"><span class="pre">None</span></code>，则写入的任何<code class="docutils literal"><span class="pre">'\n'</span></code>字符都将转换为系统默认行分隔符<a class="reference internal" href="os.html#os.linesep" title="os.linesep"><code class="xref py py-data docutils literal"><span class="pre">os.linesep</span></code></a>。</span><span class="yiyi-st" id="yiyi-419">如果<em>换行符</em>是<code class="docutils literal"><span class="pre">''</span></code>或<code class="docutils literal"><span class="pre">'\n'</span></code>，则不会进行转换。</span><span class="yiyi-st" id="yiyi-420">如果<em>换行符</em>是任何其他合法值，写入的任何<code class="docutils literal"><span class="pre">'\n'</span></code>字符都将转换为给定字符串。</span></li></ul><p><span class="yiyi-st" id="yiyi-421">如果<em>line_buffering</em>是<code class="docutils literal"><span class="pre">True</span></code>，则当写入调用包含换行符时，将隐含<code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-422">If <em>write_through</em> is <code class="docutils literal"><span class="pre">True</span></code>, calls to <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> are guaranteed not to be buffered: any data written on the <a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal"><span class="pre">TextIOWrapper</span></code></a> object is immediately handled to its underlying binary <em>buffer</em>.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-423"><span class="versionmodified">在版本3.3中已更改：</span>已添加<em>write_through</em>参数。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-424"><span class="versionmodified">在版本3.3中更改：</span>默认的<em>编码</em>现在为<code class="docutils literal"><span class="pre">locale.getpreferredencoding(False)</span></code>，而不是<code class="docutils literal"><span class="pre">locale.getpreferredencoding()</span></code></span><span class="yiyi-st" id="yiyi-425">请勿使用<a class="reference internal" href="locale.html#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal"><span class="pre">locale.setlocale()</span></code></a>临时更改语言区域编码，而是使用当前语言环境编码，而不是用户首选编码。</span></p></div><p><span class="yiyi-st" id="yiyi-426"><a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal"><span class="pre">TextIOWrapper</span></code></a>除了<a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a>及其父项提供一个属性：</span></p><dl class="attribute"><dt id="io.TextIOWrapper.line_buffering"><span class="yiyi-st" id="yiyi-427"> <code class="descname">line_buffering</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-428">是否启用线路缓冲。</span></p></dd></dl></dd></dl><dl class="class"><dt id="io.StringIO"><span class="yiyi-st" id="yiyi-429"> <em class="property">class </em><code class="descclassname">io.</code><code class="descname">StringIO</code><span class="sig-paren">(</span><em>initial_value=''</em>, <em>newline='\n'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-430">用于文本I / O的内存中流。</span><span class="yiyi-st" id="yiyi-431">当调用<a class="reference internal" href="#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a>方法时，文本缓冲区将被丢弃。</span></p><p><span class="yiyi-st" id="yiyi-432">可以通过提供<em>initial_value</em>来设置缓冲区的初始值。</span><span class="yiyi-st" id="yiyi-433">如果启用了换行符，则换行符将按照<a class="reference internal" href="#io.TextIOBase.write" title="io.TextIOBase.write"><code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></a>进行编码。</span><span class="yiyi-st" id="yiyi-434">流位于缓冲区的开始。</span></p><p><span class="yiyi-st" id="yiyi-435"><em>换行符</em>参数的工作方式类似于<a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal"><span class="pre">TextIOWrapper</span></code></a>。</span><span class="yiyi-st" id="yiyi-436">默认设置仅将<code class="docutils literal"><span class="pre">\n</span></code>字符视为行的末尾，并且不进行换行。</span><span class="yiyi-st" id="yiyi-437">如果<em>换行符</em>设置为<code class="docutils literal"><span class="pre">None</span></code>，则在所有平台上将换行符写为<code class="docutils literal"><span class="pre">\n</span></code>，但是读取时仍会执行通用换行符解码。</span></p><p><span class="yiyi-st" id="yiyi-438"><a class="reference internal" href="#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">StringIO</span></code></a>除了来自<a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code></a>及其父类的方法，还提供此方法：</span></p><dl class="method"><dt id="io.StringIO.getvalue"><span class="yiyi-st" id="yiyi-439"> <code class="descname">getvalue</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-440">返回包含缓冲区的全部内容的<code class="docutils literal"><span class="pre">str</span></code>。</span><span class="yiyi-st" id="yiyi-441">换行符被解码，如同通过<a class="reference internal" href="#io.TextIOBase.read" title="io.TextIOBase.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>，虽然流的位置没有改变。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-442">用法示例：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">io</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
<span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'First line.</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Second line.'</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

<span class="c1"># Retrieve file contents -- this will be</span>
<span class="c1"># 'First line.\nSecond line.\n'</span>
<span class="n">contents</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

<span class="c1"># Close object and discard memory buffer --</span>
<span class="c1"># .getvalue() will now raise an exception.</span>
<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></dd></dl><dl class="class"><dt id="io.IncrementalNewlineDecoder"><span class="yiyi-st" id="yiyi-443"><em class="property">class</em> <code class="descclassname">io。</code> <code class="descname">IncrementalNewlineDecoder</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-444">辅助编解码器，用于解码<a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>模式的换行符。</span><span class="yiyi-st" id="yiyi-445">它继承<a class="reference internal" href="codecs.html#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">codecs.IncrementalDecoder</span></code></a>。</span></p></dd></dl></div></div><div class="section" id="performance"><h2><span class="yiyi-st" id="yiyi-447">16.2.4. </span><span class="yiyi-st" id="yiyi-448">性能</span></h2><p><span class="yiyi-st" id="yiyi-449">本节讨论提供的具体I / O实现的性能。</span></p><div class="section" id="id2"><h3><span class="yiyi-st" id="yiyi-450">16.2.4.1. </span><span class="yiyi-st" id="yiyi-451">二进制I / O </span></h3><p><span class="yiyi-st" id="yiyi-452">通过只读取和写入大量数据，即使用户请求单个字节，缓冲I / O隐藏了调用和执行操作系统的未缓冲I / O例程的任何低效率。</span><span class="yiyi-st" id="yiyi-453">增益取决于OS和执行的I / O的种类。</span><span class="yiyi-st" id="yiyi-454">例如，在某些现代操作系统（如Linux）上，无缓冲磁盘I / O可以与缓冲I / O一样快。</span><span class="yiyi-st" id="yiyi-455">然而，底线是缓冲I / O提供可预测的性能，而不管平台和后备设备。</span><span class="yiyi-st" id="yiyi-456">因此，对于二进制数据，几乎总是优选使用缓冲I / O而不是无缓冲I / O。</span></p></div><div class="section" id="id3"><h3><span class="yiyi-st" id="yiyi-457">16.2.4.2. </span><span class="yiyi-st" id="yiyi-458">文本I / O </span></h3><p><span class="yiyi-st" id="yiyi-459">二进制存储（例如文件）上的文本I / O比同一存储上的二进制I / O慢得多，因为它需要使用字符编解码器在Unicode和二进制数据之间进行转换。</span><span class="yiyi-st" id="yiyi-460">这可以变得明显处理大量的文本数据，如大日志文件。</span><span class="yiyi-st" id="yiyi-461">此外，由于使用重构算法，<code class="xref py py-meth docutils literal"><span class="pre">TextIOWrapper.tell()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">TextIOWrapper.seek()</span></code>都相当慢。</span></p><p><span class="yiyi-st" id="yiyi-462"><a class="reference internal" href="#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">StringIO</span></code></a>是一个原生的内存中的unicode容器，并且会显示与<a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>类似的速度。</span></p></div><div class="section" id="multi-threading"><h3><span class="yiyi-st" id="yiyi-463">16.2.4.3. </span><span class="yiyi-st" id="yiyi-464">多线程</span></h3><p><span class="yiyi-st" id="yiyi-465"><a class="reference internal" href="#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal"><span class="pre">FileIO</span></code></a>对象在操作系统调用（例如Unix下的<code class="docutils literal"><span class="pre">read(2)</span></code>）范围内是线程安全的，它们也是线程安全的。</span></p><p><span class="yiyi-st" id="yiyi-466">二进制缓冲对象（<a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal"><span class="pre">BufferedReader</span></code></a>，<a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">BufferedWriter</span></code></a>，<a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal"><span class="pre">BufferedRandom</span></code></a>和<a class="reference internal" href="#io.BufferedRWPair" title="io.BufferedRWPair"><code class="xref py py-class docutils literal"><span class="pre">BufferedRWPair</span></code></a>）的实例使用锁保护其内部结构；因此可以安全地同时从多个线程调用它们。</span></p><p><span class="yiyi-st" id="yiyi-467"><a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal"><span class="pre">TextIOWrapper</span></code></a>对象不是线程安全的。</span></p></div><div class="section" id="reentrancy"><h3><span class="yiyi-st" id="yiyi-468">16.2.4.4. </span><span class="yiyi-st" id="yiyi-469">重入</span></h3><p><span class="yiyi-st" id="yiyi-470">二进制缓冲对象（<a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal"><span class="pre">BufferedReader</span></code></a>，<a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">BufferedWriter</span></code></a>，<a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal"><span class="pre">BufferedRandom</span></code></a>和<a class="reference internal" href="#io.BufferedRWPair" title="io.BufferedRWPair"><code class="xref py py-class docutils literal"><span class="pre">BufferedRWPair</span></code></a>）的实例不可重入。</span><span class="yiyi-st" id="yiyi-471">虽然在正常情况下不会发生可重入呼叫，但它们可能来自在<a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal"><span class="pre">signal</span></code></a>处理程序中执行I / O。</span><span class="yiyi-st" id="yiyi-472">如果线程尝试重新输入它已经访问的缓冲对象，则会引发<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-473">注意，这并不禁止不同的线程进入缓冲对象。</span></p><p><span class="yiyi-st" id="yiyi-474">上面隐含地扩展到文本文件，因为<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>函数会将缓冲对象包裹在<a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal"><span class="pre">TextIOWrapper</span></code></a>内。</span><span class="yiyi-st" id="yiyi-475">这包括标准流，因此也影响内建函数<a class="reference internal" href="functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a>。</span></p></div></div></div></div>