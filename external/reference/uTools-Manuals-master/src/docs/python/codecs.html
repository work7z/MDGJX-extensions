<div class="body" role="main"><div class="section" id="module-codecs"><h1><span class="yiyi-st" id="yiyi-10">7.2.  <a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a>  - 编解码器注册表和基类</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/codecs.py">Lib / codecs.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">此模块为标准Python编解码器（编码器和解码器）定义基类，并提供对内部Python编解码器注册表的访问，该注册表管理编解码器和错误处理查找过程。</span><span class="yiyi-st" id="yiyi-13">大多数标准编解码器都是<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>，它将文本编码为字节，但也提供了将文本编码为文本以及将字节编码为字节的编解码器。</span><span class="yiyi-st" id="yiyi-14">自定义编解码器可以在任意类型之间进行编码和解码，但是某些模块功能仅限于<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>或编码为<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>的编解码器。</span></p><p><span class="yiyi-st" id="yiyi-15">该模块为任何编解码器定义了以下编码和解码功能：</span></p><dl class="function"><dt id="codecs.encode"><span class="yiyi-st" id="yiyi-16"> <code class="descclassname">codecs.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>obj</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-17">使用为<em>编码</em>注册的编解码器编码<em>obj</em>。</span></p><p><span class="yiyi-st" id="yiyi-18"><em>Errors</em> may be given to set the desired error handling scheme. </span><span class="yiyi-st" id="yiyi-19">默认错误处理程序是<code class="docutils literal"><span class="pre">'strict'</span></code>，这意味着编码错误会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>（或更多的特定于codec的子类，如<a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeEncodeError</span></code></a>）。</span><span class="yiyi-st" id="yiyi-20">有关编解码器错误处理的更多信息，请参阅<a class="reference internal" href="#codec-base-classes"><span>Codec Base Classes</span></a>。</span></p></dd></dl><dl class="function"><dt id="codecs.decode"><span class="yiyi-st" id="yiyi-21"> <code class="descclassname">codecs.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>obj</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-22">使用为<em>编码</em>注册的编解码器解码<em>obj</em>。</span></p><p><span class="yiyi-st" id="yiyi-23"><em>Errors</em> may be given to set the desired error handling scheme. </span><span class="yiyi-st" id="yiyi-24">默认错误处理程序是<code class="docutils literal"><span class="pre">'strict'</span></code>，这意味着解码错误会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>（或更多的编解码器特定子类，例如<a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeDecodeError</span></code></a>）。</span><span class="yiyi-st" id="yiyi-25">有关编解码器错误处理的更多信息，请参阅<a class="reference internal" href="#codec-base-classes"><span>Codec Base Classes</span></a>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-26">每个编解码器的全部细节也可以直接查询：</span></p><dl class="function"><dt id="codecs.lookup"><span class="yiyi-st" id="yiyi-27"><code class="descclassname">codecs.</code><code class="descname">lookup</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-28">在Python编解码器注册表中查找编解码器信息，并返回如下定义的<a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal"><span class="pre">CodecInfo</span></code></a>对象。</span></p><p><span class="yiyi-st" id="yiyi-29">编码首先在注册表的缓存中查找。</span><span class="yiyi-st" id="yiyi-30">如果未找到，则会扫描已注册搜索功能的列表。</span><span class="yiyi-st" id="yiyi-31">If no <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal"><span class="pre">CodecInfo</span></code></a> object is found, a <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> is raised. </span><span class="yiyi-st" id="yiyi-32">否则，<a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal"><span class="pre">CodecInfo</span></code></a>对象存储在缓存中并返回给调用者。</span></p></dd></dl><dl class="class"><dt id="codecs.CodecInfo"><span class="yiyi-st" id="yiyi-33"><em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">CodecInfo</code><span class="sig-paren">(</span><em>encode</em>, <em>decode</em>, <em>streamreader=None</em>, <em>streamwriter=None</em>, <em>incrementalencoder=None</em>, <em>incrementaldecoder=None</em>, <em>name=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-34">查找编解码器注册表时的编解码器详细信息。</span><span class="yiyi-st" id="yiyi-35">构造函数参数存储在相同名称的属性中：</span></p><dl class="attribute"><dt id="codecs.CodecInfo.name"><span class="yiyi-st" id="yiyi-36"> <code class="descname">name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-37">编码的名称。</span></p></dd></dl><dl class="attribute"><dt id="codecs.CodecInfo.encode"><span class="yiyi-st" id="yiyi-38"> <code class="descname">encode</code></span></dt><dt id="codecs.CodecInfo.decode"><span class="yiyi-st" id="yiyi-39"> <code class="descname">decode</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-40">无状态的编码和解码功能。</span><span class="yiyi-st" id="yiyi-41">这些必须是与Codec实例的<a class="reference internal" href="#codecs.Codec.encode" title="codecs.Codec.encode"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code></a>和<a class="reference internal" href="#codecs.Codec.decode" title="codecs.Codec.decode"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code></a>方法具有相同接口的函数或方法（请参阅<a class="reference internal" href="#codec-objects"><span>Codec Interface</span></a>） 。</span><span class="yiyi-st" id="yiyi-42">预期功能或方法在无状态模式下工作。</span></p></dd></dl><dl class="attribute"><dt id="codecs.CodecInfo.incrementalencoder"><span class="yiyi-st" id="yiyi-43"> <code class="descname">incrementalencoder</code></span></dt><dt id="codecs.CodecInfo.incrementaldecoder"><span class="yiyi-st" id="yiyi-44"> <code class="descname">incrementaldecoder</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-45">增量编码器和解码器类或工厂功能。</span><span class="yiyi-st" id="yiyi-46">这些必须分别提供由基类<a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a>和<a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a>定义的接口。</span><span class="yiyi-st" id="yiyi-47">增量编解码器可以保持状态。</span></p></dd></dl><dl class="attribute"><dt id="codecs.CodecInfo.streamwriter"><span class="yiyi-st" id="yiyi-48"> <code class="descname">streamwriter</code></span></dt><dt id="codecs.CodecInfo.streamreader"><span class="yiyi-st" id="yiyi-49"> <code class="descname">streamreader</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-50">流式写入器和读取器类或工厂功能。</span><span class="yiyi-st" id="yiyi-51">这些必须分别提供由基类<a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>和<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>定义的接口。</span><span class="yiyi-st" id="yiyi-52">流编解码器可以维护状态。</span></p></dd></dl></dd></dl><p><span class="yiyi-st" id="yiyi-53">为了简化对各种编解码器组件的访问，模块提供了使用<a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal"><span class="pre">lookup()</span></code></a>进行编解码器查找的这些附加功能：</span></p><dl class="function"><dt id="codecs.getencoder"><span class="yiyi-st" id="yiyi-54"><code class="descclassname">codecs.</code><code class="descname">getencoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-55">查找给定编码的编解码器并返回其编码器功能。</span></p><p><span class="yiyi-st" id="yiyi-56">如果无法找到编码，则引发<a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="codecs.getdecoder"><span class="yiyi-st" id="yiyi-57"><code class="descclassname">codecs.</code><code class="descname">getdecoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-58">查找给定编码的编解码器并返回其解码器功能。</span></p><p><span class="yiyi-st" id="yiyi-59">如果无法找到编码，则引发<a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="codecs.getincrementalencoder"><span class="yiyi-st" id="yiyi-60"><code class="descclassname">codecs.</code><code class="descname">getincrementalencoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-61">查找给定编码的编解码器并返回其增量编码器类或工厂功能。</span></p><p><span class="yiyi-st" id="yiyi-62">如果无法找到编码或者编解码器不支持增量编码器，则引发<a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="codecs.getincrementaldecoder"><span class="yiyi-st" id="yiyi-63"><code class="descclassname">codecs.</code><code class="descname">getincrementaldecoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-64">查找给定编码的编解码器并返回其增量解码器类或工厂功能。</span></p><p><span class="yiyi-st" id="yiyi-65">如果无法找到编码或编解码器不支持增量解码器，则引发<a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="codecs.getreader"><span class="yiyi-st" id="yiyi-66"> <code class="descclassname">codecs.</code><code class="descname">getreader</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-67">查找给定编码的编解码器并返回它的<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>类或工厂函数。</span></p><p><span class="yiyi-st" id="yiyi-68">如果无法找到编码，则引发<a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="codecs.getwriter"><span class="yiyi-st" id="yiyi-69"><code class="descclassname">codecs.</code><code class="descname">getwriter</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-70">查找给定编码的编解码器并返回它的<a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>类或工厂函数。</span></p><p><span class="yiyi-st" id="yiyi-71">如果无法找到编码，则引发<a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-72">通过注册合适的编解码器搜索功能可以使用自定义编解码器：</span></p><dl class="function"><dt id="codecs.register"><span class="yiyi-st" id="yiyi-73"><code class="descclassname">codecs.</code><code class="descname">register</code><span class="sig-paren">(</span><em>search_function</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-74">注册编解码器搜索功能。</span><span class="yiyi-st" id="yiyi-75">搜索功能需要一个参数，即所有小写字母的编码名称，并返回一个<a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal"><span class="pre">CodecInfo</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-76">如果搜索功能找不到给定的编码，它应该返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-77">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-78">搜索功能注册目前不可逆，这在某些情况下可能会导致问题，如单元测试或模块重新加载。</span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-79">虽然内置<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>和相关的<a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a>模块是使用编码文本文件的推荐方法，但该模块提供了额外的实用程序函数和类，它们允许使用处理二进制文件时更广泛的编解码器：</span></p><dl class="function"><dt id="codecs.open"><span class="yiyi-st" id="yiyi-80"> <code class="descclassname">codecs.</code><code class="descname">open</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='r'</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>buffering=1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">使用给定的<em>模式</em>打开编码文件并返回<a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamReaderWriter</span></code></a>的实例，从而提供透明的编码/解码。</span><span class="yiyi-st" id="yiyi-82">默认文件模式是<code class="docutils literal"><span class="pre">'r'</span></code>，这意味着以读取模式打开文件。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-83">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-84">底层编码文件始终以二进制模式打开。</span><span class="yiyi-st" id="yiyi-85">读取和写入时不会自动转换<code class="docutils literal"><span class="pre">'\n'</span></code>。</span><span class="yiyi-st" id="yiyi-86"><em>mode</em>参数可以是内置<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>函数可接受的任何二进制模式； <code class="docutils literal"><span class="pre">'b'</span></code>会自动添加。</span></p></div><p><span class="yiyi-st" id="yiyi-87"><em>encoding</em>指定要用于该文件的编码。</span><span class="yiyi-st" id="yiyi-88">任何对字节进行编码和解码的编码都是允许的，并且文件方法支持的数据类型取决于所使用的编解码器。</span></p><p><span class="yiyi-st" id="yiyi-89"><em>errors</em>可能会给出了定义的错误处理。</span><span class="yiyi-st" id="yiyi-90">它默认为<code class="docutils literal"><span class="pre">'strict'</span></code>，如果发生编码错误，会导致引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-91"><em>缓冲</em>与内置<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>函数具有相同的含义。</span><span class="yiyi-st" id="yiyi-92">它默认为行缓冲。</span></p></dd></dl><dl class="function"><dt id="codecs.EncodedFile"><span class="yiyi-st" id="yiyi-93"><code class="descclassname">codecs.</code><code class="descname">EncodedFile</code><span class="sig-paren">(</span><em>file</em>, <em>data_encoding</em>, <em>file_encoding=None</em>, <em>errors='strict'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">返回一个<a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal"><span class="pre">StreamRecoder</span></code></a>实例，它提供了透明代码转换的<em>文件</em>的包装版本。</span><span class="yiyi-st" id="yiyi-95">当封装版本关闭时，原始文件关闭。</span></p><p><span class="yiyi-st" id="yiyi-96">写入包装文件的数据根据​​给定的<em>data_encoding</em>进行解码，然后使用<em>file_encoding</em>以字节的形式写入原始文件。</span><span class="yiyi-st" id="yiyi-97">根据<em>file_encoding</em>解码从原始文件读取的字节，并使用<em>data_encoding</em>对结果进行编码。</span></p><p><span class="yiyi-st" id="yiyi-98">如果未给出<em>file_encoding</em>，则默认为<em>data_encoding</em>。</span></p><p><span class="yiyi-st" id="yiyi-99"><em>errors</em>可能会给出了定义的错误处理。</span><span class="yiyi-st" id="yiyi-100">它默认为<code class="docutils literal"><span class="pre">'strict'</span></code>，这会导致在发生编码错误时引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="codecs.iterencode"><span class="yiyi-st" id="yiyi-101"><code class="descclassname">codecs.</code><code class="descname">iterencode</code><span class="sig-paren">(</span><em>iterator</em>, <em>encoding</em>, <em>errors='strict'</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-102">使用增量编码器迭代编码<em>迭代器</em>提供的输入。</span><span class="yiyi-st" id="yiyi-103">这个函数是一个<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>。</span><span class="yiyi-st" id="yiyi-104"><em>errors</em>参数（以及任何其他关键字参数）传递给增量编码器。</span></p></dd></dl><dl class="function"><dt id="codecs.iterdecode"><span class="yiyi-st" id="yiyi-105"><code class="descclassname">codecs.</code><code class="descname">iterdecode</code><span class="sig-paren">(</span><em>iterator</em>, <em>encoding</em>, <em>errors='strict'</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-106">使用增量式解码器迭代解码<em>迭代器</em>提供的输入。</span><span class="yiyi-st" id="yiyi-107">这个函数是一个<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>。</span><span class="yiyi-st" id="yiyi-108"><em>errors</em>参数（以及任何其他关键字参数）传递给增量解码器。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-109">该模块还提供以下常数，这些常数对读取和写入平台相关文件非常有用：</span></p><dl class="data"><dt id="codecs.BOM"><span class="yiyi-st" id="yiyi-110"><code class="descclassname">codecs.</code><code class="descname">BOM</code></span></dt><dt id="codecs.BOM_BE"><span class="yiyi-st" id="yiyi-111"><code class="descclassname">codecs.</code><code class="descname">BOM_BE</code></span></dt><dt id="codecs.BOM_LE"><span class="yiyi-st" id="yiyi-112"><code class="descclassname">codecs.</code><code class="descname">BOM_LE</code></span></dt><dt id="codecs.BOM_UTF8"><span class="yiyi-st" id="yiyi-113"><code class="descclassname">codecs.</code><code class="descname">BOM_UTF8</code></span></dt><dt id="codecs.BOM_UTF16"><span class="yiyi-st" id="yiyi-114"><code class="descclassname">codecs.</code><code class="descname">BOM_UTF16</code></span></dt><dt id="codecs.BOM_UTF16_BE"><span class="yiyi-st" id="yiyi-115"><code class="descclassname">codecs.</code><code class="descname">BOM_UTF16_BE</code></span></dt><dt id="codecs.BOM_UTF16_LE"><span class="yiyi-st" id="yiyi-116"><code class="descclassname">codecs.</code><code class="descname">BOM_UTF16_LE</code></span></dt><dt id="codecs.BOM_UTF32"><span class="yiyi-st" id="yiyi-117"><code class="descclassname">codecs.</code><code class="descname">BOM_UTF32</code></span></dt><dt id="codecs.BOM_UTF32_BE"><span class="yiyi-st" id="yiyi-118"><code class="descclassname">codecs.</code><code class="descname">BOM_UTF32_BE</code></span></dt><dt id="codecs.BOM_UTF32_LE"><span class="yiyi-st" id="yiyi-119"><code class="descclassname">codecs.</code><code class="descname">BOM_UTF32_LE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-120">这些常量定义了各种字节序列，即多个编码的Unicode字节顺序标记（BOM）。</span><span class="yiyi-st" id="yiyi-121">它们用于UTF-16和UTF-32数据流以指示所使用的字节顺序，并以UTF-8作为Unicode签名。</span><span class="yiyi-st" id="yiyi-122"><a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16</span></code></a> is either <a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16_BE</span></code></a> or <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16_LE</span></code></a> depending on the platform’s native byte order, <a class="reference internal" href="#codecs.BOM" title="codecs.BOM"><code class="xref py py-const docutils literal"><span class="pre">BOM</span></code></a> is an alias for <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16</span></code></a>, <a class="reference internal" href="#codecs.BOM_LE" title="codecs.BOM_LE"><code class="xref py py-const docutils literal"><span class="pre">BOM_LE</span></code></a> for <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16_LE</span></code></a> and <a class="reference internal" href="#codecs.BOM_BE" title="codecs.BOM_BE"><code class="xref py py-const docutils literal"><span class="pre">BOM_BE</span></code></a> for <a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16_BE</span></code></a>. </span><span class="yiyi-st" id="yiyi-123">其他代表UTF-8和UTF-32编码的BOM。</span></p></dd></dl><div class="section" id="codec-base-classes"><h2><span class="yiyi-st" id="yiyi-124">7.2.1.</span><span class="yiyi-st" id="yiyi-125">编解码器基类</span></h2><p><span class="yiyi-st" id="yiyi-126"><a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a>模块定义了一组基类，它们定义了用于处理编解码器对象的接口，也可以用作自定义编解码器实现的基础。</span></p><p><span class="yiyi-st" id="yiyi-127">每个编解码器必须定义四个接口，以使其可用作Python中的编解码器：无状态编码器，无状态解码器，流读取器和流编写器。</span><span class="yiyi-st" id="yiyi-128">流读取器和写入器通常重新使用无状态编码器/解码器来实现文件协议。</span><span class="yiyi-st" id="yiyi-129">编解码器作者还需要定义编解码器将如何处理编码和解码错误。</span></p><div class="section" id="error-handlers"><h3><span class="yiyi-st" id="yiyi-130">7.2.1.1.</span><span class="yiyi-st" id="yiyi-131">错误处理程序</span></h3><p><span class="yiyi-st" id="yiyi-132">为了简化和标准化错误处理，编解码器可以通过接受<em>errors</em>字符串参数来实现不同的错误处理方案。</span><span class="yiyi-st" id="yiyi-133">以下字符串值由所有标准Python编解码器定义和实现：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-134">值</span></th><th class="head"><span class="yiyi-st" id="yiyi-135">含义</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-136"><code class="docutils literal"><span class="pre">'strict'</span></code></span></td><td><span class="yiyi-st" id="yiyi-137">提升<a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a>（或一个子类）；这是默认值。</span><span class="yiyi-st" id="yiyi-138">在<a class="reference internal" href="#codecs.strict_errors" title="codecs.strict_errors"><code class="xref py py-func docutils literal"><span class="pre">strict_errors()</span></code></a>中实现。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-139"><code class="docutils literal"><span class="pre">'ignore'</span></code></span></td><td><span class="yiyi-st" id="yiyi-140">忽略格式错误的数据，并继续不另行通知。</span><span class="yiyi-st" id="yiyi-141">在<a class="reference internal" href="#codecs.ignore_errors" title="codecs.ignore_errors"><code class="xref py py-func docutils literal"><span class="pre">ignore_errors()</span></code></a>中实现。</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-142">以下错误处理程序仅适用于<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-143">值</span></th><th class="head"><span class="yiyi-st" id="yiyi-144">含义</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-145"><code class="docutils literal"><span class="pre">'replace'</span></code></span></td><td><span class="yiyi-st" id="yiyi-146">替换为合适的替换标记； Python将使用正式的<code class="docutils literal"><span class="pre">U+FFFD</span></code>替换字符作为解码时的内置编解码器，编码时使用'？'。</span><span class="yiyi-st" id="yiyi-147">在<a class="reference internal" href="#codecs.replace_errors" title="codecs.replace_errors"><code class="xref py py-func docutils literal"><span class="pre">replace_errors()</span></code></a>。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-148"><code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code></span></td><td><span class="yiyi-st" id="yiyi-149">替换为适当的XML字符引用（仅用于编码）。</span><span class="yiyi-st" id="yiyi-150">在<a class="reference internal" href="#codecs.xmlcharrefreplace_errors" title="codecs.xmlcharrefreplace_errors"><code class="xref py py-func docutils literal"><span class="pre">xmlcharrefreplace_errors()</span></code></a>中实现。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-151"><code class="docutils literal"><span class="pre">'backslashreplace'</span></code></span></td><td><span class="yiyi-st" id="yiyi-152">用反斜杠转义序列替换。</span><span class="yiyi-st" id="yiyi-153">在<a class="reference internal" href="#codecs.backslashreplace_errors" title="codecs.backslashreplace_errors"><code class="xref py py-func docutils literal"><span class="pre">backslashreplace_errors()</span></code></a>中实现。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-154"><code class="docutils literal"><span class="pre">'namereplace'</span></code></span></td><td><span class="yiyi-st" id="yiyi-155">用<code class="docutils literal"><span class="pre">\N{...}</span></code>转义序列替换（仅用于编码）。</span><span class="yiyi-st" id="yiyi-156">在<a class="reference internal" href="#codecs.namereplace_errors" title="codecs.namereplace_errors"><code class="xref py py-func docutils literal"><span class="pre">namereplace_errors()</span></code></a>中实现。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-157"><code class="docutils literal"><span class="pre">'surrogateescape'</span></code></span></td><td><span class="yiyi-st" id="yiyi-158">在解码时，将字节替换为范围从<code class="docutils literal"><span class="pre">U+DC80</span></code>到<code class="docutils literal"><span class="pre">U+DCFF</span></code>的单个替代码。</span><span class="yiyi-st" id="yiyi-159">当编码数据时使用<code class="docutils literal"><span class="pre">'surrogateescape'</span></code>错误处理程序时，此代码将被重新转换为相同的字节。</span><span class="yiyi-st" id="yiyi-160">（有关更多信息，请参阅<span class="target" id="index-1"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>。）</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-161">另外，下面的错误处理程序是特定于给定的编解码器的：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-162">值</span></th><th class="head"><span class="yiyi-st" id="yiyi-163">编解码器</span></th><th class="head"><span class="yiyi-st" id="yiyi-164">含义</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-165"><code class="docutils literal"><span class="pre">'surrogatepass'</span></code></span></td><td><span class="yiyi-st" id="yiyi-166">utf-8，utf-16，utf-32，utf-16-be，utf-16-le，utf-32-be，utf-32-le</span></td><td><span class="yiyi-st" id="yiyi-167">允许替代码的编码和解码。</span><span class="yiyi-st" id="yiyi-168">这些编解码器通常将代理的存在视为错误。</span></td></tr></tbody></table><div class="versionadded"><p><span class="yiyi-st" id="yiyi-169"><span class="versionmodified">版本3.1中的新内容：</span> <code class="docutils literal"><span class="pre">'surrogateescape'</span></code>和<code class="docutils literal"><span class="pre">'surrogatepass'</span></code>错误处理程序。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-170"><span class="versionmodified">版本3.4中改变：</span> <code class="docutils literal"><span class="pre">'surrogatepass'</span></code>错误处理程序现在可以与utf-16 *和utf-32 *编解码器一起使用。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-171"><span class="versionmodified">版本3.5中的新功能：</span> <code class="docutils literal"><span class="pre">'namereplace'</span></code>错误处理程序。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-172"><span class="versionmodified">在版本3.5中更改：</span> <code class="docutils literal"><span class="pre">'backslashreplace'</span></code>错误处理程序现在可用于解码和翻译。</span></p></div><p><span class="yiyi-st" id="yiyi-173">允许值的集合可以通过注册一个新的命名错误处理程序来扩展：</span></p><dl class="function"><dt id="codecs.register_error"><span class="yiyi-st" id="yiyi-174"><code class="descclassname">codecs.</code><code class="descname">register_error</code><span class="sig-paren">(</span><em>name</em>, <em>error_handler</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-175">在名称<em>name</em>下注册错误处理函数<em>error_handler</em>。</span><span class="yiyi-st" id="yiyi-176">The <em>error_handler</em> argument will be called during encoding and decoding in case of an error, when <em>name</em> is specified as the errors parameter.</span></p><p><span class="yiyi-st" id="yiyi-177">为了进行编码，<em>error_handler</em>将使用<a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeEncodeError</span></code></a>实例调用，其中包含有关错误位置的信息。</span><span class="yiyi-st" id="yiyi-178">错误处理程序必须提出这个或另一个异常，或返回一个元组，替换输入的不可解码部分和编码应该继续的位置。</span><span class="yiyi-st" id="yiyi-179">替换可以是<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>或<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span><span class="yiyi-st" id="yiyi-180">如果替换为字节，编码器将简单地将它们复制到输出缓冲区中。</span><span class="yiyi-st" id="yiyi-181">如果替换为字符串，则编码器将对替换进行编码。</span><span class="yiyi-st" id="yiyi-182">编码继续在指定位置的原始输入。</span><span class="yiyi-st" id="yiyi-183">负位置值将被视为相对于输入字符串的末尾。</span><span class="yiyi-st" id="yiyi-184">如果结果位置超出限制，将会引发<a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-185">除了<a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeDecodeError</span></code></a>或<a class="reference internal" href="exceptions.html#UnicodeTranslateError" title="UnicodeTranslateError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeTranslateError</span></code></a>之外，解码和翻译的工作方式相同，将传递给处理程序，并且错误处理程序的替换将直接放入输出中。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-186">以前注册的错误处理程序（包括标准错误处理程序）可以按名称查找：</span></p><dl class="function"><dt id="codecs.lookup_error"><span class="yiyi-st" id="yiyi-187"><code class="descclassname">codecs.</code><code class="descname">lookup_error</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-188">返回之前在名称<em>name</em>下注册的错误处理程序。</span></p><p><span class="yiyi-st" id="yiyi-189">如果找不到处理程序，则引发<a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-190">以下标准错误处理程序也可用作模块级功能：</span></p><dl class="function"><dt id="codecs.strict_errors"><span class="yiyi-st" id="yiyi-191"><code class="descclassname">codecs.</code><code class="descname">strict_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-192">实现<code class="docutils literal"><span class="pre">'strict'</span></code>错误处理：每个编码或解码错误都会引发一个<a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="codecs.replace_errors"><span class="yiyi-st" id="yiyi-193"><code class="descclassname">codecs.</code><code class="descname">replace_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-194">实现<code class="docutils literal"><span class="pre">'replace'</span></code>错误处理（仅用于<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>）：替换<code class="docutils literal"><span class="pre">'?'</span></code></span><span class="yiyi-st" id="yiyi-195"> for encoding errors (to be encoded by the codec), and <code class="docutils literal"><span class="pre">'\ufffd'</span></code> (the Unicode replacement character) for decoding errors.</span></p></dd></dl><dl class="function"><dt id="codecs.ignore_errors"><span class="yiyi-st" id="yiyi-196"><code class="descclassname">codecs.</code><code class="descname">ignore_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-197">实现<code class="docutils literal"><span class="pre">'ignore'</span></code>错误处理：忽略格式错误的数据，继续编码或解码，恕不另行通知。</span></p></dd></dl><dl class="function"><dt id="codecs.xmlcharrefreplace_errors"><span class="yiyi-st" id="yiyi-198"><code class="descclassname">codecs.</code><code class="descname">xmlcharrefreplace_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-199">实现<code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code>错误处理（仅适用于使用<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>编码）：将不可编码字符替换为适当的XML字符引用。</span></p></dd></dl><dl class="function"><dt id="codecs.backslashreplace_errors"><span class="yiyi-st" id="yiyi-200"><code class="descclassname">codecs.</code><code class="descname">backslashreplace_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-201">实现<code class="docutils literal"><span class="pre">'backslashreplace'</span></code>错误处理（仅适用于<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>）：格式错误的数据被替换为反斜杠转义序列。</span></p></dd></dl><dl class="function"><dt id="codecs.namereplace_errors"><span class="yiyi-st" id="yiyi-202"><code class="descclassname">codecs.</code><code class="descname">namereplace_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-203">实现<code class="docutils literal"><span class="pre">'namereplace'</span></code>错误处理（仅适用于使用<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>编码）：不可编码字符被替换为<code class="docutils literal"><span class="pre">\N{...}</span></code></span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-204"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="stateless-encoding-and-decoding"><h3><span class="yiyi-st" id="yiyi-205">7.2.1.2.</span><span class="yiyi-st" id="yiyi-206">无状态编码和解码</span></h3><p><span class="yiyi-st" id="yiyi-207">基础<code class="xref py py-class docutils literal"><span class="pre">Codec</span></code>类定义了这些方法，它们也定义了无状态编码器和解码器的功能接口：</span></p><dl class="method"><dt id="codecs.Codec.encode"><span class="yiyi-st" id="yiyi-208"><code class="descclassname">Codec.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>input</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-209">编码对象<em>input</em>并返回一个元组（输出对象，消耗的长度）。</span><span class="yiyi-st" id="yiyi-210">例如，<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a>使用特定的字符集编码（例如<code class="docutils literal"><span class="pre">cp1252</span></code>或<code class="docutils literal"><span class="pre">iso-8859-1</span></code>）将字符串对象转换为字节对象。 ）。</span></p><p><span class="yiyi-st" id="yiyi-211"><em>errors</em>参数定义要应用的错误处理。</span><span class="yiyi-st" id="yiyi-212">它默认为<code class="docutils literal"><span class="pre">'strict'</span></code>处理。</span></p><p><span class="yiyi-st" id="yiyi-213">该方法可能不会在<code class="xref py py-class docutils literal"><span class="pre">Codec</span></code>实例中存储状态。</span><span class="yiyi-st" id="yiyi-214">使用<a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>来编码，这些编解码器必须保持状态才能使编码更有效率。</span></p><p><span class="yiyi-st" id="yiyi-215">在这种情况下，编码器必须能够处理零长度输入并返回输出对象类型的空对象。</span></p></dd></dl><dl class="method"><dt id="codecs.Codec.decode"><span class="yiyi-st" id="yiyi-216"><code class="descclassname">Codec.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>input</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-217">解码对象<em>input</em>并返回一个元组（输出对象，消耗的长度）。</span><span class="yiyi-st" id="yiyi-218">例如，对于<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a>，解码将使用特定字符集编码编码的字节对象转换为字符串对象。</span></p><p><span class="yiyi-st" id="yiyi-219">对于文本编码和字节到字节编解码器，<em>input</em>必须是一个字节对象或一个提供只读缓冲接口的对象，例如缓冲对象和内存映射文件。</span></p><p><span class="yiyi-st" id="yiyi-220"><em>errors</em>参数定义要应用的错误处理。</span><span class="yiyi-st" id="yiyi-221">它默认为<code class="docutils literal"><span class="pre">'strict'</span></code>处理。</span></p><p><span class="yiyi-st" id="yiyi-222">该方法可能不会在<code class="xref py py-class docutils literal"><span class="pre">Codec</span></code>实例中存储状态。</span><span class="yiyi-st" id="yiyi-223">对于必须保持状态的编解码器，使用<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>以使解码效率更高。</span></p><p><span class="yiyi-st" id="yiyi-224">在这种情况下，解码器必须能够处理零长度输入并返回输出对象类型的空对象。</span></p></dd></dl></div><div class="section" id="incremental-encoding-and-decoding"><h3><span class="yiyi-st" id="yiyi-225">7.2.1.3.</span><span class="yiyi-st" id="yiyi-226">增量编码和解码</span></h3><p><span class="yiyi-st" id="yiyi-227">The <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a> and <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a> classes provide the basic interface for incremental encoding and decoding. </span><span class="yiyi-st" id="yiyi-228">编码/解码输入不是通过一次调用无状态编码器/解码器函数完成的，而是通过对<a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code></a> / <a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code></a>方法的多次调用增量编码器/解码器。</span><span class="yiyi-st" id="yiyi-229">增量编码器/解码器在方法调用期间跟踪编码/解码过程。</span></p><p><span class="yiyi-st" id="yiyi-230">对<a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code></a> / <a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code></a>方法的调用的联合输出与将所有单个输入合并为一个并且该输入被编码/解码与无状态编码器/解码器。</span></p><div class="section" id="incrementalencoder-objects"><h4><span class="yiyi-st" id="yiyi-231">7.2.1.3.1.</span><span class="yiyi-st" id="yiyi-232">IncrementalEncoder对象</span></h4><p><span class="yiyi-st" id="yiyi-233"><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a>类用于以多个步骤对输入进行编码。</span><span class="yiyi-st" id="yiyi-234">它定义了每个增量编码器必须定义的以下方法，以便与Python编解码器注册表兼容。</span></p><dl class="class"><dt id="codecs.IncrementalEncoder"><span class="yiyi-st" id="yiyi-235"><em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">IncrementalEncoder</code><span class="sig-paren">(</span><em>errors='strict'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-236"><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a>实例的构造函数。</span></p><p><span class="yiyi-st" id="yiyi-237">所有增量编码器都必须提供此构造器接口。</span><span class="yiyi-st" id="yiyi-238">他们可以自由添加额外的关键字参数，但只有在这里定义的关键字参数被Python编解码器注册表使用。</span></p><p><span class="yiyi-st" id="yiyi-239"><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a>可以通过提供<em>errors</em>关键字参数来实现不同的错误处理方案。</span><span class="yiyi-st" id="yiyi-240">有关可能的值，请参阅<a class="reference internal" href="#error-handlers"><span>Error Handlers</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-241"><em>errors</em>参数将被分配给同名的属性。</span><span class="yiyi-st" id="yiyi-242">赋值给该属性可以在<a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a>对象的生命周期内在不同的错误处理策略之间切换。</span></p><dl class="method"><dt id="codecs.IncrementalEncoder.encode"><span class="yiyi-st" id="yiyi-243"> <code class="descname">encode</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>final</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-244">编码<em>对象</em>（考虑到编码器的当前状态）并返回结果编码对象。</span><span class="yiyi-st" id="yiyi-245">如果这是最后一次调用<a class="reference internal" href="#codecs.encode" title="codecs.encode"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code></a> <em>final</em>必须为true（默认值为false）。</span></p></dd></dl><dl class="method"><dt id="codecs.IncrementalEncoder.reset"><span class="yiyi-st" id="yiyi-246"><code class="descname">重置 T0&gt; <span class="sig-paren">（ T1&gt; <span class="sig-paren">） T2&gt; </span></span></code></span></dt><dd><p><span class="yiyi-st" id="yiyi-247">将编码器重置为初始状态。</span><span class="yiyi-st" id="yiyi-248">输出被丢弃：调用<code class="docutils literal"><span class="pre">.encode（object，</span> <span class="pre">final = True）</span></code>，如果需要传递空字节或文本字符串，编码器并获得输出。</span></p></dd></dl></dd></dl><dl class="method"><dt id="codecs.IncrementalEncoder.getstate"><span class="yiyi-st" id="yiyi-249"><code class="descclassname">IncrementalEncoder.</code><code class="descname">getstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-250">返回编码器的当前状态，该状态必须是整数。</span><span class="yiyi-st" id="yiyi-251">实现应该确保<code class="docutils literal"><span class="pre">0</span></code>是最常见的状态。</span><span class="yiyi-st" id="yiyi-252">（比整数更复杂的状态可以通过编组/整理状态并将结果字符串的字节编码为整数来转换为整数）。</span></p></dd></dl><dl class="method"><dt id="codecs.IncrementalEncoder.setstate"><span class="yiyi-st" id="yiyi-253"><code class="descclassname">IncrementalEncoder.</code><code class="descname">setstate</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-254">将编码器的状态设置为<em>状态</em>。</span><span class="yiyi-st" id="yiyi-255"><em>状态</em>必须是由<a class="reference internal" href="#codecs.IncrementalEncoder.getstate" title="codecs.IncrementalEncoder.getstate"><code class="xref py py-meth docutils literal"><span class="pre">getstate()</span></code></a>返回的编码器状态。</span></p></dd></dl></div><div class="section" id="incrementaldecoder-objects"><h4><span class="yiyi-st" id="yiyi-256">7.2.1.3.2.</span><span class="yiyi-st" id="yiyi-257">IncrementalDecoder对象</span></h4><p><span class="yiyi-st" id="yiyi-258"><a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a>类用于多步骤解码输入。</span><span class="yiyi-st" id="yiyi-259">它定义了每个增量解码器必须定义的以下方法，以便与Python编解码器注册表兼容。</span></p><dl class="class"><dt id="codecs.IncrementalDecoder"><span class="yiyi-st" id="yiyi-260"><em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">IncrementalDecoder</code><span class="sig-paren">(</span><em>errors='strict'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-261"><a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a>实例的构造函数。</span></p><p><span class="yiyi-st" id="yiyi-262">所有增量解码器都必须提供此构造器接口。</span><span class="yiyi-st" id="yiyi-263">他们可以自由添加额外的关键字参数，但只有在这里定义的关键字参数被Python编解码器注册表使用。</span></p><p><span class="yiyi-st" id="yiyi-264">通过提供<em>errors</em>关键字参数，<a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a>可以实现不同的错误处理方案。</span><span class="yiyi-st" id="yiyi-265">有关可能的值，请参阅<a class="reference internal" href="#error-handlers"><span>Error Handlers</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-266"><em>errors</em>参数将被分配给同名的属性。</span><span class="yiyi-st" id="yiyi-267">赋值给该属性可以在<a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a>对象的生命周期内在不同的错误处理策略之间切换。</span></p><dl class="method"><dt id="codecs.IncrementalDecoder.decode"><span class="yiyi-st" id="yiyi-268"> <code class="descname">decode</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>final</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-269">解码<em>object</em>（考虑到解码器的当前状态）并返回结果解码对象。</span><span class="yiyi-st" id="yiyi-270">如果这是最后一次调用<a class="reference internal" href="#codecs.decode" title="codecs.decode"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code></a> <em>final</em>必须为true（默认值为false）。</span><span class="yiyi-st" id="yiyi-271">如果<em>final</em>为真，则解码器必须彻底解码输入，并且必须清空所有缓冲区。</span><span class="yiyi-st" id="yiyi-272">如果这是不可能的（例如</span><span class="yiyi-st" id="yiyi-273">由于输入末尾的字节序列不完整），它必须启动错误处理，就像在无状态的情况下（这可能会引发异常）。</span></p></dd></dl><dl class="method"><dt id="codecs.IncrementalDecoder.reset"><span class="yiyi-st" id="yiyi-274"><code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-275">将解码器重置为初始状态。</span></p></dd></dl><dl class="method"><dt id="codecs.IncrementalDecoder.getstate"><span class="yiyi-st" id="yiyi-276"><code class="descname">getstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-277">返回解码器的当前状态。</span><span class="yiyi-st" id="yiyi-278">这必须是一个包含两项的元组，第一个必须是包含尚未解码输入的缓冲区。</span><span class="yiyi-st" id="yiyi-279">第二个必须是一个整数，可以是附加的状态信息。</span><span class="yiyi-st" id="yiyi-280">（实现应该确保<code class="docutils literal"><span class="pre">0</span></code>是最常见的附加状态信息。）</span><span class="yiyi-st" id="yiyi-281">如果这个附加状态信息是<code class="docutils literal"><span class="pre">0</span></code>，则必须可以将解码器设置为没有输入缓冲的状态并且将<code class="docutils literal"><span class="pre">0</span></code>设置为附加状态信息，以便馈送先前缓冲输入到解码器将其返回到先前的状态而不产生任何输出。</span><span class="yiyi-st" id="yiyi-282">（通过编组/整理信息并将结果字符串的字节编码为整数，可以将比整数更复杂的其他状态信息转换为整数。）</span></p></dd></dl><dl class="method"><dt id="codecs.IncrementalDecoder.setstate"><span class="yiyi-st" id="yiyi-283"><code class="descname">setstate</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-284">将编码器的状态设置为<em>状态</em>。</span><span class="yiyi-st" id="yiyi-285"><em>状态</em>必须是由<a class="reference internal" href="#codecs.IncrementalDecoder.getstate" title="codecs.IncrementalDecoder.getstate"><code class="xref py py-meth docutils literal"><span class="pre">getstate()</span></code></a>返回的解码器状态。</span></p></dd></dl></dd></dl></div></div><div class="section" id="stream-encoding-and-decoding"><h3><span class="yiyi-st" id="yiyi-286">7.2.1.4.</span><span class="yiyi-st" id="yiyi-287">流编码和解码</span></h3><p><span class="yiyi-st" id="yiyi-288">The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> and <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> classes provide generic working interfaces which can be used to implement new encoding submodules very easily. </span><span class="yiyi-st" id="yiyi-289">有关如何完成的示例，请参阅<code class="xref py py-mod docutils literal"><span class="pre">encodings.utf_8</span></code>。</span></p><div class="section" id="streamwriter-objects"><h4><span class="yiyi-st" id="yiyi-290">7.2.1.4.1.</span><span class="yiyi-st" id="yiyi-291">StreamWriter对象</span></h4><p><span class="yiyi-st" id="yiyi-292"><a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>类是<code class="xref py py-class docutils literal"><span class="pre">Codec</span></code>的子类，并定义了以下方法，每个流写入器必须定义以便与Python编解码器注册表兼容。</span></p><dl class="class"><dt id="codecs.StreamWriter"><span class="yiyi-st" id="yiyi-293"><em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamWriter</code><span class="sig-paren">(</span><em>stream</em>, <em>errors='strict'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-294"><a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>实例的构造函数。</span></p><p><span class="yiyi-st" id="yiyi-295">所有流写入器都必须提供此构造器接口。</span><span class="yiyi-st" id="yiyi-296">他们可以自由添加额外的关键字参数，但只有在这里定义的关键字参数被Python编解码器注册表使用。</span></p><p><span class="yiyi-st" id="yiyi-297">根据特定编解码器的情况，<em>stream</em>参数必须是一个类似文件的对象，用于写入文本或二进制数据。</span></p><p><span class="yiyi-st" id="yiyi-298">通过提供<em>错误</em>关键字参数，<a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>可以实现不同的错误处理方案。</span><span class="yiyi-st" id="yiyi-299">有关底层流编解码器可能支持的标准错误处理程序，请参阅<a class="reference internal" href="#error-handlers"><span>Error Handlers</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-300"><em>errors</em>参数将被分配给同名的属性。</span><span class="yiyi-st" id="yiyi-301">分配给该属性可以在<a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>对象的生命周期内在不同的错误处理策略之间切换。</span></p><dl class="method"><dt id="codecs.StreamWriter.write"><span class="yiyi-st" id="yiyi-302"><code class="descname">write</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-303">将编码对象的内容写入流中。</span></p></dd></dl><dl class="method"><dt id="codecs.StreamWriter.writelines"><span class="yiyi-st" id="yiyi-304"><code class="descname">writelines</code><span class="sig-paren">(</span><em>list</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-305">将连接的字符串列表写入流（可能通过重用<a class="reference internal" href="#codecs.StreamWriter.write" title="codecs.StreamWriter.write"><code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></a>方法）。</span><span class="yiyi-st" id="yiyi-306">标准的字节到字节编解码器不支持这种方法。</span></p></dd></dl><dl class="method"><dt id="codecs.StreamWriter.reset"><span class="yiyi-st" id="yiyi-307"><code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-308">刷新并重置用于保持状态的编解码器缓冲区。</span></p><p><span class="yiyi-st" id="yiyi-309">调用此方法应确保将输出中的数据置于干净状态，以允许附加新的新数据，而无需重新扫描整个流以恢复状态。</span></p></dd></dl></dd></dl><p><span class="yiyi-st" id="yiyi-310">In addition to the above methods, the <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> must also inherit all other methods and attributes from the underlying stream.</span></p></div><div class="section" id="streamreader-objects"><h4><span class="yiyi-st" id="yiyi-311">7.2.1.4.2.</span><span class="yiyi-st" id="yiyi-312">StreamReader对象</span></h4><p><span class="yiyi-st" id="yiyi-313"><a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>类是<code class="xref py py-class docutils literal"><span class="pre">Codec</span></code>的一个子类，并定义了以下方法，每个流读者必须定义以便与Python编解码器注册表兼容。</span></p><dl class="class"><dt id="codecs.StreamReader"><span class="yiyi-st" id="yiyi-314"><em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamReader</code><span class="sig-paren">(</span><em>stream</em>, <em>errors='strict'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-315"><a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>实例的构造函数。</span></p><p><span class="yiyi-st" id="yiyi-316">所有流读取器都必须提供此构造器接口。</span><span class="yiyi-st" id="yiyi-317">他们可以自由添加额外的关键字参数，但只有在这里定义的关键字参数被Python编解码器注册表使用。</span></p><p><span class="yiyi-st" id="yiyi-318">根据特定的编解码器，<em>stream</em>参数必须是打开的文件类对象，用于读取文本或二进制数据。</span></p><p><span class="yiyi-st" id="yiyi-319">通过提供<em>错误</em>关键字参数，<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>可以实现不同的错误处理方案。</span><span class="yiyi-st" id="yiyi-320">有关底层流编解码器可能支持的标准错误处理程序，请参阅<a class="reference internal" href="#error-handlers"><span>Error Handlers</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-321"><em>errors</em>参数将被分配给同名的属性。</span><span class="yiyi-st" id="yiyi-322">分配给该属性可以在<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>对象的生命周期内在不同的错误处理策略之间切换。</span></p><p><span class="yiyi-st" id="yiyi-323"><em>errors</em>参数的允许值组可以通过<a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">register_error()</span></code></a>扩展。</span></p><dl class="method"><dt id="codecs.StreamReader.read"><span class="yiyi-st" id="yiyi-324"> <code class="descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">[</span>, <em>chars</em><span class="optional">[</span>, <em>firstline</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-325">解码流中的数据并返回结果对象。</span></p><p><span class="yiyi-st" id="yiyi-326">参数<em>chars</em>指示要返回的解码代码点或字节的数量。</span><span class="yiyi-st" id="yiyi-327"><a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-func docutils literal"><span class="pre">read()</span></code></a>方法永远不会返回比请求更多的数据，但如果没有足够的可用空间，它可能会返回更少的数据。</span></p><p><span class="yiyi-st" id="yiyi-328"><em>size</em>参数表示要解码时读取的编码字节或编码点的近似最大数量。</span><span class="yiyi-st" id="yiyi-329">解码器可以根据需要修改此设置。</span><span class="yiyi-st" id="yiyi-330">默认值-1表示尽可能多地读取和解码。</span><span class="yiyi-st" id="yiyi-331">该参数旨在防止在一个步骤中解码大文件。</span></p><p><span class="yiyi-st" id="yiyi-332">The <em>firstline</em> flag indicates that it would be sufficient to only return the first line, if there are decoding errors on later lines.</span></p><p><span class="yiyi-st" id="yiyi-333">该方法应该使用贪婪读取策略，这意味着它应该读取在编码定义和给定大小内所允许的数据，例如，</span><span class="yiyi-st" id="yiyi-334">如果可选的编码结尾或状态标记在流上可用，则这些也应该读取。</span></p></dd></dl><dl class="method"><dt id="codecs.StreamReader.readline"><span class="yiyi-st" id="yiyi-335"> <code class="descname">readline</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">[</span>, <em>keepends</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-336">从输入流中读取一行并返回解码后的数据。</span></p><p><span class="yiyi-st" id="yiyi-337"><em>size</em>, if given, is passed as size argument to the stream’s <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a> method.</span></p><p><span class="yiyi-st" id="yiyi-338">如果<em>keepends</em>为假行结束符将从返回的行中剥离。</span></p></dd></dl><dl class="method"><dt id="codecs.StreamReader.readlines"><span class="yiyi-st" id="yiyi-339"> <code class="descname">readlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>sizehint</em><span class="optional">[</span>, <em>keepends</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-340">读取输入流中可用的所有行，并将它们作为行列表返回。</span></p><p><span class="yiyi-st" id="yiyi-341">如果<em>keepends</em>为true，则使用编解码器的解码器方法实现行结束符，并将其包含在列表条目中。</span></p><p><span class="yiyi-st" id="yiyi-342"><em>sizehint</em>, if given, is passed as the <em>size</em> argument to the stream’s <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a> method.</span></p></dd></dl><dl class="method"><dt id="codecs.StreamReader.reset"><span class="yiyi-st" id="yiyi-343"><code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-344">重置用于保持状态的编解码器缓冲区。</span></p><p><span class="yiyi-st" id="yiyi-345">请注意，不应该发生流重定位。</span><span class="yiyi-st" id="yiyi-346">这种方法主要是为了能够从解码错误中恢复。</span></p></dd></dl></dd></dl><p><span class="yiyi-st" id="yiyi-347">In addition to the above methods, the <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> must also inherit all other methods and attributes from the underlying stream.</span></p></div><div class="section" id="streamreaderwriter-objects"><h4><span class="yiyi-st" id="yiyi-348">7.2.1.4.3.</span><span class="yiyi-st" id="yiyi-349">StreamReaderWriter对象</span></h4><p><span class="yiyi-st" id="yiyi-350"><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamReaderWriter</span></code></a>是一个便利的类，它允许封装可在读取和写入模式下工作的流。</span></p><p><span class="yiyi-st" id="yiyi-351">该设计使得可以使用由<a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal"><span class="pre">lookup()</span></code></a>函数返回的工厂函数来构造实例。</span></p><dl class="class"><dt id="codecs.StreamReaderWriter"><span class="yiyi-st" id="yiyi-352"> <em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamReaderWriter</code><span class="sig-paren">(</span><em>stream</em>, <em>Reader</em>, <em>Writer</em>, <em>errors</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-353">创建一个<a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamReaderWriter</span></code></a>实例。</span><span class="yiyi-st" id="yiyi-354"><em>stream</em> must be a file-like object. </span><span class="yiyi-st" id="yiyi-355"><em>Reader</em>和<em>Writer</em>必须是提供<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>和<a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>接口的工厂函数或类。</span><span class="yiyi-st" id="yiyi-356">错误处理以与流读取器和写入器定义相同的方式完成。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-357"><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamReaderWriter</span></code></a> instances define the combined interfaces of <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> classes. </span><span class="yiyi-st" id="yiyi-358">它们从基础流继承所有其他方法和属性。</span></p></div><div class="section" id="streamrecoder-objects"><h4><span class="yiyi-st" id="yiyi-359">7.2.1.4.4.</span><span class="yiyi-st" id="yiyi-360">StreamRecoder对象</span></h4><p><span class="yiyi-st" id="yiyi-361">The <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal"><span class="pre">StreamRecoder</span></code></a> translates data from one encoding to another, which is sometimes useful when dealing with different encoding environments.</span></p><p><span class="yiyi-st" id="yiyi-362">该设计使得可以使用由<a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal"><span class="pre">lookup()</span></code></a>函数返回的工厂函数来构造实例。</span></p><dl class="class"><dt id="codecs.StreamRecoder"><span class="yiyi-st" id="yiyi-363"><em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamRecoder</code><span class="sig-paren">(</span><em>stream</em>, <em>encode</em>, <em>decode</em>, <em>Reader</em>, <em>Writer</em>, <em>errors</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-364">创建一个实现双向转换的<a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal"><span class="pre">StreamRecoder</span></code></a>实例：<em>编码</em>和<em>解码</em>在前端工作 - 数据可见代码调用<code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">write()</span></code>，而<em>Reader</em>和<em>Writer</em>在后端工作 -  <em>/ T11&gt;。</em></span></p><p><span class="yiyi-st" id="yiyi-365">您可以使用这些对象来执行透明转码。</span><span class="yiyi-st" id="yiyi-366">Latin-1转换为UTF-8并返回。</span></p><p><span class="yiyi-st" id="yiyi-367"><em>stream</em>参数必须是一个类似文件的对象。</span></p><p><span class="yiyi-st" id="yiyi-368"><em>encode</em>和<em>decode</em>参数必须遵守<code class="xref py py-class docutils literal"><span class="pre">Codec</span></code>接口。</span><span class="yiyi-st" id="yiyi-369"><em>Reader</em> and <em>Writer</em> must be factory functions or classes providing objects of the <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> interface respectively.</span></p><p><span class="yiyi-st" id="yiyi-370">错误处理以与流读取器和写入器定义相同的方式完成。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-371"><a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal"><span class="pre">StreamRecoder</span></code></a> instances define the combined interfaces of <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> classes. </span><span class="yiyi-st" id="yiyi-372">它们从基础流继承所有其他方法和属性。</span></p></div></div></div><div class="section" id="encodings-and-unicode"><h2><span class="yiyi-st" id="yiyi-373">7.2.2.</span><span class="yiyi-st" id="yiyi-374">编码和Unicode </span></h2><p><span class="yiyi-st" id="yiyi-375">字符串在内部存储为<code class="docutils literal"><span class="pre">0x0</span></code>  -  <code class="docutils literal"><span class="pre">0x10FFFF</span></code>范围内的代码点序列。</span><span class="yiyi-st" id="yiyi-376">（有关实现的更多细节，请参阅<span class="target" id="index-2"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a>。）</span><span class="yiyi-st" id="yiyi-377">一旦在CPU和内存之外使用字符串对象，字节顺序以及如何将这些数组作为字节存储成为问题。</span><span class="yiyi-st" id="yiyi-378">与其他编解码器一样，将字符串串行化为字节序列称为<em>编码</em>，并且从字节序列重新创建字符串称为<em>解码</em>。</span><span class="yiyi-st" id="yiyi-379">有各种不同的文本序列化编解码器，它们被称为<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-380">The simplest text encoding (called <code class="docutils literal"><span class="pre">'latin-1'</span></code> or <code class="docutils literal"><span class="pre">'iso-8859-1'</span></code>) maps the code points 0-255 to the bytes <code class="docutils literal"><span class="pre">0x0</span></code>-<code class="docutils literal"><span class="pre">0xff</span></code>, which means that a string object that contains code points above <code class="docutils literal"><span class="pre">U+00FF</span></code> can’t be encoded with this codec. </span><span class="yiyi-st" id="yiyi-381">Doing so will raise a <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeEncodeError</span></code></a> that looks like the following (although the details of the error message may differ): <code class="docutils literal"><span class="pre">UnicodeEncodeError:</span> <span class="pre">'latin-1'</span> <span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span> <span class="pre">'\u1234'</span> <span class="pre">in</span> <span class="pre">position</span> <span class="pre">3:</span> <span class="pre">ordinal</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">range(256)</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-382">还有另一组编码（所谓的charmap编码），它们选择所有Unicode代码点的不同子集，以及这些代码点如何映射到字节<code class="docutils literal"><span class="pre">0x0</span></code>  -  <code class="docutils literal"><span class="pre">0xff</span></code>。</span><span class="yiyi-st" id="yiyi-383">要查看如何完成这个操作，只需打开例如</span><span class="yiyi-st" id="yiyi-384"><code class="file docutils literal"><span class="pre">encodings/cp1252.py</span></code>（这是一种主要用于Windows的编码）。</span><span class="yiyi-st" id="yiyi-385">有一个256个字符的字符串常量，显示哪个字符映射到哪个字节值。</span></p><p><span class="yiyi-st" id="yiyi-386">所有这些编码只能编码Unicode中定义的1114112个码点中的256个。</span><span class="yiyi-st" id="yiyi-387">可以存储每个Unicode代码点的简单而直接的方法是将每个代码点存储为四个连续的字节。</span><span class="yiyi-st" id="yiyi-388">有两种可能性：以big endian或little endian顺序存储字节。</span><span class="yiyi-st" id="yiyi-389">这两种编码分别称为<code class="docutils literal"><span class="pre">UTF-32-BE</span></code>和<code class="docutils literal"><span class="pre">UTF-32-LE</span></code>。</span><span class="yiyi-st" id="yiyi-390">它们的缺点是，如果例如</span><span class="yiyi-st" id="yiyi-391">你在一个小端机上使用<code class="docutils literal"><span class="pre">UTF-32-BE</span></code>，你总是必须在编码和解码时交换字节。</span><span class="yiyi-st" id="yiyi-392"><code class="docutils literal"><span class="pre">UTF-32</span></code>避免了这个问题：字节总是处于自然字节顺序。</span><span class="yiyi-st" id="yiyi-393">当这些字节被具有不同字节顺序的CPU读取时，字节必须交换。</span><span class="yiyi-st" id="yiyi-394">为了能够检测<code class="docutils literal"><span class="pre">UTF-16</span></code>或<code class="docutils literal"><span class="pre">UTF-32</span></code>字节序列的字节顺序，有所谓的BOM（“字节顺序标记”）。</span><span class="yiyi-st" id="yiyi-395">这是Unicode字符<code class="docutils literal"><span class="pre">U+FEFF</span></code>。</span><span class="yiyi-st" id="yiyi-396">该字符可以作为每个<code class="docutils literal"><span class="pre">UTF-16</span></code>或<code class="docutils literal"><span class="pre">UTF-32</span></code>字节序列的前缀。</span><span class="yiyi-st" id="yiyi-397">该字符（<code class="docutils literal"><span class="pre">0xFFFE</span></code>）的字节交换版本是非法字符，可能不会出现在Unicode文本中。</span><span class="yiyi-st" id="yiyi-398">因此，当<code class="docutils literal"><span class="pre">UTF-16</span></code>或<code class="docutils literal"><span class="pre">UTF-32</span></code>字节序列中的第一个字符看起来是<code class="docutils literal"><span class="pre">U+FFFE</span></code>时，字节必须交换在解码。</span><span class="yiyi-st" id="yiyi-399">Unfortunately the character <code class="docutils literal"><span class="pre">U+FEFF</span></code> had a second purpose as a <code class="docutils literal"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code>: a character that has no width and doesn’t allow a word to be split. </span><span class="yiyi-st" id="yiyi-400">它可以例如</span><span class="yiyi-st" id="yiyi-401">用于提示连字算法。</span><span class="yiyi-st" id="yiyi-402">使用Unicode 4.0使用<code class="docutils literal"><span class="pre">U+FEFF</span></code>作为<span class="pre"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">/ t6&gt;已被弃用（与<code class="docutils literal"><span class="pre">U+2060</span></code>（<code class="docutils literal"><span class="pre">WORD</span> <span class="pre">JOINER</span></code>） ）。</span></span></span><span class="yiyi-st" id="yiyi-403">Nevertheless Unicode software still must be able to handle <code class="docutils literal"><span class="pre">U+FEFF</span></code> in both roles: as a BOM it’s a device to determine the storage layout of the encoded bytes, and vanishes once the byte sequence has been decoded into a string; as a <code class="docutils literal"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code> it’s a normal character that will be decoded like any other.</span></p><p><span class="yiyi-st" id="yiyi-404">还有另一种编码能够编码全部的Unicode字符：UTF-8。</span><span class="yiyi-st" id="yiyi-405">UTF-8是一个8位编码，这意味着在UTF-8中没有字节顺序的问题。</span><span class="yiyi-st" id="yiyi-406">UTF-8字节序列中的每个字节由两部分组成：标记位（最高有效位）和有效负载位。</span><span class="yiyi-st" id="yiyi-407">标记位是一个0到4 <code class="docutils literal"><span class="pre">1</span></code>位，后跟一个<code class="docutils literal"><span class="pre">0</span></code>位的序列。</span><span class="yiyi-st" id="yiyi-408">Unicode字符是这样编码的（x是有效载荷位，当连接时给出Unicode字符）：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-409">范围</span></th><th class="head"><span class="yiyi-st" id="yiyi-410">编码</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-411"><code class="docutils literal"><span class="pre">U-00000000</span></code> ... <code class="docutils literal"><span class="pre">U-0000007F</span></code></span></td><td><span class="yiyi-st" id="yiyi-412">0xxxxxxx</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-413"><code class="docutils literal"><span class="pre">U-00000080</span></code> ... <code class="docutils literal"><span class="pre">U-000007FF</span></code></span></td><td><span class="yiyi-st" id="yiyi-414">110xxxxx 10xxxxxx</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-415"><code class="docutils literal"><span class="pre">U-00000800</span></code> ... <code class="docutils literal"><span class="pre">U-0000FFFF</span></code></span></td><td><span class="yiyi-st" id="yiyi-416">1110xxxx 10xxxxxx 10xxxxxx</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-417"><code class="docutils literal"><span class="pre">U-00010000</span></code> ... <code class="docutils literal"><span class="pre">U-0010FFFF</span></code></span></td><td><span class="yiyi-st" id="yiyi-418">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-419">Unicode字符的最低有效位是最右边的x位。</span></p><p><span class="yiyi-st" id="yiyi-420">As UTF-8 is an 8-bit encoding no BOM is required and any <code class="docutils literal"><span class="pre">U+FEFF</span></code> character in the decoded string (even if it’s the first character) is treated as a <code class="docutils literal"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-421">没有外部信息，就不可能可靠地确定使用哪种编码来编码字符串。</span><span class="yiyi-st" id="yiyi-422">每个charmap编码可以解码任何随机字节序列。</span><span class="yiyi-st" id="yiyi-423">但UTF-8无法实现，因为UTF-8字节序列具有不允许任意字节序列的结构。</span><span class="yiyi-st" id="yiyi-424">为了提高可检测到UTF-8编码的可靠性，Microsoft发明了记事本程序的UTF-8变体（Python 2.5称为<code class="docutils literal"><span class="pre">"utf-8-sig"</span></code>）：的Unicode字符被写入文件，UTF-8编码的BOM（它看起来像是一个字节序列：<code class="docutils literal"><span class="pre">0xef</span></code>，<code class="docutils literal"><span class="pre">0xbb</span></code>，<code class="docutils literal"><span class="pre">0xbf</span></code></span><span class="yiyi-st" id="yiyi-425">由于任何charmap编码文件都以这些字节值开始（例如，</span><span class="yiyi-st" id="yiyi-426">映射到</span></p><span class="yiyi-st" id="yiyi-432"> <blockquote> <div><div class="line-block"> <div class="line">LATIN SMALL LETTER I WITH DIAERESIS</div> <div class="line">RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK</div> <div class="line">INVERTED QUESTION MARK</div> </div> </div></blockquote></span><p><span class="yiyi-st" id="yiyi-427">在iso-8859-1中），这增加了从字节序列正确猜测<code class="docutils literal"><span class="pre">utf-8-sig</span></code>编码的可能性。</span><span class="yiyi-st" id="yiyi-428">所以这里的BOM并不能用于确定用于生成字节序列的字节顺序，而是用作帮助猜测编码的签名。</span><span class="yiyi-st" id="yiyi-429">On encoding the utf-8-sig codec will write <code class="docutils literal"><span class="pre">0xef</span></code>, <code class="docutils literal"><span class="pre">0xbb</span></code>, <code class="docutils literal"><span class="pre">0xbf</span></code> as the first three bytes to the file. </span><span class="yiyi-st" id="yiyi-430">On decoding <code class="docutils literal"><span class="pre">utf-8-sig</span></code> will skip those three bytes if they appear as the first three bytes in the file. </span><span class="yiyi-st" id="yiyi-431">在UTF-8中，不鼓励使用BOM，通常应避免使用。</span></p></div><div class="section" id="standard-encodings"><h2><span class="yiyi-st" id="yiyi-433">7.2.3.</span><span class="yiyi-st" id="yiyi-434">标准编码</span></h2><p><span class="yiyi-st" id="yiyi-435">Python带有一些内置的编解码器，可以作为C函数或字典作为映射表来实现。</span><span class="yiyi-st" id="yiyi-436">下表按名称列出了编解码器，以及一些常用别名，以及可能使用编码的语言。</span><span class="yiyi-st" id="yiyi-437">别名列表和语言列表都不是详尽无遗的。</span><span class="yiyi-st" id="yiyi-438">请注意，仅在大小写不同的情况下使用拼写替代方法或使用连字符而不是下划线也是有效的别名；因此，例如</span><span class="yiyi-st" id="yiyi-439"><code class="docutils literal"><span class="pre">'utf-8'</span></code>是<code class="docutils literal"><span class="pre">'utf_8'</span></code>编解码器的有效别名。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-440"><strong>CPython implementation detail:</strong> Some common encodings can bypass the codecs lookup machinery to improve performance. </span><span class="yiyi-st" id="yiyi-441">这些优化机会仅由CPython针对一组有限的别名识别：utf-8，utf8，latin-1，latin1，iso-8859-1，mbcs（仅限Windows），ascii，utf-16和utf-32。</span><span class="yiyi-st" id="yiyi-442">对这些编码使用替代拼写可能导致执行速度变慢。</span></p></div><p><span class="yiyi-st" id="yiyi-443">许多字符集都支持相同的语言。</span><span class="yiyi-st" id="yiyi-444">它们在个别字符（例如</span><span class="yiyi-st" id="yiyi-445">是否支持EURO SIGN）以及将字符分配给代码位置。</span><span class="yiyi-st" id="yiyi-446">对于欧洲语言尤其如此，通常存在以下变体：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-447">ISO 8859代码集</span></li><li><span class="yiyi-st" id="yiyi-448">一个Microsoft Windows代码页，通常从8859代码集派生而来，但用其他图形字符替换控制字符</span></li><li><span class="yiyi-st" id="yiyi-449">一个IBM EBCDIC代码页</span></li><li><span class="yiyi-st" id="yiyi-450">IBM PC代码页，与ASCII兼容</span></li></ul><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-451">编解码器</span></th><th class="head"><span class="yiyi-st" id="yiyi-452">别名</span></th><th class="head"><span class="yiyi-st" id="yiyi-453">语言</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-454">ASCII</span></td><td><span class="yiyi-st" id="yiyi-455">646，us-ascii</span></td><td><span class="yiyi-st" id="yiyi-456">英语</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-457">中文</span></td><td><span class="yiyi-st" id="yiyi-458">big5-tw，csbig5</span></td><td><span class="yiyi-st" id="yiyi-459">繁体中文</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-460">big5hkscs</span></td><td><span class="yiyi-st" id="yiyi-461">big5-hkscs，hkscs</span></td><td><span class="yiyi-st" id="yiyi-462">繁体中文</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-463">cp037</span></td><td><span class="yiyi-st" id="yiyi-464">IBM037，IBM039</span></td><td><span class="yiyi-st" id="yiyi-465">英语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-466">cp273</span></td><td><span class="yiyi-st" id="yiyi-467">273，IBM273，csIBM273</span></td><td><p class="first"><span class="yiyi-st" id="yiyi-468">德语</span></p><div class="last versionadded"><p><span class="yiyi-st" id="yiyi-469"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-470">cp424</span></td><td><span class="yiyi-st" id="yiyi-471">EBCDIC-CP-HE，IBM424</span></td><td><span class="yiyi-st" id="yiyi-472">希伯来语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-473">CP437</span></td><td><span class="yiyi-st" id="yiyi-474">437，IBM437</span></td><td><span class="yiyi-st" id="yiyi-475">英语</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-476">CP500</span></td><td><span class="yiyi-st" id="yiyi-477">EBCDIC-CP-BE，EBCDIC-CP-CH，IBM500</span></td><td><span class="yiyi-st" id="yiyi-478">西欧</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-479">CP720</span></td><td></td><td><span class="yiyi-st" id="yiyi-480">阿拉伯</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-481">cp737</span></td><td></td><td><span class="yiyi-st" id="yiyi-482">希腊语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-483">CP775</span></td><td><span class="yiyi-st" id="yiyi-484">IBM775</span></td><td><span class="yiyi-st" id="yiyi-485">波罗的语言</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-486">CP850</span></td><td><span class="yiyi-st" id="yiyi-487">850，IBM850</span></td><td><span class="yiyi-st" id="yiyi-488">西欧</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-489">CP852</span></td><td><span class="yiyi-st" id="yiyi-490">852，IBM852</span></td><td><span class="yiyi-st" id="yiyi-491">中欧和东欧</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-492">cp855</span></td><td><span class="yiyi-st" id="yiyi-493">855，IBM855</span></td><td><span class="yiyi-st" id="yiyi-494">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-495">cp856</span></td><td></td><td><span class="yiyi-st" id="yiyi-496">希伯来语</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-497">cp857</span></td><td><span class="yiyi-st" id="yiyi-498">857，IBM857</span></td><td><span class="yiyi-st" id="yiyi-499">土耳其</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-500">cp858</span></td><td><span class="yiyi-st" id="yiyi-501">858，IBM858</span></td><td><span class="yiyi-st" id="yiyi-502">西欧</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-503">CP860</span></td><td><span class="yiyi-st" id="yiyi-504">860，IBM860</span></td><td><span class="yiyi-st" id="yiyi-505">葡萄牙语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-506">cp861</span></td><td><span class="yiyi-st" id="yiyi-507">861，CP-IS，IBM861</span></td><td><span class="yiyi-st" id="yiyi-508">冰岛的</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-509">cp862</span></td><td><span class="yiyi-st" id="yiyi-510">862，IBM862</span></td><td><span class="yiyi-st" id="yiyi-511">希伯来语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-512">cp863</span></td><td><span class="yiyi-st" id="yiyi-513">863，IBM863</span></td><td><span class="yiyi-st" id="yiyi-514">加拿大</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-515">cp864</span></td><td><span class="yiyi-st" id="yiyi-516">IBM864</span></td><td><span class="yiyi-st" id="yiyi-517">阿拉伯</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-518">cp865</span></td><td><span class="yiyi-st" id="yiyi-519">865，IBM865</span></td><td><span class="yiyi-st" id="yiyi-520">丹麦语，挪威语</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-521">CP866</span></td><td><span class="yiyi-st" id="yiyi-522">866，IBM866</span></td><td><span class="yiyi-st" id="yiyi-523">俄语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-524">cp869</span></td><td><span class="yiyi-st" id="yiyi-525">869，CP-GR，IBM869</span></td><td><span class="yiyi-st" id="yiyi-526">希腊语</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-527">cp874</span></td><td></td><td><span class="yiyi-st" id="yiyi-528">泰国</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-529">cp875</span></td><td></td><td><span class="yiyi-st" id="yiyi-530">希腊语</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-531">CP932</span></td><td><span class="yiyi-st" id="yiyi-532">932，ms932，mskanji，ms-kanji</span></td><td><span class="yiyi-st" id="yiyi-533">日本</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-534">CP949</span></td><td><span class="yiyi-st" id="yiyi-535">949，ms949，uhc</span></td><td><span class="yiyi-st" id="yiyi-536">朝鲜的</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-537">CP950</span></td><td><span class="yiyi-st" id="yiyi-538">950，ms950</span></td><td><span class="yiyi-st" id="yiyi-539">繁体中文</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-540">cp1006</span></td><td></td><td><span class="yiyi-st" id="yiyi-541">乌尔都语</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-542">cp1026</span></td><td><span class="yiyi-st" id="yiyi-543">ibm1026</span></td><td><span class="yiyi-st" id="yiyi-544">土耳其</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-545">cp1125</span></td><td><span class="yiyi-st" id="yiyi-546">1125，ibm1125，cp866u，ruscii</span></td><td><p class="first"><span class="yiyi-st" id="yiyi-547">乌克兰</span></p><div class="last versionadded"><p><span class="yiyi-st" id="yiyi-548"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-549">cp1140</span></td><td><span class="yiyi-st" id="yiyi-550">ibm1140</span></td><td><span class="yiyi-st" id="yiyi-551">西欧</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-552">CP1250</span></td><td><span class="yiyi-st" id="yiyi-553">窗户-1250</span></td><td><span class="yiyi-st" id="yiyi-554">中欧和东欧</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-555">CP1251</span></td><td><span class="yiyi-st" id="yiyi-556">窗户-1251</span></td><td><span class="yiyi-st" id="yiyi-557">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-558">CP1252</span></td><td><span class="yiyi-st" id="yiyi-559">窗口1252</span></td><td><span class="yiyi-st" id="yiyi-560">西欧</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-561">cp1253</span></td><td><span class="yiyi-st" id="yiyi-562">窗户-1253</span></td><td><span class="yiyi-st" id="yiyi-563">希腊语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-564">cp1254</span></td><td><span class="yiyi-st" id="yiyi-565">窗户-1254</span></td><td><span class="yiyi-st" id="yiyi-566">土耳其</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-567">cp1255</span></td><td><span class="yiyi-st" id="yiyi-568">窗户-1255</span></td><td><span class="yiyi-st" id="yiyi-569">希伯来语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-570">cp1256</span></td><td><span class="yiyi-st" id="yiyi-571">窗户-1256</span></td><td><span class="yiyi-st" id="yiyi-572">阿拉伯</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-573">cp1257</span></td><td><span class="yiyi-st" id="yiyi-574">窗户-1257</span></td><td><span class="yiyi-st" id="yiyi-575">波罗的语言</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-576">cp1258</span></td><td><span class="yiyi-st" id="yiyi-577">窗户-1258</span></td><td><span class="yiyi-st" id="yiyi-578">越南</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-579">cp65001</span></td><td></td><td><p class="first"><span class="yiyi-st" id="yiyi-580">仅Windows：Windows UTF-8（<code class="docutils literal"><span class="pre">CP_UTF8</span></code>）</span></p><div class="last versionadded"><p><span class="yiyi-st" id="yiyi-581"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-582">EUC_JP</span></td><td><span class="yiyi-st" id="yiyi-583">eucjp, ujis, u-jis</span></td><td><span class="yiyi-st" id="yiyi-584">日本</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-585">euc_jis_2004</span></td><td><span class="yiyi-st" id="yiyi-586">jisx0213，eucjis2004</span></td><td><span class="yiyi-st" id="yiyi-587">日本</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-588">euc_jisx0213</span></td><td><span class="yiyi-st" id="yiyi-589">eucjisx0213</span></td><td><span class="yiyi-st" id="yiyi-590">日本</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-591">EUC_KR</span></td><td><span class="yiyi-st" id="yiyi-592">euckr，korean，ksc5601，ks_c-5601，ks_c-5601-1987，ksx1001，ks_x-1001</span></td><td><span class="yiyi-st" id="yiyi-593">朝鲜的</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-594">GB2312</span></td><td><span class="yiyi-st" id="yiyi-595">chinese, csiso58gb231280, euc- cn, euccn, eucgb2312-cn, gb2312-1980, gb2312-80, iso- ir-58</span></td><td><span class="yiyi-st" id="yiyi-596">简体中文</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-597">GBK</span></td><td><span class="yiyi-st" id="yiyi-598">936，cp936，ms936</span></td><td><span class="yiyi-st" id="yiyi-599">统一的中文</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-600">GB18030</span></td><td><span class="yiyi-st" id="yiyi-601">GB18030-2000</span></td><td><span class="yiyi-st" id="yiyi-602">统一的中文</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-603">赫兹</span></td><td><span class="yiyi-st" id="yiyi-604">hzgb，hz-gb，hz-gb-2312</span></td><td><span class="yiyi-st" id="yiyi-605">简体中文</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-606">iso2022_jp</span></td><td><span class="yiyi-st" id="yiyi-607">csiso2022jp，iso2022jp，iso-2022-jp</span></td><td><span class="yiyi-st" id="yiyi-608">日本</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-609">iso2022_jp_1</span></td><td><span class="yiyi-st" id="yiyi-610">iso2022jp-1，iso-2022-jp-1</span></td><td><span class="yiyi-st" id="yiyi-611">日本</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-612">iso2022_jp_2</span></td><td><span class="yiyi-st" id="yiyi-613">iso2022jp-2，iso-2022-jp-2</span></td><td><span class="yiyi-st" id="yiyi-614">日语，韩语，简体中文，西欧，希腊</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-615">iso2022_jp_2004</span></td><td><span class="yiyi-st" id="yiyi-616">iso2022jp-2004，iso-2022-jp-2004</span></td><td><span class="yiyi-st" id="yiyi-617">日本</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-618">iso2022_jp_3</span></td><td><span class="yiyi-st" id="yiyi-619">iso2022jp-3，iso-2022-jp-3</span></td><td><span class="yiyi-st" id="yiyi-620">日本</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-621">iso2022_jp_ext</span></td><td><span class="yiyi-st" id="yiyi-622">iso2022jp-ext，iso-2022-jp-ext</span></td><td><span class="yiyi-st" id="yiyi-623">日本</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-624">iso2022_kr</span></td><td><span class="yiyi-st" id="yiyi-625">csiso2022kr，iso2022kr，iso-2022-kr</span></td><td><span class="yiyi-st" id="yiyi-626">朝鲜的</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-627">LATIN_1</span></td><td><span class="yiyi-st" id="yiyi-628">iso-8859-1，iso8859-1,8889，cp819，latin，latin1，L1</span></td><td><span class="yiyi-st" id="yiyi-629">西欧</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-630">iso8859_2</span></td><td><span class="yiyi-st" id="yiyi-631">iso-8859-2，latin2，L2</span></td><td><span class="yiyi-st" id="yiyi-632">中欧和东欧</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-633">iso8859_3</span></td><td><span class="yiyi-st" id="yiyi-634">iso-8859-3，latin3，L3</span></td><td><span class="yiyi-st" id="yiyi-635">世界语，马耳他</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-636">iso8859_4</span></td><td><span class="yiyi-st" id="yiyi-637">iso-8859-4，latin4，L4</span></td><td><span class="yiyi-st" id="yiyi-638">波罗的语言</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-639">iso8859_5</span></td><td><span class="yiyi-st" id="yiyi-640">iso-8859-5, cyrillic</span></td><td><span class="yiyi-st" id="yiyi-641">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-642">iso8859_6</span></td><td><span class="yiyi-st" id="yiyi-643">iso-8859-6，阿拉伯语</span></td><td><span class="yiyi-st" id="yiyi-644">阿拉伯</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-645">iso8859_7</span></td><td><span class="yiyi-st" id="yiyi-646">iso-8859-7，希腊语，希腊语8</span></td><td><span class="yiyi-st" id="yiyi-647">希腊语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-648">iso8859_8</span></td><td><span class="yiyi-st" id="yiyi-649">iso-8859-8，希伯来语</span></td><td><span class="yiyi-st" id="yiyi-650">希伯来语</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-651">iso8859_9</span></td><td><span class="yiyi-st" id="yiyi-652">iso-8859-9, latin5, L5</span></td><td><span class="yiyi-st" id="yiyi-653">土耳其</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-654">iso8859_10</span></td><td><span class="yiyi-st" id="yiyi-655">iso-8859-10，latin6，L6</span></td><td><span class="yiyi-st" id="yiyi-656">北欧语言</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-657">iso8859_11</span></td><td><span class="yiyi-st" id="yiyi-658">iso-8859-11，泰语</span></td><td><span class="yiyi-st" id="yiyi-659">泰语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-660">iso8859_13</span></td><td><span class="yiyi-st" id="yiyi-661">iso-8859-13，latin7，L7</span></td><td><span class="yiyi-st" id="yiyi-662">波罗的语言</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-663">iso8859_14</span></td><td><span class="yiyi-st" id="yiyi-664">iso-8859-14，latin8，L8</span></td><td><span class="yiyi-st" id="yiyi-665">凯尔特语言</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-666">iso8859_15</span></td><td><span class="yiyi-st" id="yiyi-667">iso-8859-15，latin9，L9</span></td><td><span class="yiyi-st" id="yiyi-668">西欧</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-669">iso8859_16</span></td><td><span class="yiyi-st" id="yiyi-670">iso-8859-16，latin10，L10</span></td><td><span class="yiyi-st" id="yiyi-671">东南欧</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-672">裘哈</span></td><td><span class="yiyi-st" id="yiyi-673">cp1361，ms1361</span></td><td><span class="yiyi-st" id="yiyi-674">朝鲜的</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-675">koi8_r</span></td><td></td><td><span class="yiyi-st" id="yiyi-676">俄语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-677">koi8_t</span></td><td></td><td><p class="first"><span class="yiyi-st" id="yiyi-678">塔吉克</span></p><div class="last versionadded"><p><span class="yiyi-st" id="yiyi-679"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-680">koi8_u</span></td><td></td><td><span class="yiyi-st" id="yiyi-681">乌克兰</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-682">kz1048</span></td><td><span class="yiyi-st" id="yiyi-683">kz_1048，strk1048_2002，rk1048</span></td><td><p class="first"><span class="yiyi-st" id="yiyi-684">哈萨克人</span></p><div class="last versionadded"><p><span class="yiyi-st" id="yiyi-685"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-686">mac_cyrillic</span></td><td><span class="yiyi-st" id="yiyi-687">maccyrillic</span></td><td><span class="yiyi-st" id="yiyi-688">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-689">mac_greek</span></td><td><span class="yiyi-st" id="yiyi-690">macgreek</span></td><td><span class="yiyi-st" id="yiyi-691">希腊语</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-692">mac_iceland</span></td><td><span class="yiyi-st" id="yiyi-693">maciceland</span></td><td><span class="yiyi-st" id="yiyi-694">冰岛的</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-695">mac_latin2</span></td><td><span class="yiyi-st" id="yiyi-696">maclatin2，maccentraleurope</span></td><td><span class="yiyi-st" id="yiyi-697">中欧和东欧</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-698">mac_roman</span></td><td><span class="yiyi-st" id="yiyi-699">宏观人，麦金托什</span></td><td><span class="yiyi-st" id="yiyi-700">西欧</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-701">mac_turkish</span></td><td><span class="yiyi-st" id="yiyi-702">macturkish</span></td><td><span class="yiyi-st" id="yiyi-703">土耳其</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-704">ptcp154</span></td><td><span class="yiyi-st" id="yiyi-705">csptcp154, pt154, cp154, cyrillic-asian</span></td><td><span class="yiyi-st" id="yiyi-706">哈萨克人</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-707">shift_jis访问</span></td><td><span class="yiyi-st" id="yiyi-708">csshiftjis，shiftjis，sjis，s_jis</span></td><td><span class="yiyi-st" id="yiyi-709">日本</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-710">shift_jis_2004</span></td><td><span class="yiyi-st" id="yiyi-711">shiftjis2004，sjis_2004，sjis2004</span></td><td><span class="yiyi-st" id="yiyi-712">日本</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-713">shift_jisx0213</span></td><td><span class="yiyi-st" id="yiyi-714">shiftjisx0213，sjisx0213，s_jisx0213</span></td><td><span class="yiyi-st" id="yiyi-715">日本</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-716">utf_32</span></td><td><span class="yiyi-st" id="yiyi-717">U32，utf32</span></td><td><span class="yiyi-st" id="yiyi-718">所有语言</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-719">utf_32_be</span></td><td><span class="yiyi-st" id="yiyi-720">UTF-32BE</span></td><td><span class="yiyi-st" id="yiyi-721">所有语言</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-722">utf_32_le</span></td><td><span class="yiyi-st" id="yiyi-723">UTF-32LE</span></td><td><span class="yiyi-st" id="yiyi-724">所有语言</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-725">utf_16</span></td><td><span class="yiyi-st" id="yiyi-726">U16，utf16</span></td><td><span class="yiyi-st" id="yiyi-727">所有语言</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-728">utf_16_be</span></td><td><span class="yiyi-st" id="yiyi-729">UTF-16BE</span></td><td><span class="yiyi-st" id="yiyi-730">所有语言</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-731">utf_16_le</span></td><td><span class="yiyi-st" id="yiyi-732">UTF-16LE</span></td><td><span class="yiyi-st" id="yiyi-733">所有语言</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-734">utf_7</span></td><td><span class="yiyi-st" id="yiyi-735">U7，unicode-1-1-utf-7</span></td><td><span class="yiyi-st" id="yiyi-736">所有语言</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-737">UTF_8</span></td><td><span class="yiyi-st" id="yiyi-738">U8，UTF，utf8</span></td><td><span class="yiyi-st" id="yiyi-739">所有语言</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-740">utf_8_sig</span></td><td></td><td><span class="yiyi-st" id="yiyi-741">所有语言</span></td></tr></tbody></table><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-742"><span class="versionmodified">在版本3.4中更改：</span> utf-16 *和utf-32 *编码器不再允许代理码点（<code class="docutils literal"><span class="pre">U+D800</span></code>  -  <code class="docutils literal"><span class="pre">U+DFFF</span></code></span><span class="yiyi-st" id="yiyi-743">utf-32 *解码器不再解码对应于替代码点的字节序列。</span></p></div></div><div class="section" id="python-specific-encodings"><h2><span class="yiyi-st" id="yiyi-744">7.2.4.</span><span class="yiyi-st" id="yiyi-745">Python特定的编码</span></h2><p><span class="yiyi-st" id="yiyi-746">一些预定义的编解码器是Python特有的，因此它们的编解码器名称在Python之外没有任何意义。</span><span class="yiyi-st" id="yiyi-747">根据预期的输入和输出类型，这些在下表中列出（请注意，虽然文本编码是编解码器最常见的用例，但底层编解码器基础结构支持任意数据转换，而不仅仅支持文本编码）。</span><span class="yiyi-st" id="yiyi-748">对于不对称编解码器，所述目的描述编码方向。</span></p><div class="section" id="text-encodings"><h3><span class="yiyi-st" id="yiyi-749">7.2.4.1.</span><span class="yiyi-st" id="yiyi-750">文本编码</span></h3><p><span class="yiyi-st" id="yiyi-751">以下编解码器提供了<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>到<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>编码和<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>到<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>解码，类似于Unicode文本编码。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-752">编解码器</span></th><th class="head"><span class="yiyi-st" id="yiyi-753">别名</span></th><th class="head"><span class="yiyi-st" id="yiyi-754">目的</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-755">IDNA</span></td><td></td><td><span class="yiyi-st" id="yiyi-756">实现<span class="target" id="index-3"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>，另请参阅<a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal"><span class="pre">encodings.idna</span></code></a>。</span><span class="yiyi-st" id="yiyi-757">只支持<code class="docutils literal"><span class="pre">errors='strict'</span></code>。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-758">MBCS</span></td><td><span class="yiyi-st" id="yiyi-759">DBCS</span></td><td><span class="yiyi-st" id="yiyi-760">仅Windows：根据ANSI代码页（CP_ACP）对操作数进行编码</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-761">的PalmOS</span></td><td></td><td><span class="yiyi-st" id="yiyi-762">PalmOS 3.5的编码</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-763">Punycode码</span></td><td></td><td><span class="yiyi-st" id="yiyi-764">实现<span class="target" id="index-4"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html"><strong>RFC 3492</strong></a>。</span><span class="yiyi-st" id="yiyi-765">不支持状态编解码器。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-766">raw_unicode_escape</span></td><td></td><td><span class="yiyi-st" id="yiyi-767">对于其他代码点，使用<code class="docutils literal"><span class="pre">\uXXXX</span></code>和<code class="docutils literal"><span class="pre">\UXXXXXXXX</span></code>进行Latin-1编码。</span><span class="yiyi-st" id="yiyi-768">现有的反斜杠不会以任何方式逃脱。</span><span class="yiyi-st" id="yiyi-769">它用在Python pickle协议中。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-770">未定义</span></td><td></td><td><span class="yiyi-st" id="yiyi-771">引发所有转换的异常，甚至是空字符串。</span><span class="yiyi-st" id="yiyi-772">错误处理程序被忽略。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-773">unicode_escape</span></td><td></td><td><span class="yiyi-st" id="yiyi-774">编码适合作为ASCII编码Python源代码中的Unicode文字的内容，但引号不会转义。</span><span class="yiyi-st" id="yiyi-775">从Latin-1源代码解码。</span><span class="yiyi-st" id="yiyi-776">请注意，Python源代码默认使用UTF-8。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-777">unicode_internal</span></td><td></td><td><p class="first"><span class="yiyi-st" id="yiyi-778">返回操作数的内部表示。</span><span class="yiyi-st" id="yiyi-779">不支持状态编解码器。</span></p><div class="last deprecated"><p><span class="yiyi-st" id="yiyi-780"><span class="versionmodified">从版本3.3开始弃用：</span>这种表示已经被<span class="target" id="index-5"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a>废弃。</span></p></div></td></tr></tbody></table></div><div class="section" id="binary-transforms"><h3><span class="yiyi-st" id="yiyi-781">7.2.4.2.</span><span class="yiyi-st" id="yiyi-782">二进制变换</span></h3><p><span class="yiyi-st" id="yiyi-783">以下编解码器提供了二进制转换：<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>到<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>映射。</span><span class="yiyi-st" id="yiyi-784">它们不受<a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a>（仅产生<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>输出）的支持。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-785">编解码器</span></th><th class="head"><span class="yiyi-st" id="yiyi-786">别名</span></th><th class="head"><span class="yiyi-st" id="yiyi-787">目的</span></th><th class="head"><span class="yiyi-st" id="yiyi-788">编码器/解码器</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-789">base64_codec <a class="footnote-reference" href="#b64" id="id5">[1]</a></span></td><td><span class="yiyi-st" id="yiyi-790">base64，base_64</span></td><td><p class="first"><span class="yiyi-st" id="yiyi-791">将操作数转换为多行MIME base64（结果始终包含尾部<code class="docutils literal"><span class="pre">'\n'</span></code>）</span></p><div class="last versionchanged"><p><span class="yiyi-st" id="yiyi-792"><span class="versionmodified">Changed in version 3.4: </span>accepts any <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> as input for encoding and decoding</span></p></div></td><td><span class="yiyi-st" id="yiyi-793"><a class="reference internal" href="base64.html#base64.encodebytes" title="base64.encodebytes"><code class="xref py py-meth docutils literal"><span class="pre">base64.encodebytes()</span></code></a> / <a class="reference internal" href="base64.html#base64.decodebytes" title="base64.decodebytes"><code class="xref py py-meth docutils literal"><span class="pre">base64.decodebytes()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-794">bz2_codec</span></td><td><span class="yiyi-st" id="yiyi-795">BZ2</span></td><td><span class="yiyi-st" id="yiyi-796">使用bz2压缩操作数</span></td><td><span class="yiyi-st" id="yiyi-797"><a class="reference internal" href="bz2.html#bz2.compress" title="bz2.compress"><code class="xref py py-meth docutils literal"><span class="pre">bz2.compress()</span></code></a> / <a class="reference internal" href="bz2.html#bz2.decompress" title="bz2.decompress"><code class="xref py py-meth docutils literal"><span class="pre">bz2.decompress()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-798">hex_codec</span></td><td><span class="yiyi-st" id="yiyi-799">十六进制</span></td><td><span class="yiyi-st" id="yiyi-800">将操作数转换为十六进制表示，每个字节有两位数字</span></td><td><span class="yiyi-st" id="yiyi-801"><a class="reference internal" href="binascii.html#binascii.b2a_hex" title="binascii.b2a_hex"><code class="xref py py-meth docutils literal"><span class="pre">binascii.b2a_hex()</span></code></a> / <a class="reference internal" href="binascii.html#binascii.a2b_hex" title="binascii.a2b_hex"><code class="xref py py-meth docutils literal"><span class="pre">binascii.a2b_hex()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-802">quopri_codec</span></td><td><span class="yiyi-st" id="yiyi-803">quopri，quotedprintable，quoted_printable</span></td><td><span class="yiyi-st" id="yiyi-804">将操作数转换为可引用的MIME引用</span></td><td><span class="yiyi-st" id="yiyi-805"><a class="reference internal" href="quopri.html#quopri.encode" title="quopri.encode"><code class="xref py py-meth docutils literal"><span class="pre">quopri.encode()</span></code></a> with <code class="docutils literal"><span class="pre">quotetabs=True</span></code> / <a class="reference internal" href="quopri.html#quopri.decode" title="quopri.decode"><code class="xref py py-meth docutils literal"><span class="pre">quopri.decode()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-806">uu_codec</span></td><td><span class="yiyi-st" id="yiyi-807">UU</span></td><td><span class="yiyi-st" id="yiyi-808">使用uuencode转换操作数</span></td><td><span class="yiyi-st" id="yiyi-809"><a class="reference internal" href="uu.html#uu.encode" title="uu.encode"><code class="xref py py-meth docutils literal"><span class="pre">uu.encode()</span></code></a> / <a class="reference internal" href="uu.html#uu.decode" title="uu.decode"><code class="xref py py-meth docutils literal"><span class="pre">uu.decode()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-810">zlib_codec</span></td><td><span class="yiyi-st" id="yiyi-811">zip，zlib</span></td><td><span class="yiyi-st" id="yiyi-812">使用gzip压缩操作数</span></td><td><span class="yiyi-st" id="yiyi-813"><a class="reference internal" href="zlib.html#zlib.compress" title="zlib.compress"><code class="xref py py-meth docutils literal"><span class="pre">zlib.compress()</span></code></a> / <a class="reference internal" href="zlib.html#zlib.decompress" title="zlib.decompress"><code class="xref py py-meth docutils literal"><span class="pre">zlib.decompress()</span></code></a></span></td></tr></tbody></table><table class="docutils footnote" frame="void" id="b64" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-814"><a class="fn-backref" href="#id5"> [1]  T0&gt;</a></span></td><td><span class="yiyi-st" id="yiyi-815">除<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>外，<code class="docutils literal"><span class="pre">'base64_codec'</span></code>还接受<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>的仅ASCII码实例进行解码</span></td></tr></tbody></table><div class="versionadded"><p><span class="yiyi-st" id="yiyi-816"><span class="versionmodified">版本3.2中的新功能：</span>恢复二进制转换。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-817"><span class="versionmodified">Changed in version 3.4: </span>Restoration of the aliases for the binary transforms.</span></p></div></div><div class="section" id="text-transforms"><h3><span class="yiyi-st" id="yiyi-818">7.2.4.3.</span><span class="yiyi-st" id="yiyi-819">文本转换</span></h3><p><span class="yiyi-st" id="yiyi-820">下面的编解码器提供了一个文本转换：一个<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>到<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>映射。</span><span class="yiyi-st" id="yiyi-821">它不受<a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal"><span class="pre">str.encode()</span></code></a>（仅产生<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>输出）的支持。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-822">编解码器</span></th><th class="head"><span class="yiyi-st" id="yiyi-823">别名</span></th><th class="head"><span class="yiyi-st" id="yiyi-824">目的</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-825">rot_13</span></td><td><span class="yiyi-st" id="yiyi-826">ROT13</span></td><td><span class="yiyi-st" id="yiyi-827">返回操作数的凯撒密码加密</span></td></tr></tbody></table><div class="versionadded"><p><span class="yiyi-st" id="yiyi-828"><span class="versionmodified">版本3.2中的新功能：</span>恢复<code class="docutils literal"><span class="pre">rot_13</span></code>文本转换。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-829"><span class="versionmodified">在版本3.4中更改：</span>恢复<code class="docutils literal"><span class="pre">rot13</span></code>别名。</span></p></div></div></div><div class="section" id="module-encodings.idna"><h2><span class="yiyi-st" id="yiyi-830">7.2.5.  <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal"><span class="pre">encodings.idna</span></code></a>  - 应用程序中的国际化域名</span></h2><p><span class="yiyi-st" id="yiyi-831">This module implements <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a> (Internationalized Domain Names in Applications) and <span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html"><strong>RFC 3492</strong></a> (Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)). </span><span class="yiyi-st" id="yiyi-832">它建立在<code class="docutils literal"><span class="pre">punycode</span></code>编码和<a class="reference internal" href="stringprep.html#module-stringprep" title="stringprep: String preparation, as per RFC 3453"><code class="xref py py-mod docutils literal"><span class="pre">stringprep</span></code></a>上。</span></p><p><span class="yiyi-st" id="yiyi-833">这些RFC一起定义了一个协议来支持域名中的非ASCII字符。</span><span class="yiyi-st" id="yiyi-834">包含非ASCII字符的域名（如<code class="docutils literal"><span class="pre">www.Alliancefrançaise.nu</span></code>）将转换为ASCII兼容编码（ACE，如<code class="docutils literal"><span class="pre">www.xn--alliancefranaise-npb.nu</span></code></span><span class="yiyi-st" id="yiyi-835">然后，域名的ACE格式将用于协议不允许任意字符的所有地方，例如DNS查询，HTTP <em class="mailheader">Host</em>字段等。</span><span class="yiyi-st" id="yiyi-836">该转换在应用程序中执行；如果可能的话对用户不可见：应用程序应该在线上将Unicode域标签透明地转换为IDNA，并在将ACE标签呈现给用户之前将它们转换回Unicode。</span></p><p><span class="yiyi-st" id="yiyi-837">Python supports this conversion in several ways: the <code class="docutils literal"><span class="pre">idna</span></code> codec performs conversion between Unicode and ACE, separating an input string into labels based on the separator characters defined in <a class="reference external" href="https://tools.ietf.org/html/rfc3490#section-3.1">section 3.1</a> (1) of <span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a> and converting each label to ACE as required, and conversely separating an input byte string into labels based on the <code class="docutils literal"><span class="pre">.</span></code></span><span class="yiyi-st" id="yiyi-838">分隔符并将任何发现的ACE标签转换为unicode。</span><span class="yiyi-st" id="yiyi-839">此外，<a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a>模块将Unicode主机名透明地转换为ACE，因此应用程序在将主机名传递给套接字模块时无需担心自己的转换。</span><span class="yiyi-st" id="yiyi-840">On top of that, modules that have host names as function parameters, such as <a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">http.client</span></code></a> and <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">ftplib</span></code></a>, accept Unicode host names (<a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">http.client</span></code></a> then also transparently sends an IDNA hostname in the <em class="mailheader">Host</em> field if it sends that field at all).</span></p><p><span class="yiyi-st" id="yiyi-841">从线路接收主机名时（例如在反向名称查找中），不会自动转换为Unicode：希望向用户显示此类主机名的应用程序应将它们解码为Unicode。</span></p><p><span class="yiyi-st" id="yiyi-842">模块<a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal"><span class="pre">encodings.idna</span></code></a>还实现了nameprep过程，该过程对主机名执行特定的规范化操作，实现国际域名不区分大小写，统一类似字符。</span><span class="yiyi-st" id="yiyi-843">如果需要，可以直接使用nameprep函数。</span></p><dl class="function"><dt id="encodings.idna.nameprep"><span class="yiyi-st" id="yiyi-844"><code class="descclassname"> encodings.idna。 T0&gt; <code class="descname"> NAMEPREP  T1&gt; <span class="sig-paren">（ T2&gt; <em>标签 T3&gt; <span class="sig-paren">） T4&gt; </span></em></span></code></code></span></dt><dd><p><span class="yiyi-st" id="yiyi-845">返回<em>标签</em>的名称准备版本。</span><span class="yiyi-st" id="yiyi-846">该实现目前假定查询字符串，因此<code class="docutils literal"><span class="pre">AllowUnassigned</span></code>为true。</span></p></dd></dl><dl class="function"><dt id="encodings.idna.ToASCII"><span class="yiyi-st" id="yiyi-847"><code class="descclassname"> encodings.idna。 T0&gt; <code class="descname"> toascii将 T1&gt; <span class="sig-paren">（ T2&gt; <em>标签 T3&gt; <span class="sig-paren">） T4&gt; </span></em></span></code></code></span></dt><dd><p><span class="yiyi-st" id="yiyi-848">按照<span class="target" id="index-9"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>的规定将标签转换为ASCII。</span><span class="yiyi-st" id="yiyi-849"><code class="docutils literal"><span class="pre">UseSTD3ASCIIRules</span></code> is assumed to be false.</span></p></dd></dl><dl class="function"><dt id="encodings.idna.ToUnicode"><span class="yiyi-st" id="yiyi-850"><code class="descclassname"> encodings.idna。 T0&gt; <code class="descname"> ToUnicode  T1&gt; <span class="sig-paren">（ T2&gt; <em>标签 T3&gt; <span class="sig-paren">） T4&gt; </span></em></span></code></code></span></dt><dd><p><span class="yiyi-st" id="yiyi-851">按照<span class="target" id="index-10"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>的规定将标签转换为Unicode。</span></p></dd></dl></div><div class="section" id="module-encodings.mbcs"><h2><span class="yiyi-st" id="yiyi-852">7.2.6.  <a class="reference internal" href="#module-encodings.mbcs" title="encodings.mbcs: Windows ANSI codepage"><code class="xref py py-mod docutils literal"><span class="pre">encodings.mbcs</span></code></a>  -  Windows ANSI代码页</span></h2><p><span class="yiyi-st" id="yiyi-853">根据ANSI代码页（CP_ACP）编码操作数。</span></p><p><span class="yiyi-st" id="yiyi-854">可用性：仅限Windows。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-855"><span class="versionmodified">在版本3.3中更改：</span>支持任何错误处理程序。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-856"><span class="versionmodified">在版本3.2中更改：</span>在3.2之前，<em>错误</em>参数被忽略； <code class="docutils literal"><span class="pre">'replace'</span></code>总是用于编码，<code class="docutils literal"><span class="pre">'ignore'</span></code>用于解码。</span></p></div></div><div class="section" id="module-encodings.utf_8_sig"><h2><span class="yiyi-st" id="yiyi-857">7.2.7.  <a class="reference internal" href="#module-encodings.utf_8_sig" title="encodings.utf_8_sig: UTF-8 codec with BOM signature"><code class="xref py py-mod docutils literal"><span class="pre">encodings.utf_8_sig</span></code></a>  - 带BOM签名的UTF-8编解码器</span></h2><p><span class="yiyi-st" id="yiyi-858">该模块实现了UTF-8编解码器的一种变体：在编码时，UTF-8编码的BOM将被添加到UTF-8编码的字节中。</span><span class="yiyi-st" id="yiyi-859">对于有状态编码器，这只会执行一次（在第一次写入字节流时）。</span><span class="yiyi-st" id="yiyi-860">在数据开始时解码可选的UTF-8编码BOM将被跳过。</span></p></div></div></div>