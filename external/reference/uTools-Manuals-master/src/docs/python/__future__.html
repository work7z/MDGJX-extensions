<div class="body" role="main"><div class="section" id="module-__future__"><h1><span class="yiyi-st" id="yiyi-10">29.10. </span><span class="yiyi-st" id="yiyi-11"><a class="reference internal" href="#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a> — Future statement definitions</span></h1><p><span class="yiyi-st" id="yiyi-12"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/__future__.py">Lib/__future__.py</a></span></p><p><span class="yiyi-st" id="yiyi-13"><a class="reference internal" href="#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a>是一个真正的模块，具有三个目的：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-14">为了避免混淆分析import语句并希望找到他们正在导入的模块的现有工具。</span></li><li><span class="yiyi-st" id="yiyi-15">要确保<a class="reference internal" href="../reference/simple_stmts.html#future"><span>future statements</span></a>在2.1之前的版本下运行，至少会出现运行时异常（导入<a class="reference internal" href="#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a>将失败，因为在2.1之前没有该名称的模块） 。</span></li><li><span class="yiyi-st" id="yiyi-16">记录何时引入了不兼容的更改，以及何时或将要强制执行。</span><span class="yiyi-st" id="yiyi-17">这是一种可执行文档的形式，可以通过导入<a class="reference internal" href="#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a>并检查其内容以编程方式检查。</span></li></ul><p><span class="yiyi-st" id="yiyi-18"><code class="file docutils literal"><span class="pre">__future__.py</span></code>中的每个语句的格式如下：</span></p><pre><code class="language-python"><span></span><span class="n">FeatureName</span> <span class="o">=</span> <span class="n">_Feature</span><span class="p">(</span><span class="n">OptionalRelease</span><span class="p">,</span> <span class="n">MandatoryRelease</span><span class="p">,</span>
                       <span class="n">CompilerFlag</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-19">通常，<em>OptionalRelease</em>小于<em>MandatoryRelease</em>，并且都是与<a class="reference internal" href="sys.html#sys.version_info" title="sys.version_info"><code class="xref py py-data docutils literal"><span class="pre">sys.version_info</span></code></a>相同形式的5元组：</span></p><pre><code class="language-python"><span></span><span class="p">(</span><span class="n">PY_MAJOR_VERSION</span><span class="p">,</span> <span class="c1"># the 2 in 2.1.0a3; an int</span>
 <span class="n">PY_MINOR_VERSION</span><span class="p">,</span> <span class="c1"># the 1; an int</span>
 <span class="n">PY_MICRO_VERSION</span><span class="p">,</span> <span class="c1"># the 0; an int</span>
 <span class="n">PY_RELEASE_LEVEL</span><span class="p">,</span> <span class="c1"># "alpha", "beta", "candidate" or "final"; string</span>
 <span class="n">PY_RELEASE_SERIAL</span> <span class="c1"># the 3; an int</span>
<span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-20"><em>OptionalRelease</em>记录接受功能的第一个版本。</span></p><p><span class="yiyi-st" id="yiyi-21">在尚未发生<em>MandatoryRelease</em>的情况下，<em>MandatoryRelease</em>预测功能将成为语言一部分的版本。</span></p><p><span class="yiyi-st" id="yiyi-22">Else <em>MandatoryRelease</em>记录该功能成为语言的一部分；在版本中或之后，模块不再需要未来语句来使用相关功能，但可以继续使用此类导入。</span></p><p><span class="yiyi-st" id="yiyi-23"><em>MandatoryRelease</em>也可能是<code class="docutils literal"><span class="pre">None</span></code>，意味着计划的要素被删除。</span></p><p><span class="yiyi-st" id="yiyi-24">类<code class="xref py py-class docutils literal"><span class="pre">_Feature</span></code>的实例有两个对应的方法，<code class="xref py py-meth docutils literal"><span class="pre">getOptionalRelease()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">getMandatoryRelease()</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-25"><em>CompilerFlag</em>是在内部函数<a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a>的第四个参数中传递的（位字段）标志，以启用动态编译代码中的功能。</span><span class="yiyi-st" id="yiyi-26">此标志存储在<code class="xref py py-class docutils literal"><span class="pre">_Feature</span></code>实例上的<code class="xref py py-attr docutils literal"><span class="pre">compiler_flag</span></code>属性中。</span></p><p><span class="yiyi-st" id="yiyi-27">将不会从<a class="reference internal" href="#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a>中删除功能说明。</span><span class="yiyi-st" id="yiyi-28">自从它在Python 2.1中的引入以来，以下功能已经使用这种机制找到了它们的在语言中的方式：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-29">特征</span></th><th class="head"><span class="yiyi-st" id="yiyi-30">可选</span></th><th class="head"><span class="yiyi-st" id="yiyi-31">强制性</span></th><th class="head"><span class="yiyi-st" id="yiyi-32">影响</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-33">nested_scopes</span></td><td><span class="yiyi-st" id="yiyi-34">2.1.0b1</span></td><td><span class="yiyi-st" id="yiyi-35">2.2</span></td><td><span class="yiyi-st" id="yiyi-36"><span class="target" id="index-0"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0227"><strong>PEP 227</strong></a>：<em>静态嵌套作用域</em></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-37">generators</span></td><td><span class="yiyi-st" id="yiyi-38">2.2.0a1</span></td><td><span class="yiyi-st" id="yiyi-39">2.3</span></td><td><span class="yiyi-st" id="yiyi-40"><span class="target" id="index-1"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0255"><strong>PEP 255</strong></a>：<em>简单生成器</em></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-41">division</span></td><td><span class="yiyi-st" id="yiyi-42">2.2.0a2</span></td><td><span class="yiyi-st" id="yiyi-43">3.0</span></td><td><span class="yiyi-st" id="yiyi-44"><span class="target" id="index-2"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0238"><strong>PEP 238</strong></a>：<em>更改除法操作符</em></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-45">absolute_import</span></td><td><span class="yiyi-st" id="yiyi-46">2.5.0a1</span></td><td><span class="yiyi-st" id="yiyi-47">3.0</span></td><td><span class="yiyi-st" id="yiyi-48"><span class="target" id="index-3"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a>：<em>导入：多行和绝对/相对</em></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-49">with_statement</span></td><td><span class="yiyi-st" id="yiyi-50">2.5.0a1</span></td><td><span class="yiyi-st" id="yiyi-51">2.6</span></td><td><span class="yiyi-st" id="yiyi-52"><span class="target" id="index-4"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a>：<em>“with”语句</em></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-53">print_function</span></td><td><span class="yiyi-st" id="yiyi-54">2.6.0a2</span></td><td><span class="yiyi-st" id="yiyi-55">3.0</span></td><td><span class="yiyi-st" id="yiyi-56"><span class="target" id="index-5"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3105"><strong>PEP 3105</strong></a>：<em>使print变成一个函数</em></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-57">unicode_literals</span></td><td><span class="yiyi-st" id="yiyi-58">2.6.0a2</span></td><td><span class="yiyi-st" id="yiyi-59">3.0</span></td><td><span class="yiyi-st" id="yiyi-60"><span class="target" id="index-6"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3112"><strong>PEP 3112</strong></a>：<em>Python3000中的字节字面值</em></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-61">generator_stop</span></td><td><span class="yiyi-st" id="yiyi-62">3.5.0b1</span></td><td><span class="yiyi-st" id="yiyi-63">3.7</span></td><td><span class="yiyi-st" id="yiyi-64"><span class="target" id="index-7"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0479"><strong>PEP 479</strong></a>：<em>生成器内的StopIteration处理</em></span></td></tr></tbody></table><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-65">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-66"><a class="reference internal" href="../reference/simple_stmts.html#future"><span>Future语句</span></a></span></dt><dd><span class="yiyi-st" id="yiyi-67">编译器如何处理future导入。</span></dd></dl></div></div></div>