<div class="body" role="main"><div class="section" id="module-zlib"><h1><span class="yiyi-st" id="yiyi-10">13.1. <a class="reference internal" href="#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal"><span class="pre">zlib</span></code></a>  - 与<strong class="program">gzip</strong> 兼容的压缩</span></h1><p><span class="yiyi-st" id="yiyi-11">对于需要数据压缩的应用程序，此模块中的函数允许使用zlib库进行压缩和解压缩。</span><span class="yiyi-st" id="yiyi-12">zlib库在<a class="reference external" href="http://www.zlib.net">http://www.zlib.net</a>上有自己的主页。</span><span class="yiyi-st" id="yiyi-13">Python模块和早于1.1.3的zlib库的版本之间存在已知不兼容性； 1.1.3具有安全漏洞，因此我们建议使用1.1.4或更高版本。</span></p><p><span class="yiyi-st" id="yiyi-14">zlib的函数有很多选项，并且通常需要以特定的顺序使用。</span><span class="yiyi-st" id="yiyi-15">本文档并不试图覆盖所有的排列；有关权威信息，请参阅<a class="reference external" href="http://www.zlib.net/manual.html">http://www.zlib.net/manual.html</a>上的zlib手册。</span></p><p><span class="yiyi-st" id="yiyi-16">对于读取和写入<code class="docutils literal"><span class="pre">.gz</span></code>文件，请参阅<a class="reference internal" href="gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal"><span class="pre">gzip</span></code></a>模块。</span></p><p><span class="yiyi-st" id="yiyi-17">此模块中的可用异常和功能包括：</span></p><dl class="exception"><dt id="zlib.error"><span class="yiyi-st" id="yiyi-18"> <em class="property">exception </em><code class="descclassname">zlib.</code><code class="descname">error</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-19">在压缩和解压缩错误时引发异常。</span></p></dd></dl><dl class="function"><dt id="zlib.adler32"><span class="yiyi-st" id="yiyi-20"> <code class="descclassname">zlib.</code><code class="descname">adler32</code><span class="sig-paren">(</span><em>data</em><span class="optional">[</span>, <em>value</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-21">计算<em>数据</em>的Adler-32校验和。</span><span class="yiyi-st" id="yiyi-22">（Adler-32校验和几乎与CRC32一样可靠，但可以计算得更快）。</span><span class="yiyi-st" id="yiyi-23">结果是无符号的32位整数。</span><span class="yiyi-st" id="yiyi-24">如果存在<em>值</em>，则将其用作校验和的起始值；否则，使用默认值1。</span><span class="yiyi-st" id="yiyi-25">传入<em>值</em>允许在多个输入的并置上计算运行的校验和。</span><span class="yiyi-st" id="yiyi-26">该算法不是加密强的，并且不应该用于认证或数字签名。</span><span class="yiyi-st" id="yiyi-27">由于算法被设计为用作校验和算法，所以它不适合用作一般的哈希算法。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-28"><span class="versionmodified">在3.0版中已更改：</span>始终返回未签名的值。</span><span class="yiyi-st" id="yiyi-29">要在所有Python版本和平台上生成相同的数值，请使用<code class="docutils literal"><span class="pre">adler32（data）</span> <span class="pre">＆amp；</span> <span class="pre">0xffffffff</span> </code></span></p></div></dd></dl><dl class="function"><dt id="zlib.compress"><span class="yiyi-st" id="yiyi-30"> <code class="descclassname">zlib.</code><code class="descname">compress</code><span class="sig-paren">(</span><em>data</em><span class="optional">[</span>, <em>level</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-31">压缩<em>数据</em>中的字节，返回包含压缩数据的字节对象。</span><span class="yiyi-st" id="yiyi-32"><em>level</em>是从<code class="docutils literal"><span class="pre">0</span></code>到<code class="docutils literal"><span class="pre">9</span></code>的整数，控制压缩级别； <code class="docutils literal"><span class="pre">1</span></code>是最快的，并产生最小的压缩，<code class="docutils literal"><span class="pre">9</span></code>最慢，产生最多。</span><span class="yiyi-st" id="yiyi-33"><code class="docutils literal"><span class="pre">0</span></code>是无压缩。</span><span class="yiyi-st" id="yiyi-34">默认值为<code class="docutils literal"><span class="pre">6</span></code>。</span><span class="yiyi-st" id="yiyi-35">如果发生任何错误，则引发<a class="reference internal" href="#zlib.error" title="zlib.error"><code class="xref py py-exc docutils literal"><span class="pre">error</span></code></a>异常。</span></p></dd></dl><dl class="function"><dt id="zlib.compressobj"><span class="yiyi-st" id="yiyi-36"> <code class="descclassname">zlib.</code><code class="descname">compressobj</code><span class="sig-paren">(</span><em>level=-1</em>, <em>method=DEFLATED</em>, <em>wbits=15</em>, <em>memLevel=8</em>, <em>strategy=Z_DEFAULT_STRATEGY</em><span class="optional">[</span>, <em>zdict</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-37">返回一个压缩对象，用于压缩不能立即适合内存的数据流。</span></p><p><span class="yiyi-st" id="yiyi-38"><em>level</em>是压缩级别 - 从<code class="docutils literal"><span class="pre">0</span></code>到<code class="docutils literal"><span class="pre">9</span></code>或<code class="docutils literal"><span class="pre">-1</span></code>的整数。</span><span class="yiyi-st" id="yiyi-39">值<code class="docutils literal"><span class="pre">1</span></code>是最快的并且产生最小的压缩，而<code class="docutils literal"><span class="pre">9</span></code>的值最慢并且产生最多。</span><span class="yiyi-st" id="yiyi-40"><code class="docutils literal"><span class="pre">0</span></code>是无压缩。</span><span class="yiyi-st" id="yiyi-41">默认值为<code class="docutils literal"><span class="pre">-1</span></code>（Z_DEFAULT_COMPRESSION）。</span><span class="yiyi-st" id="yiyi-42">Z_DEFAULT_COMPRESSION表示速度和压缩之间的默认折中（目前等于6级）。</span></p><p><span class="yiyi-st" id="yiyi-43"><em>方法</em>是压缩算法。</span><span class="yiyi-st" id="yiyi-44">目前，唯一支持的值为<code class="docutils literal"><span class="pre">DEFLATED</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-45"><em>wbits</em>参数控制压缩数据时使用的历史缓冲区大小（或“窗口大小”），以及输出中是否包括标头和尾部。</span><span class="yiyi-st" id="yiyi-46">它可以取几个值的范围：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-47">+9到+15：窗口大小的基二对数，因此其范围在512和32768之间。</span><span class="yiyi-st" id="yiyi-48">较大的值以更大的内存使用为代价产生更好的压缩。</span><span class="yiyi-st" id="yiyi-49">生成的输出将包括zlib特定的头和尾部。</span></li><li><span class="yiyi-st" id="yiyi-50">-9至-15：使用<em>wbits</em>的绝对值作为窗口大小对数，同时生成没有头或尾校验和的原始输出流。</span></li><li><span class="yiyi-st" id="yiyi-51">+25到+31 = 16 +（9到15）：使用值的低4位作为窗口大小对数，同时在输出中包括基本的<strong class="program">gzip</strong>头和尾随校验和。</span></li></ul><p><span class="yiyi-st" id="yiyi-52"><em>memLevel</em>参数控制用于内部压缩状态的内存量。</span><span class="yiyi-st" id="yiyi-53">有效值范围从<code class="docutils literal"><span class="pre">1</span></code>到<code class="docutils literal"><span class="pre">9</span></code>。</span><span class="yiyi-st" id="yiyi-54">更高的值使用更多的内存，但是更快，产生更小的输出。</span></p><p><span class="yiyi-st" id="yiyi-55"><em>策略</em>用于调整压缩算法。</span><span class="yiyi-st" id="yiyi-56">可能的值为<code class="docutils literal"><span class="pre">Z_DEFAULT_STRATEGY</span></code>，<code class="docutils literal"><span class="pre">Z_FILTERED</span></code>和<code class="docutils literal"><span class="pre">Z_HUFFMAN_ONLY</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-57"><em>zdict</em>是预定义的压缩字典。</span><span class="yiyi-st" id="yiyi-58">这是包含预期在要压缩的数据中频繁出现的子序列的字节序列（例如<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>对象）。</span><span class="yiyi-st" id="yiyi-59">那些预期最常见的子序列应该出现在字典的结尾。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-60"><span class="versionmodified">在版本3.3中更改：</span>添加了<em>zdict</em>参数和关键字参数支持。</span></p></div></dd></dl><dl class="function"><dt id="zlib.crc32"><span class="yiyi-st" id="yiyi-61"> <code class="descclassname">zlib.</code><code class="descname">crc32</code><span class="sig-paren">(</span><em>data</em><span class="optional">[</span>, <em>value</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p id="index-0"><span class="yiyi-st" id="yiyi-62">计算<em>数据</em>的CRC（循环冗余校验）校验和。</span><span class="yiyi-st" id="yiyi-63">结果是无符号的32位整数。</span><span class="yiyi-st" id="yiyi-64">如果存在<em>值</em>，则将其用作校验和的起始值；否则，使用默认值0。</span><span class="yiyi-st" id="yiyi-65">传入<em>值</em>允许在多个输入的并置上计算运行的校验和。</span><span class="yiyi-st" id="yiyi-66">该算法不是加密强的，并且不应该用于认证或数字签名。</span><span class="yiyi-st" id="yiyi-67">由于算法被设计为用作校验和算法，所以它不适合用作一般的哈希算法。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-68"><span class="versionmodified">在3.0版中已更改：</span>始终返回未签名的值。</span><span class="yiyi-st" id="yiyi-69">要在所有Python版本和平台上生成相同的数值，请使用<code class="docutils literal"><span class="pre">crc32（data）</span> <span class="pre">＆amp；</span> <span class="pre">0xffffffff</span></code>。</span></p></div></dd></dl><dl class="function"><dt id="zlib.decompress"><span class="yiyi-st" id="yiyi-70"> <code class="descclassname">zlib.</code><code class="descname">decompress</code><span class="sig-paren">(</span><em>data</em><span class="optional">[</span>, <em>wbits</em><span class="optional">[</span>, <em>bufsize</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-71">解压缩<em>数据</em>中的字节，返回包含未压缩数据的字节对象。</span><span class="yiyi-st" id="yiyi-72"><em>wbits</em>参数取决于<em>数据</em>的格式，并在下面进一步讨论。</span><span class="yiyi-st" id="yiyi-73">如果给定<em>bufsize</em>，则将其用作输出缓冲区的初始大小。</span><span class="yiyi-st" id="yiyi-74">如果发生任何错误，则引发<a class="reference internal" href="#zlib.error" title="zlib.error"><code class="xref py py-exc docutils literal"><span class="pre">error</span></code></a>异常。</span></p><p id="decompress-wbits"><span class="yiyi-st" id="yiyi-75"><em>wbits</em>参数控制历史缓冲区的大小（或“窗口大小”），以及预期的报头和尾部格式。</span><span class="yiyi-st" id="yiyi-76">它类似于<a class="reference internal" href="#zlib.compressobj" title="zlib.compressobj"><code class="xref py py-func docutils literal"><span class="pre">compressobj()</span></code></a>的参数，但接受更多的值范围：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-77">+8到+15：窗口大小的基二对数。</span><span class="yiyi-st" id="yiyi-78">输入必须包括zlib标头和预告片。</span></li><li><span class="yiyi-st" id="yiyi-79">0：从zlib头自动确定窗口大小。</span><span class="yiyi-st" id="yiyi-80">只支持自zlib 1.2.3.5。</span></li><li><span class="yiyi-st" id="yiyi-81">-8至-15：使用<em>wbits</em>的绝对值作为窗口大小对数。</span><span class="yiyi-st" id="yiyi-82">输入必须是没有标题或预告片的原始流。</span></li><li><span class="yiyi-st" id="yiyi-83">+24到+31 = 16 +（8到15）：使用值的低4位作为窗口大小对数。</span><span class="yiyi-st" id="yiyi-84">输入必须包含gzip标头和预告片。</span></li><li><span class="yiyi-st" id="yiyi-85">+40到+47 = 32 +（8到15）：使用值的低4位作为窗口大小对数，并自动接受zlib或gzip格式。</span></li></ul><p><span class="yiyi-st" id="yiyi-86">当解压缩流时，窗口大小必须不小于最初用于压缩流的大小；使用太小的值可能会导致<a class="reference internal" href="#zlib.error" title="zlib.error"><code class="xref py py-exc docutils literal"><span class="pre">error</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-87">默认的<em>wbits</em>值为15，这对应于最大的窗口大小，需要包含一个zlib标头和trailer。</span></p><p><span class="yiyi-st" id="yiyi-88"><em>bufsize</em>是用于保存解压缩数据的缓冲区的初始大小。</span><span class="yiyi-st" id="yiyi-89">如果需要更多的空间，缓冲区大小将根据需要增加，所以你不必得到这个值完全正确；调整它只会保存对<code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code>的几个调用。</span><span class="yiyi-st" id="yiyi-90">默认大小为16384。</span></p></dd></dl><dl class="function"><dt id="zlib.decompressobj"><span class="yiyi-st" id="yiyi-91"> <code class="descclassname">zlib.</code><code class="descname">decompressobj</code><span class="sig-paren">(</span><em>wbits=15</em><span class="optional">[</span>, <em>zdict</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-92">返回解压缩对象，用于解压缩不能立即适合内存的数据流。</span></p><p><span class="yiyi-st" id="yiyi-93"><em>wbits</em>参数控制历史缓冲区的大小（或“窗口大小”），以及预期的报头和尾部格式。</span><span class="yiyi-st" id="yiyi-94">它与为decompress()描述的<a class="reference external" href="#decompress-wbits">具有相同的含义。</a></span></p><p><span class="yiyi-st" id="yiyi-95"><em>zdict</em>参数指定预定义的压缩字典。</span><span class="yiyi-st" id="yiyi-96">如果提供，这必须是与产生要解压缩的数据的压缩器所使用的字典相同的字典。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-97">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-98">If <em>zdict</em> is a mutable object (such as a <a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>), you must not modify its contents between the call to <a class="reference internal" href="#zlib.decompressobj" title="zlib.decompressobj"><code class="xref py py-func docutils literal"><span class="pre">decompressobj()</span></code></a> and the first call to the decompressor’s <code class="docutils literal"><span class="pre">decompress()</span></code> method.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-99"><span class="versionmodified">在版本3.3中已更改：</span>添加了<em>zdict</em>参数。</span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-100">压缩对象支持以下方法：</span></p><dl class="method"><dt id="zlib.Compress.compress"><span class="yiyi-st" id="yiyi-101"> <code class="descclassname">Compress.</code><code class="descname">compress</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-102">压缩<em>数据</em>，返回包含<em>数据</em>中至少部分数据的压缩数据的字节对象。</span><span class="yiyi-st" id="yiyi-103">此数据应连接到之前对<a class="reference internal" href="#zlib.compress" title="zlib.compress"><code class="xref py py-meth docutils literal"><span class="pre">compress()</span></code></a>方法的任何调用产生的输出。</span><span class="yiyi-st" id="yiyi-104">一些输入可以保持在内部缓冲器中以供稍后处理。</span></p></dd></dl><dl class="method"><dt id="zlib.Compress.flush"><span class="yiyi-st" id="yiyi-105"> <code class="descclassname">Compress.</code><code class="descname">flush</code><span class="sig-paren">(</span><span class="optional">[</span><em>mode</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-106">将处理所有待处理的输入，并返回包含剩余压缩输出的字节对象。</span><span class="yiyi-st" id="yiyi-107">可以从常量<code class="xref py py-const docutils literal"><span class="pre">Z_SYNC_FLUSH</span></code>，<code class="xref py py-const docutils literal"><span class="pre">Z_FULL_FLUSH</span></code>或<code class="xref py py-const docutils literal"><span class="pre">Z_FINISH</span></code>中选择<em>模式</em>，默认为<code class="xref py py-const docutils literal"><span class="pre">Z_FINISH</span></code></span><span class="yiyi-st" id="yiyi-108"><code class="xref py py-const docutils literal"><span class="pre">Z_SYNC_FLUSH</span></code>和<code class="xref py py-const docutils literal"><span class="pre">Z_FULL_FLUSH</span></code>允许通过数据测试进一步压缩，而<code class="xref py py-const docutils literal"><span class="pre">Z_FINISH</span></code>完成压缩流并防止压缩任何更多数据。</span><span class="yiyi-st" id="yiyi-109">在使用<em>模式</em>设置为<code class="xref py py-const docutils literal"><span class="pre">Z_FINISH</span></code>调用<a class="reference internal" href="#zlib.Compress.flush" title="zlib.Compress.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a>之后，无法再次调用<a class="reference internal" href="#zlib.compress" title="zlib.compress"><code class="xref py py-meth docutils literal"><span class="pre">compress()</span></code></a></span></p></dd></dl><dl class="method"><dt id="zlib.Compress.copy"><span class="yiyi-st" id="yiyi-110"> <code class="descclassname">Compress.</code><code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">返回压缩对象的副本。</span><span class="yiyi-st" id="yiyi-112">这可以用于有效地压缩共享公共初始前缀的一组数据。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-113">解压缩对象支持以下方法和属性：</span></p><dl class="attribute"><dt id="zlib.Decompress.unused_data"><span class="yiyi-st" id="yiyi-114"> <code class="descclassname">Decompress.</code><code class="descname">unused_data</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-115">包含超过压缩数据末尾的任何字节的字节对象。</span><span class="yiyi-st" id="yiyi-116">也就是说，这保持<code class="docutils literal"><span class="pre">b""</span></code>，直到包含压缩数据的最后一个字节可用。</span><span class="yiyi-st" id="yiyi-117">如果整个字节表明包含压缩数据，这是<code class="docutils literal"><span class="pre">b""</span></code>，一个空字节对象。</span></p></dd></dl><dl class="attribute"><dt id="zlib.Decompress.unconsumed_tail"><span class="yiyi-st" id="yiyi-118"> <code class="descclassname">Decompress.</code><code class="descname">unconsumed_tail</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-119">包含上一个<a class="reference internal" href="#zlib.decompress" title="zlib.decompress"><code class="xref py py-meth docutils literal"><span class="pre">decompress()</span></code></a>调用未占用的任何数据的字节对象，因为它超出了未压缩数据缓冲区的限制。</span><span class="yiyi-st" id="yiyi-120">这个数据还没有被zlib机器看到，因此你必须将它（可能还有更多的数据连接到它）返回到随后的<a class="reference internal" href="#zlib.decompress" title="zlib.decompress"><code class="xref py py-meth docutils literal"><span class="pre">decompress()</span></code></a>方法调用，以获得正确的输出。</span></p></dd></dl><dl class="attribute"><dt id="zlib.Decompress.eof"><span class="yiyi-st" id="yiyi-121"> <code class="descclassname">Decompress.</code><code class="descname">eof</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-122">指示是否已达到压缩数据流结束的布尔值。</span></p><p><span class="yiyi-st" id="yiyi-123">这使得可以区分正确形成的压缩流和不完全或截断的压缩流。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-124"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="zlib.Decompress.decompress"><span class="yiyi-st" id="yiyi-125"> <code class="descclassname">Decompress.</code><code class="descname">decompress</code><span class="sig-paren">(</span><em>data</em><span class="optional">[</span>, <em>max_length</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-126">解压缩<em>数据</em>，返回包含对应于<em>string</em>中至少部分数据的未压缩数据的字节对象。</span><span class="yiyi-st" id="yiyi-127">此数据应与由<a class="reference internal" href="#zlib.decompress" title="zlib.decompress"><code class="xref py py-meth docutils literal"><span class="pre">decompress()</span></code></a>方法的任何先前调用产生的输出连接。</span><span class="yiyi-st" id="yiyi-128">一些输入数据可以保存在内部缓冲器中以供稍后处理。</span></p><p><span class="yiyi-st" id="yiyi-129">如果可选参数<em>max_length</em>不为零，则返回值将不再长于<em>max_length</em>。</span><span class="yiyi-st" id="yiyi-130">这可能意味着不是所有的压缩输入都可以被处理；并且未消费的数据将被存储在属性<a class="reference internal" href="#zlib.Decompress.unconsumed_tail" title="zlib.Decompress.unconsumed_tail"><code class="xref py py-attr docutils literal"><span class="pre">unconsumed_tail</span></code></a>中。</span><span class="yiyi-st" id="yiyi-131">如果解压缩要继续，则此字节必须传递到<a class="reference internal" href="#zlib.decompress" title="zlib.decompress"><code class="xref py py-meth docutils literal"><span class="pre">decompress()</span></code></a>的后续调用。</span><span class="yiyi-st" id="yiyi-132">如果未提供<em>max_length</em>，则整个输入被解压缩，并且<a class="reference internal" href="#zlib.Decompress.unconsumed_tail" title="zlib.Decompress.unconsumed_tail"><code class="xref py py-attr docutils literal"><span class="pre">unconsumed_tail</span></code></a>为空。</span></p></dd></dl><dl class="method"><dt id="zlib.Decompress.flush"><span class="yiyi-st" id="yiyi-133"> <code class="descclassname">Decompress.</code><code class="descname">flush</code><span class="sig-paren">(</span><span class="optional">[</span><em>length</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-134">将处理所有待处理的输入，并返回包含剩余未压缩输出的字节对象。</span><span class="yiyi-st" id="yiyi-135">调用<a class="reference internal" href="#zlib.Decompress.flush" title="zlib.Decompress.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a>后，无法再次调用<a class="reference internal" href="#zlib.decompress" title="zlib.decompress"><code class="xref py py-meth docutils literal"><span class="pre">decompress()</span></code></a>方法；唯一真实的动作是删除对象。</span></p><p><span class="yiyi-st" id="yiyi-136">可选参数<em>length</em>设置输出缓冲区的初始大小。</span></p></dd></dl><dl class="method"><dt id="zlib.Decompress.copy"><span class="yiyi-st" id="yiyi-137"> <code class="descclassname">Decompress.</code><code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-138">返回解压缩对象的副本。</span><span class="yiyi-st" id="yiyi-139">这可以用于保存解压缩器在数据流中途的状态，以便在未来点加速随机搜索到流中。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-140">有关正在使用的zlib库版本的信息可通过以下常量获得：</span></p><dl class="data"><dt id="zlib.ZLIB_VERSION"><span class="yiyi-st" id="yiyi-141"> <code class="descclassname">zlib.</code><code class="descname">ZLIB_VERSION</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-142">用于构建模块的zlib库的版本字符串。</span><span class="yiyi-st" id="yiyi-143">这可能不同于在运行时实际使用的zlib库，它可作为<a class="reference internal" href="#zlib.ZLIB_RUNTIME_VERSION" title="zlib.ZLIB_RUNTIME_VERSION"><code class="xref py py-const docutils literal"><span class="pre">ZLIB_RUNTIME_VERSION</span></code></a>提供。</span></p></dd></dl><dl class="data"><dt id="zlib.ZLIB_RUNTIME_VERSION"><span class="yiyi-st" id="yiyi-144"> <code class="descclassname">zlib.</code><code class="descname">ZLIB_RUNTIME_VERSION</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-145">由解释器实际加载的zlib库的版本字符串。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-146"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-147">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-148">模块<a class="reference internal" href="gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal"><span class="pre">gzip</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-149">读取和写入<strong class="program">gzip</strong> -format文件。</span></dd><dt><span class="yiyi-st" id="yiyi-150"><a class="reference external" href="http://www.zlib.net">http://www.zlib.net</a></span></dt><dd><span class="yiyi-st" id="yiyi-151">zlib库主页。</span></dd><dt><span class="yiyi-st" id="yiyi-152"><a class="reference external" href="http://www.zlib.net/manual.html">http://www.zlib.net/manual.html</a></span></dt><dd><span class="yiyi-st" id="yiyi-153">zlib手册解释了库的许多函数的语义和用法。</span></dd></dl></div></div></div>