<div class="body" role="main"><div class="section" id="module-py_compile"><h1><span class="yiyi-st" id="yiyi-10">32.10. <a class="reference internal" href="#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal"><span class="pre">py_compile</span></code></a>  - 编译Python源文件</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/py_compile.py">Lib / py_compile.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal"><span class="pre">py_compile</span></code></a>模块提供了从源文件生成字节代码文件的功能，以及当模块源文件作为脚本调用时使用的另一个函数。</span></p><p><span class="yiyi-st" id="yiyi-13">虽然不常需要，但是在安装用于共享使用的模块时，此功能可能很有用，尤其是如果某些用户可能没有在包含源代码的目录中写入字节代码缓存文件的权限。</span></p><dl class="exception"><dt id="py_compile.PyCompileError"><span class="yiyi-st" id="yiyi-14"> <em class="property">exception </em><code class="descclassname">py_compile.</code><code class="descname">PyCompileError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-15">尝试编译文件时发生错误时抛出异常。</span></p></dd></dl><dl class="function"><dt id="py_compile.compile"><span class="yiyi-st" id="yiyi-16"> <code class="descclassname">py_compile.</code><code class="descname">compile</code><span class="sig-paren">(</span><em>file</em>, <em>cfile=None</em>, <em>dfile=None</em>, <em>doraise=False</em>, <em>optimize=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-17">将源文件编译为字节代码并写出字节代码高速缓存文件。</span><span class="yiyi-st" id="yiyi-18">源代码从名为<em>文件</em>的文件加载。</span><span class="yiyi-st" id="yiyi-19">The byte-code is written to <em>cfile</em>, which defaults to the <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>/<span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> path, ending in <code class="docutils literal"><span class="pre">.pyc</span></code>. </span><span class="yiyi-st" id="yiyi-20">例如，如果<em>文件</em>是<code class="docutils literal"><span class="pre">/foo/bar/baz.py</span></code> <em>cfile</em>，则默认为<code class="docutils literal"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>。</span><span class="yiyi-st" id="yiyi-21">如果指定<em>dfile</em>，则它将用作错误消息中源文件的名称，而不是<em>文件</em>。</span><span class="yiyi-st" id="yiyi-22">如果<em>doraise</em>为真，则在编译<em>文件</em>时遇到错误时会引发<a class="reference internal" href="#py_compile.PyCompileError" title="py_compile.PyCompileError"><code class="xref py py-exc docutils literal"><span class="pre">PyCompileError</span></code></a>。</span><span class="yiyi-st" id="yiyi-23">如果<em>doraise</em>为false（默认值），则将错误字符串写入<code class="docutils literal"><span class="pre">sys.stderr</span></code>，但不会引发异常。</span><span class="yiyi-st" id="yiyi-24">此函数返回字节编译文件的路径，即</span><span class="yiyi-st" id="yiyi-25">不管使用什么<em>cfile</em>值。</span></p><p><span class="yiyi-st" id="yiyi-26">如果<em>cfile</em>（显式指定或计算）的路径是符号链接或非常规文件，则会引发<a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a>。</span><span class="yiyi-st" id="yiyi-27">这是作为一个警告，如果允许导入将这些路径转换为常规文件，如果允许将字节编译文件写入这些路径。</span><span class="yiyi-st" id="yiyi-28">这是导入的副作用，使用文件重命名将最终的字节编译文件放置到位，以防止并发文件写入问题。</span></p><p><span class="yiyi-st" id="yiyi-29"><em>optimize</em>控制优化级别，并传递到内建<a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a>函数。</span><span class="yiyi-st" id="yiyi-30">默认值<code class="docutils literal"><span class="pre">-1</span></code>选择当前解释器的优化级别。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-31"><span class="versionmodified">在版本3.2中已更改：</span>将<em>cfile</em>的默认值更改为<span class="target" id="index-3"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>。</span><span class="yiyi-st" id="yiyi-32">之前的默认值为<em>文件</em> + <code class="docutils literal"><span class="pre">'c'</span></code>（如果启用优化，则为<code class="docutils literal"><span class="pre">'o'</span></code>）。</span><span class="yiyi-st" id="yiyi-33">还添加了<em>optimize</em>参数。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-34"><span class="versionmodified">在版本3.4中更改：</span>更改了代码以使用<a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal"><span class="pre">importlib</span></code></a>进行字节代码缓存文件写入。</span><span class="yiyi-st" id="yiyi-35">这意味着文件创建/写入语义现在匹配<a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal"><span class="pre">importlib</span></code></a>所做的，例如。</span><span class="yiyi-st" id="yiyi-36">权限，写和移动语义等。</span><span class="yiyi-st" id="yiyi-37">还添加了以下警告：如果<em>cfile</em>是符号链接或非常规文件，则会引发<a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a>。</span></p></div></dd></dl><dl class="function"><dt id="py_compile.main"><span class="yiyi-st" id="yiyi-38"> <code class="descclassname">py_compile.</code><code class="descname">main</code><span class="sig-paren">(</span><em>args=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-39">编译几个源文件。</span><span class="yiyi-st" id="yiyi-40">在<em>args</em>中命名的文件（或在命令行上，如果<em>args</em>是<code class="docutils literal"><span class="pre">None</span></code>）被编译，并且生成的字节代码缓存在正常方式。</span><span class="yiyi-st" id="yiyi-41">此函数不搜索目录结构以查找源文件；它只编译明确命名的文件。</span><span class="yiyi-st" id="yiyi-42">如果<code class="docutils literal"><span class="pre">'-'</span></code>是args中的唯一参数，则文件列表取自标准输入。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-43"><span class="versionmodified">在版本3.2中更改：</span>添加对<code class="docutils literal"><span class="pre">'-'</span></code>的支持。</span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-44">当此模块作为脚本运行时，<a class="reference internal" href="#py_compile.main" title="py_compile.main"><code class="xref py py-func docutils literal"><span class="pre">main()</span></code></a>用于编译命令行中命名的所有文件。</span><span class="yiyi-st" id="yiyi-45">如果其中一个文件无法编译，退出状态为非零。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-46">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-47">模块<a class="reference internal" href="compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code class="xref py py-mod docutils literal"><span class="pre">compileall</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-48">用于编译目录树中所有Python源文件的实用程序。</span></dd></dl></div></div></div>