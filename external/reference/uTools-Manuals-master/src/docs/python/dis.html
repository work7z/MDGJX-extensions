<div class="body" role="main"><div class="section" id="module-dis"><h1><span class="yiyi-st" id="yiyi-10">32.12. <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal"><span class="pre">dis</span></code></a>  -  Python字节码的反汇编程序</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/dis.py">Lib/dis.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal"><span class="pre">dis</span></code></a>模块支持通过反汇编分析CPython <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>。</span><span class="yiyi-st" id="yiyi-13">该模块作为输入的CPython字节码在文件<code class="file docutils literal"><span class="pre">Include/opcode.h</span></code>中定义，由编译器和解释器使用。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-14"><strong>CPython实现细节：</strong>字节码是CPython解释器的实现细节。</span><span class="yiyi-st" id="yiyi-15">不保证字节码不会在Python版本之间添加，删除或更改。</span><span class="yiyi-st" id="yiyi-16">使用此模块不应被视为在Python VM或Python版本上工作。</span></p></div><p><span class="yiyi-st" id="yiyi-17">示例：给定函数<code class="xref py py-func docutils literal"><span class="pre">myfunc()</span></code>：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-18">以下命令可用于显示<code class="xref py py-func docutils literal"><span class="pre">myfunc()</span></code>的反汇编：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="go">  2           0 LOAD_GLOBAL              0 (len)</span>
<span class="go">              3 LOAD_FAST                0 (alist)</span>
<span class="go">              6 CALL_FUNCTION            1</span>
<span class="go">              9 RETURN_VALUE</span>
</code></pre><p><span class="yiyi-st" id="yiyi-19">（“2”是行号）。</span></p><div class="section" id="bytecode-analysis"><h2><span class="yiyi-st" id="yiyi-20">32.12.1. </span><span class="yiyi-st" id="yiyi-21">字节码分析</span></h2><div class="versionadded"><p><span class="yiyi-st" id="yiyi-22"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div><p><span class="yiyi-st" id="yiyi-23">字节码分析API允许将Python代码片段封装在<a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal"><span class="pre">Bytecode</span></code></a>对象中，从而可以轻松访问已编译代码的详细信息。</span></p><dl class="class"><dt id="dis.Bytecode"><span class="yiyi-st" id="yiyi-24"> <em class="property">class </em><code class="descclassname">dis.</code><code class="descname">Bytecode</code><span class="sig-paren">(</span><em>x</em>, <em>*</em>, <em>first_line=None</em>, <em>current_offset=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-25">分析对应于函数，生成器，方法，源代码字符串或代码对象（由<a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a>返回）的字节码。</span></p><p><span class="yiyi-st" id="yiyi-26">这是围绕下面列出的许多函数的一个便捷包装，最着名的是<a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code class="xref py py-func docutils literal"><span class="pre">get_instructions()</span></code></a>，因为对<a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal"><span class="pre">Bytecode</span></code></a>实例的迭代产生的字节码操作与<a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal"><span class="pre">Instruction</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-27">如果<em>first_line</em>不是None，它表示应该为反汇编代码中的第一个源行报告的行号。</span><span class="yiyi-st" id="yiyi-28">否则，源行信息（如果有的话）直接取自已拆解的代码对象。</span></p><p><span class="yiyi-st" id="yiyi-29">如果<em>current_offset</em>不为None，则它指的是在反汇编代码中的指令偏移量。</span><span class="yiyi-st" id="yiyi-30">设置这意味着<a class="reference internal" href="#dis.Bytecode.dis" title="dis.Bytecode.dis"><code class="xref py py-meth docutils literal"><span class="pre">dis()</span></code></a>将针对指定的操作码显示“当前指令”标记。</span></p><dl class="classmethod"><dt id="dis.Bytecode.from_traceback"><span class="yiyi-st" id="yiyi-31"> <em class="property">classmethod </em><code class="descname">from_traceback</code><span class="sig-paren">(</span><em>tb</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-32">从给定traceback构造<a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal"><span class="pre">Bytecode</span></code></a>实例，将<em>current_offset</em>设置为负责异常的指令。</span></p></dd></dl><dl class="data"><dt id="dis.Bytecode.codeobj"><span class="yiyi-st" id="yiyi-33"> <code class="descname">codeobj</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-34">编译的代码对象。</span></p></dd></dl><dl class="data"><dt id="dis.Bytecode.first_line"><span class="yiyi-st" id="yiyi-35"> <code class="descname">first_line</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-36">代码对象的第一个源代码行（如果可用）</span></p></dd></dl><dl class="method"><dt id="dis.Bytecode.dis"><span class="yiyi-st" id="yiyi-37"> <code class="descname">dis</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-38">返回字节码操作的格式化视图（与<a class="reference internal" href="#dis.dis" title="dis.dis"><code class="xref py py-func docutils literal"><span class="pre">dis.dis()</span></code></a>打印的相同，但返回为多行字符串）。</span></p></dd></dl><dl class="method"><dt id="dis.Bytecode.info"><span class="yiyi-st" id="yiyi-39"> <code class="descname">info</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-40">返回格式化的多行字符串，其中包含有关代码对象的详细信息，例如<a class="reference internal" href="#dis.code_info" title="dis.code_info"><code class="xref py py-func docutils literal"><span class="pre">code_info()</span></code></a>。</span></p></dd></dl></dd></dl><p><span class="yiyi-st" id="yiyi-41">例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bytecode</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="n">Bytecode</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">bytecode</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">opname</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">LOAD_GLOBAL</span>
<span class="go">LOAD_FAST</span>
<span class="go">CALL_FUNCTION</span>
<span class="go">RETURN_VALUE</span>
</code></pre></div><div class="section" id="analysis-functions"><h2><span class="yiyi-st" id="yiyi-42">32.12.2. </span><span class="yiyi-st" id="yiyi-43">分析函数</span></h2><p><span class="yiyi-st" id="yiyi-44"><a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal"><span class="pre">dis</span></code></a>模块还定义了将输入直接转换为所需输出的以下分析函数。</span><span class="yiyi-st" id="yiyi-45">如果只执行单个操作，它们可能很有用，因此中间分析对象不起作用：</span></p><dl class="function"><dt id="dis.code_info"><span class="yiyi-st" id="yiyi-46"> <code class="descclassname">dis.</code><code class="descname">code_info</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-47">返回带有提供的函数，生成器，方法，源代码字符串或代码对象的详细代码对象信息的格式化多行字符串。</span></p><p><span class="yiyi-st" id="yiyi-48">注意，代码信息字符串的确切内容高度依赖于实现，并且它们可以在Python VM或Python版本中任意改变。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-49"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="dis.show_code"><span class="yiyi-st" id="yiyi-50"> <code class="descclassname">dis.</code><code class="descname">show_code</code><span class="sig-paren">(</span><em>x</em>, <em>*</em>, <em>file=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-51">将<em>文件</em>（或<code class="docutils literal"><span class="pre">sys.stdout</span></code>）中提供的函数，方法，源代码字符串或代码对象的详细代码对象信息打印到<em>文件指定）。</em></span></p><p><span class="yiyi-st" id="yiyi-52">这是<code class="docutils literal"><span class="pre">打印（code_info（x），</span> <span class="pre">file = file）</span></code>的方便缩写，用于在解释器提示符处进行交互式探索。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-53"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-54"><span class="versionmodified">在版本3.4中更改：</span>添加了<em>文件</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="dis.dis"><span class="yiyi-st" id="yiyi-55"> <code class="descclassname">dis.</code><code class="descname">dis</code><span class="sig-paren">(</span><em>x=None</em>, <em>*</em>, <em>file=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-56">拆分<em>x</em>对象。</span><span class="yiyi-st" id="yiyi-57"><em>x</em>可以表示模块，类，方法，函数，生成器，代码对象，源代码字符串或原始字节码的字节序列。</span><span class="yiyi-st" id="yiyi-58">对于模块，它会拆散所有函数。</span><span class="yiyi-st" id="yiyi-59">对于一个类，它反汇编所有的方法（包括类和静态方法）。</span><span class="yiyi-st" id="yiyi-60">对于代码对象或原始字节码序列，每个字节码指令打印一行。</span><span class="yiyi-st" id="yiyi-61">在反汇编之前，字符串首先用<a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a>内建函数编译为代码对象。</span><span class="yiyi-st" id="yiyi-62">如果没有提供对象，则此函数将反汇编最后一个回溯。</span></p><p><span class="yiyi-st" id="yiyi-63">反汇编作为文本写入提供的<em>文件</em>参数（如果提供）和<code class="docutils literal"><span class="pre">sys.stdout</span></code>，否则。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-64"><span class="versionmodified">在版本3.4中更改：</span>添加了<em>文件</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="dis.distb"><span class="yiyi-st" id="yiyi-65"> <code class="descclassname">dis.</code><code class="descname">distb</code><span class="sig-paren">(</span><em>tb=None</em>, <em>*</em>, <em>file=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-66">如果没有通过，则使用最后一个traceback来反汇编回栈顶层函数。</span><span class="yiyi-st" id="yiyi-67">指示引起异常的指令。</span></p><p><span class="yiyi-st" id="yiyi-68">反汇编作为文本写入提供的<em>文件</em>参数（如果提供）和<code class="docutils literal"><span class="pre">sys.stdout</span></code>，否则。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-69"><span class="versionmodified">在版本3.4中更改：</span>添加了<em>文件</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="dis.disassemble"><span class="yiyi-st" id="yiyi-70"> <code class="descclassname">dis.</code><code class="descname">disassemble</code><span class="sig-paren">(</span><em>code</em>, <em>lasti=-1</em>, <em>*</em>, <em>file=None</em><span class="sig-paren">)</span></span></dt><dt id="dis.disco"><span class="yiyi-st" id="yiyi-71"> <code class="descclassname">dis.</code><code class="descname">disco</code><span class="sig-paren">(</span><em>code</em>, <em>lasti=-1</em>, <em>*</em>, <em>file=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-72">拆分代码对象，如果提供<em>lasti</em>，则指示最后一条指令。</span><span class="yiyi-st" id="yiyi-73">输出分为以下列：</span></p><ol class="arabic simple"><li><span class="yiyi-st" id="yiyi-74">行号，用于每行的第一条指令</span></li><li><span class="yiyi-st" id="yiyi-75">指示为<code class="docutils literal"><span class="pre">--&gt;</span></code>的当前指令，</span></li><li><span class="yiyi-st" id="yiyi-76">由<code class="docutils literal"><span class="pre">&gt;&gt;</span></code>指示的标记指令，</span></li><li><span class="yiyi-st" id="yiyi-77">指令的地址，</span></li><li><span class="yiyi-st" id="yiyi-78">操作代码名称，</span></li><li><span class="yiyi-st" id="yiyi-79">操作参数和</span></li><li><span class="yiyi-st" id="yiyi-80">括号中的参数的解释。</span></li></ol><p><span class="yiyi-st" id="yiyi-81">参数解释识别局部和全局变量名，常量值，分支目标和比较运算符。</span></p><p><span class="yiyi-st" id="yiyi-82">反汇编作为文本写入提供的<em>文件</em>参数（如果提供）和<code class="docutils literal"><span class="pre">sys.stdout</span></code>，否则。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-83"><span class="versionmodified">在版本3.4中更改：</span>添加了<em>文件</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="dis.get_instructions"><span class="yiyi-st" id="yiyi-84"> <code class="descclassname">dis.</code><code class="descname">get_instructions</code><span class="sig-paren">(</span><em>x</em>, <em>*</em>, <em>first_line=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-85">对提供的函数，方法，源代码字符串或代码对象中的指令返回一个迭代器。</span></p><p><span class="yiyi-st" id="yiyi-86">迭代器生成一系列<a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal"><span class="pre">Instruction</span></code></a>命名元组，提供所提供代码中每个操作的详细信息。</span></p><p><span class="yiyi-st" id="yiyi-87">如果<em>first_line</em>不是None，它表示应该为反汇编代码中的第一个源行报告的行号。</span><span class="yiyi-st" id="yiyi-88">否则，源行信息（如果有的话）直接取自已拆解的代码对象。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-89"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="dis.findlinestarts"><span class="yiyi-st" id="yiyi-90"> <code class="descclassname">dis.</code><code class="descname">findlinestarts</code><span class="sig-paren">(</span><em>code</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-91">这个生成器函数使用代码对象<em>代码</em>的<code class="docutils literal"><span class="pre">co_firstlineno</span></code>和<code class="docutils literal"><span class="pre">co_lnotab</span></code>属性来找到源代码中行开头的偏移。</span><span class="yiyi-st" id="yiyi-92">它们生成为<code class="docutils literal"><span class="pre">（偏移，</span> <span class="pre">lineno）</span></code>对。</span></p></dd></dl><dl class="function"><dt id="dis.findlabels"><span class="yiyi-st" id="yiyi-93"> <code class="descclassname">dis.</code><code class="descname">findlabels</code><span class="sig-paren">(</span><em>code</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">检测作为跳转目标的代码对象<em>代码</em>中的所有偏移量，并返回这些偏移量的列表。</span></p></dd></dl><dl class="function"><dt id="dis.stack_effect"><span class="yiyi-st" id="yiyi-95"> <code class="descclassname">dis.</code><code class="descname">stack_effect</code><span class="sig-paren">(</span><em>opcode</em><span class="optional">[</span>, <em>oparg</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-96">计算<em>opcode</em>与参数<em>oparg</em>的堆栈效果。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-97"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="python-bytecode-instructions"><h2><span class="yiyi-st" id="yiyi-98">32.12.3. </span><span class="yiyi-st" id="yiyi-99">Python字节码指令</span></h2><p><span class="yiyi-st" id="yiyi-100"><a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code class="xref py py-func docutils literal"><span class="pre">get_instructions()</span></code></a>函数和<a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal"><span class="pre">Bytecode</span></code></a>类提供了字节码指令作为<a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal"><span class="pre">Instruction</span></code></a>实例的详细信息：</span></p><dl class="class"><dt id="dis.Instruction"><span class="yiyi-st" id="yiyi-101"> <em class="property">class </em><code class="descclassname">dis.</code><code class="descname">Instruction</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-102">字节码操作的详细信息</span></p><dl class="data"><dt id="dis.Instruction.opcode"><span class="yiyi-st" id="yiyi-103"> <code class="descname">opcode</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">操作的数字代码，对应于下面列出的操作码值和<a class="reference internal" href="#opcode-collections"><span>Opcode collections</span></a>中的字节码值。</span></p></dd></dl><dl class="data"><dt id="dis.Instruction.opname"><span class="yiyi-st" id="yiyi-105"> <code class="descname">opname</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-106">操作的人类可读名称</span></p></dd></dl><dl class="data"><dt id="dis.Instruction.arg"><span class="yiyi-st" id="yiyi-107"> <code class="descname">arg</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-108">操作的数字参数（如果有），否则为无</span></p></dd></dl><dl class="data"><dt id="dis.Instruction.argval"><span class="yiyi-st" id="yiyi-109"> <code class="descname">argval</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-110">解析的arg值（如果已知），否则与arg相同</span></p></dd></dl><dl class="data"><dt id="dis.Instruction.argrepr"><span class="yiyi-st" id="yiyi-111"> <code class="descname">argrepr</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-112">操作参数的可读描述</span></p></dd></dl><dl class="data"><dt id="dis.Instruction.offset"><span class="yiyi-st" id="yiyi-113"> <code class="descname">offset</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-114">在字节码序列内的操作的开始索引</span></p></dd></dl><dl class="data"><dt id="dis.Instruction.starts_line"><span class="yiyi-st" id="yiyi-115"> <code class="descname">starts_line</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-116">由此操作码开始的行（如果有），否则为无</span></p></dd></dl><dl class="data"><dt id="dis.Instruction.is_jump_target"><span class="yiyi-st" id="yiyi-117"> <code class="descname">is_jump_target</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-118"><code class="docutils literal"><span class="pre">True</span></code>如果其他代码跳到此处，否则<code class="docutils literal"><span class="pre">False</span></code></span></p></dd></dl><div class="versionadded"><p><span class="yiyi-st" id="yiyi-119"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-120">Python编译器当前生成以下字节码指令。</span></p><p><span class="yiyi-st" id="yiyi-121"><strong>一般指令</strong></span></p><dl class="opcode"><dt id="opcode-NOP"><span class="yiyi-st" id="yiyi-122"> <code class="descname">NOP</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-123">不做任何代码。</span><span class="yiyi-st" id="yiyi-124">由字节码优化器用作占位符。</span></p></dd></dl><dl class="opcode"><dt id="opcode-POP_TOP"><span class="yiyi-st" id="yiyi-125"> <code class="descname">POP_TOP</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-126">删除顶部（TOS）项。</span></p></dd></dl><dl class="opcode"><dt id="opcode-ROT_TWO"><span class="yiyi-st" id="yiyi-127"> <code class="descname">ROT_TWO</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-128">交换两个最顶层的堆栈项。</span></p></dd></dl><dl class="opcode"><dt id="opcode-ROT_THREE"><span class="yiyi-st" id="yiyi-129"> <code class="descname">ROT_THREE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-130">将第二和第三堆叠物品提升一个位置，将顶部向下移动到位置三。</span></p></dd></dl><dl class="opcode"><dt id="opcode-DUP_TOP"><span class="yiyi-st" id="yiyi-131"> <code class="descname">DUP_TOP</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-132">复制堆栈顶部的引用。</span></p></dd></dl><dl class="opcode"><dt id="opcode-DUP_TOP_TWO"><span class="yiyi-st" id="yiyi-133"> <code class="descname">DUP_TOP_TWO</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-134">复制堆栈顶部的两个引用，使它们按相同的顺序。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-135"><strong>一元操作</strong></span></p><p><span class="yiyi-st" id="yiyi-136">一元操作占用堆栈的顶部，应用操作，并将结果推回堆栈。</span></p><dl class="opcode"><dt id="opcode-UNARY_POSITIVE"><span class="yiyi-st" id="yiyi-137"> <code class="descname">UNARY_POSITIVE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-138">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">+ TOS</span></code>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-UNARY_NEGATIVE"><span class="yiyi-st" id="yiyi-139"> <code class="descname">UNARY_NEGATIVE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-140">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">-TOS</span></code>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-UNARY_NOT"><span class="yiyi-st" id="yiyi-141"> <code class="descname">UNARY_NOT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-142">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">而不是</span> <span class="pre">TOS</span></code>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-UNARY_INVERT"><span class="yiyi-st" id="yiyi-143"> <code class="descname">UNARY_INVERT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-144">实现<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">〜TOS</span></code>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-GET_ITER"><span class="yiyi-st" id="yiyi-145"> <code class="descname">GET_ITER</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-146">实现<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">iter（TOS）</span></code>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-GET_YIELD_FROM_ITER"><span class="yiyi-st" id="yiyi-147"> <code class="descname">GET_YIELD_FROM_ITER</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-148">如果<code class="docutils literal"><span class="pre">TOS</span></code>是<a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a>或<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>对象，则保持原样。</span><span class="yiyi-st" id="yiyi-149">否则，实现<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">iter（TOS）</span></code>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-150"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-151"><strong>二进制操作</strong></span></p><p><span class="yiyi-st" id="yiyi-152">二进制操作从堆栈中删除堆栈顶部（TOS）和第二个最顶层堆栈项目（TOS1）。</span><span class="yiyi-st" id="yiyi-153">他们执行操作，并将结果放回堆栈。</span></p><dl class="opcode"><dt id="opcode-BINARY_POWER"><span class="yiyi-st" id="yiyi-154"> <code class="descname">BINARY_POWER</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-155">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">**</span> <span class="pre">TOS</span> </code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_MULTIPLY"><span class="yiyi-st" id="yiyi-156"> <code class="descname">BINARY_MULTIPLY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-157">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">*</span> <span class="pre">TOS</span> </code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_MATRIX_MULTIPLY"><span class="yiyi-st" id="yiyi-158"> <code class="descname">BINARY_MATRIX_MULTIPLY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-159">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">@</span> <span class="pre">TOS</span> </code></span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-160"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="opcode"><dt id="opcode-BINARY_FLOOR_DIVIDE"><span class="yiyi-st" id="yiyi-161"> <code class="descname">BINARY_FLOOR_DIVIDE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-162">实现<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">//</span> <span class="pre">TOS</span> </code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_TRUE_DIVIDE"><span class="yiyi-st" id="yiyi-163"> <code class="descname">BINARY_TRUE_DIVIDE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-164">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">/</span> <span class="pre">TOS</span> </code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_MODULO"><span class="yiyi-st" id="yiyi-165"> <code class="descname">BINARY_MODULO</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-166">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">％</span> <span class="pre">TOS</span> </code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_ADD"><span class="yiyi-st" id="yiyi-167"> <code class="descname">BINARY_ADD</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-168">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">+</span> <span class="pre">TOS</span> </code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_SUBTRACT"><span class="yiyi-st" id="yiyi-169"> <code class="descname">BINARY_SUBTRACT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-170">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre"> - </span> <span class="pre">TOS</span> </code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_SUBSCR"><span class="yiyi-st" id="yiyi-171"> <code class="descname">BINARY_SUBSCR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-172">实现<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1 [TOS]</span></code>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_LSHIFT"><span class="yiyi-st" id="yiyi-173"> <code class="descname">BINARY_LSHIFT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-174">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre"></span> <span class="pre">TOS</span>  t0 &gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_RSHIFT"><span class="yiyi-st" id="yiyi-175"> <code class="descname">BINARY_RSHIFT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-176">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">&gt;＆gt；</span> <span class="pre">TOS</span>  t0 &gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_AND"><span class="yiyi-st" id="yiyi-177"> <code class="descname">BINARY_AND</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-178">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">＆amp；</span> <span class="pre">TOS</span> </code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_XOR"><span class="yiyi-st" id="yiyi-179"> <code class="descname">BINARY_XOR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-180">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">^</span> <span class="pre">TOS</span> </code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BINARY_OR"><span class="yiyi-st" id="yiyi-181"> <code class="descname">BINARY_OR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-182">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">|</span> <span class="pre">TOS</span> </code></span></p></dd></dl><p><span class="yiyi-st" id="yiyi-183"><strong>就地操作</strong></span></p><p><span class="yiyi-st" id="yiyi-184">就地操作类似于二进制操作，因为它们删除TOS和TOS1，并将结果推回堆栈，但操作是在TOS1支持它时就地完成的，并且生成的TOS可以是（但不是是原来的TOS1。</span></p><dl class="opcode"><dt id="opcode-INPLACE_POWER"><span class="yiyi-st" id="yiyi-185"> <code class="descname">INPLACE_POWER</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-186">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">**</span> <span class="pre">TOS</span> t0&gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_MULTIPLY"><span class="yiyi-st" id="yiyi-187"> <code class="descname">INPLACE_MULTIPLY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-188">立即实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">*</span> <span class="pre">TOS</span>  t0 &gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_MATRIX_MULTIPLY"><span class="yiyi-st" id="yiyi-189"> <code class="descname">INPLACE_MATRIX_MULTIPLY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-190">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">@</span> <span class="pre">TOS</span>  t0 &gt;。</code></span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-191"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_FLOOR_DIVIDE"><span class="yiyi-st" id="yiyi-192"> <code class="descname">INPLACE_FLOOR_DIVIDE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-193">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">//</span> <span class="pre">TOS</span> t0&gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_TRUE_DIVIDE"><span class="yiyi-st" id="yiyi-194"> <code class="descname">INPLACE_TRUE_DIVIDE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-195">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">/</span> <span class="pre">TOS</span>  t0 &gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_MODULO"><span class="yiyi-st" id="yiyi-196"> <code class="descname">INPLACE_MODULO</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-197">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">％</span> <span class="pre">TOS</span>  t0 &gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_ADD"><span class="yiyi-st" id="yiyi-198"> <code class="descname">INPLACE_ADD</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-199">立即实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">+</span> <span class="pre">TOS</span>  t0 &gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_SUBTRACT"><span class="yiyi-st" id="yiyi-200"> <code class="descname">INPLACE_SUBTRACT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-201">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre"> - </span> <span class="pre">TOS</span>  t0 &gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_LSHIFT"><span class="yiyi-st" id="yiyi-202"> <code class="descname">INPLACE_LSHIFT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-203">实现<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre"></span> <span class="pre">TOS</span> </code>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_RSHIFT"><span class="yiyi-st" id="yiyi-204"> <code class="descname">INPLACE_RSHIFT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-205">Implements in-place <code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">&gt;&gt;</span> <span class="pre">TOS</span></code>.</span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_AND"><span class="yiyi-st" id="yiyi-206"> <code class="descname">INPLACE_AND</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-207">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">＆amp；</span> <span class="pre">TOS</span> t0&gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_XOR"><span class="yiyi-st" id="yiyi-208"> <code class="descname">INPLACE_XOR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-209">立即实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">^</span> <span class="pre">TOS</span>  t0 &gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-INPLACE_OR"><span class="yiyi-st" id="yiyi-210"> <code class="descname">INPLACE_OR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-211">实施<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">|</span> <span class="pre">TOS</span>  t0 &gt;。</code></span></p></dd></dl><dl class="opcode"><dt id="opcode-STORE_SUBSCR"><span class="yiyi-st" id="yiyi-212"> <code class="descname">STORE_SUBSCR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-213">实现<code class="docutils literal"><span class="pre">TOS1[TOS]</span> <span class="pre">=</span> <span class="pre">TOS2</span></code>.</span></p></dd></dl><dl class="opcode"><dt id="opcode-DELETE_SUBSCR"><span class="yiyi-st" id="yiyi-214"> <code class="descname">DELETE_SUBSCR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-215">实现<code class="docutils literal"><span class="pre">del</span> <span class="pre">TOS1[TOS]</span></code>.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-216"><strong>协程操作码</strong></span></p><dl class="opcode"><dt id="opcode-GET_AWAITABLE"><span class="yiyi-st" id="yiyi-217"> <code class="descname">GET_AWAITABLE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-218">Implements <code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">get_awaitable(TOS)</span></code>, where <code class="docutils literal"><span class="pre">get_awaitable(o)</span></code> returns <code class="docutils literal"><span class="pre">o</span></code> if <code class="docutils literal"><span class="pre">o</span></code> is a coroutine object or a generator object with the CO_ITERABLE_COROUTINE flag, or resolves <code class="docutils literal"><span class="pre">o.__await__</span></code>.</span></p></dd></dl><dl class="opcode"><dt id="opcode-GET_AITER"><span class="yiyi-st" id="yiyi-219"> <code class="descname">GET_AITER</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-220">实现<code class="docutils literal"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">get_awaitable（TOS .__ aiter __()）</span></code>。</span><span class="yiyi-st" id="yiyi-221">有关<code class="docutils literal"><span class="pre">get_awaitable</span></code>的详细信息，请参阅<code class="docutils literal"><span class="pre">GET_AWAITABLE</span></code></span></p></dd></dl><dl class="opcode"><dt id="opcode-GET_ANEXT"><span class="yiyi-st" id="yiyi-222"> <code class="descname">GET_ANEXT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-223">实现<code class="docutils literal"><span class="pre">PUSH(get_awaitable(TOS.__anext__()))</span></code>。</span><span class="yiyi-st" id="yiyi-224">有关<code class="docutils literal"><span class="pre">get_awaitable</span></code>的详细信息，请参阅<code class="docutils literal"><span class="pre">GET_AWAITABLE</span></code></span></p></dd></dl><dl class="opcode"><dt id="opcode-BEFORE_ASYNC_WITH"><span class="yiyi-st" id="yiyi-225"> <code class="descname">BEFORE_ASYNC_WITH</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-226">从堆栈顶部的对象解析<code class="docutils literal"><span class="pre">__aenter__</span></code>和<code class="docutils literal"><span class="pre">__aexit__</span></code>。</span><span class="yiyi-st" id="yiyi-227">将<code class="docutils literal"><span class="pre">__aexit__</span></code>和<code class="docutils literal"><span class="pre">__aenter__()</span></code>的结果推送到堆栈。</span></p></dd></dl><dl class="opcode"><dt id="opcode-SETUP_ASYNC_WITH"><span class="yiyi-st" id="yiyi-228"> <code class="descname">SETUP_ASYNC_WITH</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-229">创建一个新的框架对象。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-230"><strong>其他操作码</strong></span></p><dl class="opcode"><dt id="opcode-PRINT_EXPR"><span class="yiyi-st" id="yiyi-231"> <code class="descname">PRINT_EXPR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-232">实现交互式模式的表达式语句。</span><span class="yiyi-st" id="yiyi-233">TOS从堆栈中删除并打印。</span><span class="yiyi-st" id="yiyi-234">在非交互模式下，使用<a class="reference internal" href="#opcode-POP_TOP"><code class="xref std std-opcode docutils literal"><span class="pre">POP_TOP</span></code></a>终止表达式语句。</span></p></dd></dl><dl class="opcode"><dt id="opcode-BREAK_LOOP"><span class="yiyi-st" id="yiyi-235"> <code class="descname">BREAK_LOOP</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-236">由于<a class="reference internal" href="../reference/simple_stmts.html#break"><code class="xref std std-keyword docutils literal"><span class="pre">break</span></code></a>语句而终止循环。</span></p></dd></dl><dl class="opcode"><dt id="opcode-CONTINUE_LOOP"><span class="yiyi-st" id="yiyi-237"> <code class="descname">CONTINUE_LOOP</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-238">由于<a class="reference internal" href="../reference/simple_stmts.html#continue"><code class="xref std std-keyword docutils literal"><span class="pre">continue</span></code></a>语句，继续循环。</span><span class="yiyi-st" id="yiyi-239"><em>target</em>是要跳转的地址（应为<a class="reference internal" href="#opcode-FOR_ITER"><code class="xref std std-opcode docutils literal"><span class="pre">FOR_ITER</span></code></a>指令）。</span></p></dd></dl><dl class="opcode"><dt id="opcode-SET_ADD"><span class="yiyi-st" id="yiyi-240"> <code class="descname">SET_ADD</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-241">调用<code class="docutils literal"><span class="pre">set.add（TOS1 [-i]，</span> <span class="pre">TOS）</span></code>。</span><span class="yiyi-st" id="yiyi-242">用于实现集推式。</span></p></dd></dl><dl class="opcode"><dt id="opcode-LIST_APPEND"><span class="yiyi-st" id="yiyi-243"> <code class="descname">LIST_APPEND</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-244">调用<code class="docutils literal"><span class="pre">list.append（TOS [-i]，</span> <span class="pre">TOS）</span></code>。</span><span class="yiyi-st" id="yiyi-245">用于实现列表推导式。</span></p></dd></dl><dl class="opcode"><dt id="opcode-MAP_ADD"><span class="yiyi-st" id="yiyi-246"> <code class="descname">MAP_ADD</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-247">调用<code class="docutils literal"><span class="pre">dict.setitem（TOS1 [-i]，</span> <span class="pre">TOS，</span> <span class="pre">TOS1）</span></code>。</span><span class="yiyi-st" id="yiyi-248">用于实现dict推导式。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-249">对于所有<a class="reference internal" href="#opcode-SET_ADD"><code class="xref std std-opcode docutils literal"><span class="pre">SET_ADD</span></code></a>，<a class="reference internal" href="#opcode-LIST_APPEND"><code class="xref std std-opcode docutils literal"><span class="pre">LIST_APPEND</span></code></a>和<a class="reference internal" href="#opcode-MAP_ADD"><code class="xref std std-opcode docutils literal"><span class="pre">MAP_ADD</span></code></a>指令，当添加的值或键/值对被弹出时，容器对象保持开启使得它可用于循环的进一步迭代。</span></p><dl class="opcode"><dt id="opcode-RETURN_VALUE"><span class="yiyi-st" id="yiyi-250"> <code class="descname">RETURN_VALUE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-251">返回带有TOS的函数的调用者。</span></p></dd></dl><dl class="opcode"><dt id="opcode-YIELD_VALUE"><span class="yiyi-st" id="yiyi-252"> <code class="descname">YIELD_VALUE</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-253">弹出TOS并从<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>生成它。</span></p></dd></dl><dl class="opcode"><dt id="opcode-YIELD_FROM"><span class="yiyi-st" id="yiyi-254"> <code class="descname">YIELD_FROM</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-255">弹出TOS并从<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>中委托它作为辅助参数。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-256"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="opcode"><dt id="opcode-IMPORT_STAR"><span class="yiyi-st" id="yiyi-257"><code class="descname"> IMPORT_STAR  T0&gt; </code></span></dt><dd><p><span class="yiyi-st" id="yiyi-258">将所有不以<code class="docutils literal"><span class="pre">'_'</span></code>开头的符号直接从模块TOS加载到本地命名空间。</span><span class="yiyi-st" id="yiyi-259">加载所有名称后，将弹出该模块。</span><span class="yiyi-st" id="yiyi-260">此操作码从 <span class="pre">模块</span> <span class="pre">导入</span> <span class="pre">*</span>实现<code class="docutils literal"><span class="pre">。</span></code></span></p></dd></dl><dl class="opcode"><dt id="opcode-POP_BLOCK"><span class="yiyi-st" id="yiyi-261"> <code class="descname">POP_BLOCK</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-262">从块堆栈中删除一个块。</span><span class="yiyi-st" id="yiyi-263">每帧，有一堆块，表示嵌套循环，try语句等。</span></p></dd></dl><dl class="opcode"><dt id="opcode-POP_EXCEPT"><span class="yiyi-st" id="yiyi-264"> <code class="descname">POP_EXCEPT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-265">从块堆栈中删除一个块。</span><span class="yiyi-st" id="yiyi-266">弹出的块必须是异常处理程序块，这是在输入except处理程序时隐式创建的。</span><span class="yiyi-st" id="yiyi-267">除了从帧堆栈中弹出无关的值之外，最后三个弹出的值还用于恢复异常状态。</span></p></dd></dl><dl class="opcode"><dt id="opcode-END_FINALLY"><span class="yiyi-st" id="yiyi-268"> <code class="descname">END_FINALLY</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-269">终止<a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a>子句。</span><span class="yiyi-st" id="yiyi-270">解释器调用异常是否必须重新提升，或者该函数是否返回，并继续下一个下一个块。</span></p></dd></dl><dl class="opcode"><dt id="opcode-LOAD_BUILD_CLASS"><span class="yiyi-st" id="yiyi-271"> <code class="descname">LOAD_BUILD_CLASS</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-272">将<code class="xref py py-func docutils literal"><span class="pre">builtins.__build_class__()</span></code>推送到堆栈。</span><span class="yiyi-st" id="yiyi-273">它稍后由<a class="reference internal" href="#opcode-CALL_FUNCTION"><code class="xref std std-opcode docutils literal"><span class="pre">CALL_FUNCTION</span></code></a>调用以构造一个类。</span></p></dd></dl><dl class="opcode"><dt id="opcode-SETUP_WITH"><span class="yiyi-st" id="yiyi-274"> <code class="descname">SETUP_WITH</code><span class="sig-paren">(</span><em>delta</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-275">这个操作码在块开始之前执行几个操作。</span><span class="yiyi-st" id="yiyi-276">首先，它从上下文管理器加载<a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a>并将其推送到堆栈以供稍后由<code class="xref std std-opcode docutils literal"><span class="pre">WITH_CLEANUP</span></code>使用。</span><span class="yiyi-st" id="yiyi-277">然后，调用<a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a>，并按下指向<em>delta</em>的finally块。</span><span class="yiyi-st" id="yiyi-278">最后，调用enter方法的结果被推入堆栈。</span><span class="yiyi-st" id="yiyi-279">The next opcode will either ignore it (<a class="reference internal" href="#opcode-POP_TOP"><code class="xref std std-opcode docutils literal"><span class="pre">POP_TOP</span></code></a>), or store it in (a) variable(s) (<a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal"><span class="pre">STORE_FAST</span></code></a>, <a class="reference internal" href="#opcode-STORE_NAME"><code class="xref std std-opcode docutils literal"><span class="pre">STORE_NAME</span></code></a>, or <a class="reference internal" href="#opcode-UNPACK_SEQUENCE"><code class="xref std std-opcode docutils literal"><span class="pre">UNPACK_SEQUENCE</span></code></a>).</span></p></dd></dl><dl class="opcode"><dt id="opcode-WITH_CLEANUP_START"><span class="yiyi-st" id="yiyi-280"> <code class="descname">WITH_CLEANUP_START</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-281">当<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句块退出时清理堆栈。</span><span class="yiyi-st" id="yiyi-282">TOS是上下文管理器的<a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a>绑定方法。</span><span class="yiyi-st" id="yiyi-283">TOS下面有1-3个值，表示如何/为什么输入finally子句：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-284">SECOND = <code class="docutils literal"><span class="pre">None</span></code></span></li><li><span class="yiyi-st" id="yiyi-285">（SECOND，THIRD）=（<code class="docutils literal"><span class="pre">WHY_{RETURN,CONTINUE}</span></code>），retval</span></li><li><span class="yiyi-st" id="yiyi-286">SECOND = <code class="docutils literal"><span class="pre">WHY_*</span></code>；没有retval下面</span></li><li><span class="yiyi-st" id="yiyi-287">（SECOND，THIRD，FOURTH）= exc_info()</span></li></ul><p><span class="yiyi-st" id="yiyi-288">在最后一种情况下，调用<code class="docutils literal"><span class="pre">TOS（SECOND，</span> <span class="pre">THIRD，</span> <span class="pre">FOURTH）</span></code>，否则<code class="docutils literal"><span class="pre"> TOS（无，</span> <span class="pre">无，</span> <span class="pre">无）</span></code>。</span><span class="yiyi-st" id="yiyi-289">将SECOND和调用的结果推送到堆栈。</span></p></dd></dl><dl class="opcode"><dt id="opcode-WITH_CLEANUP_FINISH"><span class="yiyi-st" id="yiyi-290"> <code class="descname">WITH_CLEANUP_FINISH</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-291">从堆栈中弹出“exit”函数调用的异常类型和结果。</span></p><p><span class="yiyi-st" id="yiyi-292">如果堆栈表示异常，<em>和</em>函数调用返回“true”值，此信息为“zapped”，并替换为单个<code class="docutils literal"><span class="pre">WHY_SILENCED</span></code>，以防止<a class="reference internal" href="#opcode-END_FINALLY"><code class="xref std std-opcode docutils literal"><span class="pre">END_FINALLY</span></code></a>重新提高异常。</span><span class="yiyi-st" id="yiyi-293">（但非本地gotos将仍然恢复。）</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-294">所有以下操作码都需要参数。</span><span class="yiyi-st" id="yiyi-295">参数是两个字节，最高有效字节。</span></p><dl class="opcode"><dt id="opcode-STORE_NAME"><span class="yiyi-st" id="yiyi-296"> <code class="descname">STORE_NAME</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-297">实施<code class="docutils literal"><span class="pre">名称</span> <span class="pre">=</span> <span class="pre">TOS</span></code>。</span><span class="yiyi-st" id="yiyi-298"><em>namei</em>是代码对象的属性<code class="xref py py-attr docutils literal"><span class="pre">co_names</span></code>中<em>名称</em>的索引。</span><span class="yiyi-st" id="yiyi-299">如果可能，编译器尝试使用<a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal"><span class="pre">STORE_FAST</span></code></a>或<a class="reference internal" href="#opcode-STORE_GLOBAL"><code class="xref std std-opcode docutils literal"><span class="pre">STORE_GLOBAL</span></code></a>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-DELETE_NAME"><span class="yiyi-st" id="yiyi-300"> <code class="descname">DELETE_NAME</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-301">实现<code class="docutils literal"><span class="pre">del</span> <span class="pre">名称</span></code>，其中<em>namei</em>是<code class="xref py py-attr docutils literal"><span class="pre">co_names</span></code>目的。</span></p></dd></dl><dl class="opcode"><dt id="opcode-UNPACK_SEQUENCE"><span class="yiyi-st" id="yiyi-302"> <code class="descname">UNPACK_SEQUENCE</code><span class="sig-paren">(</span><em>count</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-303">将TOS解包到<em>计数</em>个别值中，这些值从右到左放在堆栈中。</span></p></dd></dl><dl class="opcode"><dt id="opcode-UNPACK_EX"><span class="yiyi-st" id="yiyi-304"> <code class="descname">UNPACK_EX</code><span class="sig-paren">(</span><em>counts</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-305">使用已加星标的目标实现分配：将TOS中的迭代包解压为单个值，其中值的总数可以小于可迭代项中的项数：其中一个新值将是所有剩余项的列表。</span></p><p><span class="yiyi-st" id="yiyi-306"><em>计数的低字节</em>是列表值之前的值的数量，<em>的高字节计数</em>它之后的值的数量。</span><span class="yiyi-st" id="yiyi-307">结果值从右到左放在堆栈中。</span></p></dd></dl><dl class="opcode"><dt id="opcode-STORE_ATTR"><span class="yiyi-st" id="yiyi-308"> <code class="descname">STORE_ATTR</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-309">实现<code class="docutils literal"><span class="pre">TOS.name</span> <span class="pre">=</span> <span class="pre">TOS1</span></code>，其中<em>namei</em> <code class="xref py py-attr docutils literal"><span class="pre">co_names</span></code>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-DELETE_ATTR"><span class="yiyi-st" id="yiyi-310"> <code class="descname">DELETE_ATTR</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-311">使用<em>namei</em>作为<code class="xref py py-attr docutils literal"><span class="pre">co_names</span></code>中的索引，实现<code class="docutils literal"><span class="pre">del</span> <span class="pre">TOS.name</span> </code></span></p></dd></dl><dl class="opcode"><dt id="opcode-STORE_GLOBAL"><span class="yiyi-st" id="yiyi-312"> <code class="descname">STORE_GLOBAL</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-313">用作<a class="reference internal" href="#opcode-STORE_NAME"><code class="xref std std-opcode docutils literal"><span class="pre">STORE_NAME</span></code></a>，但将名称存储为全局名称。</span></p></dd></dl><dl class="opcode"><dt id="opcode-DELETE_GLOBAL"><span class="yiyi-st" id="yiyi-314"> <code class="descname">DELETE_GLOBAL</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-315">用作<a class="reference internal" href="#opcode-DELETE_NAME"><code class="xref std std-opcode docutils literal"><span class="pre">DELETE_NAME</span></code></a>，但会删除全局名称。</span></p></dd></dl><dl class="opcode"><dt id="opcode-LOAD_CONST"><span class="yiyi-st" id="yiyi-316"> <code class="descname">LOAD_CONST</code><span class="sig-paren">(</span><em>consti</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-317">将<code class="docutils literal"><span class="pre">co_consts[consti]</span></code>推送到堆栈。</span></p></dd></dl><dl class="opcode"><dt id="opcode-LOAD_NAME"><span class="yiyi-st" id="yiyi-318"> <code class="descname">LOAD_NAME</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-319">将与<code class="docutils literal"><span class="pre">co_names[namei]</span></code>关联的值推送到堆栈。</span></p></dd></dl><dl class="opcode"><dt id="opcode-BUILD_TUPLE"><span class="yiyi-st" id="yiyi-320"> <code class="descname">BUILD_TUPLE</code><span class="sig-paren">(</span><em>count</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-321">从堆栈中创建消耗<em>计数</em>的元组，并将生成的元组推送到堆栈。</span></p></dd></dl><dl class="opcode"><dt id="opcode-BUILD_LIST"><span class="yiyi-st" id="yiyi-322"> <code class="descname">BUILD_LIST</code><span class="sig-paren">(</span><em>count</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-323">用作<a class="reference internal" href="#opcode-BUILD_TUPLE"><code class="xref std std-opcode docutils literal"><span class="pre">BUILD_TUPLE</span></code></a>，但会创建列表。</span></p></dd></dl><dl class="opcode"><dt id="opcode-BUILD_SET"><span class="yiyi-st" id="yiyi-324"> <code class="descname">BUILD_SET</code><span class="sig-paren">(</span><em>count</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-325">用作<a class="reference internal" href="#opcode-BUILD_TUPLE"><code class="xref std std-opcode docutils literal"><span class="pre">BUILD_TUPLE</span></code></a>，但会创建一个集合。</span></p></dd></dl><dl class="opcode"><dt id="opcode-BUILD_MAP"><span class="yiyi-st" id="yiyi-326"> <code class="descname">BUILD_MAP</code><span class="sig-paren">(</span><em>count</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-327">将一个新的字典对象推送到堆栈。</span><span class="yiyi-st" id="yiyi-328">字典预先设置为保存<em>计数</em>条目。</span></p></dd></dl><dl class="opcode"><dt id="opcode-LOAD_ATTR"><span class="yiyi-st" id="yiyi-329"> <code class="descname">LOAD_ATTR</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-330">用<code class="docutils literal"><span class="pre">getattr（TOS，</span> <span class="pre">co_names [namei]）</span></code>替换TOS。</span></p></dd></dl><dl class="opcode"><dt id="opcode-COMPARE_OP"><span class="yiyi-st" id="yiyi-331"> <code class="descname">COMPARE_OP</code><span class="sig-paren">(</span><em>opname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-332">执行布尔操作。</span><span class="yiyi-st" id="yiyi-333">操作名称可以在<code class="docutils literal"><span class="pre">cmp_op[opname]</span></code>中找到。</span></p></dd></dl><dl class="opcode"><dt id="opcode-IMPORT_NAME"><span class="yiyi-st" id="yiyi-334"> <code class="descname">IMPORT_NAME</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-335">导入模块<code class="docutils literal"><span class="pre">co_names[namei]</span></code>。</span><span class="yiyi-st" id="yiyi-336">TOS和TOS1被弹出并提供<a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a>的<em>从列表</em>和<em>级</em>参数。</span><span class="yiyi-st" id="yiyi-337">模块对象被推入堆栈。</span><span class="yiyi-st" id="yiyi-338">当前命名空间不受影响：对于正确的导入语句，后续的<a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal"><span class="pre">STORE_FAST</span></code></a>指令修改命名空间。</span></p></dd></dl><dl class="opcode"><dt id="opcode-IMPORT_FROM"><span class="yiyi-st" id="yiyi-339"> <code class="descname">IMPORT_FROM</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-340">从TOS中找到的模块加载属性<code class="docutils literal"><span class="pre">co_names[namei]</span></code>。</span><span class="yiyi-st" id="yiyi-341">结果对象被推入堆栈，随后通过<a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal"><span class="pre">STORE_FAST</span></code></a>指令存储。</span></p></dd></dl><dl class="opcode"><dt id="opcode-JUMP_FORWARD"><span class="yiyi-st" id="yiyi-342"> <code class="descname">JUMP_FORWARD</code><span class="sig-paren">(</span><em>delta</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-343">通过<em>delta</em>增加字节码计数器。</span></p></dd></dl><dl class="opcode"><dt id="opcode-POP_JUMP_IF_TRUE"><span class="yiyi-st" id="yiyi-344"> <code class="descname">POP_JUMP_IF_TRUE</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-345">如果TOS为真，则将字节码计数器设置为<em>target</em>。</span><span class="yiyi-st" id="yiyi-346">TOS弹出。</span></p></dd></dl><dl class="opcode"><dt id="opcode-POP_JUMP_IF_FALSE"><span class="yiyi-st" id="yiyi-347"> <code class="descname">POP_JUMP_IF_FALSE</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-348">如果TOS为假，则将字节码计数器设置为<em>target</em>。</span><span class="yiyi-st" id="yiyi-349">TOS弹出。</span></p></dd></dl><dl class="opcode"><dt id="opcode-JUMP_IF_TRUE_OR_POP"><span class="yiyi-st" id="yiyi-350"> <code class="descname">JUMP_IF_TRUE_OR_POP</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-351">如果TOS为真，则将字节码计数器设置为<em>target</em>，并在堆栈上保留TOS。</span><span class="yiyi-st" id="yiyi-352">否则（TOS为假），TOS被弹出。</span></p></dd></dl><dl class="opcode"><dt id="opcode-JUMP_IF_FALSE_OR_POP"><span class="yiyi-st" id="yiyi-353"> <code class="descname">JUMP_IF_FALSE_OR_POP</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-354">如果TOS为假，则将字节码计数器设置为<em>target</em>，并在堆栈上保留TOS。</span><span class="yiyi-st" id="yiyi-355">否则（TOS为真），TOS被弹出。</span></p></dd></dl><dl class="opcode"><dt id="opcode-JUMP_ABSOLUTE"><span class="yiyi-st" id="yiyi-356"> <code class="descname">JUMP_ABSOLUTE</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-357">将字节码计数器设置为<em>目标</em>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-FOR_ITER"><span class="yiyi-st" id="yiyi-358"> <code class="descname">FOR_ITER</code><span class="sig-paren">(</span><em>delta</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-359">TOS是<a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>。</span><span class="yiyi-st" id="yiyi-360">调用其<a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a>方法。</span><span class="yiyi-st" id="yiyi-361">如果这产生一个新的值，推它在堆栈（留下下面的迭代器）。</span><span class="yiyi-st" id="yiyi-362">如果迭代器指示它被耗尽，则TOS被弹出，并且字节代码计数器递增<em>delta</em>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-LOAD_GLOBAL"><span class="yiyi-st" id="yiyi-363"> <code class="descname">LOAD_GLOBAL</code><span class="sig-paren">(</span><em>namei</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-364">将名为<code class="docutils literal"><span class="pre">co_names[namei]</span></code>的全局加载到堆栈中。</span></p></dd></dl><dl class="opcode"><dt id="opcode-SETUP_LOOP"><span class="yiyi-st" id="yiyi-365"> <code class="descname">SETUP_LOOP</code><span class="sig-paren">(</span><em>delta</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-366">将一个循环的块推送到块堆栈。</span><span class="yiyi-st" id="yiyi-367">该块跨越当前指令，大小为<em>delta</em>字节。</span></p></dd></dl><dl class="opcode"><dt id="opcode-SETUP_EXCEPT"><span class="yiyi-st" id="yiyi-368"> <code class="descname">SETUP_EXCEPT</code><span class="sig-paren">(</span><em>delta</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-369">将try块从try-except子句推送到块堆栈。</span><span class="yiyi-st" id="yiyi-370"><em>delta</em>指向第一个除外块。</span></p></dd></dl><dl class="opcode"><dt id="opcode-SETUP_FINALLY"><span class="yiyi-st" id="yiyi-371"> <code class="descname">SETUP_FINALLY</code><span class="sig-paren">(</span><em>delta</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-372">将try块从try-except子句推送到块堆栈上。</span><span class="yiyi-st" id="yiyi-373"><em>delta</em>指向finally块。</span></p></dd></dl><dl class="opcode"><dt id="opcode-LOAD_FAST"><span class="yiyi-st" id="yiyi-374"> <code class="descname">LOAD_FAST</code><span class="sig-paren">(</span><em>var_num</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-375">将对本地<code class="docutils literal"><span class="pre">co_varnames[var_num]</span></code>的引用推送到堆栈。</span></p></dd></dl><dl class="opcode"><dt id="opcode-STORE_FAST"><span class="yiyi-st" id="yiyi-376"> <code class="descname">STORE_FAST</code><span class="sig-paren">(</span><em>var_num</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-377">将TOS存储到本地<code class="docutils literal"><span class="pre">co_varnames[var_num]</span></code>中。</span></p></dd></dl><dl class="opcode"><dt id="opcode-DELETE_FAST"><span class="yiyi-st" id="yiyi-378"> <code class="descname">DELETE_FAST</code><span class="sig-paren">(</span><em>var_num</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-379">删除本地<code class="docutils literal"><span class="pre">co_varnames[var_num]</span></code>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-LOAD_CLOSURE"><span class="yiyi-st" id="yiyi-380"> <code class="descname">LOAD_CLOSURE</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-381">推动对单元格的插槽<em>i</em>中包含的单元格的引用和自由变量存储。</span><span class="yiyi-st" id="yiyi-382">变量的名称为<code class="docutils literal"><span class="pre">co_cellvars[i]</span></code> if <em>i</em>小于<em>co_cellvars</em>的长度。</span><span class="yiyi-st" id="yiyi-383">否则为<code class="docutils literal"><span class="pre">co_freevars [i</span> <span class="pre"> - </span> <span class="pre">len（co_cellvars）]</span></code>。</span></p></dd></dl><dl class="opcode"><dt id="opcode-LOAD_DEREF"><span class="yiyi-st" id="yiyi-384"> <code class="descname">LOAD_DEREF</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-385">加载单元格的插槽<em>i</em>中包含的单元格和自由变量存储。</span><span class="yiyi-st" id="yiyi-386">推动对单元格在堆栈上包含的对象的引用。</span></p></dd></dl><dl class="opcode"><dt id="opcode-LOAD_CLASSDEREF"><span class="yiyi-st" id="yiyi-387"> <code class="descname">LOAD_CLASSDEREF</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-388">很像<a class="reference internal" href="#opcode-LOAD_DEREF"><code class="xref std std-opcode docutils literal"><span class="pre">LOAD_DEREF</span></code></a>，但在咨询单元格之前首先检查本地字典。</span><span class="yiyi-st" id="yiyi-389">这用于在类体中加载自由变量。</span></p></dd></dl><dl class="opcode"><dt id="opcode-STORE_DEREF"><span class="yiyi-st" id="yiyi-390"> <code class="descname">STORE_DEREF</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-391">将TOS存储到单元的插槽<em>i</em>中包含的单元和自由变量存储器中。</span></p></dd></dl><dl class="opcode"><dt id="opcode-DELETE_DEREF"><span class="yiyi-st" id="yiyi-392"> <code class="descname">DELETE_DEREF</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-393">清空单元格的插槽<em>i</em>中包含的单元格和自由变量存储。</span><span class="yiyi-st" id="yiyi-394">由<a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a>语句使用。</span></p></dd></dl><dl class="opcode"><dt id="opcode-RAISE_VARARGS"><span class="yiyi-st" id="yiyi-395"> <code class="descname">RAISE_VARARGS</code><span class="sig-paren">(</span><em>argc</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-396">引发异常。</span><span class="yiyi-st" id="yiyi-397"><em>argc</em>指示引数语句的参数数，范围为0到3。</span><span class="yiyi-st" id="yiyi-398">处理程序将找到跟踪作为TOS2，参数为TOS1，异常为TOS。</span></p></dd></dl><dl class="opcode"><dt id="opcode-CALL_FUNCTION"><span class="yiyi-st" id="yiyi-399"> <code class="descname">CALL_FUNCTION</code><span class="sig-paren">(</span><em>argc</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-400">调用函数。</span><span class="yiyi-st" id="yiyi-401"><em>argc</em>的低字节表示位置参数的数量，高字节表示关键字参数的数量。</span><span class="yiyi-st" id="yiyi-402">在堆栈上，操作码首先找到关键字参数。</span><span class="yiyi-st" id="yiyi-403">对于每个关键字参数，值是在键的顶部。</span><span class="yiyi-st" id="yiyi-404">在关键字参数下面，位置参数在堆栈上，最右边的参数在顶部。</span><span class="yiyi-st" id="yiyi-405">在参数下面，要调用的函数对象在堆栈上。</span><span class="yiyi-st" id="yiyi-406">弹出所有函数参数，函数本身关闭堆栈，并推送返回值。</span></p></dd></dl><dl class="opcode"><dt id="opcode-MAKE_FUNCTION"><span class="yiyi-st" id="yiyi-407"> <code class="descname">MAKE_FUNCTION</code><span class="sig-paren">(</span><em>argc</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-408">在堆栈上推送一个新的函数对象。</span><span class="yiyi-st" id="yiyi-409">从底部到顶部，消耗的堆栈必须包含</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-410"><code class="docutils literal"><span class="pre">argc</span> <span class="pre">＆amp；</span> <span class="pre">0xFF</span></code></span></li><li><span class="yiyi-st" id="yiyi-411"><code class="docutils literal"><span class="pre">（argc</span> <span class="pre">&gt;</span> <span class="pre">8）</span> <span class="pre">＆amp；</span> <span class="pre">0xFF</span> / t0&gt;名称和默认参数对，其名称正好位于堆栈上的对象下方，用于仅限关键字的参数</code></span></li><li><span class="yiyi-st" id="yiyi-412"><code class="docutils literal"><span class="pre">（argc</span> <span class="pre">＆gt；</span> <span class="pre">16）</span> <span class="pre">＆amp；</span> <span class="pre">0x7FFF</span> / t0&gt;参数注释对象</code></span></li><li><span class="yiyi-st" id="yiyi-413">一个列出注解的参数名称的元组（仅当存在ony注释对象时）</span></li><li><span class="yiyi-st" id="yiyi-414">与功能相关的代码（在TOS1处）</span></li><li><span class="yiyi-st" id="yiyi-415">函数的<a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a>（在TOS处）</span></li></ul></dd></dl><dl class="opcode"><dt id="opcode-MAKE_CLOSURE"><span class="yiyi-st" id="yiyi-416"> <code class="descname">MAKE_CLOSURE</code><span class="sig-paren">(</span><em>argc</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-417">创建一个新的函数对象，设置其<em>__ closure __</em>槽，并将其推入堆栈。</span><span class="yiyi-st" id="yiyi-418">TOS是函数的<a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a>，TOS1是与函数相关联的代码，TOS2是包含闭包自由变量的单元格的元组。</span><span class="yiyi-st" id="yiyi-419"><em>argc</em>解释为<code class="docutils literal"><span class="pre">MAKE_FUNCTION</span></code>；注释和默认值也在TOS2之下的相同顺序。</span></p></dd></dl><dl class="opcode"><dt id="opcode-BUILD_SLICE"><span class="yiyi-st" id="yiyi-420"> <code class="descname">BUILD_SLICE</code><span class="sig-paren">(</span><em>argc</em><span class="sig-paren">)</span></span></dt><dd><p id="index-0"><span class="yiyi-st" id="yiyi-421">在堆栈上推动一个切片对象。</span><span class="yiyi-st" id="yiyi-422"><em>argc</em>必须为2或3。</span><span class="yiyi-st" id="yiyi-423">如果为2，则按下<code class="docutils literal"><span class="pre">切片（TOS1，</span> <span class="pre">TOS）</span> 如果是3，则按下<code class="docutils literal"><span class="pre">切片（TOS2，</span> <span class="pre">TOS1，</span> <span class="pre">TOS）</span> </code></code></span><span class="yiyi-st" id="yiyi-424">有关详细信息，请参阅<a class="reference internal" href="functions.html#slice" title="slice"><code class="xref py py-func docutils literal"><span class="pre">slice()</span></code></a>内建函数。</span></p></dd></dl><dl class="opcode"><dt id="opcode-EXTENDED_ARG"><span class="yiyi-st" id="yiyi-425"> <code class="descname">EXTENDED_ARG</code><span class="sig-paren">(</span><em>ext</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-426">前缀任何操作码，其参数太大，不适合默认的两个字节。</span><span class="yiyi-st" id="yiyi-427"><em>ext</em>包含两个附加字节，与后续操作码的参数一起构成一个四字节参数，<em>ext</em>是两个最高有效字节。</span></p></dd></dl><dl class="opcode"><dt id="opcode-CALL_FUNCTION_VAR"><span class="yiyi-st" id="yiyi-428"> <code class="descname">CALL_FUNCTION_VAR</code><span class="sig-paren">(</span><em>argc</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-429">调用函数。</span><span class="yiyi-st" id="yiyi-430"><em>argc</em>解释为<a class="reference internal" href="#opcode-CALL_FUNCTION"><code class="xref std std-opcode docutils literal"><span class="pre">CALL_FUNCTION</span></code></a>。</span><span class="yiyi-st" id="yiyi-431">堆栈上的顶层元素包含变量参数列表，后跟关键字和位置参数。</span></p></dd></dl><dl class="opcode"><dt id="opcode-CALL_FUNCTION_KW"><span class="yiyi-st" id="yiyi-432"> <code class="descname">CALL_FUNCTION_KW</code><span class="sig-paren">(</span><em>argc</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-433">调用函数。</span><span class="yiyi-st" id="yiyi-434"><em>argc</em>解释为<a class="reference internal" href="#opcode-CALL_FUNCTION"><code class="xref std std-opcode docutils literal"><span class="pre">CALL_FUNCTION</span></code></a>。</span><span class="yiyi-st" id="yiyi-435">堆栈顶部的元素包含关键字参数字典，其次是显式关键字和位置参数。</span></p></dd></dl><dl class="opcode"><dt id="opcode-CALL_FUNCTION_VAR_KW"><span class="yiyi-st" id="yiyi-436"> <code class="descname">CALL_FUNCTION_VAR_KW</code><span class="sig-paren">(</span><em>argc</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-437">调用函数。</span><span class="yiyi-st" id="yiyi-438"><em>argc</em>解释为<a class="reference internal" href="#opcode-CALL_FUNCTION"><code class="xref std std-opcode docutils literal"><span class="pre">CALL_FUNCTION</span></code></a>。</span><span class="yiyi-st" id="yiyi-439">栈上的顶层元素包含关键字arguments字典，后面跟着variable-arguments tuple，后面是显式关键字和位置参数。</span></p></dd></dl><dl class="opcode"><dt id="opcode-HAVE_ARGUMENT"><span class="yiyi-st" id="yiyi-440"><code class="descname"> HAVE_ARGUMENT  T0&gt; </code></span></dt><dd><p><span class="yiyi-st" id="yiyi-441">这不是一个真正的操作码。</span><span class="yiyi-st" id="yiyi-442">它标识不接受参数的操作码之间的分界线<code class="docutils literal"><span class="pre"></span> <span class="pre">HAVE_ARGUMENT</span></code>和执行<code class="docutils literal"><span class="pre">&gt; = </span> <span class="pre">HAVE_ARGUMENT</span></code>。</span></p></dd></dl></div><div class="section" id="opcode-collections"><h2><span class="yiyi-st" id="yiyi-443">32.12.4. </span><span class="yiyi-st" id="yiyi-444">操作码集合</span></h2><p><span class="yiyi-st" id="yiyi-445">这些容器用于自动内省字节码指令：</span></p><dl class="data"><dt id="dis.opname"><span class="yiyi-st" id="yiyi-446"> <code class="descclassname">dis.</code><code class="descname">opname</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-447">操作名称序列，使用字节码可索引。</span></p></dd></dl><dl class="data"><dt id="dis.opmap"><span class="yiyi-st" id="yiyi-448"> <code class="descclassname">dis.</code><code class="descname">opmap</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-449">将操作名称映射到字节码的字典。</span></p></dd></dl><dl class="data"><dt id="dis.cmp_op"><span class="yiyi-st" id="yiyi-450"> <code class="descclassname">dis.</code><code class="descname">cmp_op</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-451">所有比较操作名称的顺序。</span></p></dd></dl><dl class="data"><dt id="dis.hasconst"><span class="yiyi-st" id="yiyi-452"> <code class="descclassname">dis.</code><code class="descname">hasconst</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-453">具有常量参数的字节码序列。</span></p></dd></dl><dl class="data"><dt id="dis.hasfree"><span class="yiyi-st" id="yiyi-454"> <code class="descclassname">dis.</code><code class="descname">hasfree</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-455">访问自由变量的字节码序列（请注意，在本上下文中的“自由”是指内部作用域引用的当前作用域中的名称或从此作用域引用的外部作用域中的名称。</span><span class="yiyi-st" id="yiyi-456">它<em>不</em>包括对全局或内置作用域的引用）。</span></p></dd></dl><dl class="data"><dt id="dis.hasname"><span class="yiyi-st" id="yiyi-457"> <code class="descclassname">dis.</code><code class="descname">hasname</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-458">按名称访问属性的字节码序列。</span></p></dd></dl><dl class="data"><dt id="dis.hasjrel"><span class="yiyi-st" id="yiyi-459"> <code class="descclassname">dis.</code><code class="descname">hasjrel</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-460">具有相对跳转目标的字节码序列。</span></p></dd></dl><dl class="data"><dt id="dis.hasjabs"><span class="yiyi-st" id="yiyi-461"> <code class="descclassname">dis.</code><code class="descname">hasjabs</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-462">具有绝对跳转目标的字节码序列。</span></p></dd></dl><dl class="data"><dt id="dis.haslocal"><span class="yiyi-st" id="yiyi-463"> <code class="descclassname">dis.</code><code class="descname">haslocal</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-464">访问局部变量的字节码序列。</span></p></dd></dl><dl class="data"><dt id="dis.hascompare"><span class="yiyi-st" id="yiyi-465"> <code class="descclassname">dis.</code><code class="descname">hascompare</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-466">布尔运算的字节码序列。</span></p></dd></dl></div></div></div>