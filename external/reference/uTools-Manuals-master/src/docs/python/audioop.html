<div class="body" role="main"><div class="section" id="module-audioop"><h1><span class="yiyi-st" id="yiyi-10">22.1. <a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data."><code class="xref py py-mod docutils literal"><span class="pre">audioop</span></code></a>  - 处理原始音频数据</span></h1><p><span class="yiyi-st" id="yiyi-11"><a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data."><code class="xref py py-mod docutils literal"><span class="pre">audioop</span></code></a>模块包含对声音片段的一些有用的操作。</span><span class="yiyi-st" id="yiyi-12">它对存储在<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>中的有符号整数采样8,16,24或32位宽的声音片段进行操作。</span><span class="yiyi-st" id="yiyi-13">除非另有说明，否则所有标量项都是整数。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-14"><span class="versionmodified">在版本3.4中已更改：</span>添加了对24位示例的支持。</span><span class="yiyi-st" id="yiyi-15">所有函数现在都接受任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</span><span class="yiyi-st" id="yiyi-16">字符串输入现在将导致立即错误。</span></p></div><p id="index-0"><span class="yiyi-st" id="yiyi-17">此模块支持a-LAW，u-LAW和Intel / DVI ADPCM编码。</span></p><p><span class="yiyi-st" id="yiyi-18">一些更复杂的操作只需要16位的样本，否则样本大小（以字节为单位）总是操作的一个参数。</span></p><p><span class="yiyi-st" id="yiyi-19">模块定义以下变量和函数：</span></p><dl class="exception"><dt id="audioop.error"><span class="yiyi-st" id="yiyi-20"><em class="property">异常</em> <code class="descclassname">audioop。</code> <code class="descname">错误</code> </span></dt><dd><p><span class="yiyi-st" id="yiyi-21">对所有错误都会引发此异常，例如每个样本的未知字节数等。</span></p></dd></dl><dl class="function"><dt id="audioop.add"><span class="yiyi-st" id="yiyi-22"> <code class="descclassname">audioop.</code><code class="descname">add</code><span class="sig-paren">(</span><em>fragment1</em>, <em>fragment2</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-23">返回一个片段，它是作为参数传递的两个样本的相加。</span><span class="yiyi-st" id="yiyi-24"><em>width</em>是以字节为单位的样本宽度，<code class="docutils literal"><span class="pre">1</span></code>，<code class="docutils literal"><span class="pre">2</span></code>，<code class="docutils literal"><span class="pre">3</span></code>或<code class="docutils literal"><span class="pre">4</span></code></span><span class="yiyi-st" id="yiyi-25">两个片段应具有相同的长度。</span><span class="yiyi-st" id="yiyi-26">在溢出的情况下截取样本。</span></p></dd></dl><dl class="function"><dt id="audioop.adpcm2lin"><span class="yiyi-st" id="yiyi-27"> <code class="descclassname">audioop.</code><code class="descname">adpcm2lin</code><span class="sig-paren">(</span><em>adpcmfragment</em>, <em>width</em>, <em>state</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-28">将Intel / DVI ADPCM编码片段解码为线性片段。</span><span class="yiyi-st" id="yiyi-29">有关ADPCM编码的详细信息，请参阅<a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal"><span class="pre">lin2adpcm()</span></code></a>的描述。</span><span class="yiyi-st" id="yiyi-30">返回元组<code class="docutils literal"><span class="pre">（sample，</span> <span class="pre">newstate）</span></code>，其中样本具有<em>width</em>中指定的宽度。</span></p></dd></dl><dl class="function"><dt id="audioop.alaw2lin"><span class="yiyi-st" id="yiyi-31"> <code class="descclassname">audioop.</code><code class="descname">alaw2lin</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-32">将a-LAW编码中的声音片段转换为线性编码的声音片段。</span><span class="yiyi-st" id="yiyi-33">a-LAW编码始终使用8位采样，因此<em>width</em>仅指此处的输出片段的采样宽度。</span></p></dd></dl><dl class="function"><dt id="audioop.avg"><span class="yiyi-st" id="yiyi-34"> <code class="descclassname">audioop.</code><code class="descname">avg</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-35">返回片段中所有样本的平均值。</span></p></dd></dl><dl class="function"><dt id="audioop.avgpp"><span class="yiyi-st" id="yiyi-36"> <code class="descclassname">audioop.</code><code class="descname">avgpp</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-37">返回片段中所有样本的平均峰 - 峰值。</span><span class="yiyi-st" id="yiyi-38">没有进行过滤，所以这个例程的有用性是有问题的。</span></p></dd></dl><dl class="function"><dt id="audioop.bias"><span class="yiyi-st" id="yiyi-39"> <code class="descclassname">audioop.</code><code class="descname">bias</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em>, <em>bias</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-40">返回作为原始片段的片段，并向每个样本添加偏差。</span><span class="yiyi-st" id="yiyi-41">样品在溢出的情况下包裹。</span></p></dd></dl><dl class="function"><dt id="audioop.byteswap"><span class="yiyi-st" id="yiyi-42"> <code class="descclassname">audioop.</code><code class="descname">byteswap</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-43">“Byteswap”片段中的所有样本，并返回修改的片段。</span><span class="yiyi-st" id="yiyi-44">将大尾数样本转换为小尾数法，反之亦然。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-45"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="audioop.cross"><span class="yiyi-st" id="yiyi-46"> <code class="descclassname">audioop.</code><code class="descname">cross</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-47">返回作为参数传递的片段中的零交叉的数量。</span></p></dd></dl><dl class="function"><dt id="audioop.findfactor"><span class="yiyi-st" id="yiyi-48"> <code class="descclassname">audioop.</code><code class="descname">findfactor</code><span class="sig-paren">(</span><em>fragment</em>, <em>reference</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-49">返回因子<em>F</em>使得<code class="docutils literal"><span class="pre">rms（add（fragment，</span> <span class="pre">mul（reference，</span> <span class="pre">-F））） t4&gt;</span></code>是最小的，即返回要乘以<em>参考</em>的因子，以使其与<em>片段</em>尽可能匹配。</span><span class="yiyi-st" id="yiyi-50">片段都应包含2字节样本。</span></p><p><span class="yiyi-st" id="yiyi-51">该例程所花费的时间与<code class="docutils literal"><span class="pre">len(fragment)</span></code>成比例。</span></p></dd></dl><dl class="function"><dt id="audioop.findfit"><span class="yiyi-st" id="yiyi-52"> <code class="descclassname">audioop.</code><code class="descname">findfit</code><span class="sig-paren">(</span><em>fragment</em>, <em>reference</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-53">尝试将<em>引用</em>与<em>片段</em>（应为更长的片段）的一部分匹配。</span><span class="yiyi-st" id="yiyi-54">（概念上）通过使用<a class="reference internal" href="#audioop.findfactor" title="audioop.findfactor"><code class="xref py py-func docutils literal"><span class="pre">findfactor()</span></code></a>从<em>片段</em>中取出片段来计算最佳匹配并最小化结果。</span><span class="yiyi-st" id="yiyi-55">片段都应包含2字节样本。</span><span class="yiyi-st" id="yiyi-56">Return a tuple <code class="docutils literal"><span class="pre">(offset,</span> <span class="pre">factor)</span></code> where <em>offset</em> is the (integer) offset into <em>fragment</em> where the optimal match started and <em>factor</em> is the (floating-point) factor as per <a class="reference internal" href="#audioop.findfactor" title="audioop.findfactor"><code class="xref py py-func docutils literal"><span class="pre">findfactor()</span></code></a>.</span></p></dd></dl><dl class="function"><dt id="audioop.findmax"><span class="yiyi-st" id="yiyi-57"> <code class="descclassname">audioop.</code><code class="descname">findmax</code><span class="sig-paren">(</span><em>fragment</em>, <em>length</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-58">搜索<em>片段</em>获取长度<em>长度</em>的切片（不是字节！）</span><span class="yiyi-st" id="yiyi-59">with maximum energy, i.e., return <em>i</em> for which <code class="docutils literal"><span class="pre">rms(fragment[i*2:(i+length)*2])</span></code> is maximal. </span><span class="yiyi-st" id="yiyi-60">片段都应包含2字节样本。</span></p><p><span class="yiyi-st" id="yiyi-61">该程序需要与<code class="docutils literal"><span class="pre">len(fragment)</span></code>成正比的时间。</span></p></dd></dl><dl class="function"><dt id="audioop.getsample"><span class="yiyi-st" id="yiyi-62"> <code class="descclassname">audioop.</code><code class="descname">getsample</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em>, <em>index</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-63">返回样本<em>index</em>的值。</span></p></dd></dl><dl class="function"><dt id="audioop.lin2adpcm"><span class="yiyi-st" id="yiyi-64"> <code class="descclassname">audioop.</code><code class="descname">lin2adpcm</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em>, <em>state</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-65">将采样转换为4位Intel / DVI ADPCM编码。</span><span class="yiyi-st" id="yiyi-66">ADPCM编码是自适应编码方案，其中每个4比特数是一个采样和下一个采样之间的差除以（变化）步长。</span><span class="yiyi-st" id="yiyi-67">英特尔/ DVI ADPCM算法已经选择供IMA使用，因此它很可能成为一个标准。</span></p><p><span class="yiyi-st" id="yiyi-68"><em>state</em>是包含编码器状态的元组。</span><span class="yiyi-st" id="yiyi-69">编码器返回一个tuple <code class="docutils literal"><span class="pre">（adpcmfrag，</span> <span class="pre">newstate）</span></code>，并且<em>newstate</em> <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal"><span class="pre">lin2adpcm()</span></code></a>。</span><span class="yiyi-st" id="yiyi-70">在初始调用中，<code class="docutils literal"><span class="pre">None</span></code>可以作为状态传递。</span><span class="yiyi-st" id="yiyi-71"><em>adpcmfrag</em>是每个字节打包2个4位值的ADPCM编码片段。</span></p></dd></dl><dl class="function"><dt id="audioop.lin2alaw"><span class="yiyi-st" id="yiyi-72"> <code class="descclassname">audioop.</code><code class="descname">lin2alaw</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-73">将音频片段中的样本转换为a-LAW编码，并将其作为字节对象返回。</span><span class="yiyi-st" id="yiyi-74">a-LAW是一种音频编码格式，您只使用8位采样，即可获得约13位的动态范围。</span><span class="yiyi-st" id="yiyi-75">它由Sun音频硬件等使用。</span></p></dd></dl><dl class="function"><dt id="audioop.lin2lin"><span class="yiyi-st" id="yiyi-76"> <code class="descclassname">audioop.</code><code class="descname">lin2lin</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em>, <em>newwidth</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-77">以1-，2-，3-和4字节格式转换样本。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-78">注意</span></p><p><span class="yiyi-st" id="yiyi-79">在一些音频格式（例如.WAV文件）中，16,24和32位采样被签名，但8位采样是无符号的。</span><span class="yiyi-st" id="yiyi-80">因此，当转换为8位宽样本用于这些格式时，您还需要将128个结果添加到结果中：</span></p><pre><code class="language-python"><span></span><span class="n">new_frames</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">lin2lin</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">old_width</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">new_frames</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">bias</span><span class="p">(</span><span class="n">new_frames</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
</code></pre><p class="last"><span class="yiyi-st" id="yiyi-81">当从8位转换为16位，24位或32位宽度样本时，必须应用相同的操作。</span></p></div></dd></dl><dl class="function"><dt id="audioop.lin2ulaw"><span class="yiyi-st" id="yiyi-82"> <code class="descclassname">audioop.</code><code class="descname">lin2ulaw</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">将音频片段中的样本转换为u-LAW编码，并将其作为字节对象返回。</span><span class="yiyi-st" id="yiyi-84">u-LAW是一种音频编码格式，您只需使用8位采样即可获得约14位的动态范围。</span><span class="yiyi-st" id="yiyi-85">它由Sun音频硬件等使用。</span></p></dd></dl><dl class="function"><dt id="audioop.max"><span class="yiyi-st" id="yiyi-86"> <code class="descclassname">audioop.</code><code class="descname">max</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-87">返回片段中所有样本的<em>绝对值</em>的最大值。</span></p></dd></dl><dl class="function"><dt id="audioop.maxpp"><span class="yiyi-st" id="yiyi-88"> <code class="descclassname">audioop.</code><code class="descname">maxpp</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-89">返回声音片段中的最大峰 - 峰值。</span></p></dd></dl><dl class="function"><dt id="audioop.minmax"><span class="yiyi-st" id="yiyi-90"> <code class="descclassname">audioop.</code><code class="descname">minmax</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-91">返回由声音片段中所有样本的最小值和最大值组成的元组。</span></p></dd></dl><dl class="function"><dt id="audioop.mul"><span class="yiyi-st" id="yiyi-92"> <code class="descclassname">audioop.</code><code class="descname">mul</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em>, <em>factor</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-93">返回具有原始片段中的所有样本乘以浮点值<em>因子</em>的片段。</span><span class="yiyi-st" id="yiyi-94">在溢出的情况下截取样本。</span></p></dd></dl><dl class="function"><dt id="audioop.ratecv"><span class="yiyi-st" id="yiyi-95"> <code class="descclassname">audioop.</code><code class="descname">ratecv</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em>, <em>nchannels</em>, <em>inrate</em>, <em>outrate</em>, <em>state</em><span class="optional">[</span>, <em>weightA</em><span class="optional">[</span>, <em>weightB</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-96">转换输入片段的帧速率。</span></p><p><span class="yiyi-st" id="yiyi-97"><em>state</em>是包含转换器状态的元组。</span><span class="yiyi-st" id="yiyi-98">The converter returns a tuple <code class="docutils literal"><span class="pre">(newfragment,</span> <span class="pre">newstate)</span></code>, and <em>newstate</em> should be passed to the next call of <a class="reference internal" href="#audioop.ratecv" title="audioop.ratecv"><code class="xref py py-func docutils literal"><span class="pre">ratecv()</span></code></a>. </span><span class="yiyi-st" id="yiyi-99">初始调用应通过<code class="docutils literal"><span class="pre">None</span></code>作为状态。</span></p><p><span class="yiyi-st" id="yiyi-100"><em>weightA</em>和<em>weightB</em>参数是简单数字滤波器的参数，默认分别为<code class="docutils literal"><span class="pre">1</span></code>和<code class="docutils literal"><span class="pre">0</span></code>。</span></p></dd></dl><dl class="function"><dt id="audioop.reverse"><span class="yiyi-st" id="yiyi-101"> <code class="descclassname">audioop.</code><code class="descname">reverse</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-102">反转片段中的样本，并返回修改的片段。</span></p></dd></dl><dl class="function"><dt id="audioop.rms"><span class="yiyi-st" id="yiyi-103"> <code class="descclassname">audioop.</code><code class="descname">rms</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">返回片段的均方根，即</span><span class="yiyi-st" id="yiyi-105"><code class="docutils literal"><span class="pre">sqrt(sum(S_i^2)/n)</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-106">这是音频信号中的功率的度量。</span></p></dd></dl><dl class="function"><dt id="audioop.tomono"><span class="yiyi-st" id="yiyi-107"> <code class="descclassname">audioop.</code><code class="descname">tomono</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em>, <em>lfactor</em>, <em>rfactor</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-108">将立体声片段转换为单声道片段。</span><span class="yiyi-st" id="yiyi-109">在添加两个声道以给出单声道信号之前，左声道乘以<em>lfactor</em>，右声道乘以<em>rfactor</em>。</span></p></dd></dl><dl class="function"><dt id="audioop.tostereo"><span class="yiyi-st" id="yiyi-110"> <code class="descclassname">audioop.</code><code class="descname">tostereo</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em>, <em>lfactor</em>, <em>rfactor</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">从单声道片段生成立体声片段。</span><span class="yiyi-st" id="yiyi-112">从单声道采样计算立体声片段中的每对采样，由此通过<em>rfactor</em>将左声道采样乘以<em>1因子</em>和右声道采样。</span></p></dd></dl><dl class="function"><dt id="audioop.ulaw2lin"><span class="yiyi-st" id="yiyi-113"> <code class="descclassname">audioop.</code><code class="descname">ulaw2lin</code><span class="sig-paren">(</span><em>fragment</em>, <em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-114">将u-LAW编码中的声音片段转换为线性编码的声音片段。</span><span class="yiyi-st" id="yiyi-115">u-LAW编码始终使用8位样本，因此<em>width</em>仅指此处的输出片段的样本宽度。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-116">注意，诸如<a class="reference internal" href="#audioop.mul" title="audioop.mul"><code class="xref py py-func docutils literal"><span class="pre">mul()</span></code></a>或<a class="reference internal" href="#audioop.max" title="audioop.max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a>的操作不区分单声道片段和立体声片段，即</span><span class="yiyi-st" id="yiyi-117">所有样品均相等。</span><span class="yiyi-st" id="yiyi-118">如果这是一个问题，立体片段应该首先分裂成两个单声道片段，然后重组。</span><span class="yiyi-st" id="yiyi-119">下面是一个如何做的例子：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">mul_stereo</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">):</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tomono</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tomono</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">)</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tostereo</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tostereo</span><span class="p">(</span><span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">audioop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-120">如果您使用ADPCM编码器来构建网络数据包，并且您希望您的协议是无状态的（即。</span><span class="yiyi-st" id="yiyi-121">以能够容忍数据包丢失）你不应该只传输数据，而且状态。</span><span class="yiyi-st" id="yiyi-122">请注意，您应该将<em>初始</em>状态（传递到<a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal"><span class="pre">lin2adpcm()</span></code></a>的状态）发送到解码器，而不是最终状态（由编码器返回）。</span><span class="yiyi-st" id="yiyi-123">如果你想使用<a class="reference internal" href="struct.html#struct.Struct" title="struct.Struct"><code class="xref py py-class docutils literal"><span class="pre">struct.Struct</span></code></a>将状态存储在二进制中，你可以在16位中编码第一个元素（预测值），在8中编写第二个（delta索引）。</span></p><p><span class="yiyi-st" id="yiyi-124">ADPCM编码器从未尝试过对其他ADPCM编码器，只针对自己。</span><span class="yiyi-st" id="yiyi-125">很可能我错误地解释了标准，在这种情况下，他们将不能与相应的标准互操作。</span></p><p><span class="yiyi-st" id="yiyi-126">在<code class="xref py py-func docutils literal"><span class="pre">find*()</span></code></span><span class="yiyi-st" id="yiyi-127">它们主要用于进行回声消除。</span><span class="yiyi-st" id="yiyi-128">一个相当快速的方法是选择输出样本中最具活力的部分，在输入样本中找到它，并从输入样本中减去整个输出样本：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">echocancel</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="n">inputdata</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">findmax</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>    <span class="c1"># one tenth second</span>
    <span class="n">out_test</span> <span class="o">=</span> <span class="n">outputdata</span><span class="p">[</span><span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">in_test</span> <span class="o">=</span> <span class="n">inputdata</span><span class="p">[</span><span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">ipos</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">findfit</span><span class="p">(</span><span class="n">in_test</span><span class="p">,</span> <span class="n">out_test</span><span class="p">)</span>
    <span class="c1"># Optional (for better cancellation):</span>
    <span class="c1"># factor = audioop.findfactor(in_test[ipos*2:ipos*2+len(out_test)],</span>
    <span class="c1">#              out_test)</span>
    <span class="n">prefill</span> <span class="o">=</span> <span class="s1">'</span><span class="se">\0</span><span class="s1">'</span><span class="o">*</span><span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">ipos</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">postfill</span> <span class="o">=</span> <span class="s1">'</span><span class="se">\0</span><span class="s1">'</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputdata</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">prefill</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">outputdata</span><span class="p">))</span>
    <span class="n">outputdata</span> <span class="o">=</span> <span class="n">prefill</span> <span class="o">+</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">postfill</span>
    <span class="k">return</span> <span class="n">audioop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">inputdata</span><span class="p">,</span> <span class="n">outputdata</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>