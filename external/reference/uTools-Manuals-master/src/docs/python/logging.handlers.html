<div class="body" role="main"><div class="section" id="module-logging.handlers"><h1><span class="yiyi-st" id="yiyi-10">16.8. <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> — Logging handlers</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>Source code:</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/logging/handlers.py">Lib/logging/handlers.py</a></span></p><div class="sidebar"><p class="first sidebar-title"><span class="yiyi-st" id="yiyi-12">Important</span></p><p><span class="yiyi-st" id="yiyi-13">This page contains only reference information. </span><span class="yiyi-st" id="yiyi-14">For tutorials, please see</span></p><ul class="last simple"><li><span class="yiyi-st" id="yiyi-15"><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span>Basic Tutorial</span></a></span></li><li><span class="yiyi-st" id="yiyi-16"><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span>Advanced Tutorial</span></a></span></li><li><span class="yiyi-st" id="yiyi-17"><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span>Logging Cookbook</span></a></span></li></ul></div><p><span class="yiyi-st" id="yiyi-18">The following useful handlers are provided in the package. </span><span class="yiyi-st" id="yiyi-19">Note that three of the handlers (<a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamHandler</span></code></a>, <a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code></a> and <a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal"><span class="pre">NullHandler</span></code></a>) are actually defined in the <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> module itself, but have been documented here along with the other handlers.</span></p><div class="section" id="streamhandler"><h2><span class="yiyi-st" id="yiyi-20">16.8.1. </span><span class="yiyi-st" id="yiyi-21">StreamHandler</span></h2><p><span class="yiyi-st" id="yiyi-22">The <a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamHandler</span></code></a> class, located in the core <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> package, sends logging output to streams such as <em>sys.stdout</em>, <em>sys.stderr</em> or any file-like object (or, more precisely, any object which supports <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code> methods).</span></p><dl class="class"><dt id="logging.StreamHandler"><span class="yiyi-st" id="yiyi-23"> <em class="property">class </em><code class="descclassname">logging.</code><code class="descname">StreamHandler</code><span class="sig-paren">(</span><em>stream=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-24">Returns a new instance of the <a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamHandler</span></code></a> class. </span><span class="yiyi-st" id="yiyi-25">If <em>stream</em> is specified, the instance will use it for logging output; otherwise, <em>sys.stderr</em> will be used.</span></p><dl class="method"><dt id="logging.StreamHandler.emit"><span class="yiyi-st" id="yiyi-26"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-27">If a formatter is specified, it is used to format the record. </span><span class="yiyi-st" id="yiyi-28">The record is then written to the stream with a terminator. </span><span class="yiyi-st" id="yiyi-29">If exception information is present, it is formatted using <a class="reference internal" href="traceback.html#traceback.print_exception" title="traceback.print_exception"><code class="xref py py-func docutils literal"><span class="pre">traceback.print_exception()</span></code></a> and appended to the stream.</span></p></dd></dl><dl class="method"><dt id="logging.StreamHandler.flush"><span class="yiyi-st" id="yiyi-30"> <code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-31">Flushes the stream by calling its <a class="reference internal" href="#logging.StreamHandler.flush" title="logging.StreamHandler.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> method. </span><span class="yiyi-st" id="yiyi-32">Note that the <code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> method is inherited from <code class="xref py py-class docutils literal"><span class="pre">Handler</span></code> and so does no output, so an explicit <a class="reference internal" href="#logging.StreamHandler.flush" title="logging.StreamHandler.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> call may be needed at times.</span></p></dd></dl></dd></dl><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-33"><span class="versionmodified">Changed in version 3.2: </span>The <code class="docutils literal"><span class="pre">StreamHandler</span></code> class now has a <code class="docutils literal"><span class="pre">terminator</span></code> attribute, default value <code class="docutils literal"><span class="pre">'\n'</span></code>, which is used as the terminator when writing a formatted record to a stream. </span><span class="yiyi-st" id="yiyi-34">If you don’t want this newline termination, you can set the handler instance’s <code class="docutils literal"><span class="pre">terminator</span></code> attribute to the empty string. </span><span class="yiyi-st" id="yiyi-35">In earlier versions, the terminator was hardcoded as <code class="docutils literal"><span class="pre">'\n'</span></code>.</span></p></div></div><div class="section" id="filehandler"><h2><span class="yiyi-st" id="yiyi-36">16.8.2. </span><span class="yiyi-st" id="yiyi-37">FileHandler</span></h2><p><span class="yiyi-st" id="yiyi-38">The <a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code></a> class, located in the core <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> package, sends logging output to a disk file. </span><span class="yiyi-st" id="yiyi-39">It inherits the output functionality from <a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamHandler</span></code></a>.</span></p><dl class="class"><dt id="logging.FileHandler"><span class="yiyi-st" id="yiyi-40"> <em class="property">class </em><code class="descclassname">logging.</code><code class="descname">FileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-41">Returns a new instance of the <a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code></a> class. </span><span class="yiyi-st" id="yiyi-42">The specified file is opened and used as the stream for logging. </span><span class="yiyi-st" id="yiyi-43">If <em>mode</em> is not specified, <code class="xref py py-const docutils literal"><span class="pre">'a'</span></code> is used. </span><span class="yiyi-st" id="yiyi-44">If <em>encoding</em> is not <em>None</em>, it is used to open the file with that encoding. </span><span class="yiyi-st" id="yiyi-45">If <em>delay</em> is true, then file opening is deferred until the first call to <a class="reference internal" href="#logging.FileHandler.emit" title="logging.FileHandler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a>. </span><span class="yiyi-st" id="yiyi-46">By default, the file grows indefinitely.</span></p><dl class="method"><dt id="logging.FileHandler.close"><span class="yiyi-st" id="yiyi-47"> <code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-48">Closes the file.</span></p></dd></dl><dl class="method"><dt id="logging.FileHandler.emit"><span class="yiyi-st" id="yiyi-49"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-50">Outputs the record to the file.</span></p></dd></dl></dd></dl></div><div class="section" id="nullhandler"><h2><span class="yiyi-st" id="yiyi-51">16.8.3. </span><span class="yiyi-st" id="yiyi-52">NullHandler</span></h2><div class="versionadded"><p><span class="yiyi-st" id="yiyi-53"><span class="versionmodified">New in version 3.1.</span></span></p></div><p><span class="yiyi-st" id="yiyi-54">The <a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal"><span class="pre">NullHandler</span></code></a> class, located in the core <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> package, does not do any formatting or output. </span><span class="yiyi-st" id="yiyi-55">It is essentially a ‘no-op’ handler for use by library developers.</span></p><dl class="class"><dt id="logging.NullHandler"><span class="yiyi-st" id="yiyi-56"> <em class="property">class </em><code class="descclassname">logging.</code><code class="descname">NullHandler</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-57">Returns a new instance of the <a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal"><span class="pre">NullHandler</span></code></a> class.</span></p><dl class="method"><dt id="logging.NullHandler.emit"><span class="yiyi-st" id="yiyi-58"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-59">This method does nothing.</span></p></dd></dl><dl class="method"><dt id="logging.NullHandler.handle"><span class="yiyi-st" id="yiyi-60"> <code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-61">This method does nothing.</span></p></dd></dl><dl class="method"><dt id="logging.NullHandler.createLock"><span class="yiyi-st" id="yiyi-62"> <code class="descname">createLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-63">This method returns <code class="docutils literal"><span class="pre">None</span></code> for the lock, since there is no underlying I/O to which access needs to be serialized.</span></p></dd></dl></dd></dl><p><span class="yiyi-st" id="yiyi-64">See <a class="reference internal" href="../howto/logging.html#library-config"><span>Configuring Logging for a Library</span></a> for more information on how to use <a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal"><span class="pre">NullHandler</span></code></a>.</span></p></div><div class="section" id="watchedfilehandler"><h2><span class="yiyi-st" id="yiyi-65">16.8.4. </span><span class="yiyi-st" id="yiyi-66">WatchedFileHandler</span></h2><p><span class="yiyi-st" id="yiyi-67">The <a class="reference internal" href="#logging.handlers.WatchedFileHandler" title="logging.handlers.WatchedFileHandler"><code class="xref py py-class docutils literal"><span class="pre">WatchedFileHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, is a <code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code> which watches the file it is logging to. </span><span class="yiyi-st" id="yiyi-68">If the file changes, it is closed and reopened using the file name.</span></p><p><span class="yiyi-st" id="yiyi-69">A file change can happen because of usage of programs such as <em>newsyslog</em> and <em>logrotate</em> which perform log file rotation. </span><span class="yiyi-st" id="yiyi-70">This handler, intended for use under Unix/Linux, watches the file to see if it has changed since the last emit. </span><span class="yiyi-st" id="yiyi-71">(A file is deemed to have changed if its device or inode have changed.) </span><span class="yiyi-st" id="yiyi-72">If the file has changed, the old file stream is closed, and the file opened to get a new stream.</span></p><p><span class="yiyi-st" id="yiyi-73">This handler is not appropriate for use under Windows, because under Windows open log files cannot be moved or renamed - logging opens the files with exclusive locks - and so there is no need for such a handler. </span><span class="yiyi-st" id="yiyi-74">Furthermore, <em>ST_INO</em> is not supported under Windows; <a class="reference internal" href="os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a> always returns zero for this value.</span></p><dl class="class"><dt id="logging.handlers.WatchedFileHandler"><span class="yiyi-st" id="yiyi-75"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">WatchedFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-76">Returns a new instance of the <a class="reference internal" href="#logging.handlers.WatchedFileHandler" title="logging.handlers.WatchedFileHandler"><code class="xref py py-class docutils literal"><span class="pre">WatchedFileHandler</span></code></a> class. </span><span class="yiyi-st" id="yiyi-77">The specified file is opened and used as the stream for logging. </span><span class="yiyi-st" id="yiyi-78">If <em>mode</em> is not specified, <code class="xref py py-const docutils literal"><span class="pre">'a'</span></code> is used. </span><span class="yiyi-st" id="yiyi-79">If <em>encoding</em> is not <em>None</em>, it is used to open the file with that encoding. </span><span class="yiyi-st" id="yiyi-80">If <em>delay</em> is true, then file opening is deferred until the first call to <a class="reference internal" href="#logging.handlers.WatchedFileHandler.emit" title="logging.handlers.WatchedFileHandler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a>. </span><span class="yiyi-st" id="yiyi-81">By default, the file grows indefinitely.</span></p><dl class="method"><dt id="logging.handlers.WatchedFileHandler.emit"><span class="yiyi-st" id="yiyi-82"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">Outputs the record to the file, but first checks to see if the file has changed. </span><span class="yiyi-st" id="yiyi-84">If it has, the existing stream is flushed and closed and the file opened again, before outputting the record to the file.</span></p></dd></dl></dd></dl></div><div class="section" id="baserotatinghandler"><h2><span class="yiyi-st" id="yiyi-85">16.8.5. </span><span class="yiyi-st" id="yiyi-86">BaseRotatingHandler</span></h2><p><span class="yiyi-st" id="yiyi-87">The <a class="reference internal" href="#logging.handlers.BaseRotatingHandler" title="logging.handlers.BaseRotatingHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseRotatingHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, is the base class for the rotating file handlers, <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></code></a> and <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code></a>. </span><span class="yiyi-st" id="yiyi-88">You should not need to instantiate this class, but it has attributes and methods you may need to override.</span></p><dl class="class"><dt id="logging.handlers.BaseRotatingHandler"><span class="yiyi-st" id="yiyi-89"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">BaseRotatingHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">The parameters are as for <code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code>. </span><span class="yiyi-st" id="yiyi-91">The attributes are:</span></p><dl class="attribute"><dt id="logging.handlers.BaseRotatingHandler.namer"><span class="yiyi-st" id="yiyi-92"> <code class="descname">namer</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-93">If this attribute is set to a callable, the <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="logging.handlers.BaseRotatingHandler.rotation_filename"><code class="xref py py-meth docutils literal"><span class="pre">rotation_filename()</span></code></a> method delegates to this callable. </span><span class="yiyi-st" id="yiyi-94">The parameters passed to the callable are those passed to <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="logging.handlers.BaseRotatingHandler.rotation_filename"><code class="xref py py-meth docutils literal"><span class="pre">rotation_filename()</span></code></a>.</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-95">Note</span></p><p class="last"><span class="yiyi-st" id="yiyi-96">The namer function is called quite a few times during rollover, so it should be as simple and as fast as possible. </span><span class="yiyi-st" id="yiyi-97">It should also return the same output every time for a given input, otherwise the rollover behaviour may not work as expected.</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-98"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="attribute"><dt id="logging.handlers.BaseRotatingHandler.rotator"><span class="yiyi-st" id="yiyi-99"> <code class="descname">rotator</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-100">If this attribute is set to a callable, the <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotate" title="logging.handlers.BaseRotatingHandler.rotate"><code class="xref py py-meth docutils literal"><span class="pre">rotate()</span></code></a> method delegates to this callable. </span><span class="yiyi-st" id="yiyi-101">The parameters passed to the callable are those passed to <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotate" title="logging.handlers.BaseRotatingHandler.rotate"><code class="xref py py-meth docutils literal"><span class="pre">rotate()</span></code></a>.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-102"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="method"><dt id="logging.handlers.BaseRotatingHandler.rotation_filename"><span class="yiyi-st" id="yiyi-103"> <code class="descname">rotation_filename</code><span class="sig-paren">(</span><em>default_name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">Modify the filename of a log file when rotating.</span></p><p><span class="yiyi-st" id="yiyi-105">This is provided so that a custom filename can be provided.</span></p><p><span class="yiyi-st" id="yiyi-106">The default implementation calls the ‘namer’ attribute of the handler, if it’s callable, passing the default name to it. </span><span class="yiyi-st" id="yiyi-107">If the attribute isn’t callable (the default is <code class="docutils literal"><span class="pre">None</span></code>), the name is returned unchanged.</span></p><table class="docutils field-list" frame="void" rules="none"><tbody valign="top"><tr class="field-odd field"><th class="field-name"><span class="yiyi-st" id="yiyi-108">Parameters:</span></th><td class="field-body"><span class="yiyi-st" id="yiyi-109"><strong>default_name</strong> – The default name for the log file.</span></td></tr></tbody></table><div class="versionadded"><p><span class="yiyi-st" id="yiyi-110"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl><dl class="method"><dt id="logging.handlers.BaseRotatingHandler.rotate"><span class="yiyi-st" id="yiyi-111"> <code class="descname">rotate</code><span class="sig-paren">(</span><em>source</em>, <em>dest</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-112">When rotating, rotate the current log.</span></p><p><span class="yiyi-st" id="yiyi-113">The default implementation calls the ‘rotator’ attribute of the handler, if it’s callable, passing the source and dest arguments to it. </span><span class="yiyi-st" id="yiyi-114">If the attribute isn’t callable (the default is <code class="docutils literal"><span class="pre">None</span></code>), the source is simply renamed to the destination.</span></p><table class="docutils field-list" frame="void" rules="none"><tbody valign="top"><tr class="field-odd field"><th class="field-name"><span class="yiyi-st" id="yiyi-115">Parameters:</span></th><td class="field-body"><ul class="first last simple"><li><span class="yiyi-st" id="yiyi-116"><strong>source</strong> – The source filename. </span><span class="yiyi-st" id="yiyi-117">This is normally the base filename, e.g. </span><span class="yiyi-st" id="yiyi-118">‘test.log’.</span></li><li><span class="yiyi-st" id="yiyi-119"><strong>dest</strong> – The destination filename. </span><span class="yiyi-st" id="yiyi-120">This is normally what the source is rotated to, e.g. </span><span class="yiyi-st" id="yiyi-121">‘test.log.1’.</span></li></ul></td></tr></tbody></table><div class="versionadded"><p><span class="yiyi-st" id="yiyi-122"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl></dd></dl><p><span class="yiyi-st" id="yiyi-123">The reason the attributes exist is to save you having to subclass - you can use the same callables for instances of <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></code></a> and <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code></a>. </span><span class="yiyi-st" id="yiyi-124">If either the namer or rotator callable raises an exception, this will be handled in the same way as any other exception during an <code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code> call, i.e. </span><span class="yiyi-st" id="yiyi-125">via the <code class="xref py py-meth docutils literal"><span class="pre">handleError()</span></code> method of the handler.</span></p><p><span class="yiyi-st" id="yiyi-126">If you need to make more significant changes to rotation processing, you can override the methods.</span></p><p><span class="yiyi-st" id="yiyi-127">For an example, see <a class="reference internal" href="../howto/logging-cookbook.html#cookbook-rotator-namer"><span>Using a rotator and namer to customize log rotation processing</span></a>.</span></p></div><div class="section" id="rotatingfilehandler"><h2><span class="yiyi-st" id="yiyi-128">16.8.6. </span><span class="yiyi-st" id="yiyi-129">RotatingFileHandler</span></h2><p><span class="yiyi-st" id="yiyi-130">The <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, supports rotation of disk log files.</span></p><dl class="class"><dt id="logging.handlers.RotatingFileHandler"><span class="yiyi-st" id="yiyi-131"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">RotatingFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>maxBytes=0</em>, <em>backupCount=0</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-132">Returns a new instance of the <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></code></a> class. </span><span class="yiyi-st" id="yiyi-133">The specified file is opened and used as the stream for logging. </span><span class="yiyi-st" id="yiyi-134">If <em>mode</em> is not specified, <code class="docutils literal"><span class="pre">'a'</span></code> is used. </span><span class="yiyi-st" id="yiyi-135">If <em>encoding</em> is not <em>None</em>, it is used to open the file with that encoding. </span><span class="yiyi-st" id="yiyi-136">If <em>delay</em> is true, then file opening is deferred until the first call to <a class="reference internal" href="#logging.handlers.RotatingFileHandler.emit" title="logging.handlers.RotatingFileHandler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a>. </span><span class="yiyi-st" id="yiyi-137">By default, the file grows indefinitely.</span></p><p><span class="yiyi-st" id="yiyi-138">You can use the <em>maxBytes</em> and <em>backupCount</em> values to allow the file to <em class="dfn">rollover</em> at a predetermined size. </span><span class="yiyi-st" id="yiyi-139">When the size is about to be exceeded, the file is closed and a new file is silently opened for output. </span><span class="yiyi-st" id="yiyi-140">Rollover occurs whenever the current log file is nearly <em>maxBytes</em> in length; if either of <em>maxBytes</em> or <em>backupCount</em> is zero, rollover never occurs. </span><span class="yiyi-st" id="yiyi-141">If <em>backupCount</em> is non-zero, the system will save old log files by appending the extensions ‘.1’, ‘.2’ etc., to the filename. </span><span class="yiyi-st" id="yiyi-142">For example, with a <em>backupCount</em> of 5 and a base file name of <code class="file docutils literal"><span class="pre">app.log</span></code>, you would get <code class="file docutils literal"><span class="pre">app.log</span></code>, <code class="file docutils literal"><span class="pre">app.log.1</span></code>, <code class="file docutils literal"><span class="pre">app.log.2</span></code>, up to <code class="file docutils literal"><span class="pre">app.log.5</span></code>. </span><span class="yiyi-st" id="yiyi-143">The file being written to is always <code class="file docutils literal"><span class="pre">app.log</span></code>. </span><span class="yiyi-st" id="yiyi-144">When this file is filled, it is closed and renamed to <code class="file docutils literal"><span class="pre">app.log.1</span></code>, and if files <code class="file docutils literal"><span class="pre">app.log.1</span></code>, <code class="file docutils literal"><span class="pre">app.log.2</span></code>, etc. </span><span class="yiyi-st" id="yiyi-145">exist, then they are renamed to <code class="file docutils literal"><span class="pre">app.log.2</span></code>, <code class="file docutils literal"><span class="pre">app.log.3</span></code> etc. </span><span class="yiyi-st" id="yiyi-146">respectively.</span></p><dl class="method"><dt id="logging.handlers.RotatingFileHandler.doRollover"><span class="yiyi-st" id="yiyi-147"> <code class="descname">doRollover</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-148">Does a rollover, as described above.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.RotatingFileHandler.emit"><span class="yiyi-st" id="yiyi-149"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-150">Outputs the record to the file, catering for rollover as described previously.</span></p></dd></dl></dd></dl></div><div class="section" id="timedrotatingfilehandler"><h2><span class="yiyi-st" id="yiyi-151">16.8.7. </span><span class="yiyi-st" id="yiyi-152">TimedRotatingFileHandler</span></h2><p><span class="yiyi-st" id="yiyi-153">The <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, supports rotation of disk log files at certain timed intervals.</span></p><dl class="class"><dt id="logging.handlers.TimedRotatingFileHandler"><span class="yiyi-st" id="yiyi-154"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">TimedRotatingFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>when='h'</em>, <em>interval=1</em>, <em>backupCount=0</em>, <em>encoding=None</em>, <em>delay=False</em>, <em>utc=False</em>, <em>atTime=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-155">Returns a new instance of the <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code></a> class. </span><span class="yiyi-st" id="yiyi-156">The specified file is opened and used as the stream for logging. </span><span class="yiyi-st" id="yiyi-157">On rotating it also sets the filename suffix. </span><span class="yiyi-st" id="yiyi-158">Rotating happens based on the product of <em>when</em> and <em>interval</em>.</span></p><p><span class="yiyi-st" id="yiyi-159">You can use the <em>when</em> to specify the type of <em>interval</em>. </span><span class="yiyi-st" id="yiyi-160">The list of possible values is below. </span><span class="yiyi-st" id="yiyi-161">Note that they are not case sensitive.</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-162">Value</span></th><th class="head"><span class="yiyi-st" id="yiyi-163">Type of interval</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-164"><code class="docutils literal"><span class="pre">'S'</span></code></span></td><td><span class="yiyi-st" id="yiyi-165">Seconds</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-166"><code class="docutils literal"><span class="pre">'M'</span></code></span></td><td><span class="yiyi-st" id="yiyi-167">Minutes</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-168"><code class="docutils literal"><span class="pre">'H'</span></code></span></td><td><span class="yiyi-st" id="yiyi-169">Hours</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-170"><code class="docutils literal"><span class="pre">'D'</span></code></span></td><td><span class="yiyi-st" id="yiyi-171">Days</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-172"><code class="docutils literal"><span class="pre">'W0'-'W6'</span></code></span></td><td><span class="yiyi-st" id="yiyi-173">Weekday (0=Monday)</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-174"><code class="docutils literal"><span class="pre">'midnight'</span></code></span></td><td><span class="yiyi-st" id="yiyi-175">Roll over at midnight</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-176">When using weekday-based rotation, specify ‘W0’ for Monday, ‘W1’ for Tuesday, and so on up to ‘W6’ for Sunday. </span><span class="yiyi-st" id="yiyi-177">In this case, the value passed for <em>interval</em> isn’t used.</span></p><p><span class="yiyi-st" id="yiyi-178">The system will save old log files by appending extensions to the filename. </span><span class="yiyi-st" id="yiyi-179">The extensions are date-and-time based, using the strftime format <code class="docutils literal"><span class="pre">%Y-%m-%d_%H-%M-%S</span></code> or a leading portion thereof, depending on the rollover interval.</span></p><p><span class="yiyi-st" id="yiyi-180">When computing the next rollover time for the first time (when the handler is created), the last modification time of an existing log file, or else the current time, is used to compute when the next rotation will occur.</span></p><p><span class="yiyi-st" id="yiyi-181">If the <em>utc</em> argument is true, times in UTC will be used; otherwise local time is used.</span></p><p><span class="yiyi-st" id="yiyi-182">If <em>backupCount</em> is nonzero, at most <em>backupCount</em> files will be kept, and if more would be created when rollover occurs, the oldest one is deleted. </span><span class="yiyi-st" id="yiyi-183">The deletion logic uses the interval to determine which files to delete, so changing the interval may leave old files lying around.</span></p><p><span class="yiyi-st" id="yiyi-184">If <em>delay</em> is true, then file opening is deferred until the first call to <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler.emit" title="logging.handlers.TimedRotatingFileHandler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-185">If <em>atTime</em> is not <code class="docutils literal"><span class="pre">None</span></code>, it must be a <code class="docutils literal"><span class="pre">datetime.time</span></code> instance which specifies the time of day when rollover occurs, for the cases where rollover is set to happen “at midnight” or “on a particular weekday”.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-186"><span class="versionmodified">Changed in version 3.4: </span><em>atTime</em> parameter was added.</span></p></div><dl class="method"><dt id="logging.handlers.TimedRotatingFileHandler.doRollover"><span class="yiyi-st" id="yiyi-187"> <code class="descname">doRollover</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-188">Does a rollover, as described above.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.TimedRotatingFileHandler.emit"><span class="yiyi-st" id="yiyi-189"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-190">Outputs the record to the file, catering for rollover as described above.</span></p></dd></dl></dd></dl></div><div class="section" id="sockethandler"><h2><span class="yiyi-st" id="yiyi-191">16.8.8. </span><span class="yiyi-st" id="yiyi-192">SocketHandler</span></h2><p><span class="yiyi-st" id="yiyi-193">The <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal"><span class="pre">SocketHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, sends logging output to a network socket. </span><span class="yiyi-st" id="yiyi-194">The base class uses a TCP socket.</span></p><dl class="class"><dt id="logging.handlers.SocketHandler"><span class="yiyi-st" id="yiyi-195"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SocketHandler</code><span class="sig-paren">(</span><em>host</em>, <em>port</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-196">Returns a new instance of the <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal"><span class="pre">SocketHandler</span></code></a> class intended to communicate with a remote machine whose address is given by <em>host</em> and <em>port</em>.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-197"><span class="versionmodified">Changed in version 3.4: </span>If <code class="docutils literal"><span class="pre">port</span></code> is specified as <code class="docutils literal"><span class="pre">None</span></code>, a Unix domain socket is created using the value in <code class="docutils literal"><span class="pre">host</span></code> - otherwise, a TCP socket is created.</span></p></div><dl class="method"><dt id="logging.handlers.SocketHandler.close"><span class="yiyi-st" id="yiyi-198"> <code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-199">Closes the socket.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.SocketHandler.emit"><span class="yiyi-st" id="yiyi-200"> <code class="descname">emit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-201">Pickles the record’s attribute dictionary and writes it to the socket in binary format. </span><span class="yiyi-st" id="yiyi-202">If there is an error with the socket, silently drops the packet. </span><span class="yiyi-st" id="yiyi-203">If the connection was previously lost, re-establishes the connection. </span><span class="yiyi-st" id="yiyi-204">To unpickle the record at the receiving end into a <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a>, use the <a class="reference internal" href="logging.html#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal"><span class="pre">makeLogRecord()</span></code></a> function.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.SocketHandler.handleError"><span class="yiyi-st" id="yiyi-205"> <code class="descname">handleError</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-206">Handles an error which has occurred during <a class="reference internal" href="#logging.handlers.SocketHandler.emit" title="logging.handlers.SocketHandler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a>. </span><span class="yiyi-st" id="yiyi-207">The most likely cause is a lost connection. </span><span class="yiyi-st" id="yiyi-208">Closes the socket so that we can retry on the next event.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.SocketHandler.makeSocket"><span class="yiyi-st" id="yiyi-209"> <code class="descname">makeSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-210">This is a factory method which allows subclasses to define the precise type of socket they want. </span><span class="yiyi-st" id="yiyi-211">The default implementation creates a TCP socket (<a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_STREAM</span></code></a>).</span></p></dd></dl><dl class="method"><dt id="logging.handlers.SocketHandler.makePickle"><span class="yiyi-st" id="yiyi-212"> <code class="descname">makePickle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-213">Pickles the record’s attribute dictionary in binary format with a length prefix, and returns it ready for transmission across the socket.</span></p><p><span class="yiyi-st" id="yiyi-214">Note that pickles aren’t completely secure. </span><span class="yiyi-st" id="yiyi-215">If you are concerned about security, you may want to override this method to implement a more secure mechanism. </span><span class="yiyi-st" id="yiyi-216">For example, you can sign pickles using HMAC and then verify them on the receiving end, or alternatively you can disable unpickling of global objects on the receiving end.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.SocketHandler.send"><span class="yiyi-st" id="yiyi-217"> <code class="descname">send</code><span class="sig-paren">(</span><em>packet</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-218">Send a pickled string <em>packet</em> to the socket. </span><span class="yiyi-st" id="yiyi-219">This function allows for partial sends which can happen when the network is busy.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.SocketHandler.createSocket"><span class="yiyi-st" id="yiyi-220"> <code class="descname">createSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-221">Tries to create a socket; on failure, uses an exponential back-off algorithm. </span><span class="yiyi-st" id="yiyi-222">On initial failure, the handler will drop the message it was trying to send. </span><span class="yiyi-st" id="yiyi-223">When subsequent messages are handled by the same instance, it will not try connecting until some time has passed. </span><span class="yiyi-st" id="yiyi-224">The default parameters are such that the initial delay is one second, and if after that delay the connection still can’t be made, the handler will double the delay each time up to a maximum of 30 seconds.</span></p><p><span class="yiyi-st" id="yiyi-225">This behaviour is controlled by the following handler attributes:</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-226"><code class="docutils literal"><span class="pre">retryStart</span></code> (initial delay, defaulting to 1.0 seconds).</span></li><li><span class="yiyi-st" id="yiyi-227"><code class="docutils literal"><span class="pre">retryFactor</span></code> (multiplier, defaulting to 2.0).</span></li><li><span class="yiyi-st" id="yiyi-228"><code class="docutils literal"><span class="pre">retryMax</span></code> (maximum delay, defaulting to 30.0 seconds).</span></li></ul><p><span class="yiyi-st" id="yiyi-229">This means that if the remote listener starts up <em>after</em> the handler has been used, you could lose messages (since the handler won’t even attempt a connection until the delay has elapsed, but just silently drop messages during the delay period).</span></p></dd></dl></dd></dl></div><div class="section" id="datagramhandler"><h2><span class="yiyi-st" id="yiyi-230">16.8.9. </span><span class="yiyi-st" id="yiyi-231">DatagramHandler</span></h2><p><span class="yiyi-st" id="yiyi-232">The <a class="reference internal" href="#logging.handlers.DatagramHandler" title="logging.handlers.DatagramHandler"><code class="xref py py-class docutils literal"><span class="pre">DatagramHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, inherits from <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal"><span class="pre">SocketHandler</span></code></a> to support sending logging messages over UDP sockets.</span></p><dl class="class"><dt id="logging.handlers.DatagramHandler"><span class="yiyi-st" id="yiyi-233"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">DatagramHandler</code><span class="sig-paren">(</span><em>host</em>, <em>port</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-234">Returns a new instance of the <a class="reference internal" href="#logging.handlers.DatagramHandler" title="logging.handlers.DatagramHandler"><code class="xref py py-class docutils literal"><span class="pre">DatagramHandler</span></code></a> class intended to communicate with a remote machine whose address is given by <em>host</em> and <em>port</em>.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-235"><span class="versionmodified">Changed in version 3.4: </span>If <code class="docutils literal"><span class="pre">port</span></code> is specified as <code class="docutils literal"><span class="pre">None</span></code>, a Unix domain socket is created using the value in <code class="docutils literal"><span class="pre">host</span></code> - otherwise, a TCP socket is created.</span></p></div><dl class="method"><dt id="logging.handlers.DatagramHandler.emit"><span class="yiyi-st" id="yiyi-236"> <code class="descname">emit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-237">Pickles the record’s attribute dictionary and writes it to the socket in binary format. </span><span class="yiyi-st" id="yiyi-238">If there is an error with the socket, silently drops the packet. </span><span class="yiyi-st" id="yiyi-239">To unpickle the record at the receiving end into a <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a>, use the <a class="reference internal" href="logging.html#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal"><span class="pre">makeLogRecord()</span></code></a> function.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.DatagramHandler.makeSocket"><span class="yiyi-st" id="yiyi-240"> <code class="descname">makeSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-241">The factory method of <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal"><span class="pre">SocketHandler</span></code></a> is here overridden to create a UDP socket (<a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_DGRAM</span></code></a>).</span></p></dd></dl><dl class="method"><dt id="logging.handlers.DatagramHandler.send"><span class="yiyi-st" id="yiyi-242"> <code class="descname">send</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-243">Send a pickled string to a socket.</span></p></dd></dl></dd></dl></div><div class="section" id="sysloghandler"><h2><span class="yiyi-st" id="yiyi-244">16.8.10. </span><span class="yiyi-st" id="yiyi-245">SysLogHandler</span></h2><p><span class="yiyi-st" id="yiyi-246">The <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal"><span class="pre">SysLogHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, supports sending logging messages to a remote or local Unix syslog.</span></p><dl class="class"><dt id="logging.handlers.SysLogHandler"><span class="yiyi-st" id="yiyi-247"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SysLogHandler</code><span class="sig-paren">(</span><em>address=('localhost'</em>, <em>SYSLOG_UDP_PORT)</em>, <em>facility=LOG_USER</em>, <em>socktype=socket.SOCK_DGRAM</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-248">Returns a new instance of the <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal"><span class="pre">SysLogHandler</span></code></a> class intended to communicate with a remote Unix machine whose address is given by <em>address</em> in the form of a <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code> tuple. </span><span class="yiyi-st" id="yiyi-249">If <em>address</em> is not specified, <code class="docutils literal"><span class="pre">('localhost',</span> <span class="pre">514)</span></code> is used. </span><span class="yiyi-st" id="yiyi-250">The address is used to open a socket. </span><span class="yiyi-st" id="yiyi-251">An alternative to providing a <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code> tuple is providing an address as a string, for example ‘/dev/log’. </span><span class="yiyi-st" id="yiyi-252">In this case, a Unix domain socket is used to send the message to the syslog. </span><span class="yiyi-st" id="yiyi-253">If <em>facility</em> is not specified, <code class="xref py py-const docutils literal"><span class="pre">LOG_USER</span></code> is used. </span><span class="yiyi-st" id="yiyi-254">The type of socket opened depends on the <em>socktype</em> argument, which defaults to <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_DGRAM</span></code></a> and thus opens a UDP socket. </span><span class="yiyi-st" id="yiyi-255">To open a TCP socket (for use with the newer syslog daemons such as rsyslog), specify a value of <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_STREAM</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-256">Note that if your server is not listening on UDP port 514, <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal"><span class="pre">SysLogHandler</span></code></a> may appear not to work. </span><span class="yiyi-st" id="yiyi-257">In that case, check what address you should be using for a domain socket - it’s system dependent. </span><span class="yiyi-st" id="yiyi-258">For example, on Linux it’s usually ‘/dev/log’ but on OS/X it’s ‘/var/run/syslog’. </span><span class="yiyi-st" id="yiyi-259">You’ll need to check your platform and use the appropriate address (you may need to do this check at runtime if your application needs to run on several platforms). </span><span class="yiyi-st" id="yiyi-260">On Windows, you pretty much have to use the UDP option.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-261"><span class="versionmodified">Changed in version 3.2: </span><em>socktype</em> was added.</span></p></div><dl class="method"><dt id="logging.handlers.SysLogHandler.close"><span class="yiyi-st" id="yiyi-262"> <code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-263">Closes the socket to the remote host.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.SysLogHandler.emit"><span class="yiyi-st" id="yiyi-264"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-265">The record is formatted, and then sent to the syslog server. </span><span class="yiyi-st" id="yiyi-266">If exception information is present, it is <em>not</em> sent to the server.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-267"><span class="versionmodified">Changed in version 3.2.1: </span>(See: <a class="reference external" href="https://bugs.python.org/issue12168">issue 12168</a>.) </span><span class="yiyi-st" id="yiyi-268">In earlier versions, the message sent to the syslog daemons was always terminated with a NUL byte, because early versions of these daemons expected a NUL terminated message - even though it’s not in the relevant specification (RFC 5424). </span><span class="yiyi-st" id="yiyi-269">More recent versions of these daemons don’t expect the NUL byte but strip it off if it’s there, and even more recent daemons (which adhere more closely to RFC 5424) pass the NUL byte on as part of the message.</span></p><p><span class="yiyi-st" id="yiyi-270">To enable easier handling of syslog messages in the face of all these differing daemon behaviours, the appending of the NUL byte has been made configurable, through the use of a class-level attribute, <code class="docutils literal"><span class="pre">append_nul</span></code>. </span><span class="yiyi-st" id="yiyi-271">This defaults to <code class="docutils literal"><span class="pre">True</span></code> (preserving the existing behaviour) but can be set to <code class="docutils literal"><span class="pre">False</span></code> on a <code class="docutils literal"><span class="pre">SysLogHandler</span></code> instance in order for that instance to <em>not</em> append the NUL terminator.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-272"><span class="versionmodified">Changed in version 3.3: </span>(See: <a class="reference external" href="https://bugs.python.org/issue12419">issue 12419</a>.) </span><span class="yiyi-st" id="yiyi-273">In earlier versions, there was no facility for an “ident” or “tag” prefix to identify the source of the message. </span><span class="yiyi-st" id="yiyi-274">This can now be specified using a class-level attribute, defaulting to <code class="docutils literal"><span class="pre">""</span></code> to preserve existing behaviour, but which can be overridden on a <code class="docutils literal"><span class="pre">SysLogHandler</span></code> instance in order for that instance to prepend the ident to every message handled. </span><span class="yiyi-st" id="yiyi-275">Note that the provided ident must be text, not bytes, and is prepended to the message exactly as is.</span></p></div></dd></dl><dl class="method"><dt id="logging.handlers.SysLogHandler.encodePriority"><span class="yiyi-st" id="yiyi-276"> <code class="descname">encodePriority</code><span class="sig-paren">(</span><em>facility</em>, <em>priority</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-277">Encodes the facility and priority into an integer. </span><span class="yiyi-st" id="yiyi-278">You can pass in strings or integers - if strings are passed, internal mapping dictionaries are used to convert them to integers.</span></p><p><span class="yiyi-st" id="yiyi-279">The symbolic <code class="docutils literal"><span class="pre">LOG_</span></code> values are defined in <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal"><span class="pre">SysLogHandler</span></code></a> and mirror the values defined in the <code class="docutils literal"><span class="pre">sys/syslog.h</span></code> header file.</span></p><p><span class="yiyi-st" id="yiyi-280"><strong>Priorities</strong></span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-281">Name (string)</span></th><th class="head"><span class="yiyi-st" id="yiyi-282">Symbolic value</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-283"><code class="docutils literal"><span class="pre">alert</span></code></span></td><td><span class="yiyi-st" id="yiyi-284">LOG_ALERT</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-285"><code class="docutils literal"><span class="pre">crit</span></code> or <code class="docutils literal"><span class="pre">critical</span></code></span></td><td><span class="yiyi-st" id="yiyi-286">LOG_CRIT</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-287"><code class="docutils literal"><span class="pre">debug</span></code></span></td><td><span class="yiyi-st" id="yiyi-288">LOG_DEBUG</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-289"><code class="docutils literal"><span class="pre">emerg</span></code> or <code class="docutils literal"><span class="pre">panic</span></code></span></td><td><span class="yiyi-st" id="yiyi-290">LOG_EMERG</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-291"><code class="docutils literal"><span class="pre">err</span></code> or <code class="docutils literal"><span class="pre">error</span></code></span></td><td><span class="yiyi-st" id="yiyi-292">LOG_ERR</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-293"><code class="docutils literal"><span class="pre">info</span></code></span></td><td><span class="yiyi-st" id="yiyi-294">LOG_INFO</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-295"><code class="docutils literal"><span class="pre">notice</span></code></span></td><td><span class="yiyi-st" id="yiyi-296">LOG_NOTICE</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-297"><code class="docutils literal"><span class="pre">warn</span></code> or <code class="docutils literal"><span class="pre">warning</span></code></span></td><td><span class="yiyi-st" id="yiyi-298">LOG_WARNING</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-299"><strong>Facilities</strong></span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-300">Name (string)</span></th><th class="head"><span class="yiyi-st" id="yiyi-301">Symbolic value</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-302"><code class="docutils literal"><span class="pre">auth</span></code></span></td><td><span class="yiyi-st" id="yiyi-303">LOG_AUTH</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-304"><code class="docutils literal"><span class="pre">authpriv</span></code></span></td><td><span class="yiyi-st" id="yiyi-305">LOG_AUTHPRIV</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-306"><code class="docutils literal"><span class="pre">cron</span></code></span></td><td><span class="yiyi-st" id="yiyi-307">LOG_CRON</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-308"><code class="docutils literal"><span class="pre">daemon</span></code></span></td><td><span class="yiyi-st" id="yiyi-309">LOG_DAEMON</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-310"><code class="docutils literal"><span class="pre">ftp</span></code></span></td><td><span class="yiyi-st" id="yiyi-311">LOG_FTP</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-312"><code class="docutils literal"><span class="pre">kern</span></code></span></td><td><span class="yiyi-st" id="yiyi-313">LOG_KERN</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-314"><code class="docutils literal"><span class="pre">lpr</span></code></span></td><td><span class="yiyi-st" id="yiyi-315">LOG_LPR</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-316"><code class="docutils literal"><span class="pre">mail</span></code></span></td><td><span class="yiyi-st" id="yiyi-317">LOG_MAIL</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-318"><code class="docutils literal"><span class="pre">news</span></code></span></td><td><span class="yiyi-st" id="yiyi-319">LOG_NEWS</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-320"><code class="docutils literal"><span class="pre">syslog</span></code></span></td><td><span class="yiyi-st" id="yiyi-321">LOG_SYSLOG</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-322"><code class="docutils literal"><span class="pre">user</span></code></span></td><td><span class="yiyi-st" id="yiyi-323">LOG_USER</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-324"><code class="docutils literal"><span class="pre">uucp</span></code></span></td><td><span class="yiyi-st" id="yiyi-325">LOG_UUCP</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-326"><code class="docutils literal"><span class="pre">local0</span></code></span></td><td><span class="yiyi-st" id="yiyi-327">LOG_LOCAL0</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-328"><code class="docutils literal"><span class="pre">local1</span></code></span></td><td><span class="yiyi-st" id="yiyi-329">LOG_LOCAL1</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-330"><code class="docutils literal"><span class="pre">local2</span></code></span></td><td><span class="yiyi-st" id="yiyi-331">LOG_LOCAL2</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-332"><code class="docutils literal"><span class="pre">local3</span></code></span></td><td><span class="yiyi-st" id="yiyi-333">LOG_LOCAL3</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-334"><code class="docutils literal"><span class="pre">local4</span></code></span></td><td><span class="yiyi-st" id="yiyi-335">LOG_LOCAL4</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-336"><code class="docutils literal"><span class="pre">local5</span></code></span></td><td><span class="yiyi-st" id="yiyi-337">LOG_LOCAL5</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-338"><code class="docutils literal"><span class="pre">local6</span></code></span></td><td><span class="yiyi-st" id="yiyi-339">LOG_LOCAL6</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-340"><code class="docutils literal"><span class="pre">local7</span></code></span></td><td><span class="yiyi-st" id="yiyi-341">LOG_LOCAL7</span></td></tr></tbody></table></dd></dl><dl class="method"><dt id="logging.handlers.SysLogHandler.mapPriority"><span class="yiyi-st" id="yiyi-342"> <code class="descname">mapPriority</code><span class="sig-paren">(</span><em>levelname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-343">Maps a logging level name to a syslog priority name. </span><span class="yiyi-st" id="yiyi-344">You may need to override this if you are using custom levels, or if the default algorithm is not suitable for your needs. </span><span class="yiyi-st" id="yiyi-345">The default algorithm maps <code class="docutils literal"><span class="pre">DEBUG</span></code>, <code class="docutils literal"><span class="pre">INFO</span></code>, <code class="docutils literal"><span class="pre">WARNING</span></code>, <code class="docutils literal"><span class="pre">ERROR</span></code> and <code class="docutils literal"><span class="pre">CRITICAL</span></code> to the equivalent syslog names, and all other level names to ‘warning’.</span></p></dd></dl></dd></dl></div><div class="section" id="nteventloghandler"><h2><span class="yiyi-st" id="yiyi-346">16.8.11. </span><span class="yiyi-st" id="yiyi-347">NTEventLogHandler</span></h2><p><span class="yiyi-st" id="yiyi-348">The <a class="reference internal" href="#logging.handlers.NTEventLogHandler" title="logging.handlers.NTEventLogHandler"><code class="xref py py-class docutils literal"><span class="pre">NTEventLogHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, supports sending logging messages to a local Windows NT, Windows 2000 or Windows XP event log. </span><span class="yiyi-st" id="yiyi-349">Before you can use it, you need Mark Hammond’s Win32 extensions for Python installed.</span></p><dl class="class"><dt id="logging.handlers.NTEventLogHandler"><span class="yiyi-st" id="yiyi-350"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">NTEventLogHandler</code><span class="sig-paren">(</span><em>appname</em>, <em>dllname=None</em>, <em>logtype='Application'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-351">Returns a new instance of the <a class="reference internal" href="#logging.handlers.NTEventLogHandler" title="logging.handlers.NTEventLogHandler"><code class="xref py py-class docutils literal"><span class="pre">NTEventLogHandler</span></code></a> class. </span><span class="yiyi-st" id="yiyi-352">The <em>appname</em> is used to define the application name as it appears in the event log. </span><span class="yiyi-st" id="yiyi-353">An appropriate registry entry is created using this name. </span><span class="yiyi-st" id="yiyi-354">The <em>dllname</em> should give the fully qualified pathname of a .dll or .exe which contains message definitions to hold in the log (if not specified, <code class="docutils literal"><span class="pre">'win32service.pyd'</span></code> is used - this is installed with the Win32 extensions and contains some basic placeholder message definitions. </span><span class="yiyi-st" id="yiyi-355">Note that use of these placeholders will make your event logs big, as the entire message source is held in the log. </span><span class="yiyi-st" id="yiyi-356">If you want slimmer logs, you have to pass in the name of your own .dll or .exe which contains the message definitions you want to use in the event log). </span><span class="yiyi-st" id="yiyi-357">The <em>logtype</em> is one of <code class="docutils literal"><span class="pre">'Application'</span></code>, <code class="docutils literal"><span class="pre">'System'</span></code> or <code class="docutils literal"><span class="pre">'Security'</span></code>, and defaults to <code class="docutils literal"><span class="pre">'Application'</span></code>.</span></p><dl class="method"><dt id="logging.handlers.NTEventLogHandler.close"><span class="yiyi-st" id="yiyi-358"> <code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-359">At this point, you can remove the application name from the registry as a source of event log entries. </span><span class="yiyi-st" id="yiyi-360">However, if you do this, you will not be able to see the events as you intended in the Event Log Viewer - it needs to be able to access the registry to get the .dll name. </span><span class="yiyi-st" id="yiyi-361">The current version does not do this.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.NTEventLogHandler.emit"><span class="yiyi-st" id="yiyi-362"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-363">Determines the message ID, event category and event type, and then logs the message in the NT event log.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.NTEventLogHandler.getEventCategory"><span class="yiyi-st" id="yiyi-364"> <code class="descname">getEventCategory</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-365">Returns the event category for the record. </span><span class="yiyi-st" id="yiyi-366">Override this if you want to specify your own categories. </span><span class="yiyi-st" id="yiyi-367">This version returns 0.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.NTEventLogHandler.getEventType"><span class="yiyi-st" id="yiyi-368"> <code class="descname">getEventType</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-369">Returns the event type for the record. </span><span class="yiyi-st" id="yiyi-370">Override this if you want to specify your own types. </span><span class="yiyi-st" id="yiyi-371">This version does a mapping using the handler’s typemap attribute, which is set up in <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> to a dictionary which contains mappings for <code class="xref py py-const docutils literal"><span class="pre">DEBUG</span></code>, <code class="xref py py-const docutils literal"><span class="pre">INFO</span></code>, <code class="xref py py-const docutils literal"><span class="pre">WARNING</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ERROR</span></code> and <code class="xref py py-const docutils literal"><span class="pre">CRITICAL</span></code>. </span><span class="yiyi-st" id="yiyi-372">If you are using your own levels, you will either need to override this method or place a suitable dictionary in the handler’s <em>typemap</em> attribute.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.NTEventLogHandler.getMessageID"><span class="yiyi-st" id="yiyi-373"> <code class="descname">getMessageID</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-374">Returns the message ID for the record. </span><span class="yiyi-st" id="yiyi-375">If you are using your own messages, you could do this by having the <em>msg</em> passed to the logger being an ID rather than a format string. </span><span class="yiyi-st" id="yiyi-376">Then, in here, you could use a dictionary lookup to get the message ID. </span><span class="yiyi-st" id="yiyi-377">This version returns 1, which is the base message ID in <code class="file docutils literal"><span class="pre">win32service.pyd</span></code>.</span></p></dd></dl></dd></dl></div><div class="section" id="smtphandler"><h2><span class="yiyi-st" id="yiyi-378">16.8.12. </span><span class="yiyi-st" id="yiyi-379">SMTPHandler</span></h2><p><span class="yiyi-st" id="yiyi-380">The <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal"><span class="pre">SMTPHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, supports sending logging messages to an email address via SMTP.</span></p><dl class="class"><dt id="logging.handlers.SMTPHandler"><span class="yiyi-st" id="yiyi-381"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SMTPHandler</code><span class="sig-paren">(</span><em>mailhost</em>, <em>fromaddr</em>, <em>toaddrs</em>, <em>subject</em>, <em>credentials=None</em>, <em>secure=None</em>, <em>timeout=1.0</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-382">Returns a new instance of the <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal"><span class="pre">SMTPHandler</span></code></a> class. </span><span class="yiyi-st" id="yiyi-383">The instance is initialized with the from and to addresses and subject line of the email. </span><span class="yiyi-st" id="yiyi-384">The <em>toaddrs</em> should be a list of strings. </span><span class="yiyi-st" id="yiyi-385">To specify a non-standard SMTP port, use the (host, port) tuple format for the <em>mailhost</em> argument. </span><span class="yiyi-st" id="yiyi-386">If you use a string, the standard SMTP port is used. </span><span class="yiyi-st" id="yiyi-387">If your SMTP server requires authentication, you can specify a (username, password) tuple for the <em>credentials</em> argument.</span></p><p><span class="yiyi-st" id="yiyi-388">To specify the use of a secure protocol (TLS), pass in a tuple to the <em>secure</em> argument. </span><span class="yiyi-st" id="yiyi-389">This will only be used when authentication credentials are supplied. </span><span class="yiyi-st" id="yiyi-390">The tuple should be either an empty tuple, or a single-value tuple with the name of a keyfile, or a 2-value tuple with the names of the keyfile and certificate file. </span><span class="yiyi-st" id="yiyi-391">(This tuple is passed to the <a class="reference internal" href="smtplib.html#smtplib.SMTP.starttls" title="smtplib.SMTP.starttls"><code class="xref py py-meth docutils literal"><span class="pre">smtplib.SMTP.starttls()</span></code></a> method.)</span></p><p><span class="yiyi-st" id="yiyi-392">A timeout can be specified for communication with the SMTP server using the <em>timeout</em> argument.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-393"><span class="versionmodified">New in version 3.3: </span>The <em>timeout</em> argument was added.</span></p></div><dl class="method"><dt id="logging.handlers.SMTPHandler.emit"><span class="yiyi-st" id="yiyi-394"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-395">Formats the record and sends it to the specified addressees.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.SMTPHandler.getSubject"><span class="yiyi-st" id="yiyi-396"> <code class="descname">getSubject</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-397">If you want to specify a subject line which is record-dependent, override this method.</span></p></dd></dl></dd></dl></div><div class="section" id="memoryhandler"><h2><span class="yiyi-st" id="yiyi-398">16.8.13. </span><span class="yiyi-st" id="yiyi-399">MemoryHandler</span></h2><p><span class="yiyi-st" id="yiyi-400">The <a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal"><span class="pre">MemoryHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, supports buffering of logging records in memory, periodically flushing them to a <em class="dfn">target</em> handler. </span><span class="yiyi-st" id="yiyi-401">Flushing occurs whenever the buffer is full, or when an event of a certain severity or greater is seen.</span></p><p><span class="yiyi-st" id="yiyi-402"><a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal"><span class="pre">MemoryHandler</span></code></a> is a subclass of the more general <a class="reference internal" href="#logging.handlers.BufferingHandler" title="logging.handlers.BufferingHandler"><code class="xref py py-class docutils literal"><span class="pre">BufferingHandler</span></code></a>, which is an abstract class. </span><span class="yiyi-st" id="yiyi-403">This buffers logging records in memory. </span><span class="yiyi-st" id="yiyi-404">Whenever each record is added to the buffer, a check is made by calling <code class="xref py py-meth docutils literal"><span class="pre">shouldFlush()</span></code> to see if the buffer should be flushed. </span><span class="yiyi-st" id="yiyi-405">If it should, then <code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code> is expected to do the flushing.</span></p><dl class="class"><dt id="logging.handlers.BufferingHandler"><span class="yiyi-st" id="yiyi-406"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">BufferingHandler</code><span class="sig-paren">(</span><em>capacity</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-407">Initializes the handler with a buffer of the specified capacity.</span></p><dl class="method"><dt id="logging.handlers.BufferingHandler.emit"><span class="yiyi-st" id="yiyi-408"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-409">Appends the record to the buffer. </span><span class="yiyi-st" id="yiyi-410">If <a class="reference internal" href="#logging.handlers.BufferingHandler.shouldFlush" title="logging.handlers.BufferingHandler.shouldFlush"><code class="xref py py-meth docutils literal"><span class="pre">shouldFlush()</span></code></a> returns true, calls <a class="reference internal" href="#logging.handlers.BufferingHandler.flush" title="logging.handlers.BufferingHandler.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> to process the buffer.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.BufferingHandler.flush"><span class="yiyi-st" id="yiyi-411"> <code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-412">You can override this to implement custom flushing behavior. </span><span class="yiyi-st" id="yiyi-413">This version just zaps the buffer to empty.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.BufferingHandler.shouldFlush"><span class="yiyi-st" id="yiyi-414"> <code class="descname">shouldFlush</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-415">Returns true if the buffer is up to capacity. </span><span class="yiyi-st" id="yiyi-416">This method can be overridden to implement custom flushing strategies.</span></p></dd></dl></dd></dl><dl class="class"><dt id="logging.handlers.MemoryHandler"><span class="yiyi-st" id="yiyi-417"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">MemoryHandler</code><span class="sig-paren">(</span><em>capacity</em>, <em>flushLevel=ERROR</em>, <em>target=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-418">Returns a new instance of the <a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal"><span class="pre">MemoryHandler</span></code></a> class. </span><span class="yiyi-st" id="yiyi-419">The instance is initialized with a buffer size of <em>capacity</em>. </span><span class="yiyi-st" id="yiyi-420">If <em>flushLevel</em> is not specified, <code class="xref py py-const docutils literal"><span class="pre">ERROR</span></code> is used. </span><span class="yiyi-st" id="yiyi-421">If no <em>target</em> is specified, the target will need to be set using <a class="reference internal" href="#logging.handlers.MemoryHandler.setTarget" title="logging.handlers.MemoryHandler.setTarget"><code class="xref py py-meth docutils literal"><span class="pre">setTarget()</span></code></a> before this handler does anything useful.</span></p><dl class="method"><dt id="logging.handlers.MemoryHandler.close"><span class="yiyi-st" id="yiyi-422"> <code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-423">Calls <a class="reference internal" href="#logging.handlers.MemoryHandler.flush" title="logging.handlers.MemoryHandler.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a>, sets the target to <code class="docutils literal"><span class="pre">None</span></code> and clears the buffer.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.MemoryHandler.flush"><span class="yiyi-st" id="yiyi-424"> <code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-425">For a <a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal"><span class="pre">MemoryHandler</span></code></a>, flushing means just sending the buffered records to the target, if there is one. </span><span class="yiyi-st" id="yiyi-426">The buffer is also cleared when this happens. </span><span class="yiyi-st" id="yiyi-427">Override if you want different behavior.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.MemoryHandler.setTarget"><span class="yiyi-st" id="yiyi-428"> <code class="descname">setTarget</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-429">Sets the target handler for this handler.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.MemoryHandler.shouldFlush"><span class="yiyi-st" id="yiyi-430"> <code class="descname">shouldFlush</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-431">Checks for buffer full or a record at the <em>flushLevel</em> or higher.</span></p></dd></dl></dd></dl></div><div class="section" id="httphandler"><h2><span class="yiyi-st" id="yiyi-432">16.8.14. </span><span class="yiyi-st" id="yiyi-433">HTTPHandler</span></h2><p><span class="yiyi-st" id="yiyi-434">The <a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, supports sending logging messages to a Web server, using either <code class="docutils literal"><span class="pre">GET</span></code> or <code class="docutils literal"><span class="pre">POST</span></code> semantics.</span></p><dl class="class"><dt id="logging.handlers.HTTPHandler"><span class="yiyi-st" id="yiyi-435"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">HTTPHandler</code><span class="sig-paren">(</span><em>host</em>, <em>url</em>, <em>method='GET'</em>, <em>secure=False</em>, <em>credentials=None</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-436">Returns a new instance of the <a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPHandler</span></code></a> class. </span><span class="yiyi-st" id="yiyi-437">The <em>host</em> can be of the form <code class="docutils literal"><span class="pre">host:port</span></code>, should you need to use a specific port number. </span><span class="yiyi-st" id="yiyi-438">If no <em>method</em> is specified, <code class="docutils literal"><span class="pre">GET</span></code> is used. </span><span class="yiyi-st" id="yiyi-439">If <em>secure</em> is true, a HTTPS connection will be used. </span><span class="yiyi-st" id="yiyi-440">The <em>context</em> parameter may be set to a <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></code></a> instance to configure the SSL settings used for the HTTPS connection. </span><span class="yiyi-st" id="yiyi-441">If <em>credentials</em> is specified, it should be a 2-tuple consisting of userid and password, which will be placed in a HTTP ‘Authorization’ header using Basic authentication. </span><span class="yiyi-st" id="yiyi-442">If you specify credentials, you should also specify secure=True so that your userid and password are not passed in cleartext across the wire.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-443"><span class="versionmodified">Changed in version 3.5: </span>The <em>context</em> parameter was added.</span></p></div><dl class="method"><dt id="logging.handlers.HTTPHandler.mapLogRecord"><span class="yiyi-st" id="yiyi-444"> <code class="descname">mapLogRecord</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-445">Provides a dictionary, based on <code class="docutils literal"><span class="pre">record</span></code>, which is to be URL-encoded and sent to the web server. </span><span class="yiyi-st" id="yiyi-446">The default implementation just returns <code class="docutils literal"><span class="pre">record.__dict__</span></code>. </span><span class="yiyi-st" id="yiyi-447">This method can be overridden if e.g. </span><span class="yiyi-st" id="yiyi-448">only a subset of <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> is to be sent to the web server, or if more specific customization of what’s sent to the server is required.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.HTTPHandler.emit"><span class="yiyi-st" id="yiyi-449"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-450">Sends the record to the Web server as a URL-encoded dictionary. </span><span class="yiyi-st" id="yiyi-451">The <a class="reference internal" href="#logging.handlers.HTTPHandler.mapLogRecord" title="logging.handlers.HTTPHandler.mapLogRecord"><code class="xref py py-meth docutils literal"><span class="pre">mapLogRecord()</span></code></a> method is used to convert the record to the dictionary to be sent.</span></p></dd></dl><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-452">Note</span></p><p class="last"><span class="yiyi-st" id="yiyi-453">Since preparing a record for sending it to a Web server is not the same as a generic formatting operation, using <a class="reference internal" href="logging.html#logging.Handler.setFormatter" title="logging.Handler.setFormatter"><code class="xref py py-meth docutils literal"><span class="pre">setFormatter()</span></code></a> to specify a <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> for a <a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPHandler</span></code></a> has no effect. </span><span class="yiyi-st" id="yiyi-454">Instead of calling <a class="reference internal" href="logging.html#logging.Handler.format" title="logging.Handler.format"><code class="xref py py-meth docutils literal"><span class="pre">format()</span></code></a>, this handler calls <a class="reference internal" href="#logging.handlers.HTTPHandler.mapLogRecord" title="logging.handlers.HTTPHandler.mapLogRecord"><code class="xref py py-meth docutils literal"><span class="pre">mapLogRecord()</span></code></a> and then <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal"><span class="pre">urllib.parse.urlencode()</span></code></a> to encode the dictionary in a form suitable for sending to a Web server.</span></p></div></dd></dl></div><div class="section" id="queuehandler"><h2><span class="yiyi-st" id="yiyi-455">16.8.15. </span><span class="yiyi-st" id="yiyi-456">QueueHandler</span></h2><div class="versionadded"><p><span class="yiyi-st" id="yiyi-457"><span class="versionmodified">New in version 3.2.</span></span></p></div><p><span class="yiyi-st" id="yiyi-458">The <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal"><span class="pre">QueueHandler</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, supports sending logging messages to a queue, such as those implemented in the <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal"><span class="pre">queue</span></code></a> or <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> modules.</span></p><p><span class="yiyi-st" id="yiyi-459">Along with the <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal"><span class="pre">QueueListener</span></code></a> class, <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal"><span class="pre">QueueHandler</span></code></a> can be used to let handlers do their work on a separate thread from the one which does the logging. </span><span class="yiyi-st" id="yiyi-460">This is important in Web applications and also other service applications where threads servicing clients need to respond as quickly as possible, while any potentially slow operations (such as sending an email via <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal"><span class="pre">SMTPHandler</span></code></a>) are done on a separate thread.</span></p><dl class="class"><dt id="logging.handlers.QueueHandler"><span class="yiyi-st" id="yiyi-461"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">QueueHandler</code><span class="sig-paren">(</span><em>queue</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-462">Returns a new instance of the <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal"><span class="pre">QueueHandler</span></code></a> class. </span><span class="yiyi-st" id="yiyi-463">The instance is initialized with the queue to send messages to. </span><span class="yiyi-st" id="yiyi-464">The queue can be any queue- like object; it’s used as-is by the <a class="reference internal" href="#logging.handlers.QueueHandler.enqueue" title="logging.handlers.QueueHandler.enqueue"><code class="xref py py-meth docutils literal"><span class="pre">enqueue()</span></code></a> method, which needs to know how to send messages to it.</span></p><dl class="method"><dt id="logging.handlers.QueueHandler.emit"><span class="yiyi-st" id="yiyi-465"> <code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-466">Enqueues the result of preparing the LogRecord.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.QueueHandler.prepare"><span class="yiyi-st" id="yiyi-467"> <code class="descname">prepare</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-468">Prepares a record for queuing. </span><span class="yiyi-st" id="yiyi-469">The object returned by this method is enqueued.</span></p><p><span class="yiyi-st" id="yiyi-470">The base implementation formats the record to merge the message and arguments, and removes unpickleable items from the record in-place.</span></p><p><span class="yiyi-st" id="yiyi-471">You might want to override this method if you want to convert the record to a dict or JSON string, or send a modified copy of the record while leaving the original intact.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.QueueHandler.enqueue"><span class="yiyi-st" id="yiyi-472"> <code class="descname">enqueue</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-473">Enqueues the record on the queue using <code class="docutils literal"><span class="pre">put_nowait()</span></code>; you may want to override this if you want to use blocking behaviour, or a timeout, or a customized queue implementation.</span></p></dd></dl></dd></dl></div><div class="section" id="queuelistener"><h2><span class="yiyi-st" id="yiyi-474">16.8.16. </span><span class="yiyi-st" id="yiyi-475">QueueListener</span></h2><div class="versionadded"><p><span class="yiyi-st" id="yiyi-476"><span class="versionmodified">New in version 3.2.</span></span></p></div><p><span class="yiyi-st" id="yiyi-477">The <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal"><span class="pre">QueueListener</span></code></a> class, located in the <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> module, supports receiving logging messages from a queue, such as those implemented in the <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal"><span class="pre">queue</span></code></a> or <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> modules. </span><span class="yiyi-st" id="yiyi-478">The messages are received from a queue in an internal thread and passed, on the same thread, to one or more handlers for processing. </span><span class="yiyi-st" id="yiyi-479">While <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal"><span class="pre">QueueListener</span></code></a> is not itself a handler, it is documented here because it works hand-in-hand with <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal"><span class="pre">QueueHandler</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-480">Along with the <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal"><span class="pre">QueueHandler</span></code></a> class, <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal"><span class="pre">QueueListener</span></code></a> can be used to let handlers do their work on a separate thread from the one which does the logging. </span><span class="yiyi-st" id="yiyi-481">This is important in Web applications and also other service applications where threads servicing clients need to respond as quickly as possible, while any potentially slow operations (such as sending an email via <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal"><span class="pre">SMTPHandler</span></code></a>) are done on a separate thread.</span></p><dl class="class"><dt id="logging.handlers.QueueListener"><span class="yiyi-st" id="yiyi-482"> <em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">QueueListener</code><span class="sig-paren">(</span><em>queue</em>, <em>*handlers</em>, <em>respect_handler_level=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-483">Returns a new instance of the <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal"><span class="pre">QueueListener</span></code></a> class. </span><span class="yiyi-st" id="yiyi-484">The instance is initialized with the queue to send messages to and a list of handlers which will handle entries placed on the queue. </span><span class="yiyi-st" id="yiyi-485">The queue can be any queue- like object; it’s passed as-is to the <a class="reference internal" href="#logging.handlers.QueueListener.dequeue" title="logging.handlers.QueueListener.dequeue"><code class="xref py py-meth docutils literal"><span class="pre">dequeue()</span></code></a> method, which needs to know how to get messages from it. </span><span class="yiyi-st" id="yiyi-486">If <code class="docutils literal"><span class="pre">respect_handler_level</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, a handler’s level is respected (compared with the level for the message) when deciding whether to pass messages to that handler; otherwise, the behaviour is as in previous Python versions - to always pass each message to each handler.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-487"><span class="versionmodified">Changed in version 3.5: </span>The <code class="docutils literal"><span class="pre">respect_handler_levels</span></code> argument was added.</span></p></div><dl class="method"><dt id="logging.handlers.QueueListener.dequeue"><span class="yiyi-st" id="yiyi-488"> <code class="descname">dequeue</code><span class="sig-paren">(</span><em>block</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-489">Dequeues a record and return it, optionally blocking.</span></p><p><span class="yiyi-st" id="yiyi-490">The base implementation uses <code class="docutils literal"><span class="pre">get()</span></code>. </span><span class="yiyi-st" id="yiyi-491">You may want to override this method if you want to use timeouts or work with custom queue implementations.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.QueueListener.prepare"><span class="yiyi-st" id="yiyi-492"> <code class="descname">prepare</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-493">Prepare a record for handling.</span></p><p><span class="yiyi-st" id="yiyi-494">This implementation just returns the passed-in record. </span><span class="yiyi-st" id="yiyi-495">You may want to override this method if you need to do any custom marshalling or manipulation of the record before passing it to the handlers.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.QueueListener.handle"><span class="yiyi-st" id="yiyi-496"> <code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-497">Handle a record.</span></p><p><span class="yiyi-st" id="yiyi-498">This just loops through the handlers offering them the record to handle. </span><span class="yiyi-st" id="yiyi-499">The actual object passed to the handlers is that which is returned from <a class="reference internal" href="#logging.handlers.QueueListener.prepare" title="logging.handlers.QueueListener.prepare"><code class="xref py py-meth docutils literal"><span class="pre">prepare()</span></code></a>.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.QueueListener.start"><span class="yiyi-st" id="yiyi-500"> <code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-501">Starts the listener.</span></p><p><span class="yiyi-st" id="yiyi-502">This starts up a background thread to monitor the queue for LogRecords to process.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.QueueListener.stop"><span class="yiyi-st" id="yiyi-503"> <code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-504">Stops the listener.</span></p><p><span class="yiyi-st" id="yiyi-505">This asks the thread to terminate, and then waits for it to do so. </span><span class="yiyi-st" id="yiyi-506">Note that if you don’t call this before your application exits, there may be some records still left on the queue, which won’t be processed.</span></p></dd></dl><dl class="method"><dt id="logging.handlers.QueueListener.enqueue_sentinel"><span class="yiyi-st" id="yiyi-507"> <code class="descname">enqueue_sentinel</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-508">Writes a sentinel to the queue to tell the listener to quit. </span><span class="yiyi-st" id="yiyi-509">This implementation uses <code class="docutils literal"><span class="pre">put_nowait()</span></code>. </span><span class="yiyi-st" id="yiyi-510">You may want to override this method if you want to use timeouts or work with custom queue implementations.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-511"><span class="versionmodified">New in version 3.3.</span></span></p></div></dd></dl></dd></dl><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-512">See also</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-513">Module <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-514">API reference for the logging module.</span></dd><dt><span class="yiyi-st" id="yiyi-515">Module <a class="reference internal" href="logging.config.html#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.config</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-516">Configuration API for the logging module.</span></dd></dl></div></div></div></div>