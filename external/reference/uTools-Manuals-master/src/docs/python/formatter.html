<div class="body" role="main"><div class="section" id="module-formatter"><h1><span class="yiyi-st" id="yiyi-10">33.1. <a class="reference internal" href="#module-formatter" title="formatter: Generic output formatter and device interface. (deprecated)"><code class="xref py py-mod docutils literal"><span class="pre">formatter</span></code></a>  - 通用输出格式</span></h1><div class="deprecated"><p><span class="yiyi-st" id="yiyi-11"><span class="versionmodified">自版本3.4后已弃用：</span>由于缺少用法，格式化程序模块已被弃用。</span></p></div><p><span class="yiyi-st" id="yiyi-12">此模块支持两个接口定义，每个接口定义具有多个实现：<em>格式化程序</em>接口和格式化程序接口所需的<em>写入程序</em>接口。</span></p><p><span class="yiyi-st" id="yiyi-13">Formatter对象将格式化事件的抽象流转换为writer对象上的特定输出事件。</span><span class="yiyi-st" id="yiyi-14">格式化器管理若干堆栈结构，以允许改变和恢复写入器对象的各种属性；写作者不需要能够处理相对变化或任何种类的“改变”操作。</span><span class="yiyi-st" id="yiyi-15">可以通过格式器对象控制的特定写入器属性是水平对齐，字体和左边缘缩进。</span><span class="yiyi-st" id="yiyi-16">提供了一种机制，其支持也向写者提供任意的，非排他的样式设置。</span><span class="yiyi-st" id="yiyi-17">其他接口有助于格式化不可逆的事件，例如段落分隔。</span></p><p><span class="yiyi-st" id="yiyi-18">Writer对象封装设备接口。</span><span class="yiyi-st" id="yiyi-19">支持抽象设备（例如文件格式）以及物理设备。</span><span class="yiyi-st" id="yiyi-20">所提供的实现都使用抽象设备。</span><span class="yiyi-st" id="yiyi-21">该接口提供了用于设置格式化器对象管理和将数据插入到输出中的属性的可用机制。</span></p><div class="section" id="the-formatter-interface"><h2><span class="yiyi-st" id="yiyi-22">33.1.1. </span><span class="yiyi-st" id="yiyi-23">格式器接口</span></h2><p><span class="yiyi-st" id="yiyi-24">创建格式化程序的接口取决于要实例化的特定格式化程序类。</span><span class="yiyi-st" id="yiyi-25">下面描述的接口是所有格式化器必须支持的接口，一旦初始化。</span></p><p><span class="yiyi-st" id="yiyi-26">一个数据元素在模块级别定义：</span></p><dl class="data"><dt id="formatter.AS_IS"><span class="yiyi-st" id="yiyi-27"> <code class="descclassname">formatter.</code><code class="descname">AS_IS</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-28">可以在字体规范中使用的值传递给下面描述的<code class="docutils literal"><span class="pre">push_font()</span></code>方法，或作为任何其他<code class="docutils literal"><span class="pre">push_property()</span></code>方法的新值。</span><span class="yiyi-st" id="yiyi-29">按下<code class="docutils literal"><span class="pre">AS_IS</span></code>值允许调用相应的<code class="docutils literal"><span class="pre">pop_property()</span></code>方法，而不必跟踪属性是否已更改。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-30">为格式化程序实例对象定义了以下属性：</span></p><dl class="attribute"><dt id="formatter.formatter.writer"><span class="yiyi-st" id="yiyi-31"> <code class="descclassname">formatter.</code><code class="descname">writer</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-32">作者实例与格式化器交互。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.end_paragraph"><span class="yiyi-st" id="yiyi-33"> <code class="descclassname">formatter.</code><code class="descname">end_paragraph</code><span class="sig-paren">(</span><em>blanklines</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-34">关闭所有打开的段落，并在下一段落之前至少插入<em>空白行</em>。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.add_line_break"><span class="yiyi-st" id="yiyi-35"> <code class="descclassname">formatter.</code><code class="descname">add_line_break</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-36">如果尚不存在硬换行符，则添加硬换行符。</span><span class="yiyi-st" id="yiyi-37">这不会破坏逻辑段。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.add_hor_rule"><span class="yiyi-st" id="yiyi-38"> <code class="descclassname">formatter.</code><code class="descname">add_hor_rule</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-39">在输出中插入水平规则。</span><span class="yiyi-st" id="yiyi-40">如果当前段落中有数据，则插入硬中断，但逻辑段不会断开。</span><span class="yiyi-st" id="yiyi-41">参数和关键字传递给作者的<code class="xref py py-meth docutils literal"><span class="pre">send_line_break()</span></code>方法。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.add_flowing_data"><span class="yiyi-st" id="yiyi-42"> <code class="descclassname">formatter.</code><code class="descname">add_flowing_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-43">提供应采用折叠空格格式的数据。</span><span class="yiyi-st" id="yiyi-44">当执行空格折叠时，也会考虑来自先前和后续调用<a class="reference internal" href="#formatter.formatter.add_flowing_data" title="formatter.formatter.add_flowing_data"><code class="xref py py-meth docutils literal"><span class="pre">add_flowing_data()</span></code></a>的空格。</span><span class="yiyi-st" id="yiyi-45">传递给此方法的数据预期由输出设备进行字封装。</span><span class="yiyi-st" id="yiyi-46">注意，任何文字包装仍然必须由writer对象执行，因为需要依赖于设备和字体信息。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.add_literal_data"><span class="yiyi-st" id="yiyi-47"> <code class="descclassname">formatter.</code><code class="descname">add_literal_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-48">提供应该传递给写入程序的数据不变。</span><span class="yiyi-st" id="yiyi-49">在<em>数据</em>的值中，空格（包括换行符和制表符字符）被视为合法。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.add_label_data"><span class="yiyi-st" id="yiyi-50"> <code class="descclassname">formatter.</code><code class="descname">add_label_data</code><span class="sig-paren">(</span><em>format</em>, <em>counter</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-51">插入应放置在当前左边距左侧的标签。</span><span class="yiyi-st" id="yiyi-52">这应该用于构造项目符号或编号列表。</span><span class="yiyi-st" id="yiyi-53">如果<em>格式</em>值是字符串，它将被解释为<em>计数器</em>的格式规范，它应该是一个整数。</span><span class="yiyi-st" id="yiyi-54">此格式化的结果将成为标签的值；如果<em>格式</em>不是字符串，它将直接用作标签值。</span><span class="yiyi-st" id="yiyi-55">标签值作为唯一的参数传递给作者的<code class="xref py py-meth docutils literal"><span class="pre">send_label_data()</span></code>方法。</span><span class="yiyi-st" id="yiyi-56">非字符串标签值的解释取决于关联的writer。</span></p><p><span class="yiyi-st" id="yiyi-57">格式规范是与计数器值结合用于计算标签值的字符串。</span><span class="yiyi-st" id="yiyi-58">格式字符串中的每个字符都复制到标签值，其中一些字符被识别为指示对计数器值的变换。</span><span class="yiyi-st" id="yiyi-59">具体来说，字符<code class="docutils literal"><span class="pre">'1'</span></code>表示计数器值格式化器作为阿拉伯数字，字符<code class="docutils literal"><span class="pre">'A'</span></code>和<code class="docutils literal"><span class="pre">'a'</span></code>分别表示大写和小写的计数器值，并且<code class="docutils literal"><span class="pre">'I'</span></code>和<code class="docutils literal"><span class="pre">'i'</span></code>用大写和小写表示罗马数字中的计数器值。</span><span class="yiyi-st" id="yiyi-60">注意，字母和罗马变换要求计数器值大于零。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.flush_softspace"><span class="yiyi-st" id="yiyi-61"> <code class="descclassname">formatter.</code><code class="descname">flush_softspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-62">将从先前调用缓冲的任何未决空格发送到<a class="reference internal" href="#formatter.formatter.add_flowing_data" title="formatter.formatter.add_flowing_data"><code class="xref py py-meth docutils literal"><span class="pre">add_flowing_data()</span></code></a>到关联的writer对象。</span><span class="yiyi-st" id="yiyi-63">这应该在任何直接操作writer对象之前调用。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.push_alignment"><span class="yiyi-st" id="yiyi-64"> <code class="descclassname">formatter.</code><code class="descname">push_alignment</code><span class="sig-paren">(</span><em>align</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-65">将新的对齐设置推入对齐堆栈。</span><span class="yiyi-st" id="yiyi-66">如果不需要更改，则可以是<a class="reference internal" href="#formatter.AS_IS" title="formatter.AS_IS"><code class="xref py py-const docutils literal"><span class="pre">AS_IS</span></code></a>。</span><span class="yiyi-st" id="yiyi-67">如果对齐值从先前设置改变，则使用<em>align</em>值调用写入程序的<code class="xref py py-meth docutils literal"><span class="pre">new_alignment()</span></code>方法。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.pop_alignment"><span class="yiyi-st" id="yiyi-68"> <code class="descclassname">formatter.</code><code class="descname">pop_alignment</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-69">恢复上一个对齐。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.push_font"><span class="yiyi-st" id="yiyi-70"> <code class="descclassname">formatter.</code><code class="descname">push_font</code><span class="sig-paren">(</span><em>(size</em>, <em>italic</em>, <em>bold</em>, <em>teletype)</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-71">更改writer对象的一些或所有字体属性。</span><span class="yiyi-st" id="yiyi-72">未设置为<a class="reference internal" href="#formatter.AS_IS" title="formatter.AS_IS"><code class="xref py py-const docutils literal"><span class="pre">AS_IS</span></code></a>的属性设置为传入的值，而其他属性保持在其当前设置。</span><span class="yiyi-st" id="yiyi-73">使用完全解析的字体规范调用写入程序的<code class="xref py py-meth docutils literal"><span class="pre">new_font()</span></code>方法。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.pop_font"><span class="yiyi-st" id="yiyi-74"> <code class="descclassname">formatter.</code><code class="descname">pop_font</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-75">还原以前的字体。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.push_margin"><span class="yiyi-st" id="yiyi-76"> <code class="descclassname">formatter.</code><code class="descname">push_margin</code><span class="sig-paren">(</span><em>margin</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-77">将左边距缩进的数量增加1，将逻辑标记<em>边距</em>与新缩进相关联。</span><span class="yiyi-st" id="yiyi-78">初始保证金水平为<code class="docutils literal"><span class="pre">0</span></code>。</span><span class="yiyi-st" id="yiyi-79">逻辑标记的更改值必须为true值；除<a class="reference internal" href="#formatter.AS_IS" title="formatter.AS_IS"><code class="xref py py-const docutils literal"><span class="pre">AS_IS</span></code></a>之外的其他值不足以更改边距。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.pop_margin"><span class="yiyi-st" id="yiyi-80"> <code class="descclassname">formatter.</code><code class="descname">pop_margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">恢复上一个边距。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.push_style"><span class="yiyi-st" id="yiyi-82"> <code class="descclassname">formatter.</code><code class="descname">push_style</code><span class="sig-paren">(</span><em>*styles</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">推送任意数量的任意样式规格。</span><span class="yiyi-st" id="yiyi-84">所有样式都按顺序推入样式堆栈。</span><span class="yiyi-st" id="yiyi-85">表示整个堆栈的元组（包括<a class="reference internal" href="#formatter.AS_IS" title="formatter.AS_IS"><code class="xref py py-const docutils literal"><span class="pre">AS_IS</span></code></a>值）传递给写入程序的<code class="xref py py-meth docutils literal"><span class="pre">new_styles()</span></code>方法。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.pop_style"><span class="yiyi-st" id="yiyi-86"> <code class="descclassname">formatter.</code><code class="descname">pop_style</code><span class="sig-paren">(</span><em>n=1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-87">弹出传递给<a class="reference internal" href="#formatter.formatter.push_style" title="formatter.formatter.push_style"><code class="xref py py-meth docutils literal"><span class="pre">push_style()</span></code></a>的最后<em>n</em>样式规格。</span><span class="yiyi-st" id="yiyi-88">表示修订堆栈（包括<a class="reference internal" href="#formatter.AS_IS" title="formatter.AS_IS"><code class="xref py py-const docutils literal"><span class="pre">AS_IS</span></code></a>值）的元组将传递给写入程序的<code class="xref py py-meth docutils literal"><span class="pre">new_styles()</span></code>方法。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.set_spacing"><span class="yiyi-st" id="yiyi-89"> <code class="descclassname">formatter.</code><code class="descname">set_spacing</code><span class="sig-paren">(</span><em>spacing</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">设置作者的间距样式。</span></p></dd></dl><dl class="method"><dt id="formatter.formatter.assert_line_data"><span class="yiyi-st" id="yiyi-91"> <code class="descclassname">formatter.</code><code class="descname">assert_line_data</code><span class="sig-paren">(</span><em>flag=1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-92">通知格式化程序数据已经在带外添加到当前段落。</span><span class="yiyi-st" id="yiyi-93">当直接操作写入程序时，应使用此选项。</span><span class="yiyi-st" id="yiyi-94">如果写入器操作在输出结尾处产生硬换行符，则可选的<em>标志</em>参数可以设置为false。</span></p></dd></dl></div><div class="section" id="formatter-implementations"><h2><span class="yiyi-st" id="yiyi-95">33.1.2. </span><span class="yiyi-st" id="yiyi-96">格式化程序实现</span></h2><p><span class="yiyi-st" id="yiyi-97">此模块提供格式化程序对象的两个实现。</span><span class="yiyi-st" id="yiyi-98">大多数应用程序可以使用这些类之一，而无需修改或子类化。</span></p><dl class="class"><dt id="formatter.NullFormatter"><span class="yiyi-st" id="yiyi-99"> <em class="property">class </em><code class="descclassname">formatter.</code><code class="descname">NullFormatter</code><span class="sig-paren">(</span><em>writer=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-100">一个不起作用的格式化程序。</span><span class="yiyi-st" id="yiyi-101">如果省略<em>writer</em>，则会创建一个<a class="reference internal" href="#formatter.NullWriter" title="formatter.NullWriter"><code class="xref py py-class docutils literal"><span class="pre">NullWriter</span></code></a>实例。</span><span class="yiyi-st" id="yiyi-102">没有任何方法由<a class="reference internal" href="#formatter.NullFormatter" title="formatter.NullFormatter"><code class="xref py py-class docutils literal"><span class="pre">NullFormatter</span></code></a>实例调用。</span><span class="yiyi-st" id="yiyi-103">如果实现一个写入器接口，但不需要继承任何实现，实现应该继承这个类。</span></p></dd></dl><dl class="class"><dt id="formatter.AbstractFormatter"><span class="yiyi-st" id="yiyi-104"> <em class="property">class </em><code class="descclassname">formatter.</code><code class="descname">AbstractFormatter</code><span class="sig-paren">(</span><em>writer</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-105">标准格式化程序。</span><span class="yiyi-st" id="yiyi-106">这种实现已经证明了对许多作者的广泛适用性，并且可以在大多数情况下直接使用。</span><span class="yiyi-st" id="yiyi-107">它已被用于实现全功能的万维网浏览器。</span></p></dd></dl></div><div class="section" id="the-writer-interface"><h2><span class="yiyi-st" id="yiyi-108">33.1.3. </span><span class="yiyi-st" id="yiyi-109">Writer接口</span></h2><p><span class="yiyi-st" id="yiyi-110">创建写入程序的接口取决于实例化的特定写入程序类。</span><span class="yiyi-st" id="yiyi-111">下面描述的接口是所有写入器在初始化后必须支持的接口。</span><span class="yiyi-st" id="yiyi-112">请注意，虽然大多数应用程序可以使用<a class="reference internal" href="#formatter.AbstractFormatter" title="formatter.AbstractFormatter"><code class="xref py py-class docutils literal"><span class="pre">AbstractFormatter</span></code></a>类作为格式化程序，但该编写器通常必须由应用程序提供。</span></p><dl class="method"><dt id="formatter.writer.flush"><span class="yiyi-st" id="yiyi-113"> <code class="descclassname">writer.</code><code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-114">清除任何缓冲输出或设备控制事件。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.new_alignment"><span class="yiyi-st" id="yiyi-115"> <code class="descclassname">writer.</code><code class="descname">new_alignment</code><span class="sig-paren">(</span><em>align</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-116">设置对齐样式。</span><span class="yiyi-st" id="yiyi-117"><em>align</em>值可以是任何对象，但按照惯例是一个字符串或<code class="docutils literal"><span class="pre">None</span></code>，其中<code class="docutils literal"><span class="pre">None</span></code>表示作者的“首选”用过的。</span><span class="yiyi-st" id="yiyi-118">常规<em>align</em>值为<code class="docutils literal"><span class="pre">'left'</span></code>，<code class="docutils literal"><span class="pre">'center'</span></code>，<code class="docutils literal"><span class="pre">'right'</span></code>和<code class="docutils literal"><span class="pre">'justify'</span></code>。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.new_font"><span class="yiyi-st" id="yiyi-119"> <code class="descclassname">writer.</code><code class="descname">new_font</code><span class="sig-paren">(</span><em>font</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-120">设置字体样式。</span><span class="yiyi-st" id="yiyi-121"><em>字体</em>的值将为<code class="docutils literal"><span class="pre">None</span></code>，表示应使用设备的默认字体，或<code class="docutils literal"><span class="pre">（大小， t4 &gt; <span class="pre">斜体，</span> <span class="pre">粗体，</span> <span class="pre">电传）</span></span></code>。</span><span class="yiyi-st" id="yiyi-122">大小将是一个字符串，表示应该使用的字体大小；特定字符串及其解释必须由应用程序定义。</span><span class="yiyi-st" id="yiyi-123"><em>斜体</em>，<em>粗体</em>和<em>teletype</em>值是布尔值，指定应使用哪些字体属性。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.new_margin"><span class="yiyi-st" id="yiyi-124"> <code class="descclassname">writer.</code><code class="descname">new_margin</code><span class="sig-paren">(</span><em>margin</em>, <em>level</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-125">将边距水平设置为整数<em>级别</em>，将逻辑标记设置为<em>边距</em>。</span><span class="yiyi-st" id="yiyi-126">逻辑标签的解释是由作者自行决定的；对逻辑标记的值的唯一限制是它不是<em>电平</em>的非零值的假值。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.new_spacing"><span class="yiyi-st" id="yiyi-127"> <code class="descclassname">writer.</code><code class="descname">new_spacing</code><span class="sig-paren">(</span><em>spacing</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-128">将间距样式设置为<em>间距</em>。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.new_styles"><span class="yiyi-st" id="yiyi-129"> <code class="descclassname">writer.</code><code class="descname">new_styles</code><span class="sig-paren">(</span><em>styles</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-130">设置其他样式。</span><span class="yiyi-st" id="yiyi-131"><em>样式</em>值是任意值的元组；应忽略值<a class="reference internal" href="#formatter.AS_IS" title="formatter.AS_IS"><code class="xref py py-const docutils literal"><span class="pre">AS_IS</span></code></a>。</span><span class="yiyi-st" id="yiyi-132">根据应用程序和写入程序实现的要求，<em>样式</em>元组可以解释为一个集合或一个堆栈。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.send_line_break"><span class="yiyi-st" id="yiyi-133"> <code class="descclassname">writer.</code><code class="descname">send_line_break</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-134">中断当前行。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.send_paragraph"><span class="yiyi-st" id="yiyi-135"> <code class="descclassname">writer.</code><code class="descname">send_paragraph</code><span class="sig-paren">(</span><em>blankline</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-136">生成至少<em>空白行</em>空行的段落分隔，或等效的。</span><span class="yiyi-st" id="yiyi-137"><em>blankline</em>值将是一个整数。</span><span class="yiyi-st" id="yiyi-138">注意，如果需要换行符，实现将在此调用之前接收对<a class="reference internal" href="#formatter.writer.send_line_break" title="formatter.writer.send_line_break"><code class="xref py py-meth docutils literal"><span class="pre">send_line_break()</span></code></a>的调用；此方法不应包括结束段落的最后一行。</span><span class="yiyi-st" id="yiyi-139">它只负责段落之间的垂直间距。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.send_hor_rule"><span class="yiyi-st" id="yiyi-140"> <code class="descclassname">writer.</code><code class="descname">send_hor_rule</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-141">在输出设备上显示水平规则。</span><span class="yiyi-st" id="yiyi-142">此方法的参数完全是应用程序和作者特定的，应谨慎解释。</span><span class="yiyi-st" id="yiyi-143">方法实现可以假设已经通过<a class="reference internal" href="#formatter.writer.send_line_break" title="formatter.writer.send_line_break"><code class="xref py py-meth docutils literal"><span class="pre">send_line_break()</span></code></a>发出换行符。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.send_flowing_data"><span class="yiyi-st" id="yiyi-144"> <code class="descclassname">writer.</code><code class="descname">send_flowing_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-145">输出字符数据，可以根据需要进行字封装和重新流动。</span><span class="yiyi-st" id="yiyi-146">在对此方法的任何调用序列中，写者可以假定多个空格字符的跨度已经折叠为单个空格字符。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.send_literal_data"><span class="yiyi-st" id="yiyi-147"> <code class="descclassname">writer.</code><code class="descname">send_literal_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-148">输出已经格式化显示的字符数据。</span><span class="yiyi-st" id="yiyi-149">一般来说，这应该被解释为意味着由换行符指示的换行符应该被保留，并且不应该引入新的换行符。</span><span class="yiyi-st" id="yiyi-150">与提供给<code class="xref py py-meth docutils literal"><span class="pre">send_formatted_data()</span></code>接口的数据不同，数据可能包含嵌入的换行符和制表符字符。</span></p></dd></dl><dl class="method"><dt id="formatter.writer.send_label_data"><span class="yiyi-st" id="yiyi-151"> <code class="descclassname">writer.</code><code class="descname">send_label_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-152">如果可能，请将<em>数据</em>设置在当前左边距的左侧。</span><span class="yiyi-st" id="yiyi-153"><em>数据</em>的值不受限制；非字符串值的处理完全取决于应用程序和写入程序。</span><span class="yiyi-st" id="yiyi-154">此方法将只在一行的开始处调用。</span></p></dd></dl></div><div class="section" id="writer-implementations"><h2><span class="yiyi-st" id="yiyi-155">33.1.4. </span><span class="yiyi-st" id="yiyi-156">Writer实现</span></h2><p><span class="yiyi-st" id="yiyi-157">该模块提供了作者对象接口的三个实现作为示例。</span><span class="yiyi-st" id="yiyi-158">大多数应用程序将需要从<a class="reference internal" href="#formatter.NullWriter" title="formatter.NullWriter"><code class="xref py py-class docutils literal"><span class="pre">NullWriter</span></code></a>类派生新的writer类。</span></p><dl class="class"><dt id="formatter.NullWriter"><span class="yiyi-st" id="yiyi-159"> <em class="property">class </em><code class="descclassname">formatter.</code><code class="descname">NullWriter</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-160">只提供接口定义的writer；没有对任何方法采取任何行动。</span><span class="yiyi-st" id="yiyi-161">这应该是所有不需要继承任何实现方法的作者的基类。</span></p></dd></dl><dl class="class"><dt id="formatter.AbstractWriter"><span class="yiyi-st" id="yiyi-162"> <em class="property">class </em><code class="descclassname">formatter.</code><code class="descname">AbstractWriter</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-163">一个可以用于调试格式化器的写入器，但不是很多。</span><span class="yiyi-st" id="yiyi-164">每个方法通过在标准输出上打印其名称和参数来简单地宣布自身。</span></p></dd></dl><dl class="class"><dt id="formatter.DumbWriter"><span class="yiyi-st" id="yiyi-165"> <em class="property">class </em><code class="descclassname">formatter.</code><code class="descname">DumbWriter</code><span class="sig-paren">(</span><em>file=None</em>, <em>maxcol=72</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-166">将输出写入<em>文件</em>传入的<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>上的简单写入器类，或者如果省略<em>文件</em>，则在标准输出上写入输出。</span><span class="yiyi-st" id="yiyi-167">输出只是用字包裹到由<em>maxcol</em>指定的列数。</span><span class="yiyi-st" id="yiyi-168">这个类适合回流段序列。</span></p></dd></dl></div></div></div>