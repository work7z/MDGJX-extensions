<article id="wikiArticle">
<div></div>
<h2 id="信息">信息</h2>
<pre><code class="language-javascript">TypeError: "x" is not a function
</code></pre>
<h2 id="错误类型">错误类型</h2>
<p><a href="Reference/Global_Objects/TypeError" title="TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。"><code>TypeError</code></a></p>
<h2 id="哪里出错了">哪里出错了?</h2>
<p>问题出在你试图去调用一个像函数一样的值，但是该值实际上不是函数，有时候你的代码需要调用一些函数，但是那种值并不能当作函数来被调用。</p>
<p>也许函数名称上有错别字？ 也许你正在调用Object对象没有这个方法？ 例如，在JavaScript中单纯的对象(Object)没有<strong>map</strong>函数，但是JavaScript数组(Array)对象却有这个函数。</p>
<p>在比如，在JavaScript中很多原生对象的内置方法需要你提供一个（回调）函数。 所以你必须提供一个函数，以使这些方法正常工作：</p>
<ul>
<li>当你在使用 <a href="Reference/Array" title="REDIRECT Array"><code>Array</code></a> 或 <a href="Reference/Global_Objects/TypedArray" title="一个TypedArray 对象描述一个底层的二进制数据缓存区的一个类似数组(array-like)视图。事实上，没有名为 TypedArray的全局对象，也没有一个名为的 TypedArray构造函数。相反，有许多不同的全局对象，下面会列出这些针对特定元素类型的类型化数组的构造函数。在下面的页面中，你会找到一些不管什么类型都公用的属性和方法。"><code>TypedArray</code></a> 对象时:
  <ul>
<li><a href="Reference/Global_Objects/Array/every" title="every() 方法测试数组的所有元素是否都通过了指定函数的测试。"><code>Array.prototype.every()</code></a>, <a href="Reference/Global_Objects/Array/some" title="some() 方法测试是否至少有一个元素通过由提供的函数实现的测试。"><code>Array.prototype.some()</code></a>, <a href="Reference/Global_Objects/Array/forEach" title="forEach() 方法对数组的每个元素执行一次提供的函数。"><code>Array.prototype.forEach()</code></a>, <a href="Reference/Global_Objects/Array/map" title="map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。"><code>Array.prototype.map()</code></a>, <a href="Reference/Global_Objects/Array/filter" title="filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。"><code>Array.prototype.filter()</code></a>,  <a href="Reference/Global_Objects/Array/reduce" title="reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。"><code>Array.prototype.reduce()</code></a>, <a href="Reference/Global_Objects/Array/reduceRight" title="reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。"><code>Array.prototype.reduceRight()</code></a>, <a href="Reference/Global_Objects/Array/find" title="find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。"><code>Array.prototype.find()</code></a></li>
</ul>
</li>
<li>当你在使用 <a href="Reference/Map" title="此页面仍未被本地化, 期待您的翻译!"><code>Map</code></a> 和 <a href="Reference/Global_Objects/Set" title="Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。"><code>Set</code></a> 对象时:
  <ul>
<li><a href="Reference/Global_Objects/Map/forEach" title="forEach() 方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数。"><code>Map.prototype.forEach()</code></a> and <a href="Reference/Global_Objects/Set/forEach" title="forEach 方法根据集合中元素的顺序，对每个元素都执行提供的 callback 函数一次。"><code>Set.prototype.forEach()</code></a></li>
</ul>
</li>
</ul>
<h2 id="例子">例子</h2>
<h3 id="函数的名称错误">函数的名称错误</h3>
<p>函数的名称拼写错误，这种情况是经常发生的：</p>
<pre><code class="language-js example-bad">var x = document.getElementByID("foo");
// TypeError: document.getElementByID is not a function
</code></pre>
<p>正确的方法名应该是 <code>getElementByI<strong>d：</strong></code></p>
<pre><code class="language-js example-good">var x = document.getElementById("foo");
</code></pre>
<h3 id="调用Object类型中不存在的方法">调用Object类型中不存在的方法</h3>
<p>对于某些特殊的方法，它只属于某些特定的原生对象中，你必须提供一个回调函数才能正常运行。例如：这里调用了一个 <a href="Reference/Global_Objects/Array/map" title="map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。"><code>Array.prototype.map()</code></a> 方法，但是这方法只能被 <a href="Reference/Array" title="REDIRECT Array"><code>Array</code></a> 对象所调用。 </p>
<pre><code class="language-js example-bad">var obj = { a: 13, b: 37, c: 42 };

obj.map(function(num) {
  return num * 2;
});

// TypeError: obj.map is not a function</code></pre>
<p>正确的做法，使用一个数组来代替:</p>
<pre><code class="language-js example-good">var numbers = [1, 4, 9];

numbers.map(function(num) { 
  return num * 2; 
}); 

// Array [ 2, 8, 18 ]
</code></pre>
<h2 id="相关">相关</h2>
<ul>
<li><a href="/en-US/docs/Web/JavaScript/Reference/Functions">Functions</a></li>
</ul>
</article>