<article id="wikiArticle">
<div></div>
<p>下一代 ECMAScript 是指在 ECMAScript 2015 被推出后的 ECMA-262 标准（通常被称为 <a href="/en-US/docs/Web/JavaScript">JavaScript</a>）的新特性。新版本的 ECMAScript 规范会每年发布。</p>
<p>你可以在 <a class="external" href="https://github.com/tc39/ecma262" rel="noopener">tc39/ecma262</a> 这个仓库中看见当前的规范草案。</p>
<p><a class="external" href="https://mail.mozilla.org/listinfo/es-discuss" rel="noopener">es-discuss</a> 是一个关于 ECMAScript 标准有关反馈的渠道。</p>
<h2 id="ECMAScript_2016">ECMAScript 2016</h2>
<p>下面的 ECMAScript 2016 特性已实现：</p>
<p> </p>
<ul>
<li><a href="Reference/Global_Objects/Array/includes" title="includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。"><code>Array.prototype.includes()</code></a> (Firefox 43)</li>
<li><a href="Reference/Global_Objects/TypedArray/includes" title="includes()方法判断类型化数组中是否含有特定元素，并相应返回true 或者false ，这个方法的算法和Array.prototype.includes()相同。 TypedArray 是这里的 类型化数组 之一。"><code>TypedArray.prototype.includes()</code></a> (Firefox 43)</li>
</ul>
<h2 id="ECMAScript_2017">ECMAScript 2017</h2>
<p>下面的 ECMAScript 2017 特性已实现：</p>
<p> </p>
<ul>
<li><a href="Reference/Global_Objects/Object/values" title="Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。"><code>Object.values()</code></a> 和 <a href="Reference/Global_Objects/Object/entries" title="The source for this interactive example is stored in a GitHub repository. If you'd like to contribute to the interactive examples project, please clone https://github.com/mdn/interactive-examples and send us a pull request."><code>Object.entries()</code></a> (Firefox 47)</li>
<li><a href="Reference/Global_Objects/String/padEnd" title="padEnd()  方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。"><code>String.prototype.padEnd()</code></a> (Firefox 48)</li>
<li><a href="Reference/Global_Objects/String/padStart" title="padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。"><code>String.prototype.padStart()</code></a> (Firefox 48)</li>
<li><a href="Reference/Global_Objects/Object/getOwnPropertyDescriptors" title="Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。"><code>Object.getOwnPropertyDescriptors()</code></a> (Firefox 50)</li>
<li>异步函数
  <ul>
<li><a href="Reference/Statements/async_function" title="async function 声明用于定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数。"><code>异步函数语句</code></a> (Firefox 52)</li>
<li><a class="new" href="Reference/Operators/async_function" rel="nofollow" title="此页面仍未被本地化, 期待您的翻译!"><code>异步函数表达式</code></a> (Firefox 52)</li>
<li><a href="Reference/Global_Objects/AsyncFunction" title="AsyncFunction 构造函数用来创建新的 异步函数 对象，JavaScript 中每个异步函数都是  AsyncFunction 的对象。"><code>AsyncFunction</code></a> (Firefox 52)</li>
<li><a href="Reference/Operators/await" title="await  操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。"><code>await 语句</code></a> (Firefox 52)</li>
</ul>
</li>
<li><a href="Reference/Trailing_commas" title="尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制的比较更加清晰，以及代码便器的麻烦更少。"><code>函数参数列表的尾后逗号</code></a> (Firefox 52)</li>
</ul>
<h2 id="实验性的新特性">实验性的新特性</h2>
<p>以下特性已经实现，但可能仅在 Firefox Nightly 中可用、或者需要浏览器 flags 开启；且此提案的标准可能尚未正式进入 ECMAScript 规范，请小心使用。</p>
<h3 id="ArrayBuffer_对象的新方法"><code>ArrayBuffer</code> 对象的新方法</h3>
<ul>
<li><a href="Reference/Global_Objects/ArrayBuffer/transfer" title="静态ArrayBuffer.transfer() 方法返回一个新的ArrayBuffer， 其内容取自oldBuffer的数据，并且根据 newByteLength 的大小来对数据进行截取或者以0扩展。 如果 newByteLength 未定义，则使用 oldBuffer 的byteLength。这个操作使得 oldBuffer 处于被移除的状态。"><code>ArrayBuffer.transfer()</code></a> (<a class="external" href="https://gist.github.com/lukewagner/2735af7eea411e18cf20" rel="noopener">spec</a>)</li>
</ul>
<h3 id="新的_TypedObject_对象">新的 TypedObject 对象</h3>
<ul>
<li><a class="external" href="https://github.com/dslomov-chromium/typed-objects-es7" rel="noopener">Typed Objects draft</a></li>
</ul>
<h3 id="新的_Shared_Memory_对象">新的 Shared Memory 对象</h3>
<ul>
<li><a href="Reference/Global_Objects/SharedArrayBuffer" title="SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。"><code>SharedArrayBuffer</code></a></li>
<li><a href="Reference/Global_Objects/Atomics" title="Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。"><code>Atomics</code></a></li>
</ul>
<h2 id="相关链接">相关链接</h2>
<ul>
<li><a class="external" href="http://www.ecmascript.org/" rel="noopener">ECMAScript 官网</a></li>
<li><a class="external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1021376" rel="noopener">Mozilla ES2016 tracking bug</a></li>
<li><a class="external" href="http://kangax.github.io/compat-table/es7/" rel="noopener" title="http://kangax.github.io/es5-compat-table">ECMAScript 2015 support across browsers</a></li>
</ul>
</article>